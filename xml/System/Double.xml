<Type Name="Double" FullName="System.Double">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fe2787cb28ff71f760563eeef3cc17d55b5dcadb" /><Meta Name="ms.sourcegitcommit" Value="a8ca33e500a87229bed50d12e09b1347df519648" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="10/09/2020" /><Meta Name="ms.locfileid" Value="91908963" /></Metadata><TypeSignature Language="C#" Value="public struct Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit float64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float64&gt;, class System.IConvertible, class System.IEquatable`1&lt;float64&gt;, class System.IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Double" />
  <TypeSignature Language="VB.NET" Value="Public Structure Double&#xA;Implements IComparable, IComparable(Of Double), IConvertible, IEquatable(Of Double), IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public value class Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type double = struct&#xA;    interface IConvertible&#xA;    interface IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="C#" Value="public struct Double : IComparable, IConvertible, IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float64 extends System.ValueType implements class System.IComparable, class System.IConvertible, class System.IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="VB.NET" Value="Public Structure Double&#xA;Implements IComparable, IConvertible, IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C++ CLI" Value="public value class Double : IComparable, IConvertible, IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="F#" Value="type double = struct&#xA;    interface IFormattable&#xA;    interface IConvertible" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float64&gt;, class System.IConvertible, class System.IEquatable`1&lt;float64&gt;, class System.IFormattable" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C#" Value="public struct Double : IComparable, IComparable&lt;double&gt;, IEquatable&lt;double&gt;, IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit float64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float64&gt;, class System.IEquatable`1&lt;float64&gt;, class System.IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="VB.NET" Value="Public Structure Double&#xA;Implements IComparable, IComparable(Of Double), IEquatable(Of Double), IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="C++ CLI" Value="public value class Double : IComparable, IComparable&lt;double&gt;, IEquatable&lt;double&gt;, IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="F#" Value="type double = struct&#xA;    interface IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.IComparable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.IEquatable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1">
      <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示一个双精度浮点数。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double>值类型表示双精度64位数字，其值范围从负 1.79769313486232 e 308 到正 1.79769313486232 e 308，以及正或负零、 <xref:System.Double.PositiveInfinity> 、 <xref:System.Double.NegativeInfinity> ，而非数字 (<xref:System.Double.NaN>) 。 它用于表示极大型 (的值，例如行星或 galaxies 之间的距离) 或极小的 (，例如以) 千克为间隔的物质的分子质量，这通常是不精确的 (（如从地球到另一阳历系统) 的距离。 <xref:System.Double>类型符合二元浮点算法的 IEC 60559:1989 (IEEE 754) 标准。  
  
 本主题包括以下各节：  
  
-   [浮点表示形式和精度](#Precision)  
  
-   [测试是否相等](#Equality)  
  
-   [浮点值和异常](#Exceptions)  
  
-   [类型转换和双结构](#Conversions)  
  
-   [浮点型功能](#Functionality)  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>Floating-Point 表示形式和精度  
 <xref:System.Double>数据类型以64位二进制格式存储双精度浮点值，如下表所示：  
  
|组成部分|Bits|  
|----------|----------|  
|有效位数或尾数|0-51|  
|Exponent|52-62|  
|Sign (0 = 正，1 = 负值) |63|  
  
 正如小数部分无法精确表示某些小数值 (例如1/3 或 <xref:System.Math.PI?displayProperty=nameWithType>) ），二进制小数无法表示某些小数值。 例如，1/10 以小数部分的形式精确表示为小数部分，以. 001100110011 表示为二进制小数，模式 "myhpccn-0011" 重复到无限大。 在这种情况下，浮点值提供它所表示的数字的不精确表示形式。 对原始浮点值执行其他数学运算通常会增加其精度。 例如，如果将0.1 乘以10并将0.1 添加到 1 9 次，则会看到加法，因为它涉及到8个以上的操作，因此产生的结果不太精确。 请注意，仅当 <xref:System.Double> 使用 "R" [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings)显示这两个值时，此差异才明显，如有必要，将显示该类型支持的所有17位精度 <xref:System.Double> 。  
  
 [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
 [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
 由于某些数字不能精确表示为小数部分的二进制值，因此浮点数只能近似于实数。  
  
 所有浮点数还具有有限数量的有效数字，还决定了浮点值接近于实数的准确程度。   <xref:System.Double>值最多可包含15个小数位数，尽管它在内部维护最大17位数字。 这意味着，某些浮点运算可能缺乏更改浮点值的精度。 下面的示例进行了这方面的演示。 它定义了一个非常大的浮点值，然后在其中添加了的产品 <xref:System.Double.Epsilon?displayProperty=nameWithType> 和一个千万亿。 然而，该产品太小，不能修改原始浮点值。 它的最小有效位数为千分之几，而产品中最重要的位是 10<sup>-309</sup>。  
  
 [!code-csharp[System.Double.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation2.cs#4)]
 [!code-vb[System.Double.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation2.vb#4)]  
  
 浮点数的有限精度有几个后果：  
  
-   对于特定精度，看起来相等的两个浮点数在进行比较时可能不相等，因为其最小有效位不同。 在下面的示例中，将一系列数字添加在一起，并将其总计与预期的总数进行比较。 尽管这两个值看起来是相同的，但对方法的调用 `Equals` 表示它们不是。  
  
     [!code-csharp[System.Double.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Double.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist3.vb#6)]  
  
     如果将语句中的格式项 <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType> 从和更改 `{0}` `{1}` 为 `{0:R}` ，并 `{1:R}` 显示这两个值的所有有效位，则可以 <xref:System.Double> 清楚地表明这两个值不相等，因为在加法运算期间会丢失精度。 在这种情况下，可以通过调用方法来解决该问题， <xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType> 以便在 <xref:System.Double> 执行比较之前将值舍入到所需的精度。  
  
-   如果使用的是十进制数，则使用浮点数的算术或比较运算可能不会产生相同的结果，因为二进制浮点数可能不等于十进制数。 前面的示例通过显示乘以0.1 乘以10的结果，再加上1次，阐释了这一点。  
  
     当包含小数值的数值操作的准确性非常重要时，可以使用 <xref:System.Decimal> 而不是 <xref:System.Double> 类型。 当具有整数值超出或类型范围的数值操作的准确性 <xref:System.Int64> <xref:System.UInt64> 很重要时，请使用 <xref:System.Numerics.BigInteger> 类型。  
  
-   如果涉及浮点数，值可能不会往返。 如果某个操作将原始浮点数转换为另一种格式，则会将值转换为舍入，而反向运算会将转换后的窗体转换回浮点数，并且最终浮点数不等于原始浮点数。 往返过程可能会失败，因为在转换过程中一个或多个最小有效位会丢失或更改。 在下面的示例中， <xref:System.Double> 将三个值转换为字符串，并保存在一个文件中。 但在输出中，即使值看起来相同，还原的值也不等于原始值。  
  
     [!code-csharp[System.Double.Structure#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist4.cs#7)]
     [!code-vb[System.Double.Structure#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist4.vb#7)]  
  
     在这种情况下，可以使用 "G17" [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 将值成功舍入，以保留值的完整精度 <xref:System.Double> ，如下面的示例所示。  
  
     [!code-csharp[System.Double.Structure#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist5.cs#8)]
     [!code-vb[System.Double.Structure#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist5.vb#8)]  

   > [!IMPORTANT]
   >  与值一起使用时 <xref:System.Double> ，在某些情况下，"R" 格式说明符无法成功往返原始值。 若要确保 <xref:System.Double> 值成功往返，请使用 "G17" 格式说明符。

-   <xref:System.Single> 值的精度低于 <xref:System.Double> 值。 <xref:System.Single>转换为看似等效的值 <xref:System.Double> 通常不等于值， <xref:System.Double> 因为精度存在差异。 在下面的示例中，将相同除法运算的结果分配给 <xref:System.Double> 和 <xref:System.Single> 值。 在将 <xref:System.Single> 值强制转换为之后 <xref:System.Double> ，这两个值的比较表明它们不相等。  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     若要避免此问题，请使用 <xref:System.Double> 数据类型的位置 <xref:System.Single> ，或使用 <xref:System.Math.Round%2A> 方法，使这两个值具有相同的精度。  
  
 此外，由于类型的精度丢失，具有值的算术和赋值运算的结果 <xref:System.Double> 可能会略有不同 <xref:System.Double> 。 例如， <xref:System.Double> 在 .NET Framework 的32位和64位版本中，分配文本值的结果可能不同。 下面的示例说明了将文本值 4.42330604244772 E-305 和值为-305 4.42330604244772 的变量分配给变量时的这种差异 <xref:System.Double> 。 请注意， <xref:System.Double.Parse%28System.String%29> 在这种情况下，方法的结果不会受到精度损失。  
  
 [!code-csharp[System.Double.Class.Precision#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.class.precision/cs/precision1.cs#1)]
 [!code-vb[System.Double.Class.Precision#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.class.precision/vb/precision1.vb#1)]  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>测试是否相等  
 若要将视为相等，两个 <xref:System.Double> 值必须表示相同的值。 不过，由于值之间的精度差别，或由于一个或两个值的精度损失，应相同的浮点值经常会出现不相等，因为其最小有效位之间存在差异。 因此，调用 <xref:System.Double.Equals%2A> 方法来确定两个值是否相等，或调用 <xref:System.Double.CompareTo%2A> 方法来确定两个值之间的关系 <xref:System.Double> ，通常会产生意外结果。 在下面的示例中，这很明显，其中两个明显相等 <xref:System.Double> 的值是不相等的，因为第一个值的精度为15位，而第二个值为17。  
  
 [!code-csharp[System.Double.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Double.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison1.vb#9)]  
  
 采用不同的代码路径并以不同的方式操作的计算值通常证明不相等。 在下面的示例中，一个 <xref:System.Double> 值为平方，然后计算平方根以还原原始值。 第二个 <xref:System.Double> 比3.51 和 squared 相乘，然后将结果的平方根除以3.51 来还原原始值。 尽管两个值看起来相同，但对方法的调用 <xref:System.Double.Equals%28System.Double%29> 指示它们不相等。 使用 "R" 标准格式字符串返回显示每个 Double 值的所有有效位的结果字符串，显示第二个值小于第一个值 .0000000000001。  
  
 [!code-csharp[System.Double.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Double.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison2.vb#10)]  
  
 如果精度损失可能会影响比较结果，则可以采用以下任意一种方法调用 <xref:System.Double.Equals%2A> 或 <xref:System.Double.CompareTo%2A> 方法：  
  
-   调用 <xref:System.Math.Round%2A?displayProperty=nameWithType> 方法以确保这两个值具有相同的精度。 下面的示例修改了上一个示例，以使用此方法，以使两个小数值相等。  
  
     [!code-csharp[System.Double.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Double.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison3.vb#11)]  
  
     但请注意，精度问题仍适用于中点值的舍入。 有关更多信息，请参见 <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType> 方法。  
  
-   测试近似相等性，而不是相等。 这要求您定义一个绝对值，而这两个值可以不同，但仍相等，也可以定义较小值与较大值之间的差异。  
  
    > [!WARNING]
    >  <xref:System.Double.Epsilon?displayProperty=nameWithType> 在测试相等性时，有时会将其用作两个值之间的距离的绝对度量值 <xref:System.Double> 。  但 <xref:System.Double.Epsilon?displayProperty=nameWithType> 度量值为零的可添加到或从中减去的最小可能值 <xref:System.Double> 。 对于大多数正值和负值 <xref:System.Double> ，值 <xref:System.Double.Epsilon?displayProperty=nameWithType> 太小，无法检测到。 因此，除了零值以外，不建议在测试中使用它是否相等。  
  
     下面的示例使用后一种方法来定义 `IsApproximatelyEqual` 测试两个值之间的相对差异的方法。 它还比较了对方法的调用和方法的调用结果 `IsApproximatelyEqual` <xref:System.Double.Equals%28System.Double%29> 。  
  
     [!code-csharp[System.Double.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Double.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>Floating-Point 值和异常  
 与整数类型的操作不同，在溢出或非法操作（如被零除）情况下引发异常时，具有浮点值的操作不会引发异常。 在异常情况下，浮点运算的结果为零、正无穷、负无穷或不是 (NaN) 的数字：  
  
-   如果浮点运算的结果对于目标格式来说太小，则结果为零。 当两个非常小的数字相乘时，可能会出现这种情况，如下面的示例所示。  
  
     [!code-csharp[System.Double.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Double.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional1.vb#1)]  
  
-   如果浮点运算结果的大小超出目标格式的范围，则操作的结果为 <xref:System.Double.PositiveInfinity> 或 <xref:System.Double.NegativeInfinity> （适用于结果的符号）。 溢出的操作的结果为 <xref:System.Double.MaxValue?displayProperty=nameWithType> <xref:System.Double.PositiveInfinity> ，而溢出的操作的结果为 <xref:System.Double.MinValue?displayProperty=nameWithType> <xref:System.Double.NegativeInfinity> ，如下面的示例所示。  
  
     [!code-csharp[System.Double.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Double.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Double.PositiveInfinity> 还是由零除后被除数引起来的结果，并由 <xref:System.Double.NegativeInfinity> 零除导致负被除数的结果。  
  
-   如果浮点操作无效，则操作的结果为 <xref:System.Double.NaN> 。 例如， <xref:System.Double.NaN> 以下操作的结果：  
  
    -   除数为零的除以零。 请注意，除数为零的其他情况会导致 <xref:System.Double.PositiveInfinity> 或 <xref:System.Double.NegativeInfinity> 。  
  
-   具有无效输入的任何浮点运算。 例如， <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> 使用负值调用方法将返回，这与 <xref:System.Double.NaN> <xref:System.Math.Acos%2A?displayProperty=nameWithType> 使用大于1或小于1的值调用方法时相同。  
  
-   具有值为的参数的任何操作 <xref:System.Double.NaN?displayProperty=nameWithType> 。  
  
<a name="Conversions"></a>   
## <a name="type-conversions-and-the-double-structure"></a>类型转换和双结构  
 该 <xref:System.Double> 结构不定义任何显式或隐式转换运算符; 相反，转换是由编译器实现的。  
  
 任何基元数值类型的值转换为 <xref:System.Double> 扩大转换，因此不需要显式强制转换运算符或对转换方法的调用，除非编译器显式要求它。 例如，c # 编译器需要一个转换运算符用于从到的 <xref:System.Decimal> 转换 <xref:System.Double> ，而 Visual Basic 编译器则不需要。 下面的示例将其他基元数值类型的最小值或最大值转换为 <xref:System.Double> 。  
  
 [!code-csharp[System.Double.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert1.cs#20)]
 [!code-vb[System.Double.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert1.vb#20)]  
  
 此外， <xref:System.Single> 值 <xref:System.Single.NaN?displayProperty=nameWithType> 、 <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> 和 <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> 分别转换为、和 <xref:System.Double.NaN?displayProperty=nameWithType> <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 。  
  
 请注意，某些数值类型的值到值的转换 <xref:System.Double> 可能会导致精度损失。 如示例中所示，将 <xref:System.Decimal> 、 <xref:System.Int64> 、 <xref:System.Single> 和 <xref:System.UInt64> 值转换为 <xref:System.Double> 值时可能会丢失精度。  
  
 <xref:System.Double>值到任何其他基元数值数据类型的值的转换是收缩转换，要求在 c # ) 中 (转换运算符、Visual Basic) 中 (转换方法或调用 <xref:System.Convert> 方法。 超出目标数据类型范围的值（由目标类型的 `MinValue` 和 `MaxValue` 属性定义）的行为如下表中所示。  
  
|目标类型|结果|  
|-----------------|------------|  
|任何整型|<xref:System.OverflowException>如果在检查的上下文中发生转换，则为异常。<br /><br /> 如果在未检查的上下文中发生转换 (c # ) 中的默认值，则转换操作会成功，但值溢出。|  
|<xref:System.Decimal>|一个 <xref:System.OverflowException> 异常。|  
|<xref:System.Single>|<xref:System.Single.NegativeInfinity?displayProperty=nameWithType> 对于负值，则为。<br /><br /> <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> 对于正值。|  
  
 此外，、 <xref:System.Double.NaN?displayProperty=nameWithType> 、 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 和将 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 引发， <xref:System.OverflowException> 以便转换为已检查上下文中的整数，但这些值在转换为未检查的上下文中的整数时溢出。 对于到的转换 <xref:System.Decimal> ，它们始终引发 <xref:System.OverflowException> 。 对于到的转换 <xref:System.Single> ，它们分别转换为 <xref:System.Single.NaN?displayProperty=nameWithType> 、 <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> 和 <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> 。  
  
 请注意，将 <xref:System.Double> 值转换为另一种数值类型可能会导致精度损失。 在转换非整数值的情况下 <xref:System.Double> ，如示例的输出所示，如果将 <xref:System.Double> 值舍入 (与 Visual Basic) 中的一样，则会丢失小数部分，否则在 c # ) 中截断 (。 对于 <xref:System.Decimal> 和值的转换 <xref:System.Single> ，此 <xref:System.Double> 值在目标数据类型中可能没有精确的表示形式。  
  
 下面的示例将多 <xref:System.Double> 个值转换为多个其他数值类型。 由于 [checked](/dotnet/csharp/language-reference/keywords/checked) 关键字) ，转换在 Visual Basic (默认) 和 c # (中的检查上下文中进行。 该示例的输出显示了已检查的未检查上下文中的转换结果。 可以通过使用 `/removeintchecks+` 编译器开关进行编译，并通过注释掉语句，在 Visual Basic 中的未检查上下文中执行转换 `checked` 。  
  
 [!code-csharp[System.Double.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert2.cs#21)]
 [!code-vb[System.Double.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert2.vb#21)]  
  
 有关数值类型转换的详细信息，请参阅 .NET Framework 和[类型转换表](/dotnet/standard/base-types/conversion-tables)[中的类型转换](/dotnet/standard/base-types/type-conversion)。  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>Floating-Point 功能  
 <xref:System.Double>结构和相关类型提供了在以下几个方面执行操作的方法：  
  
-   **值比较**。 您可以调用 <xref:System.Double.Equals%2A> 方法来确定两个 <xref:System.Double> 值是否相等，或调用 <xref:System.Double.CompareTo%2A> 方法来确定两个值之间的关系。  
  
     该 <xref:System.Double> 结构还支持一组完整的比较运算符。 例如，你可以测试是否相等或不相等，或确定一个值是否大于或等于另一个值。 如果其中一个操作数是非的数值类型，则在 <xref:System.Double> 执行比较之前将其转换为 <xref:System.Double> 。  
  
    > [!WARNING]
    >  由于精度之间存在差异，因此两个 <xref:System.Double> 预期相等的值可能会不相等，这将影响比较的结果。 有关比较两个值的详细信息，请参阅 [测试相等性](#Equality) 部分 <xref:System.Double> 。  
  
     你还可以调用 <xref:System.Double.IsNaN%2A> 、 <xref:System.Double.IsInfinity%2A> 、 <xref:System.Double.IsPositiveInfinity%2A> 和 <xref:System.Double.IsNegativeInfinity%2A> 方法来测试这些特殊值。  
  
-   **数学运算**。 常见算术运算（例如加法、减法、乘法和除法）由语言编译器和公共中间语言 (CIL) 指令实现，而不是通过方法实现 <xref:System.Double> 。 如果数学运算中的一个操作数为数值类型而不是，则在 <xref:System.Double> 执行运算前将其转换为 <xref:System.Double> 。 操作的结果也是 <xref:System.Double> 值。  
  
     其他数学运算可以通过调用类中 `static` `Shared` Visual Basic) 方法 (来执行 <xref:System.Math?displayProperty=nameWithType> 。 它包括通常用于算术 (的其他方法，例如 <xref:System.Math.Abs%2A?displayProperty=nameWithType> 、 <xref:System.Math.Sign%2A?displayProperty=nameWithType> 和 <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>) 、几何图形 (如 <xref:System.Math.Cos%2A?displayProperty=nameWithType> 和 <xref:System.Math.Sin%2A?displayProperty=nameWithType>) ）以及 (等微积分) <xref:System.Math.Log%2A?displayProperty=nameWithType> 。  
  
     您还可以操作值中的单个位 <xref:System.Double> 。 <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType>方法 <xref:System.Double> 在64位整数中保留值的位模式。 <xref:System.BitConverter.GetBytes%28System.Double%29?displayProperty=nameWithType>方法返回其在字节数组中的位模式。  
  
-   **舍入**。 舍入通常用作一种方法，用于降低由于浮点表示形式和精度问题导致的值之间的差异。 可以 <xref:System.Double> 通过调用方法来舍入值 <xref:System.Math.Round%2A?displayProperty=nameWithType> 。  
  
-   **格式设置**。 可以 <xref:System.Double> 通过调用 <xref:System.Double.ToString%2A> 方法或使用复合格式设置功能，将值转换为其字符串表示形式。 有关格式字符串如何控制浮点值的字符串表示形式的信息，请参阅 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 和 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings) 主题。  
  
-   **分析字符串**。 可以 <xref:System.Double> 通过调用或方法，将浮点值的字符串表示形式转换为值 <xref:System.Double.Parse%2A> <xref:System.Double.TryParse%2A> 。 如果分析操作失败，则该 <xref:System.Double.Parse%2A> 方法将引发异常，而 <xref:System.Double.TryParse%2A> 方法返回 `false` 。  
  
-   **类型转换**。 <xref:System.Double>结构为接口提供了显式接口实现 <xref:System.IConvertible> ，该接口支持任意两个标准 .NET Framework 数据类型之间的转换。 语言编译器还支持将所有其他标准数值类型的值隐式转换为 <xref:System.Double> 值。 将任何标准数值类型的值转换为 <xref:System.Double> 扩大转换，不需要使用强制转换运算符或转换方法的用户。  
  
     但是， <xref:System.Int64> 和值的转换 <xref:System.Single> 可能会导致精度损失。 下表列出了每种类型的精度差异：  
  
    |类型|最大精度|内部精度|  
    |----------|-----------------------|------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int64>|19个十进制数字|19个十进制数字|  
    |<xref:System.Single>|7个十进制数字|9个十进制数字|  
  
     精确的问题会影响 <xref:System.Single> 转换为值的值 <xref:System.Double> 。 在下面的示例中，两个由相同除法运算生成的值是不相等的，因为其中一个值是转换为的单精度浮点值 <xref:System.Double> 。  
  
     [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
     [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
   
  
## Examples  
 下面的代码示例阐释了的用法 <xref:System.Double> ：  
  
 [!code-cpp[Double Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#1)]
 [!code-csharp[Double Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#1)]
 [!code-vb[Double Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此类型的所有成员都是线程安全的。 看似修改实例状态的成员实际上返回用新值初始化的新实例。 与任何其他类型一样，读取和写入包含此类型的实例的共享变量时，必须通过锁保护以保证线程安全。</threadsafe>
    <altmember cref="T:System.Decimal" />
    <altmember cref="T:System.Single" />
    <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/windowsforms-formatting-utility-cs/">示例： .NET Core WinForms 格式设置实用工具 (c # ) </related>
    <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/windowsforms-formatting-utility-vb/">示例： .NET Core WinForms 格式设置实用工具 (Visual Basic) </related>
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将此实例与指定的对象或 <see cref="T:System.Double" /> 对象进行比较，并返回一个整数，该整数指示此实例的值是小于、等于还是大于指定对象或 <see cref="T:System.Double" /> 对象的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Double) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(double value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : double -&gt; int&#xA;override this.CompareTo : double -&gt; int" Usage="double.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要比较的双精度浮点数。</param>
        <summary>将此实例与指定的双精度浮点数进行比较，并返回一个整数，该整数指示此实例的值是小于、等于还是大于指定双精度浮点数的值。</summary>
        <returns>一个带符号数字，指示此实例和 <paramref name="value" /> 的相对值。  
  
 <list type="table"><listheader><term> 返回值 
 </term><description> 描述 
 </description></listheader><item><term> 小于零 
 </term><description> 此实例小于 <paramref name="value" />，或此实例不是数字 (<see cref="F:System.Double.NaN" />)，而 <paramref name="value" /> 是数字。  
  
 </description></item><item><term> 零 
 </term><description> 此实例等于 <paramref name="value" />，或此实例和 <paramref name="value" /> 均不为数字 (<see cref="F:System.Double.NaN" />)、<see cref="F:System.Double.PositiveInfinity" /> 或 <see cref="F:System.Double.NegativeInfinity" />。  
  
 </description></item><item><term> 大于零 
 </term><description> 此实例大于 <paramref name="value" />，或此实例为数字，而 <paramref name="value" /> 不是数字 (<see cref="F:System.Double.NaN" />)。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值必须完全相同，才能视为相等。 特别是当浮点值依赖于多个数学运算时，通常情况下，它们会丢失精度，并且它们的值几乎完全相同，只是它们的最小有效位除外。 因此，方法的返回值 <xref:System.Double.CompareTo%2A> 有时可能会令人吃惊。 例如，按特定值的乘法后跟同一值相除的值应生成原始值。 但是，在下面的示例中，计算所得的值为大于原始值。 使用 "R" [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 显示这两个值的所有有效位数，表示计算所得的值与最小有效位中的原始值不同。 有关如何处理此类比较的信息，请参阅方法的 "备注" 部分 <xref:System.Double.Equals%28System.Double%29> 。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto2.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto2.vb" id="Snippet1":::
 
 此方法实现 <xref:System.IComparable%601?displayProperty=nameWithType> 接口，且执行方式略优于 <xref:System.Double.CompareTo%2A?displayProperty=nameWithType> 方法，因为它不必将 `value` 参数转换为对象。  
  
 请注意，尽管一个对象的值不 <xref:System.Double.NaN> 等于另一个对象，而该对象的值 <xref:System.Double.NaN> (甚至) ，但 <xref:System.IComparable%601> 接口要求 `A.CompareTo(A)` 返回零。  
  
## <a name="widening-conversions"></a>扩大转换  
 根据您的编程语言，可以编写一个方法，在 <xref:System.Double.CompareTo%2A> 此方法中，参数类型 (比实例类型更窄) 位。 这是可能的，因为某些编程语言会执行将参数表示为类型的隐式扩大转换，该类型的位数与实例的位数一样多。  
  
 例如，假设实例类型为 <xref:System.Double> ，而参数类型为 <xref:System.Int32> 。 Microsoft c # 编译器生成说明，以将参数的值表示为 <xref:System.Double> 对象，然后生成一个 <xref:System.Double.CompareTo%28System.Double%29?displayProperty=nameWithType> 方法，该方法将实例的值与参数的加宽表示形式进行比较。  
  
 请查阅编程语言的文档，以确定其编译器是否执行数值类型的隐式扩大转换。 有关详细信息，请参阅 [类型转换表](/dotnet/standard/base-types/conversion-tables) 主题。  
  
## <a name="precision-in-comparisons"></a>比较中的精度  
 超出所记录精度的浮点数的精度特定于 .NET Framework 的实现和版本。 因此，两个特定数字的比较可能会在 .NET Framework 的不同版本之间发生变化，因为数字的内部表示形式的精度可能会改变。  
  
   
  
## Examples  
 下面的代码示例演示了 <xref:System.Double.CompareTo%2A> 多个值和引用类型的方法的泛型和非泛型版本。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="double.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">要比较的对象，或为 <see langword="null" />。</param>
        <summary>将此实例与指定对象进行比较，并返回一个整数，该整数指示此实例的值是小于、等于还是大于指定对象的值。</summary>
        <returns>一个带符号数字，指示此实例和 <paramref name="value" /> 的相对值。  
  
 <list type="table"><listheader><term> “值” 
 </term><description> 描述 
 </description></listheader><item><term> 负整数 
 </term><description> 此实例小于 <paramref name="value" />，或此实例不是数字 (<see cref="F:System.Double.NaN" />)，而 <paramref name="value" /> 是数字。  
  
 </description></item><item><term> 零 
 </term><description> 此实例等于 <paramref name="value" />，或此实例和 <paramref name="value" /> 均为 <see langword="Double.NaN" />、<see cref="F:System.Double.PositiveInfinity" /> 或 <see cref="F:System.Double.NegativeInfinity" /></description></item><item><term> 正整数 
 </term><description> 此实例大于 <paramref name="value" />，或此实例是数字，而 <paramref name="value" /> 不是数字 (<see cref="F:System.Double.NaN" />)，或 <paramref name="value" /> 为 <see langword="null" />。</description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`参数必须为 `null` 或的实例 `Double` ; 否则，将引发异常。 的任何实例 <xref:System.Double> ，无论其值如何，都视为大于 `null` 。  
  
 值必须完全相同，才能视为相等。 特别是当浮点值依赖于多个数学运算时，通常情况下，它们会丢失精度，并且它们的值几乎完全相同，只是它们的最小有效位除外。 因此，方法的返回值 <xref:System.Double.CompareTo%2A> 有时可能会令人吃惊。 例如，按特定值的乘法后跟同一值相除的值应生成原始值。 但是，在下面的示例中，计算所得的值为大于原始值。 使用 "R" [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 显示这两个值的所有有效位数，表示计算所得的值与最小有效位中的原始值不同。 有关如何处理此类比较的信息，请参阅方法的 "备注" 部分 <xref:System.Double.Equals%28System.Double%29> 。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto3.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto3.vb" id="Snippet2":::

 实现此方法是为了支持 <xref:System.IComparable> 接口。 请注意，尽管不会被 <xref:System.Double.NaN> 视为等于其他 <xref:System.Double.NaN> (甚至) ，但 <xref:System.IComparable> 接口需要 `A.CompareTo(A)` 返回零。  
  
## <a name="precision-in-comparisons"></a>比较中的精度  
 超出所记录精度的浮点数的精度特定于 .NET Framework 的实现和版本。 因此，两个特定数字的比较可能会在 .NET Framework 的不同版本之间发生变化，因为数字的内部表示形式的精度可能会改变。  
  
   
  
## Examples  
 下面的代码示例演示如何在的 `CompareTo` 上下文中使用 `Double` 。  
  
 [!code-cpp[System.Double#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#16)]
 [!code-csharp[System.Double#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#16)]
 [!code-vb[System.Double#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> 不是 <see cref="T:System.Double" />。</exception>
        <altmember cref="M:System.Double.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const double Epsilon = 4.94065645841247E-324;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 Epsilon = float64(4.94065645841247E-324)" />
      <MemberSignature Language="DocId" Value="F:System.Double.Epsilon" />
      <MemberSignature Language="VB.NET" Value="Public Const Epsilon As Double  = 4.94065645841247E-324" />
      <MemberSignature Language="C++ CLI" Value="public: double Epsilon = 4.94065645841247E-324;" />
      <MemberSignature Language="F#" Value="val mutable Epsilon : double" Usage="System.double.Epsilon" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>4.94065645841247E-324</MemberValue>
      <Docs>
        <summary>表示大于零的最小正 <see cref="T:System.Double" /> 值。 此字段为常数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.Epsilon>如果实例的值为零，则属性的值将反映 <xref:System.Double> 数值操作或比较中重要的最小正值 <xref:System.Double> 。 例如，下面的代码显示零和被 <xref:System.Double.Epsilon> 视为不相等的值，而零和一半的值被 <xref:System.Double.Epsilon> 视为相等。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon.cs" interactive="try-dotnet" id="Snippet5":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon.vb" id="Snippet5"::: 
  
 更准确地说，浮点格式由符号、52位尾数或有效位数以及11位指数组成。 如下面的示例所示，零的指数为-1022，尾数为0。 <xref:System.Double.Epsilon> 的指数为-1022，尾数为1。 这意味着，它 <xref:System.Double.Epsilon> 是大于零的最小正值 <xref:System.Double> ，表示 <xref:System.Double> 指数为-1022 的的最小可能值和可能的最小增量。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon1.cs" interactive="try-dotnet" id="Snippet6":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon1.vb" id="Snippet6":::
  
 但是，该 <xref:System.Double.Epsilon> 属性不是类型精度的常规度量值 <xref:System.Double> ; 它仅适用于值为 <xref:System.Double> 零或指数为-1022 的实例。  
  
> [!NOTE]
>  此属性的值 <xref:System.Double.Epsilon> 不等效于计算机 epsilon，后者表示相对错误的上限，原因是浮点算法中的舍入。  
  
 此常量的值为 4.94065645841247 e-324。  
  
 两个显然等效的浮点数可能不相等，因为其最小有效位之间存在差异。 例如，c # 表达式不 `(double)1/3 == (double)0.33333` 比较相等，因为左侧的除法运算具有最大的精度，而右侧的常数仅精确到指定的位数。 如果您创建一个自定义算法来确定是否可以将两个浮点数视为相等，则建议您不要将算法基于常量的值， <xref:System.Double.Epsilon> 以确定两个值被视为相等的可接受的绝对边距。   (通常情况下，差值幅度大于 <xref:System.Double.Epsilon> 。 ) 有关比较两个双精度浮点值的信息，请参阅 <xref:System.Double> 和 <xref:System.Double.Equals%28System.Double%29> 。  
  
## <a name="platform-notes"></a>平台说明  
 ARM 系统上的 <xref:System.Double.Epsilon> 常量值太小，无法检测到，因此它等于零。 可以改为定义等于 2.2250738585072014 E-308 的备用 epsilon 值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个值，该值指示 <see cref="T:System.Double" /> 的两个实例是否表示同一个值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (double obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float64 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(double obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : double -&gt; bool" Usage="double.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">要与此示例比较的 <see cref="T:System.Double" /> 对象。</param>
        <summary>返回一个值，该值指示此实例和指定的 <see cref="T:System.Double" /> 对象是否表示相同的值。</summary>
        <returns>如果 <see langword="true" /> 与此实例相等，则为 <paramref name="obj" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法实现 <xref:System.IEquatable%601?displayProperty=nameWithType> 接口，并且执行的效果略优于， <xref:System.Double.Equals%2A> 因为无需将 `obj` 参数转换为对象。  
  
## <a name="widening-conversions"></a>扩大转换  
 根据您的编程语言，可以编写一个方法，在 <xref:System.Double.Equals%2A> 此方法中，参数类型 (比实例类型更窄) 位。 这是可能的，因为某些编程语言会执行将参数表示为类型的隐式扩大转换，该类型的位数与实例的位数一样多。  
  
 例如，假设实例类型为 <xref:System.Double> ，而参数类型为 <xref:System.Int32> 。 Microsoft c # 编译器生成说明，以将参数的值表示为 <xref:System.Double> 对象，然后生成一个 <xref:System.Double.Equals%28System.Double%29?displayProperty=nameWithType> 方法，该方法将实例的值与参数的加宽表示形式进行比较。  
  
 请查阅编程语言的文档，以确定其编译器是否执行数值类型的隐式扩大转换。 有关详细信息，请参阅 [类型转换表](/dotnet/standard/base-types/conversion-tables) 主题。  
  
## <a name="precision-in-comparisons"></a>比较中的精度  
 <xref:System.Double.Equals%2A>方法应谨慎使用，因为两个值的精度不同，因此两个明显等效的值可能不相等。 下面的示例报告 <xref:System.Double> 值333333和 <xref:System.Double> 除以3相除返回的值不相等。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb" id="Snippet1":::
  
 一种方法不是比较相等性，而是定义两个值之间的差异的可接受的相对边距 (如) 值之一的 .001%。 如果这两个值之差的绝对值小于或等于该边距，则差异可能是由于精度的不同而导致的，因此，这些值可能是相等的。 下面的示例使用此方法来比较. 33333 和1/3，前面的 <xref:System.Double> 代码示例发现的两个值是不相等的。 在这种情况下，值相等。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb" id="Snippet2":::
  
> [!NOTE]
>  由于 <xref:System.Double.Epsilon> 定义了其范围接近于零的正值的最小表达式，因此两个相似值之间的差值幅度必须大于 <xref:System.Double.Epsilon> 。 通常，它比更多 <xref:System.Double.Epsilon> 。 因此，建议您不要 <xref:System.Double.Epsilon> 在比较值是否相等时使用 <xref:System.Double> 。  
  
 第二种方法涉及将两个浮点数之间的差与某个绝对值进行比较。 如果差异小于或等于该绝对值，则数字相等。 如果大于，则数字不相等。 一种替代方法是任意选择一个绝对值。 但这是有问题的，因为差异的可接受边距取决于值的量 <xref:System.Double> 。 另一种替代方法利用了浮点格式的设计功能：两个浮点值的整数表示形式之间的差异指示了可以分隔它们的浮点值的数量。 例如，0.0 和的差 <xref:System.Double.Epsilon> 为1，因为当使用 <xref:System.Double.Epsilon> 的值为零时，是可表示的最小值 <xref:System.Double> 。 下面的示例使用此方法来比较. 33333 和1/3，这两个 <xref:System.Double> 值是前面的代码示例中找到的 <xref:System.Double.Equals%28System.Double%29> 方法不相等的两个值。 请注意，该示例使用 <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType> 方法将双精度浮点值转换为其整数表示形式。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsabs1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsabs1.vb" id="Snippet1"::: 
  
 超出所记录精度的浮点数的精度特定于 .NET Framework 的实现和版本。 因此，两个特定数字的比较可能会在 .NET Framework 的不同版本之间发生变化，因为数字的内部表示形式的精度可能会改变。  
  
 如果 <xref:System.Double.NaN?displayProperty=nameWithType> 通过调用方法测试了两个值是否相等 <xref:System.Double.Equals%2A> ，则该方法将返回 `true` 。 但是，如果 <xref:System.Double.NaN> 使用相等运算符测试两个值是否相等，则运算符返回 `false` 。 如果要确定的值是否 <xref:System.Double> 不是 (NaN) 的数字，则可以选择调用 <xref:System.Double.IsNaN%2A> 方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>编译器重载决策可能会考虑两种方法重载行为中的明显差异 <see cref="M:System.Double.Equals(System.Object)" /> 。 如果定义了参数和 a 之间的隐式转换， <paramref name="obj" /> <see cref="T:System.Double" /> 并且参数未键入为，则 <see cref="T:System.Object" /> 编译器可能会执行隐式转换并调用 <see cref="M:System.Double.Equals(System.Double)" /> 方法。 否则，它们调用 <see cref="M:System.Double.Equals(System.Object)" /> 方法， <see langword="false" /> 如果其 <paramref name="obj" /> 参数不是值，则总是返回 <see cref="T:System.Double" /> 。 下面的示例演示两个方法重载之间的行为差异。 对于除 c # 中的和以外的所有基元数值类型 <see cref="T:System.Decimal" /> ，第一次比较将返回，这是 <see langword="true" /> 因为编译器会自动执行扩大转换并调用 <see cref="M:System.Double.Equals(System.Double)" /> 方法，而第二次比较返回， <see langword="false" /> 因为编译器调用了 <see cref="M:System.Double.Equals(System.Object)" /> 方法。  
  
：：： code language = "csharp" source = "~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs" interactive = "dotnet" id = "Snippet2"：：：：：： code language = "vb" source = "~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb" id = "Snippet2"：：：</para></block>
        <altmember cref="M:System.Double.Equals(System.Object)" />
        <altmember cref="Overload:System.Double.CompareTo" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="double.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">与此实例进行比较的对象。</param>
        <summary>返回一个值，该值指示此实例是否等于指定的对象。</summary>
        <returns>如果 <see langword="true" /> 是 <paramref name="obj" /> 的实例并且等于此实例的值，则为 <see cref="T:System.Double" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.Equals%2A>方法应谨慎使用，因为两个值的精度不同，因此两个明显等效的值可能不相等。 下面的示例报告 <xref:System.Double> 值3333和 <xref:System.Double> 除以3相除后返回的值不相等。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs" interactive="try-dotnet-method" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb" id="Snippet3":::
  
 有关调用方法的替代 <xref:System.Double.Equals%2A> 方法，请参阅重载的文档 <xref:System.Double.Equals%28System.Double%29> 。  
  
> [!NOTE]
>  由于 <xref:System.Double.Epsilon> 定义了其范围接近于零的正值的最小表达式，因此两个相似值之间的差值幅度必须大于 <xref:System.Double.Epsilon> 。 通常，它比更多 <xref:System.Double.Epsilon> 。  
  
 超出所记录精度的浮点数的精度特定于 .NET Framework 的实现和版本。 因此，两个特定数字的比较可能会在 .NET Framework 的不同版本之间发生变化，因为数字的内部表示形式的精度可能会改变。  
  
 如果 <xref:System.Double.NaN?displayProperty=nameWithType> 通过调用方法测试了两个值是否相等 <xref:System.Double.Equals%2A> ，则该方法将返回 `true` 。 但是，如果 <xref:System.Double.NaN> 使用相等运算符测试两个值是否相等，则运算符返回 `false` 。 如果要确定的值是否 <xref:System.Double> 不是 (NaN) 的数字，则可以选择调用 <xref:System.Double.IsNaN%2A> 方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>编译器重载决策可能会考虑两种方法重载行为中的明显差异 <see cref="M:System.Double.Equals(System.Object)" /> 。 如果定义了参数和 a 之间的隐式转换， <paramref name="obj" /> <see cref="T:System.Double" /> 并且参数未键入为，则 <see cref="T:System.Object" /> 编译器可能会执行隐式转换并调用 <see cref="M:System.Double.Equals(System.Double)" /> 方法。 否则，它们调用 <see cref="M:System.Double.Equals(System.Object)" /> 方法， <see langword="false" /> 如果其 <paramref name="obj" /> 参数不是值，则总是返回 <see cref="T:System.Double" /> 。 下面的示例演示两个方法重载之间的行为差异。 对于除 c # 中的和以外的所有基元数值类型 <see cref="T:System.Decimal" /> ，第一次比较将返回，这是 <see langword="true" /> 因为编译器会自动执行扩大转换并调用 <see cref="M:System.Double.Equals(System.Double)" /> 方法，而第二次比较返回， <see langword="false" /> 因为编译器调用了 <see cref="M:System.Double.Equals(System.Object)" /> 方法。  
  
：：： code language = "csharp" source = "~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs" interactive = "dotnet" id = "Snippet2"：：：：：： code language = "vb" source = "~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb" id = "Snippet2"：：：</para></block>
        <altmember cref="M:System.Double.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="double.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此实例的哈希代码。</summary>
        <returns>32 位有符号整数哈希代码。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="double.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回值类型 <see cref="T:System.TypeCode" /> 的 <see cref="T:System.Double" />。</summary>
        <returns>枚举常数 <see cref="F:System.TypeCode.Double" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.TypeCode" />
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsFinite(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(double d);" />
      <MemberSignature Language="F#" Value="static member IsFinite : double -&gt; bool" Usage="System.double.IsFinite d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="d">一个双精度浮点数。</param>
        <summary>确定指定值是否为有限值（零、不正常或正常）。</summary>
        <returns>如果该值为有限值（零、不正常或正常），则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsInfinity : double -&gt; bool" Usage="System.double.IsInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">一个双精度浮点数。</param>
        <summary>返回一个值，该值指示指定数字是计算为负无穷大还是正无穷大。</summary>
        <returns>如果 <paramref name="d" /> 的计算结果为 <see cref="F:System.Double.PositiveInfinity" /> 或 <see cref="F:System.Double.NegativeInfinity" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 浮点运算返回 <xref:System.Double.PositiveInfinity> 或 <xref:System.Double.NegativeInfinity> 以通知溢出情况。  
  
   
  
## Examples  
 下面的代码示例阐释了的用法 <xref:System.Double.IsInfinity%2A> ：  
  
 [!code-cpp[System.Double#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#11)]
 [!code-csharp[System.Double#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#11)]
 [!code-vb[System.Double#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNaN(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(double d);" />
      <MemberSignature Language="F#" Value="static member IsNaN : double -&gt; bool" Usage="System.double.IsNaN d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">一个双精度浮点数。</param>
        <summary>返回一个值，该值指示指定的值是否不为数字 (<see cref="F:System.Double.NaN" />)。</summary>
        <returns>如果 <paramref name="d" /> 的计算结果为 <see cref="F:System.Double.NaN" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 浮点运算返回 <xref:System.Double.NaN> 到表示操作结果未定义的信号。 例如，将0.0 除以0.0 会导致 <xref:System.Double.NaN> 。  
  
> [!NOTE]
>  <xref:System.Double.IsNaN%2A>`false`如果 <xref:System.Double> 值为或，则 <xref:System.Double.PositiveInfinity> 返回 <xref:System.Double.NegativeInfinity> 。 若要测试这些值，请使用 <xref:System.Double.IsInfinity%2A> 、 <xref:System.Double.IsPositiveInfinity%2A> 和 <xref:System.Double.IsNegativeInfinity%2A> 方法。  
  
   
  
## Examples  
 下面的代码示例阐释了的用法 <xref:System.Double.IsNaN%2A> ：  
  
 [!code-cpp[System.Double#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#8)]
 [!code-csharp[System.Double#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#8)]
 [!code-vb[System.Double#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Double.NaN" />
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (double d);" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegative(float64 d) cil managed" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegative(System.Double)" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (d As Double) As Boolean" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(double d);" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="F#" Value="static member IsNegative : double -&gt; bool" Usage="System.double.IsNegative d" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="d">一个双精度浮点数。</param>
        <summary>确定指定值是否为负值。</summary>
        <returns>如果该值为负值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegativeInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsNegativeInfinity : double -&gt; bool" Usage="System.double.IsNegativeInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">一个双精度浮点数。</param>
        <summary>返回一个值，通过该值指示指定数字是否计算为负无穷大。</summary>
        <returns>如果 <paramref name="d" /> 的计算结果为 <see cref="F:System.Double.NegativeInfinity" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 浮点运算返回 <xref:System.Double.NegativeInfinity> 信号表示溢出情况。  
  
   
  
## Examples  
 下面的代码示例阐释了的用法 <xref:System.Double.IsNegativeInfinity%2A> ：  
  
 [!code-cpp[System.Double#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#13)]
 [!code-csharp[System.Double#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#13)]
 [!code-vb[System.Double#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#13)]  
[!code-cpp[System.Double#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#4)]
[!code-csharp[System.Double#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#4)]
[!code-vb[System.Double#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#4)]  
[!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
[!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
[!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNormal">
      <MemberSignature Language="C#" Value="public static bool IsNormal (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormal(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNormal(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormal (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(double d);" />
      <MemberSignature Language="F#" Value="static member IsNormal : double -&gt; bool" Usage="System.double.IsNormal d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="d">一个双精度浮点数。</param>
        <summary>确定指定值是否正常。</summary>
        <returns>如果该值正常，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsPositiveInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsPositiveInfinity : double -&gt; bool" Usage="System.double.IsPositiveInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">一个双精度浮点数。</param>
        <summary>返回一个值，通过该值指示指定数字是否计算为正无穷大。</summary>
        <returns>如果 <paramref name="d" /> 的计算结果为 <see cref="F:System.Double.PositiveInfinity" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 浮点运算返回 <xref:System.Double.PositiveInfinity> 信号表示溢出情况。  
  
   
  
## Examples  
 下面的代码示例阐释了的用法 <xref:System.Double.IsPositiveInfinity%2A> ：  
  
 [!code-cpp[System.Double#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#12)]
 [!code-csharp[System.Double#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#12)]
 [!code-vb[System.Double#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal">
      <MemberSignature Language="C#" Value="public static bool IsSubnormal (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormal(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsSubnormal(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormal (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(double d);" />
      <MemberSignature Language="F#" Value="static member IsSubnormal : double -&gt; bool" Usage="System.double.IsSubnormal d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="d">一个双精度浮点数。</param>
        <summary>确定指定值是否不正常。</summary>
        <returns>如果该值不正常，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const double MaxValue = 1.7976931348623157E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MaxValue = float64(1.7976931348623157E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Double  = 1.7976931348623157E+308" />
      <MemberSignature Language="C++ CLI" Value="public: double MaxValue = 1.7976931348623157E+308;" />
      <MemberSignature Language="F#" Value="val mutable MaxValue : double" Usage="System.double.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>1.7976931348623157E+308</MemberValue>
      <Docs>
        <summary>表示 <see cref="T:System.Double" /> 的最大可能值。 此字段为常数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此常量的值为正 1.7976931348623157 E + 308。  
  
 超出的操作的结果 <xref:System.Double.MaxValue?displayProperty=nameWithType> 为 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 。 在下面的示例中， <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 结果超出时，加法、乘法和求幂运算的结果 <xref:System.Double.MaxValue?displayProperty=nameWithType> 。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.maxvalue/cs/maxvalueex.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.maxvalue/vb/maxvalueex.vb" id="Snippet1":::
  
   
  
## Examples  
 下面的代码示例阐释了的用法 <xref:System.Double.MaxValue?displayProperty=nameWithType> ：  
  
 [!code-cpp[Double Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const double MinValue = -1.7976931348623157E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MinValue = float64(-1.7976931348623157E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Double  = -1.7976931348623157E+308" />
      <MemberSignature Language="C++ CLI" Value="public: double MinValue = -1.7976931348623157E+308;" />
      <MemberSignature Language="F#" Value="val mutable MinValue : double" Usage="System.double.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-1.7976931348623157E+308</MemberValue>
      <Docs>
        <summary>表示 <see cref="T:System.Double" /> 的最小可能值。 此字段为常数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此常量的值为负 1.7976931348623157 E + 308。  
  
 小于的操作的结果 <xref:System.Double.MinValue?displayProperty=nameWithType> 为 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 。 在下面的示例中， <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 当结果小于时，减法运算和乘法运算的结果 <xref:System.Double.MinValue?displayProperty=nameWithType> 。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.minvalue/cs/minvalueex.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.minvalue/vb/minvalueex.vb" id="Snippet1":::
   
  
## Examples  
 下面的代码示例阐释了的用法 <xref:System.Double.MinValue?displayProperty=nameWithType> ：  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp" id="Snippet2":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb" id="Snippet2"::: 

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const double NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NaN = float64(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Const NaN As Double  = NaN" />
      <MemberSignature Language="C++ CLI" Value="public: double NaN = NaN;" />
      <MemberSignature Language="F#" Value="val mutable NaN : double" Usage="System.double.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>表示不是数字 (<see langword="NaN" />) 的值。 此字段为常数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.NaN>当操作的结果不确定时，方法或运算符将返回。 例如，零除以零的结果为 <xref:System.Double.NaN> ，如下面的示例所示。  (但要注意的是，将非零数除以零会返回 <xref:System.Double.PositiveInfinity> 或 <xref:System.Double.NegativeInfinity> ，具体取决于除数的符号。 )   
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb" id="Snippet1"::: 
  
 此外，对于 <xref:System.Double.NaN> 值或对值进行操作的方法调用将 <xref:System.Double.NaN> 返回 <xref:System.Double.NaN> ，如下面的示例所示。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb" id="Snippet2"::: 
  
 使用 <xref:System.Double.IsNaN%2A> 方法确定某个值是否不是数字。 <xref:System.Double.op_Equality%2A>运算符将两个 <xref:System.Double.NaN> 值视为相互不相等。 通常， <xref:System.Double> 运算符不能用于 <xref:System.Double.NaN?displayProperty=nameWithType> 与其他值进行比较 <xref:System.Double> ，不过比较方法 (例如 <xref:System.Double.Equals%2A> 和 <xref:System.Double.CompareTo%2A>) 可以。 下面的示例阐释 <xref:System.Double> 比较运算符与方法之间的行为差异。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/double.nan4.cs" interactive="try-dotnet" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/double.nan4.vb" id="Snippet4":::
  
   
  
## Examples  
 以下示例演示了 <xref:System.Double.NaN> 的用法：  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp" id="Snippet7":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs" interactive="try-dotnet-method" id="Snippet7":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb" id="Snippet7"::: 
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsNaN(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const double NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NegativeInfinity = float64(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NegativeInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const NegativeInfinity As Double  = -Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: double NegativeInfinity = -Infinity;" />
      <MemberSignature Language="F#" Value="val mutable NegativeInfinity : double" Usage="System.double.NegativeInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>表示负无穷。 此字段为常数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此常量的值是负数除以零所得的结果。  
  
 当操作的结果小于时，将返回此常数 <xref:System.Double.MinValue?displayProperty=nameWithType> 。  
  
 用于 <xref:System.Double.IsNegativeInfinity%2A> 确定某个值是否计算为负无穷大。  
  
   
  
## Examples  
 下面的代码示例阐释了的用法 <xref:System.Double.NegativeInfinity> ：  
  
 [!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
 [!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
 [!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Equality(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : double * double -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示两个指定的 <see cref="T:System.Double" /> 值是否相等。</summary>
        <returns>如果 <paramref name="left" /> 和 <paramref name="right" /> 相等，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.op_Equality%2A>方法为值定义相等运算符 <xref:System.Double> 。  
  
 如果 <xref:System.Double.NaN?displayProperty=nameWithType> 使用相等运算符测试两个值是否相等，则结果为 `false` ; 两个 <xref:System.Double.NaN?displayProperty=nameWithType> 值不被视为相等。 如果通过调用方法来测试它们是否相等 <xref:System.Double.Equals%2A> ，则结果为 `true` 。  如果要确定的值是否 <xref:System.Double> 不是 (NaN) 的数字，则可以选择调用 <xref:System.Double.IsNaN%2A> 方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThan(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : double * double -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示指定的 <see cref="T:System.Double" /> 值是否大于另一个指定的 <see cref="T:System.Double" /> 值。</summary>
        <returns>如果 <see langword="true" /> 大于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.op_GreaterThan%2A>方法为值定义大于运算符的运算 <xref:System.Double> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThanOrEqual(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : double * double -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示指定的 <see cref="T:System.Double" /> 值是否大于或等于另一个指定的 <see cref="T:System.Double" /> 值。</summary>
        <returns>如果 <paramref name="left" /> 大于等于 <paramref name="right" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.op_GreaterThanOrEqual%2A>方法为值定义大于或等于运算符的运算 <xref:System.Double> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Inequality(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : double * double -&gt; bool" Usage="System.double.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示两个指定的 <see cref="T:System.Double" /> 值是否不相等。</summary>
        <returns>如果 <paramref name="left" /> 和 <paramref name="right" /> 不相等，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.op_Inequality%2A>方法为值定义不相等运算符 <xref:System.Double> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThan(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : double * double -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示指定的 <see cref="T:System.Double" /> 值是否小于另一个指定的 <see cref="T:System.Double" /> 值。</summary>
        <returns>如果 <paramref name="left" /> 小于 <paramref name="right" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.op_LessThan%2A>方法为值定义了小于运算符的运算 <xref:System.Double> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThanOrEqual(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : double * double -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示指定的 <see cref="T:System.Double" /> 值是否小于或等于另一个指定的 <see cref="T:System.Double" /> 值。</summary>
        <returns>如果 <paramref name="left" /> 小于等于 <paramref name="right" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.op_LessThanOrEqual%2A>方法为值定义了小于或等于运算符的运算 <xref:System.Double> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将数字的字符串表示形式转换为它的等效双精度浮点数。</summary>
        <altmember cref="Overload:System.Double.TryParse" />
        <remarks>在 .NET Core 3.0 及更高版本中，太大而无法表示的值将舍入到， <see cref="F:System.Double.PositiveInfinity" /> 或 <see cref="F:System.Double.NegativeInfinity" /> 根据 IEEE 754 规范的要求进行舍入。 在以前的版本中（包括 .NET Framework），分析过大而无法表示的值导致失败。</remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; double" Usage="System.double.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的数字的字符串。</param>
        <summary>将数字的字符串表示形式转换为它的等效双精度浮点数。</summary>
        <returns>与 <paramref name="s" /> 中指定的数值或符号等效的双精度浮点数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 .NET Core 3.0 及更高版本中，太大而无法表示的值将舍入到， <xref:System.Double.PositiveInfinity> 或 <xref:System.Double.NegativeInfinity> 根据 IEEE 754 规范的要求进行舍入。 在以前的版本中（包括 .NET Framework），分析过大而无法表示的值导致失败。

 `s`参数可以包含当前区域性的、、 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType> <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType> <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> 或格式的字符串：  
  
 [*ws*][*sign*][*整数位数*[*，*]]*整数位数*[*。*[*小数位数*]][E [*sign*]*指数-数字*][*ws*]  
  
 方括号 ([ and ]) 中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|一系列空白字符。|  
|*sign*|负号符号 (-) 或正号符号 (+) 。 只能使用前导符号。|  
|*整数位数*|一系列从0到9之间的数字，用于指定数字的整数部分。 *整数位数*的运行可以通过组分隔符进行分区。 例如，在某些区域性中，用逗号 (，) 分隔上千组。 如果字符串包含*小数位数*元素，则可以不存在*整数位数*元素。|  
|,|区域性特定的千位分隔符。|  
|。|区域性特定的小数点符号。|  
|*小数位数*|一系列从0到9之间的数字，用于指定数字的小数部分。|  
|E|"E" 或 "E" 字符，指示以指数 (科学) 记数法表示的值。|  
|*指数位数*|一系列从0到9之间的数字，用于指定指数。|  
  
 `s`参数使用和标志的组合来进行解释 <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 。 这意味着允许使用空格和千位分隔符，例如，货币符号不允许。 为了更好地控制允许 `s` 分析操作成功的样式元素，请调用 <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> 或 <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 方法。  
  
 `s`使用为 <xref:System.Globalization.NumberFormatInfo> 当前线程区域性初始化的对象中的格式设置信息对参数进行解释。 有关详细信息，请参阅 <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>。 若要使用其他某个区域性的格式设置信息分析字符串，请调用 <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 或 <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 方法。  
  
 通常，如果向方法传递 <xref:System.Double.Parse%2A?displayProperty=nameWithType> 通过调用方法创建的字符串 <xref:System.Double.ToString%2A?displayProperty=nameWithType> ，则 <xref:System.Double> 返回原始值。 但是，在 .NET Framework 和 .NET Core 2.2 及更早版本上，值可能不相等，因为精度损失。 此外，尝试分析或的字符串表示形式不 <xref:System.Double.MinValue?displayProperty=nameWithType> <xref:System.Double.MaxValue?displayProperty=nameWithType> 会往返。 在 .NET Framework 和 .NET Core 2.2 及早期版本上，它会引发 <xref:System.OverflowException> 。 下面的示例进行了这方面的演示。 
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs" interactive="try-dotnet-method" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb" id="Snippet3":::

在 .NET Framework 和 .NET Core 2.2 及更早版本中，如果超出了 `s` <xref:System.Double> 数据类型的范围，则该 <xref:System.Double.Parse%28System.String%29> 方法将引发 <xref:System.OverflowException> 。

在 .NET Core 3.0 及更高版本中，当 `s` 超出数据类型的范围时，不会引发异常 <xref:System.Double> 。 在大多数情况下，方法将返回 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 或 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 。 但是，有一小部分值被视为比的最大值或最小值更接近于 <xref:System.Double> 正无穷或负无穷。 在这些情况下，方法返回 <xref:System.Double.MaxValue?displayProperty=nameWithType> 或 <xref:System.Double.MinValue?displayProperty=nameWithType> 。

如果在分析操作过程中在参数中遇到分隔符 `s` ，并且适用的货币或小数分隔符和组分隔符相同，则分析操作将假定分隔符是小数点分隔符，而不是组分隔符。 有关分隔符的详细信息，请参阅 <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A> 、、 <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A> <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> 和 <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A> 。     
  
## Examples  
 下面的示例演示 <xref:System.Double.Parse%28System.String%29> 方法的用法。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp" id="Snippet5":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs" id="Snippet5":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb" id="Snippet5":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> 不表示具有有效格式的数字。</exception>
        <exception cref="T:System.OverflowException">仅限 .NET Framework 和 .NET Core 2.2 及更低版本：<paramref name="s" /> 表示一个小于 <see cref="F:System.Double.MinValue" /> 或大于 <see cref="F:System.Double.MaxValue" /> 的数字。</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="M:System.Double.TryParse(System.String,System.Double@)" />
        <related type="Article" href="/dotnet/standard/base-types/parsing-numeric">分析 .NET 中的数字字符串</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; double" Usage="System.double.Parse (s, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的数字的字符串。</param>
        <param name="style">枚举值的按位组合，用于指示可出现在 <paramref name="s" /> 中的样式元素。 一个要指定的典型值为 <see cref="F:System.Globalization.NumberStyles.Float" /> 和 <see cref="F:System.Globalization.NumberStyles.AllowThousands" /> 的组合。</param>
        <summary>将指定样式的数字的字符串表示形式转换为它的等效双精度浮点数。</summary>
        <returns>与 <paramref name="s" /> 中指定的数值或符号等效的双精度浮点数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 .NET Core 3.0 及更高版本中，太大而无法表示的值将舍入到， <xref:System.Double.PositiveInfinity> 或 <xref:System.Double.NegativeInfinity> 根据 IEEE 754 规范的要求进行舍入。 在以前的版本中（包括 .NET Framework），分析过大而无法表示的值导致失败。

 `style`参数定义在参数中允许的样式元素 (如空格、千位分隔符和货币符号) ，以便 `s` 分析操作成功。 它必须是枚举中的位标志的组合 <xref:System.Globalization.NumberStyles> 。 <xref:System.Globalization.NumberStyles>不支持以下成员：  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 `s`参数可以包含当前区域性的 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType> 、 <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType> 或 <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> 。 根据的值 `style` ，它还可以采用以下格式：  
  
 [*ws*][ *$* ] [*sign*] [*整数位数*[*，*]]*整数位数*[*。*[*小数位数*]][E [*sign*]*指数-数字*][*ws*]  
  
 方括号 ([ and ]) 中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|一系列空白字符。 如果包含标志，则空格可以出现在的开头 `s` `style` <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> ，如果包含标志，则可以在的末尾出现空白 `s` `style` <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> 。|  
|$|区域性特定的货币符号。 其在字符串中的位置由 <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> 当前区域性的和属性定义。 `s`如果包含标志，则当前区域性的货币符号可以出现在中 `style` <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> 。|  
|*sign*|负号符号 (-) 或正号符号 (+) 。 如果包含标志，则符号可以出现在的开头 `s` `style` <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> ，如果包含标志，则它可以出现在的末尾 `s` `style` <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> 。 如果包含标志，则可以在中使用括号 `s` 来表示负值 `style` <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> 。|  
|*整数位数*|一系列从0到9之间的数字，用于指定数字的整数部分。 如果字符串包含*小数位数*元素，则可以不存在*整数位数*元素。|  
|,|区域性特定的组分隔符。 `s`如果 `style` 包含 <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 标志，则当前区域性的组分隔符符号可以出现在中|  
|。|区域性特定的小数点符号。 `s`如果包含标志，则当前区域性的小数点符号可以出现在中 `style` <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 。|  
|*小数位数*|一系列从0到9之间的数字，用于指定数字的小数部分。 `s`如果 `style` 包含标志，则小数位数可以出现在中 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 。|  
|E|"E" 或 "E" 字符，指示以指数 (科学) 记数法表示的值。 `s`如果包含标志，则参数可以表示指数表示法中的数字 `style` <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> 。|  
|*指数位数*|一系列从0到9之间的数字，用于指定指数。|  
  
> [!NOTE]
> `s`无论参数的值如何，分析操作都将忽略中任何终止的 NUL (U + 0000) 字符 `style` 。

 只包含数字的字符串 (与 <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> 样式) 始终在类型范围内分析成功 <xref:System.Double> 。 其余 <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> 成员控件元素可能存在但不需要存在于输入字符串中。 下表指示各个标志如何 <xref:System.Globalization.NumberStyles> 影响可能出现在中的元素 `s` 。  
  
|NumberStyles 值|中允许的元素 `s` 以及数字|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|仅限 *整数数字* 元素。|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|小数点 () 和*小数位数**元素。*|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E" 或 "E" 字符，指示指数表示法。 此标志本身 *支持格式为*E*位*的值;若要成功地分析包含正号或负号和小数点符号的字符串，需要其他标志。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|开头的 *ws* 元素 `s` 。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|末尾处的 *ws* 元素 `s` 。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|开头的 *sign* 元素 `s` 。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|末尾的 *sign* 元素 `s` 。|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|用括号括起数值的 *符号* 元素。|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|千位分隔符 (，) 元素。|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|货币 ($) 元素。|  
|<xref:System.Globalization.NumberStyles.Currency>|所有元素。 但是， `s` 不能表示十六进制数或以指数表示法表示的数字。|  
|<xref:System.Globalization.NumberStyles.Float>|在开头或结尾处的 *ws* 元素，在 `s` 的开头处 *符号* ， `s` 小数点 ( ) 符号。 `s`参数还可以使用指数表示法。|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`、 `sign` 、千位分隔符 (、) 和小数点 ( ) 元素。|  
|<xref:System.Globalization.NumberStyles.Any>|所有元素。 但是， `s` 不能表示十六进制数。|  
  
 `s`使用为 <xref:System.Globalization.NumberFormatInfo> 当前系统区域性初始化的对象中的格式设置信息分析参数。 有关详细信息，请参阅 <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>。  
  
 通常，如果向方法传递 <xref:System.Double.Parse%2A?displayProperty=nameWithType> 通过调用方法创建的字符串 <xref:System.Double.ToString%2A?displayProperty=nameWithType> ，则 <xref:System.Double> 返回原始值。 但是，由于精度损失，值可能不相等。 此外，尝试分析或的字符串表示形式不 <xref:System.Double.MinValue?displayProperty=nameWithType> <xref:System.Double.MaxValue?displayProperty=nameWithType> 会往返。 在 .NET Framework 和 .NET Core 2.2 及早期版本上，它会引发 <xref:System.OverflowException> 。 在 .NET Core 3.0 及更高版本中， <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 如果您尝试分析 <xref:System.Double.MinValue?displayProperty=nameWithtype> 或 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 您尝试进行分析，它将返回 <xref:System.Double.MaxValue?displayProperty=nameWithtype> 。 下面的示例进行了这方面的演示。 
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs" interactive="try-dotnet-method" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb" id="Snippet3":::

在 .NET Framework 和 .NET Core 2.2 及更早版本中，如果超出了 `s` <xref:System.Double> 数据类型的范围，则该 <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> 方法将引发 <xref:System.OverflowException> 。

在 .NET Core 3.0 及更高版本中，当 `s` 超出数据类型的范围时，不会引发异常 <xref:System.Double> 。 在大多数情况下， <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> 方法将返回 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 或 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 。 但是，有一小部分值被视为比的最大值或最小值更接近于 <xref:System.Double> 正无穷或负无穷。 在这些情况下，方法返回 <xref:System.Double.MaxValue?displayProperty=nameWithType> 或 <xref:System.Double.MinValue?displayProperty=nameWithType> 。

如果在分析操作过程中在参数中遇到分隔符 `s` ，并且适用的货币或小数分隔符和组分隔符相同，则分析操作将假定分隔符是小数点分隔符，而不是组分隔符。 有关分隔符的详细信息，请参阅 <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A> 、、 <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A> <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> 和 <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A> 。   
  
## Examples  
 下面的示例使用 <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> 方法来分析使用 en-us 区域性的值的字符串表示形式 <xref:System.Double> 。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse.cs" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> 不表示具有有效格式的数字。</exception>
        <exception cref="T:System.OverflowException">仅限 .NET Framework 和 .NET Core 2.2 及更低版本：<paramref name="s" /> 表示一个小于 <see cref="F:System.Double.MinValue" /> 或大于 <see cref="F:System.Double.MaxValue" /> 的数字。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> 不是 <see cref="T:System.Globalization.NumberStyles" /> 值。  
  
- 或 - 
 <paramref name="style" /> 包括 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 值。</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="Overload:System.Double.TryParse" />
        <related type="Article" href="/dotnet/standard/base-types/parsing-numeric">分析 .NET 中的数字字符串</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, IFormatProvider provider);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; double" Usage="System.double.Parse (s, provider)" />
      <MemberSignature Language="C#" Value="public static double Parse (string s, IFormatProvider? provider);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的数字的字符串。</param>
        <param name="provider">一个对象，提供有关 <paramref name="s" /> 的区域性特定格式设置信息。</param>
        <summary>将指定的区域性特定格式的数字的字符串表示形式转换为它的等效双精度浮点数。</summary>
        <returns>与 <paramref name="s" /> 中指定的数值或符号等效的双精度浮点数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 .NET Core 3.0 及更高版本中，太大而无法表示的值将舍入到， <xref:System.Double.PositiveInfinity> 或 <xref:System.Double.NegativeInfinity> 根据 IEEE 754 规范的要求进行舍入。 在以前的版本中（包括 .NET Framework），分析过大而无法表示的值导致失败。

 此方法的重载 <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> 通常用于将可以多种方式设置格式的文本转换为 <xref:System.Double> 值。 例如，它可用于将用户输入的文本转换为一个数字值，并将其转换为一个文本框。  
  
 `s`参数使用和标志的组合来进行解释 <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 。 `s`参数可以 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType> <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType> 为指定的区域性包含、或，也可以 <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> `provider` 包含以下形式的字符串：  
  
 [*ws*][*sign*]*整数位数*[*。*[*小数位数*]][E [*sign*]*指数-数字*][*ws*]  
  
 可选元素括在方括号中， ( [和] ) 。 包含术语 "数字" 的元素包含一系列从0到9之间的数字字符。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|一系列空白字符。|  
|*sign*|负号符号 (-) 或正号符号 (+) 。|  
|*整数位数*|一系列从0到9之间的数字，用于指定数字的整数部分。 *整数位数*的运行可以通过组分隔符进行分区。 例如，在某些区域性中，用逗号 (，) 分隔上千组。 如果字符串包含*小数位数*元素，则可以不存在*整数位数*元素。|  
|。|区域性特定的小数点符号。|  
|*小数位数*|一系列从0到9之间的数字，用于指定数字的小数部分。|  
|E|"E" 或 "E" 字符，指示以指数 (科学) 记数法表示的值。|  
|*指数位数*|一系列从0到9之间的数字，用于指定指数。|  
  
 有关数字格式的详细信息，请参阅 [格式设置类型](/dotnet/standard/base-types/formatting-types) 主题。  
  
 `provider`参数是一个 <xref:System.IFormatProvider> 实现，其 <xref:System.IFormatProvider.GetFormat%2A> 方法返回 <xref:System.Globalization.NumberFormatInfo> 对象，该对象提供用于解释的格式的区域性特定信息 `s` 。 通常，它是一个 <xref:System.Globalization.NumberFormatInfo> 或 <xref:System.Globalization.CultureInfo> 对象。 如果 `provider` 为 `null` 或 <xref:System.Globalization.NumberFormatInfo> ，则使用当前系统区域性的格式设置信息。  
  
 通常，如果向方法传递 <xref:System.Double.Parse%2A?displayProperty=nameWithType> 通过调用方法创建的字符串 <xref:System.Double.ToString%2A?displayProperty=nameWithType> ，则 <xref:System.Double> 返回原始值。 但是，由于精度损失，值可能不相等。 此外，尝试分析或的字符串表示形式不 <xref:System.Double.MinValue?displayProperty=nameWithType> <xref:System.Double.MaxValue?displayProperty=nameWithType> 会往返。 在 .NET Framework 和 .NET Core 2.2 及早期版本上，它会引发 <xref:System.OverflowException> 。 在 .NET Core 3.0 及更高版本中， <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 如果您尝试分析 <xref:System.Double.MinValue?displayProperty=nameWithtype> 或 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 您尝试进行分析，它将返回 <xref:System.Double.MaxValue?displayProperty=nameWithtype> 。 下面的示例进行了这方面的演示。
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs" interactive="try-dotnet-method" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb" id="Snippet3":::

在 .NET Framework 和 .NET Core 2.2 及更早版本中，如果超出了 `s` <xref:System.Double> 数据类型的范围，则该 <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> 方法将引发 <xref:System.OverflowException> 。

在 .NET Core 3.0 及更高版本中，当 `s` 超出数据类型的范围时，不会引发异常 <xref:System.Double> 。 在大多数情况下， <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> 方法将返回 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 或 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 。 但是，有一小部分值被视为比的最大值或最小值更接近于 <xref:System.Double> 正无穷或负无穷。 在这些情况下，方法返回 <xref:System.Double.MaxValue?displayProperty=nameWithType> 或 <xref:System.Double.MinValue?displayProperty=nameWithType> 。

如果在分析操作过程中在参数中遇到分隔符 `s` ，并且适用的货币或小数分隔符和组分隔符相同，则分析操作将假定分隔符是小数点分隔符，而不是组分隔符。 有关分隔符的详细信息，请参阅 <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A> 、、 <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A> <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> 和 <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A> 。  
 
## Examples  
 下面的示例是 Web 窗体的按钮单击事件处理程序。 它使用属性返回的数组 <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType> 来确定用户的区域设置。 然后，它将实例化 <xref:System.Globalization.CultureInfo> 对应于该区域设置的对象。 然后，将 <xref:System.Globalization.NumberFormatInfo> 属于该对象的对象 <xref:System.Globalization.CultureInfo> 传递给 <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> 方法，以将用户的输入转换为 <xref:System.Double> 值。  
  
 [!code-csharp[ParseMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#2)]
 [!code-vb[ParseMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> 不表示具有有效格式的数字。</exception>
        <exception cref="T:System.OverflowException">仅限 .NET Framework 和 .NET Core 2.2 及更低版本：<paramref name="s" /> 表示一个小于 <see cref="F:System.Double.MinValue" /> 或大于 <see cref="F:System.Double.MaxValue" /> 的数字。</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="Overload:System.Double.TryParse" />
        <related type="Article" href="/dotnet/standard/base-types/parsing-numeric">分析 .NET 中的数字字符串</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, IFormatProvider? provider = default);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = Nothing) As Double" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; double" Usage="System.double.Parse (s, style, provider)" />
      <MemberSignature Language="C#" Value="public static double Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, IFormatProvider provider = default);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的数字的字符范围。</param>
        <param name="style">枚举值的按位组合，用于指示可出现在 <paramref name="s" /> 中的样式元素。  一个用来指定的典型值为 <see cref="F:System.Globalization.NumberStyles.Float" /> 与 <see cref="F:System.Globalization.NumberStyles.AllowThousands" /> 的组合。</param>
        <param name="provider">一个对象，提供有关 <paramref name="s" /> 的区域性特定格式设置信息。</param>
        <summary>将字符范围（其中包含指定样式和区域性特定格式的数字的字符串表示形式）转换为它的等效双精度浮点数。</summary>
        <returns>与 <paramref name="s" /> 中指定的数值或符号等效的双精度浮点数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

在 .NET Core 3.0 及更高版本中，太大而无法表示的值将舍入到， <xref:System.Double.PositiveInfinity> 或 <xref:System.Double.NegativeInfinity> 根据 IEEE 754 规范的要求进行舍入。 在以前的版本中（包括 .NET Framework），分析过大而无法表示的值导致失败。

如果超出 `s` 了数据类型的范围 <xref:System.Double> ，则 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 当 `s` 小于 <xref:System.Double.MinValue?displayProperty=nameWithType> 且 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> `s` 大于时 <xref:System.Double.MaxValue?displayProperty=nameWithType> ，此方法将返回。

         ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="s" /> 不表示一个数值。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> 不是 <see cref="T:System.Globalization.NumberStyles" /> 值。  
  
- 或 - 
 <paramref name="style" /> 是 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 值。</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; double" Usage="System.double.Parse (s, style, provider)" />
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style, IFormatProvider? provider);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的数字的字符串。</param>
        <param name="style">枚举值的按位组合，用于指示可出现在 <paramref name="s" /> 中的样式元素。 一个用来指定的典型值为 <see cref="F:System.Globalization.NumberStyles.Float" /> 与 <see cref="F:System.Globalization.NumberStyles.AllowThousands" /> 的组合。</param>
        <param name="provider">一个对象，提供有关 <paramref name="s" /> 的区域性特定格式设置信息。</param>
        <summary>将指定样式和区域性特定格式的数字的字符串表示形式转换为它的等效双精度浮点数。</summary>
        <returns>与 <paramref name="s" /> 中指定的数值或符号等效的双精度浮点数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 .NET Core 3.0 及更高版本中，太大而无法表示的值将舍入到， <xref:System.Double.PositiveInfinity> 或 <xref:System.Double.NegativeInfinity> 根据 IEEE 754 规范的要求进行舍入。 在以前的版本中（包括 .NET Framework），分析过大而无法表示的值导致失败。

 `style`参数定义在参数中允许的样式元素 (如空格、千位分隔符和货币符号) ，以便 `s` 分析操作成功。 它必须是枚举中的位标志的组合 <xref:System.Globalization.NumberStyles> 。 <xref:System.Globalization.NumberStyles>不支持以下成员：  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 `s` <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType> 对于由指定的区域性，参数可以包含、 <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType> 或 <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> `provider` 。 根据的值 `style` ，它还可以采用以下格式：  
  
 [*ws*][ *$* ] [*sign*] [*整数位数*，]*整数位数*[. [*小数位数*]][E [*sign*]*指数-数字*][*ws*]  
  
 括在方括号 ( [和] ) 的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|一系列空白字符。 如果包含标志，则空格可以出现在的开头 `s` `style` <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> ，如果包含标志，则可以在的末尾出现空白 `s` `style` <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> 。|  
|$|区域性特定的货币符号。 其在字符串中的位置由 <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> 当前区域性的和属性定义。 `s`如果包含标志，则当前区域性的货币符号可以出现在中 `style` <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> 。|  
|*sign*|负号符号 (-) 或正号符号 (+) 。 如果包含标志，则符号可以出现在的开头 `s` `style` <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> ，如果包含标志，则它可以出现在的末尾 `s` `style` <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> 。 如果包含标志，则可以在中使用括号 `s` 来表示负值 `style` <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> 。|  
|*整数位数*|一系列从0到9之间的数字，用于指定数字的整数部分。 如果字符串包含*小数位数*元素，则可以不存在*整数位数*元素。|  
|,|区域性特定的组分隔符。 `s`如果 `style` 包含 <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 标志，则当前区域性的组分隔符符号可以出现在中|  
|。|区域性特定的小数点符号。 `s`如果包含标志，则当前区域性的小数点符号可以出现在中 `style` <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 。|  
|*小数位数*|一系列从0到9之间的数字，用于指定数字的小数部分。 `s`如果 `style` 包含标志，则小数位数可以出现在中 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 。|  
|E|"E" 或 "E" 字符，指示以指数 (科学) 记数法表示的值。 `s`如果包含标志，则参数可以表示指数表示法中的数字 `style` <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> 。|  
|*指数位数*|一系列从0到9之间的数字，用于指定指数。|  
  
> [!NOTE]
> `s`无论参数的值如何，分析操作都将忽略中任何终止的 NUL (U + 0000) 字符 `style` 。

 只包含数字的字符串 (与 <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> 样式) 始终在类型范围内分析成功 <xref:System.Double> 。 其余 <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> 成员控件元素可能存在但不需要存在于输入字符串中。 下表指示各个标志如何 <xref:System.Globalization.NumberStyles> 影响可能出现在中的元素 `s` 。  
  
|NumberStyles 值|中允许的元素 `s` 以及数字|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|仅限 *整数数字* 元素。|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|小数点 () 和*小数位数**元素。*|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E" 或 "E" 字符，指示指数表示法。 此标志本身 *支持格式为*E*位*的值;若要成功地分析包含正号或负号和小数点符号的字符串，需要其他标志。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|开头的 *ws* 元素 `s` 。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|末尾处的 *ws* 元素 `s` 。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|开头的 *sign* 元素 `s` 。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|末尾的 *sign* 元素 `s` 。|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|用括号括起数值的 *符号* 元素。|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|千位分隔符 (，) 元素。|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|货币 ($) 元素。|  
|<xref:System.Globalization.NumberStyles.Currency>|所有元素。 但是， `s` 不能表示十六进制数或以指数表示法表示的数字。|  
|<xref:System.Globalization.NumberStyles.Float>|在开头或结尾处的 *ws* 元素，在 `s` 的开头处 *符号* ， `s` 小数点 ( ) 符号。 `s`参数还可以使用指数表示法。|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`、 `sign` 、千位分隔符 (、) 和小数点 ( ) 元素。|  
|<xref:System.Globalization.NumberStyles.Any>|所有元素。 但是， `s` 不能表示十六进制数。|  
  
 `provider`参数是一个 <xref:System.IFormatProvider> 实现，其 <xref:System.IFormatProvider.GetFormat%2A> 方法返回 <xref:System.Globalization.NumberFormatInfo> 对象，该对象提供用于解释的格式的区域性特定信息 `s` 。 通常，它是一个 <xref:System.Globalization.NumberFormatInfo> 或 <xref:System.Globalization.CultureInfo> 对象。 如果 `provider` 为 `null` 或 <xref:System.Globalization.NumberFormatInfo> ，则使用当前系统区域性的格式设置信息。  
  
 通常，如果向方法传递 <xref:System.Double.Parse%2A?displayProperty=nameWithType> 通过调用方法创建的字符串 <xref:System.Double.ToString%2A?displayProperty=nameWithType> ，则 <xref:System.Double> 返回原始值。 但是，由于精度损失，值可能不相等。 此外，尝试分析或的字符串表示形式不 <xref:System.Double.MinValue?displayProperty=nameWithtype> <xref:System.Double.MaxValue?displayProperty=nameWithType> 会往返。 在 .NET Framework 和 .NET Core 2.2 及早期版本上，它会引发 <xref:System.OverflowException> 。 在 .NET Core 3.0 及更高版本中， <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 如果您尝试分析 <xref:System.Double.MinValue?displayProperty=nameWithtype> 或 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 您尝试进行分析，它将返回 <xref:System.Double.MaxValue?displayProperty=nameWithtype> 。 下面的示例进行了这方面的演示。   
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs" interactive="try-dotnet-method" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb" id="Snippet3":::

在 .NET Framework 和 .NET Core 2.2 及更早版本中，如果超出了 `s` <xref:System.Double> 数据类型的范围，则该 <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> 方法将引发 <xref:System.OverflowException> 。

在 .NET Core 3.0 及更高版本中，当 `s` 超出数据类型的范围时，不会引发异常 <xref:System.Double> 。 在大多数情况下， <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> 方法将返回 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 或 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 。 但是，有一小部分值被视为比的最大值或最小值更接近于 <xref:System.Double> 正无穷或负无穷。 在这些情况下，方法返回 <xref:System.Double.MaxValue?displayProperty=nameWithType> 或 <xref:System.Double.MinValue?displayProperty=nameWithType> 。

如果在分析操作过程中在参数中遇到分隔符 `s` ，并且适用的货币或小数分隔符和组分隔符相同，则分析操作将假定分隔符是小数点分隔符，而不是组分隔符。 有关分隔符的详细信息，请参阅 <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A> 、、 <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A> <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> 和 <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A> 。  

## Examples  
 下面的示例演示如何使用方法将 <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> 温度值的几个字符串表示形式分配给 `Temperature` 对象。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse3.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse3.vb" id="Snippet2":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> 不表示一个数值。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> 不是 <see cref="T:System.Globalization.NumberStyles" /> 值。  
  
- 或 - 
 <paramref name="style" /> 是 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 值。</exception>
        <exception cref="T:System.OverflowException">仅限 .NET Framework 和 .NET Core 2.2 及更低版本：<paramref name="s" /> 表示一个小于 <see cref="F:System.Double.MinValue" /> 或大于 <see cref="F:System.Double.MaxValue" /> 的数字。</exception>
        <altmember cref="M:System.Double.ToString" />
        <related type="Article" href="/dotnet/standard/base-types/parsing-numeric">分析 .NET 中的数字字符串</related>
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const double PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 PositiveInfinity = float64(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.PositiveInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const PositiveInfinity As Double  = Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: double PositiveInfinity = Infinity;" />
      <MemberSignature Language="F#" Value="val mutable PositiveInfinity : double" Usage="System.double.PositiveInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>表示正无穷。 此字段为常数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此常量的值是将正数除以零所得的结果。  
  
 如果操作的结果大于，则返回此常数 <xref:System.Double.MaxValue?displayProperty=nameWithType> 。  
  
 用于 <xref:System.Double.IsPositiveInfinity%2A> 确定某个值是否计算为正无穷大。  
  
   
  
## Examples  
 下面的代码示例阐释了的用法 <xref:System.Double.PositiveInfinity> ：  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp" id="Snippet10":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs" interactive="try-dotnet-method" id="Snippet10":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb" id="Snippet10":::
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberSignature Language="F#" Value="abstract member System.IComparable.CompareTo : obj -&gt; int&#xA;override this.System.IComparable.CompareTo : obj -&gt; int" Usage="double.System.IComparable.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value">要比较的对象。</param>
        <summary>将当前实例与同一类型的另一个对象进行比较，并返回一个整数，该整数指示当前实例在排序顺序中的位置是位于另一个对象之前、之后还是与其位置相同。</summary>
        <returns>一个值，指示要比较的对象的相对顺序。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

此成员是显式接口成员的实现。 它只能在 <xref:System.Double> 实例被强制转换为 <xref:System.IComparable> 接口时使用。

返回值的含义如下：

| “值”             | 含义                                                                 |
|-------------------|-------------------------------------------------------------------------|
| 小于零    | 此实例在排序顺序中位于 `value` 之前。                       |
| 零              | 此实例在排序顺序中的位置与 `value` 相同。 |
| 大于零 | 此实例在排序顺序中位于 `value` 之后。                        |

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.GetTypeCode : unit -&gt; TypeCode&#xA;override this.System.IConvertible.GetTypeCode : unit -&gt; TypeCode" Usage="double.System.IConvertible.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此实例的 <see cref="T:System.TypeCode" />。</summary>
        <returns>枚举常数，它是实现该接口的类或值类型的 <see cref="T:System.TypeCode" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

此成员是显式接口成员的实现。 它只能在 <xref:System.Double> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToBoolean : IFormatProvider -&gt; bool&#xA;override this.System.IConvertible.ToBoolean : IFormatProvider -&gt; bool" Usage="double.System.IConvertible.ToBoolean provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">忽略此参数。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />。</summary>
        <returns>如果当前实例的值不为零，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Double> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代方法是调用 <xref:System.Convert.ToBoolean%28System.Double%29?displayProperty=nameWithType> 方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToByte : IFormatProvider -&gt; byte&#xA;override this.System.IConvertible.ToByte : IFormatProvider -&gt; byte" Usage="double.System.IConvertible.ToByte provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">忽略此参数。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />。</summary>
        <returns>当前实例的值，已转换为 <see cref="T:System.Byte" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Double> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代方法是调用 <xref:System.Convert.ToByte%28System.Double%29?displayProperty=nameWithType> 方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToChar : IFormatProvider -&gt; char&#xA;override this.System.IConvertible.ToChar : IFormatProvider -&gt; char" Usage="double.System.IConvertible.ToChar provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">忽略此参数。</param>
        <summary>不支持此转换。 尝试使用此方法将引发 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>不支持此转换。 不返回任何值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情况下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDateTime : IFormatProvider -&gt; DateTime&#xA;override this.System.IConvertible.ToDateTime : IFormatProvider -&gt; DateTime" Usage="double.System.IConvertible.ToDateTime provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">忽略此参数。</param>
        <summary>不支持此转换。 尝试使用此方法将引发 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>不支持此转换。 不返回任何值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情况下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDecimal : IFormatProvider -&gt; decimal&#xA;override this.System.IConvertible.ToDecimal : IFormatProvider -&gt; decimal" Usage="double.System.IConvertible.ToDecimal provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">忽略此参数。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />。</summary>
        <returns>当前实例的值，已转换为 <see cref="T:System.Decimal" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Double> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代方法是调用 <xref:System.Convert.ToDecimal%28System.Double%29?displayProperty=nameWithType> 方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDouble : IFormatProvider -&gt; double&#xA;override this.System.IConvertible.ToDouble : IFormatProvider -&gt; double" Usage="double.System.IConvertible.ToDouble provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">忽略此参数。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />。</summary>
        <returns>当前实例的值，未更改。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Double> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt16 : IFormatProvider -&gt; int16&#xA;override this.System.IConvertible.ToInt16 : IFormatProvider -&gt; int16" Usage="double.System.IConvertible.ToInt16 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">忽略此参数。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />。</summary>
        <returns>当前实例的值，已转换为 <see cref="T:System.Int16" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Double> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代方法是调用 <xref:System.Convert.ToInt16%28System.Double%29?displayProperty=nameWithType> 方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt32 : IFormatProvider -&gt; int&#xA;override this.System.IConvertible.ToInt32 : IFormatProvider -&gt; int" Usage="double.System.IConvertible.ToInt32 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">忽略此参数。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />。</summary>
        <returns>当前实例的值，已转换为 <see cref="T:System.Int32" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Double> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代方法是调用 <xref:System.Convert.ToInt32%28System.Double%29?displayProperty=nameWithType> 方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt64 : IFormatProvider -&gt; int64&#xA;override this.System.IConvertible.ToInt64 : IFormatProvider -&gt; int64" Usage="double.System.IConvertible.ToInt64 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">忽略此参数。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />。</summary>
        <returns>当前实例的值，已转换为 <see cref="T:System.Int64" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Double> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代方法是调用 <xref:System.Convert.ToInt64%28System.Double%29?displayProperty=nameWithType> 方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToSByte : IFormatProvider -&gt; sbyte&#xA;override this.System.IConvertible.ToSByte : IFormatProvider -&gt; sbyte" Usage="double.System.IConvertible.ToSByte provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">忽略此参数。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />。</summary>
        <returns>当前实例的值，已转换为 <see cref="T:System.SByte" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Double> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代方法是调用 <xref:System.Convert.ToSByte%28System.Double%29?displayProperty=nameWithType> 方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToSingle : IFormatProvider -&gt; single&#xA;override this.System.IConvertible.ToSingle : IFormatProvider -&gt; single" Usage="double.System.IConvertible.ToSingle provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">忽略此参数。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />。</summary>
        <returns>当前实例的值，已转换为 <see cref="T:System.Single" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Double> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代方法是调用 <xref:System.Convert.ToSingle%28System.Double%29?displayProperty=nameWithType> 方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToType (type As Type, provider As IFormatProvider) As Object Implements IConvertible.ToType" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToType : Type * IFormatProvider -&gt; obj&#xA;override this.System.IConvertible.ToType : Type * IFormatProvider -&gt; obj" Usage="double.System.IConvertible.ToType (type, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">此 <see cref="T:System.Double" /> 值要转换为的类型。</param>
        <param name="provider">一个 <see cref="T:System.IFormatProvider" /> 实现，提供有关返回值格式的区域性特定信息。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />。</summary>
        <returns>当前实例的值，已转换为 <paramref name="type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Double> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代 `static` `Shared` 项是在 Visual Basic) 方法中调用 (<xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt16 : IFormatProvider -&gt; uint16&#xA;override this.System.IConvertible.ToUInt16 : IFormatProvider -&gt; uint16" Usage="double.System.IConvertible.ToUInt16 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">忽略此参数。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />。</summary>
        <returns>当前实例的值，已转换为 <see cref="T:System.UInt16" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Double> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代方法是调用 <xref:System.Convert.ToUInt16%28System.Double%29?displayProperty=nameWithType> 方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt32 : IFormatProvider -&gt; uint32&#xA;override this.System.IConvertible.ToUInt32 : IFormatProvider -&gt; uint32" Usage="double.System.IConvertible.ToUInt32 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">忽略此参数。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />。</summary>
        <returns>当前实例的值，已转换为 <see cref="T:System.UInt32" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Double> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代方法是调用 <xref:System.Convert.ToUInt32%28System.Double%29?displayProperty=nameWithType> 方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt64 : IFormatProvider -&gt; uint64&#xA;override this.System.IConvertible.ToUInt64 : IFormatProvider -&gt; uint64" Usage="double.System.IConvertible.ToUInt64 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">忽略此参数。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />。</summary>
        <returns>当前实例的值，已转换为 <see cref="T:System.UInt64" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Double> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代方法是调用 <xref:System.Convert.ToUInt64%28System.Double%29?displayProperty=nameWithType> 方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将此实例的数值转换为其等效的字符串表示形式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="double.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将此实例的数值转换为其等效的字符串表示形式。</summary>
        <returns>此实例的值的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString>方法使用 <xref:System.Double> 当前区域性的默认 ( "G" 或常规) 格式设置值的格式。 如果要指定不同的格式、精度或区域性，请使用方法的其他重载 <xref:System.Double.ToString%2A> ，如下所示：  
  
|使用格式|对于区域性|使用重载|  
|-------------------|-----------------|----------------------|  
|默认 ( "G" ) 格式|特定区域性|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|特定的格式或精度|默认 (当前) 区域性|<xref:System.Double.ToString%28System.String%29>|  
|特定的格式或精度|特定区域性|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 返回值可以是 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> 、 <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> 、 <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> 或格式的字符串：  
  
 [sign] 整数位数 [. [小数位数]] [E [sign] 指数-数字]  
  
 可选元素括在方括号中， ( [和] ) 。 包含术语 "数字" 的元素包含一系列从0到9之间的数字字符。 支持下表中列出的元素。  
  
|元素|描述|  
|-------------|-----------------|  
|*sign*|负号或正号符号。|  
|*整数位数*|指定数字的整数部分的一系列数字。 如果有小数位数，则可以不存在整数位数。|  
|'*.*'|区域性特定的小数点符号。|  
|*小数位数*|指定数字小数部分的一系列数字。|  
|"*E*"|大写字符 "E"，指示指数 (科学) 表示法。|  
|*指数位数*|指定指数的一系列数字。|  
  
 返回值的一些示例包括 "100"、"-123456789"、"123.45 E + 6"、"500"、"3.1416"、"600"、"-0.123" 和 "-无限大"。  
  
 .NET Framework 提供了广泛的格式设置支持，以下格式设置主题更详细地介绍了这些支持：  
  
-   有关数字格式说明符的详细信息，请参阅 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 和 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。  
  
-   有关格式设置的详细信息，请参阅 [格式设置类型](/dotnet/standard/base-types/formatting-types)。  
  
   
  
## Examples  
 下面的示例使用默认 <xref:System.Double.ToString?displayProperty=nameWithType> 方法显示若干值的字符串表示形式 <xref:System.Double> 。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb" id="Snippet1":::
  
 以下示例说明了 <xref:System.Double.ToString%2A> 的用法。  
  
 [!code-cpp[System.Double#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#3)]
 [!code-csharp[System.Double#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#3)]
 [!code-vb[System.Double#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">设置 .NET 中类型的格式</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="double.ToString provider" />
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider? provider);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <summary>使用指定的区域性特定格式信息，将此实例的数值转换为它的等效字符串表示形式。</summary>
        <returns>此实例的值的字符串表示形式，由 <paramref name="provider" /> 指定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%28System.IFormatProvider%29>方法将 <xref:System.Double> 默认 ( "G" 中的值的格式设置为指定区域性的常规) 格式。 如果要指定其他格式或区域性，请使用方法的其他重载 <xref:System.Double.ToString%2A> ，如下所示：  
  
|使用格式|对于区域性|使用重载|  
|-------------------|-----------------|----------------------|  
|默认 ( "G" ) 格式|默认 (当前) |<xref:System.Double.ToString>|  
|特定的格式或精度|默认 (当前) 区域性|<xref:System.Double.ToString%28System.String%29>|  
|特定的格式或精度|特定区域性|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 返回值可以是 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> 、 <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> 、 <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> 或格式的字符串：  
  
 [sign] 整数位数 [. [小数位数]] [E [sign] 指数-数字]  
  
 可选元素括在方括号中， ( [和] ) 。 包含术语 "数字" 的元素包含一系列从0到9之间的数字字符。 支持下表中列出的元素。  
  
|元素|描述|  
|-------------|-----------------|  
|*sign*|负号或正号符号。|  
|*整数位数*|指定数字的整数部分的一系列数字。 如果有小数位数，则可以不存在整数位数。|  
|'*.*'|区域性特定的小数点符号。|  
|*小数位数*|指定数字小数部分的一系列数字。|  
|"*E*"|大写字符 "E"，指示指数 (科学) 表示法。|  
|*指数位数*|指定指数的一系列数字。|  
  
 返回值的一些示例包括 "100"、"-123456789"、"123.45 E + 6"、"500"、"3.1416"、"600"、"-0.123" 和 "-无限大"。  
  
 此实例的格式为常规数值格式说明符 ( "G" ) 。  
  
 .NET Framework 提供了广泛的格式设置支持，以下格式设置主题更详细地介绍了这些支持：  
  
-   有关数字格式说明符的详细信息，请参阅 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 和 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。  
  
-   有关格式设置的详细信息，请参阅 [格式设置类型](/dotnet/standard/base-types/formatting-types)。  
  
 `provider`参数是一个 <xref:System.IFormatProvider> 实现，其 <xref:System.IFormatProvider.GetFormat%2A> 方法返回 <xref:System.Globalization.NumberFormatInfo> 对象。 通常， `provider` 是 <xref:System.Globalization.CultureInfo> 对象或 <xref:System.Globalization.NumberFormatInfo> 对象。 `provider`参数提供用于设置格式的区域性特定信息。 如果 `provider` 为 `null` ，则使用当前区域性的对象设置返回值的格式 <xref:System.Globalization.NumberFormatInfo> 。  
  
   
  
## Examples  
 下面的示例 <xref:System.Double> 使用 <xref:System.Globalization.CultureInfo> 表示多个不同区域性的对象显示两个值的字符串表示形式。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb" id="Snippet2":::  
  
 下面的示例演示如何使用 <xref:System.Double.ToString%2A> ， <xref:System.String> 并采用和 <xref:System.IFormatProvider> 作为参数。  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">设置 .NET 中类型的格式</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="double.ToString format" />
      <MemberSignature Language="C#" Value="public string ToString (string? format);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">一个数值格式字符串。</param>
        <summary>使用指定的格式，将此实例的数值转换为它的等效字符串表示形式。</summary>
        <returns>此实例的值的字符串表示形式，由 <paramref name="format" /> 指定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%28System.String%29>方法 <xref:System.Double> 使用当前区域性的约定来设置指定格式的值的格式。 如果要指定其他格式或区域性，请使用方法的其他重载 <xref:System.Double.ToString%2A> ，如下所示：  
  
|使用格式|对于区域性|使用重载|  
|-------------------|-----------------|----------------------|  
|默认 ( "G" ) 格式|默认 (当前) 区域性|<xref:System.Double.ToString>|  
|默认 ( "G" ) 格式|特定区域性|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|特定的格式或精度|特定区域性|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 返回值可以是 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> 、 <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> 、 <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> 或数字的字符串表示形式，由指定 `format` 。  
  
 `format`参数可以是任何有效的标准数值格式说明符（D 和 X 除外）以及自定义数字格式说明符的任意组合。 如果 `format` 为 `null` 或空字符串，则返回值的格式为常规数值格式说明符 ( "G" ) 。  
  
 .NET Framework 提供了广泛的格式设置支持，以下格式设置主题更详细地介绍了这些支持：  
  
-   有关数字格式说明符的详细信息，请参阅 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 和 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。  
  
-   有关格式设置的详细信息，请参阅 [格式设置类型](/dotnet/standard/base-types/formatting-types)。  
  
 默认情况下，返回值仅包含15位精度，不过，在内部维护的最大值为17位。 如果此实例的值的位数超过15，则 <xref:System.Double.ToString%2A> 返回 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> 或 <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> 而不是预期的数字。 如果需要更高的精度，请指定 `format` with "G17" 格式规范，该规格始终返回17位精度，或 "R"，如果数字可以用该精度表示，则为; 如果数字只能用最大精度表示，则返回15位数字。  
  
   
  
## Examples  
 下面的示例定义一个数值，并使用 "C" 标准数字格式字符串将其格式设置为货币值，并使用 "N" 标准数字格式字符串将其设置为三个小数位数的数字值。 使用 en-us 区域性的约定对结果字符串进行格式设置。 有关数字格式字符串的详细信息，请参阅 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 和 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。  
  
 [!code-csharp[System.Double.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString7.cs#7)]
 [!code-vb[System.Double.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString7.vb#7)]  
  
 下面的示例 <xref:System.Double> 使用受支持的标准数值格式说明符以及三个自定义数字格式字符串来显示多个值。 其中一个自定义格式字符串说明了如何 <xref:System.Single> 用前导零填充值。 此外，此示例还使用带有除 "R" 之外的每个标准格式说明符的精度说明符。 精度说明符的值介于0到3之间。 若要将数值转换为字符串，则该示例使用 en-us 区域性的格式设置约定。  
  
 [!code-cpp[System.Double.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Double.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Double.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> 无效。</exception>
        <block subset="none" type="usage"><para>在某些情况下，如果使用“R”标准数字格式字符串格式化的 <see cref="T:System.Double" /> 值使用 <see langword="/platform:x64" /> 或 <see langword="/platform:anycpu" /> 开关编译并在 64 位系统上运行，则该值将无法成功往返。 若要解决此问题，可以使用“G17”标准数字格式字符串格式化 <see cref="T:System.Double" /> 值。 以下示例将“R”格式字符串与无法成功往返的 <see cref="T:System.Double" /> 值配合使用，并使用“G17”格式字符串以成功往返原始值。  
  
：：： code language = "csharp" source = "~/samples/snippets/csharp/VS_Snippets_CLR_System/system。Double ToString/cs/roundtripex2 "interactive =" dotnet "id =" Snippet6 "：：：：：： code language =" vb "source =" ~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system。Double ToString/vb/roundtripex2 "id =" Snippet6 "：：：</para></block>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">设置 .NET 中类型的格式</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">标准数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">自定义数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/how-to-pad-a-number-with-leading-zeros">如何：用前导零填充数字</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="double.ToString (format, provider)" />
      <MemberSignature Language="C#" Value="public string? ToString (string format, IFormatProvider provider);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">一个数值格式字符串。</param>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <summary>使用指定的格式和区域性特定格式信息，将此实例的数值转换为它的等效字符串表示形式。</summary>
        <returns>此实例的值的字符串表示形式，由 <paramref name="format" /> 和 <paramref name="provider" /> 指定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法使用指定 <xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29> <xref:System.Double> 的区域性的指定格式设置值的格式。 如果要指定其他格式或区域性，请使用方法的其他重载 <xref:System.Double.ToString%2A> ，如下所示：  
  
|使用格式|对于区域性|使用重载|  
|-------------------|-----------------|----------------------|  
|默认 ( "G" ) 格式|默认 (当前) 区域性|<xref:System.Double.ToString>|  
|默认 ( "G" ) 格式|特定区域性|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|特定的格式或精度|默认 (当前) 区域性|<xref:System.Double.ToString%28System.String%29>|  
  
 返回值可以是 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> 、 <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> 、 <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> 或数字的字符串表示形式，由指定 `format` 。  
  
 `format`参数可以是任何有效的标准数值格式说明符（D 和 X 除外）以及自定义数字格式说明符的任意组合。 如果 `format` 为 `null` 或空字符串，则此实例的返回值的格式为常规数值格式说明符 ( "G" ) 。  
  
 .NET Framework 提供了广泛的格式设置支持，以下格式设置主题更详细地介绍了这些支持：  
  
-   有关数字格式说明符的详细信息，请参阅 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 和 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。  
  
-   有关格式设置的详细信息，请参阅 [格式设置类型](/dotnet/standard/base-types/formatting-types)。  
  
 `provider`参数是一个 <xref:System.IFormatProvider> 实现，其 <xref:System.IFormatProvider.GetFormat%2A> 方法返回 <xref:System.Globalization.NumberFormatInfo> 对象。 通常， `provider` 是 <xref:System.Globalization.CultureInfo> 对象或 <xref:System.Globalization.NumberFormatInfo> 对象。 `provider`参数提供用于设置格式的区域性特定信息。 如果 `provider` 为 `null` ，则使用当前区域性的对象设置返回值的格式 <xref:System.Globalization.NumberFormatInfo> 。  
  
 默认情况下，返回值仅包含15位精度，不过，在内部维护的最大值为17位。 如果此实例的值的位数超过15，则 <xref:System.Double.ToString%2A> 返回 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> 或 <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> 而不是预期的数字。 如果需要更高的精度，请指定 `format` with "G17" 格式规范，该规格始终返回17位精度，或 "R"，如果数字可以用该精度表示，则为; 如果数字只能用最大精度表示，则返回15位数字。  
  
   
  
## Examples  
 下面的示例 <xref:System.Double> 使用多个不同区域性的每个受支持的标准数值格式说明符显示一个值。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring1.cpp" id="Snippet4":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs" interactive="try-dotnet-method" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb" id="Snippet4":::
  
 下面的示例演示如何使用 <xref:System.Double.ToString%2A> ， <xref:System.String> 并采用和 <xref:System.IFormatProvider> 作为参数。  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>在某些情况下，如果使用“R”标准数字格式字符串格式化的 <see cref="T:System.Double" /> 值使用 <see langword="/platform:x64" /> 或 <see langword="/platform:anycpu" /> 开关编译并在 64 位系统上运行，则该值将无法成功往返。 若要解决此问题，可以使用“G17”标准数字格式字符串格式化 <see cref="T:System.Double" /> 值。 以下示例将“R”格式字符串与无法成功往返的 <see cref="T:System.Double" /> 值配合使用，并使用“G17”格式字符串以成功往返原始值。  
  
：：： code language = "csharp" source = "~/samples/snippets/csharp/VS_Snippets_CLR_System/system。Double ToString/cs/roundtripex1 "interactive =" dotnet "id =" Snippet5 "：：：：：： code language =" vb "source =" ~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system。Double ToString/vb/roundtripex1 "id =" Snippet5 "：：：</para></block>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">设置 .NET 中类型的格式</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">标准数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">自定义数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/how-to-pad-a-number-with-leading-zeros">如何：用前导零填充数字</related>
        <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/windowsforms-formatting-utility-cs/">示例： .NET Core WinForms 格式设置实用工具 (c # ) </related>
        <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/windowsforms-formatting-utility-vb/">示例： .NET Core WinForms 格式设置实用工具 (Visual Basic) </related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default, IFormatProvider? provider = default);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = Nothing, Optional provider As IFormatProvider = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="double.TryFormat (destination, charsWritten, format, provider)" />
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default, IFormatProvider provider = default);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination">此方法返回时，此实例的值将设置为字符范围格式。</param>
        <param name="charsWritten">此方法返回时，为写入到 <paramref name="destination" /> 的字符数。</param>
        <param name="format">一个包含字符的范围，这些字符表示定义可接受的 <paramref name="destination" /> 格式的标准或自定义格式字符串。</param>
        <param name="provider">一个可选对象，提供有关 <paramref name="destination" /> 的区域性特定格式设置信息。</param>
        <summary>尝试将当前双精度实例的值的格式设置为提供的字符范围。</summary>
        <returns>如果格式设置成功，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将数字的字符串表示形式转换为它的等效双精度浮点数。 一个指示转换是否成功的返回值。</summary>
        <remarks>在 .NET Core 3.0 及更高版本中，太大而无法表示的值将舍入到， <see cref="F:System.Double.PositiveInfinity" /> 或 <see cref="F:System.Double.NegativeInfinity" /> 根据 IEEE 754 规范的要求进行舍入。 在以前的版本中（包括 .NET Framework），分析过大而无法表示的值导致失败。</remarks>
        <altmember cref="Overload:System.Double.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * double -&gt; bool" Usage="System.double.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.Double" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的数字的字符串表示形式的字符范围。</param>
        <param name="result">当此方法返回时，如果转换成功，则包含与 <paramref name="s" /> 参数中所包含的数值或符号等效的双精度浮点数；如果转换失败，则包含零。 如果 <paramref name="s" /> 参数为 <see langword="null" /> 或空，或其格式不符合 <paramref name="style" />，则转换失败。 如果 <paramref name="style" /> 不是 <see cref="T:System.Globalization.NumberStyles" /> 枚举常量的有效组合，则转换也会失败。 如果 <paramref name="s" /> 是小于 <see cref="F:System.Double.MinValue" /> 的有效数字，则 <paramref name="result" /> 为 <see cref="F:System.Double.NegativeInfinity" />。 如果 <paramref name="s" /> 是大于 <see cref="F:System.Double.MaxValue" /> 的有效数字，则 <paramref name="result" /> 为 <see cref="F:System.Double.PositiveInfinity" />。 此参数未经初始化即进行传递；最初在 <paramref name="result" /> 中提供的任何值都会被覆盖。</param>
        <summary>将指定样式和区域性特定格式的数字的范围表示形式转换为它的等效双精度浮点数。 一个指示转换是否成功的返回值。</summary>
        <returns>如果 <see langword="true" /> 成功转换，则为 <paramref name="s" />；否则为 <see langword="false" />。</returns>
        <remarks>在 .NET Core 3.0 及更高版本中，太大而无法表示的值将舍入到， <see cref="F:System.Double.PositiveInfinity" /> 或 <see cref="F:System.Double.NegativeInfinity" /> 根据 IEEE 754 规范的要求进行舍入。 在以前的版本中（包括 .NET Framework），分析过大而无法表示的值导致失败。</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * double -&gt; bool" Usage="System.double.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Double" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的数字的字符串。</param>
        <param name="result">当此方法返回时，如果转换成功，则包含与 <paramref name="s" /> 参数等效的双精度浮点数；如果转换失败，则包含零。 如果 <paramref name="s" /> 参数为 <see langword="null" /> 或 <see cref="F:System.String.Empty" />，或不为有效格式的数字，则转换失败。 如果 <paramref name="s" /> 表示一个小于 <see cref="F:System.Double.MinValue" /> 或大于 <see cref="F:System.Double.MaxValue" /> 的数字，则转换在 .NET Framework 和 .NET Core 2.2 及更低版本上也会失败。 此参数未经初始化即进行传递；最初在 <paramref name="result" /> 中提供的任何值都会被覆盖。</param>
        <summary>将数字的字符串表示形式转换为它的等效双精度浮点数。 一个指示转换是否成功的返回值。</summary>
        <returns>如果 <see langword="true" /> 成功转换，则为 <paramref name="s" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 .NET Core 3.0 及更高版本中，太大而无法表示的值将舍入到， <xref:System.Double.PositiveInfinity> 或 <xref:System.Double.NegativeInfinity> 根据 IEEE 754 规范的要求进行舍入。 在以前的版本中（包括 .NET Framework），分析过大而无法表示的值导致失败。

 此重载与方法的不同之处在于， <xref:System.Double.Parse%28System.String%29?displayProperty=nameWithType> 返回一个布尔值，该值指示分析操作是否成功，而不是返回已分析的数值。 这样，便无需使用异常处理来测试无效的 <xref:System.FormatException> 事件， `s` 也不能成功分析。  
  
 `s`参数可以包含当前区域性的 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType> 、 <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType> <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> (字符串比较是否区分大小写) 或格式的字符串：  
  
 ws表明[整数位数，] 整数位数 [. [小数位数]] [e [sign] 指数-数字] [ws]  
  
 括号中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|一系列空白字符。|  
|*sign*|负号或正号符号。|  
|*整数位数*|一系列从0到9之间的数字字符，用于指定数字的整数部分。 如果有小数位数，则可以不存在整数位数。|  
|*，*|区域性特定的组分隔符符号。|  
|*.*|区域性特定的小数点符号。|  
|*小数位数*|指定数字小数部分的一系列数字字符，范围为0到9。|  
|*电邮*|大写或小写字符 "e"，指示指数 (科学) 表示法。|  
|*指数位数*|指定指数的一系列数字字符，范围为0到9。|  
  
 有关数字格式的详细信息，请参阅 [格式设置类型](/dotnet/standard/base-types/formatting-types)。  
  
 `s`参数通过使用和标志的组合来进行解释 <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 。 这意味着允许使用空格和千位分隔符，但不允许货币符号。 若要显式定义可在中存在的元素 (如货币符号、千位分隔符和空格) `s` ，请使用 <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> 方法重载。  
  
 `s`使用为 <xref:System.Globalization.NumberFormatInfo> 当前系统区域性初始化的对象中的格式设置信息分析参数。 有关详细信息，请参阅 <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>。 若要使用某些其他指定的区域性的格式设置信息分析字符串，请使用 <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> 方法重载。  
  
 通常，如果向方法传递 <xref:System.Double.TryParse%2A?displayProperty=nameWithType> 通过调用方法创建的字符串 <xref:System.Double.ToString%2A?displayProperty=nameWithType> ，则 <xref:System.Double> 返回原始值。 但是，由于精度损失，值可能不相等。 此外，尝试分析或的字符串表示形式不 <xref:System.Double.MinValue?displayProperty=nameWithType> <xref:System.Double.MaxValue?displayProperty=nameWithType> 会往返。 在 .NET Framework 和 .NET Core 2.2 及早期版本上，它会引发 <xref:System.OverflowException> 。 在 .NET Core 3.0 及更高版本中， <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 如果您尝试分析 <xref:System.Double.MinValue?displayProperty=nameWithtype> 或 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 您尝试进行分析，它将返回 <xref:System.Double.MaxValue?displayProperty=nameWithtype> 。 下面的示例进行了这方面的演示。 
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb" id="Snippet3":::

在 .NET Framework 和 .NET Core 2.2 及更早版本中，如果超出了 `s` <xref:System.Double> 数据类型的范围，则该 <xref:System.Double.TryParse%28System.String%2CSystem.Double%40%29> 方法将引发 <xref:System.OverflowException> 。

在 .NET Core 3.0 及更高版本中，当 `s` 超出数据类型的范围时，不会引发异常 <xref:System.Double> 。 在大多数情况下， <xref:System.Double.TryParse%28System.String%2CSystem.Double%40%29> 方法计算或的结果 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 。 但是，有一小部分值被视为比的最大值或最小值更接近于 <xref:System.Double> 正无穷或负无穷。 在这些情况下，方法将计算或的 <xref:System.Double.MaxValue?displayProperty=nameWithType> 结果 <xref:System.Double.MinValue?displayProperty=nameWithType> 。

如果在 `s` 分析操作期间在参数中遇到分隔符，并且小数点和组分隔符相同，则分析操作将假定分隔符是小数点分隔符，而不是组分隔符。 有关分隔符的详细信息，请参阅 <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A> 、、 <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A> <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> 和 <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A> 。  
  
## Examples  
 下面的示例使用 <xref:System.Double.TryParse%28System.String%2CSystem.Double%40%29> 方法将数值的字符串表示形式转换为 <xref:System.Double> 值。 它假定 en-us 为当前区域性。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse1a.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse1a.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="M:System.Double.ToString" />
        <related type="Article" href="/dotnet/standard/base-types/parsing-numeric">分析 .NET 中的数字字符串</related>
        <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/windowsforms-formatting-utility-cs/">示例： .NET Core WinForms 格式设置实用工具 (c # ) </related>
        <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/windowsforms-formatting-utility-vb/">示例： .NET Core WinForms 格式设置实用工具 (Visual Basic) </related>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider? provider, out double result);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider * double -&gt; bool" Usage="System.double.TryParse (s, style, provider, result)" />
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.Double" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的数字的只读字符范围。</param>
        <param name="style"><see cref="T:System.Globalization.NumberStyles" /> 值的按位组合，指示 <paramref name="s" /> 的允许格式。 一个用来指定的典型值为 <see cref="F:System.Globalization.NumberStyles.Float" /> 与 <see cref="F:System.Globalization.NumberStyles.AllowThousands" /> 的组合。</param>
        <param name="provider">一个对象，提供有关 <paramref name="s" /> 的区域性特定格式设置信息。</param>
        <param name="result">当此方法返回时，如果转换成功，则包含与 <paramref name="s" /> 中所包含的数值或符号等效的双精度浮点数。 如果转换失败，则包含零。 如果 <paramref name="s" /> 参数为 <see langword="null" />、空字符范围、格式不符合 <paramref name="style" /> 的数字，则转换失败。 如果 <paramref name="s" /> 是小于 <see cref="F:System.Double.MinValue" /> 的有效数字，则 <paramref name="result" /> 为 <see cref="F:System.Double.NegativeInfinity" />。 如果 <paramref name="s" /> 是大于 <see cref="F:System.Double.MaxValue" /> 的有效数字，则 <paramref name="result" /> 为 <see cref="F:System.Double.PositiveInfinity" />。 此参数未经初始化即进行传递；最初在 <paramref name="result" /> 中提供的任何值都会被覆盖。</param>
        <summary>将字符范围（其中包含指定样式和区域性特定格式的数字的字符串表示形式）转换为它的等效双精度浮点数。 一个指示转换是否成功的返回值。</summary>
        <returns>如果 <see langword="true" /> 成功转换，则为 <paramref name="s" />；否则为 <see langword="false" />。</returns>
        <remarks>在 .NET Core 3.0 及更高版本中，太大而无法表示的值将舍入到， <see cref="F:System.Double.PositiveInfinity" /> 或 <see cref="F:System.Double.NegativeInfinity" /> 根据 IEEE 754 规范的要求进行舍入。 在以前的版本中（包括 .NET Framework），分析过大而无法表示的值导致失败。</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider * double -&gt; bool" Usage="System.double.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Double" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的数字的字符串。</param>
        <param name="style"><see cref="T:System.Globalization.NumberStyles" /> 值的按位组合，指示 <paramref name="s" /> 的允许格式。 一个用来指定的典型值为 <see cref="F:System.Globalization.NumberStyles.Float" /> 与 <see cref="F:System.Globalization.NumberStyles.AllowThousands" /> 的组合。</param>
        <param name="provider">一个 <see cref="T:System.IFormatProvider" />，它提供有关 <paramref name="s" /> 的区域性特定格式设置信息。</param>
        <param name="result">当此方法返回时，如果转换成功，则包含与 <paramref name="s" /> 中所包含的数值或符号等效的双精度浮点数；如果转换失败，则包含零。 如果 <paramref name="s" /> 参数为 <see langword="null" />、<see cref="F:System.String.Empty" />，或格式不符合 <paramref name="style" />，或 <paramref name="style" /> 不是 <see cref="T:System.Globalization.NumberStyles" /> 枚举常量的有效组合，则转换失败。 如果 <paramref name="s" /> 表示一个小于 <see cref="F:System.SByte.MinValue" /> 或大于 <see cref="F:System.SByte.MaxValue" /> 的数字，则转换在 .NET Framework 或 .NET Core 2.2 及更低版本上也会失败。 此参数未经初始化即进行传递；最初在 <paramref name="result" /> 中提供的任何值都会被覆盖。</param>
        <summary>将指定样式和区域性特定格式的数字的字符串表示形式转换为它的等效双精度浮点数。 一个指示转换是否成功的返回值。</summary>
        <returns>如果 <see langword="true" /> 成功转换，则为 <paramref name="s" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 .NET Core 3.0 及更高版本中，太大而无法表示的值将舍入到， <xref:System.Double.PositiveInfinity> 或 <xref:System.Double.NegativeInfinity> 根据 IEEE 754 规范的要求进行舍入。 在以前的版本中（包括 .NET Framework），分析过大而无法表示的值导致失败。

 <xref:System.Double.TryParse%2A>方法与 <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> 方法类似，不同的是，如果转换失败，则此方法不会引发异常。 如果转换成功，则返回值为 `true` ，而 `result` 参数设置为转换的结果。 如果转换失败，则返回值为 `false` ，而 `result` 参数设置为零。 这样就无需使用异常处理来测试 <xref:System.FormatException> 无效事件中的 `s` ，并且无法成功分析该事件。  
  
 `style`参数定义允许的参数的格式，以便 `s` 分析操作成功。 它必须是枚举中的位标志的组合 <xref:System.Globalization.NumberStyles> 。 <xref:System.Globalization.NumberStyles>不支持以下成员：  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>  
  
 `s`参数可以包含 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType> <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType> <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> 由指示的区域性、或 `provider` 。 此外，根据的值 `style` ， `s` 参数可能包括以下元素：  
  
 ws[$]表明[整数位数，] 整数位数 [. 小数] [e [sign] 指数-数字] [ws]  
  
 方括号 ([ and ]) 中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|可选空白。 `s`如果包含标志，则空格可以出现在开头 `style` <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> 。 `s`如果包含标志，则它可以出现在的结尾 `style` <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> 。|  
|*$*|区域性特定的货币符号。 其在字符串中的位置由 <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> <xref:System.Globalization.NumberFormatInfo> 参数方法返回的对象的或属性定义 <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> `provider` 。 `s`如果包含标志，则货币符号可以出现在中 `style` <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> 。|  
|*sign*|一个可选的符号。 如果包含标志，则符号可以出现在的开头 `s` `style` <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> ，如果包含标志，则它可以出现在的末尾 `s` `style` <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> 。 如果包含标志，则可以在中使用括号 `s` 来表示负值 `style` <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> 。|  
|*整数位数*|一系列从0到9之间的数字，用于指定数字的整数部分。 如果有小数位数，则可以不存在整数位数。|  
|*，*|区域性特定的千位分隔符。 `s`如果包含标志，则当前区域性的千位分隔符符号可以出现在中 `style` <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 。|  
|*.*|区域性特定的小数点符号。 `s`如果包含标志，则当前区域性的小数点符号可以出现在中 `style` <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 。|  
|*小数位数*|一系列从0到9之间的数字，用于指定数字的小数部分。 `s`如果 `style` 包含标志，则小数位数可以出现在中 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 。|  
|*e*|E 或 E 字符，指示 `s` 可以使用指数表示法表示数字。 `s`如果 style 包含标志，则参数可以表示指数表示法中的数字 <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> 。|  
|*指数位数*|一系列从0到9之间的数字，用于指定指数。|  
  
> [!NOTE]
> `s`无论参数的值如何，分析操作都将忽略中任何终止的 NUL (U + 0000) 字符 `style` 。

 只包含数字的字符串 (与 <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> 样式) 始终在类型范围内分析成功 <xref:System.Double> 。 其余 <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> 成员控件元素，这些元素可能但不要求出现在输入字符串中。 下表指示各个标志如何 <xref:System.Globalization.NumberStyles> 影响可能出现在中的元素 `s` 。  
  
|NumberStyles 值|除数字外允许在 s 中使用的元素|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|仅限 *整数数字* 元素。|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|*.* 和 *小数位数* 元素。|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|`s`参数还可以使用指数表示法。 此标志本身支持采用 *整数位数*E*指数数字*形式的值;若要成功地将指数表示法中的字符串解析为正或负号和小数点符号，则需要其他标志。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|开头的 *ws* 元素 `s` 。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|末尾处的 *ws* 元素 `s` 。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|开头的 *sign* 元素 `s` 。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|末尾的 *sign* 元素 `s` 。|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|用括号括起数值的 *符号* 元素。|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|*，* 元素。|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|*$* 元素。|  
|<xref:System.Globalization.NumberStyles.Currency>|全部。 `s`参数不能表示十六进制数或以指数表示法表示的数字。|  
|<xref:System.Globalization.NumberStyles.Float>|在开头或结尾处的 *ws* 元素，在 `s` 的开头处进行 *签名* `s` *。* 符号开头。 `s`参数还可以使用指数表示法。|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`、 `sign` 、千位分隔符 (*、) *和小数点 () 元素 *.* 。|  
|<xref:System.Globalization.NumberStyles.Any>|除之外的所有样式都 `s` 不能表示十六进制数。|  
  
 `provider`参数是一个 <xref:System.IFormatProvider> 实现，如 <xref:System.Globalization.NumberFormatInfo> 或 <xref:System.Globalization.CultureInfo> 对象。 `provider`参数提供用于分析的特定于区域性的信息。 如果 `provider` 为 `null` 或 <xref:System.Globalization.NumberFormatInfo> 无法获取对象，则使用当前区域性的格式信息。  
  
 如果 `s` 参数是数值，或者参数不是一个 `null` `provider` <xref:System.Globalization.NumberFormatInfo> 对象，或者该参数不是 `style` 枚举中的位标志的组合， <xref:System.Globalization.NumberStyles> 则转换失败。  
  
 通常，如果向方法传递 <xref:System.Double.TryParse%2A?displayProperty=nameWithType> 通过调用方法创建的字符串 <xref:System.Double.ToString%2A?displayProperty=nameWithType> ，则 <xref:System.Double> 返回原始值。 但是，由于精度损失，值可能不相等。 此外，尝试分析或的字符串表示形式不 <xref:System.Double.MinValue?displayProperty=nameWithType> <xref:System.Double.MaxValue?displayProperty=nameWithType> 会往返。 在 .NET Framework 和 .NET Core 2.2 及早期版本上，它会引发 <xref:System.OverflowException> 。 在 .NET Core 3.0 及更高版本中， <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 如果您尝试分析 <xref:System.Double.MinValue?displayProperty=nameWithtype> 或 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 您尝试进行分析，它将返回 <xref:System.Double.MaxValue?displayProperty=nameWithtype> 。 下面的示例进行了这方面的演示。
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb" id="Snippet3":::

在 .NET Framework 和 .NET Core 2.2 及更早版本中，如果超出了 `s` <xref:System.Double> 数据类型的范围，则该 <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> 方法将引发 <xref:System.OverflowException> 。

在 .NET Core 3.0 及更高版本中，当 `s` 超出数据类型的范围时，不会引发异常 <xref:System.Double> 。 在大多数情况下， <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> 方法计算或的结果 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 。 但是，有一小部分值被视为比的最大值或最小值更接近于 <xref:System.Double> 正无穷或负无穷。 在这些情况下，方法将计算或的 <xref:System.Double.MaxValue?displayProperty=nameWithType> 结果 <xref:System.Double.MinValue?displayProperty=nameWithType> 。

 如果在分析操作过程中在参数中遇到分隔符 `s` ，并且适用的货币或小数分隔符和组分隔符相同，则分析操作将假定分隔符是小数点分隔符，而不是组分隔符。 有关分隔符的详细信息，请参阅 <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A> 、、 <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A> <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> 和 <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A> 。   
  
## Examples  
 下面的示例演示如何使用 <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> 方法来分析具有特定样式的数字的字符串表示形式，并使用特定区域性的约定进行格式设置。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/TryParse1.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/TryParse1.vb" id="Snippet2":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> 不是 <see cref="T:System.Globalization.NumberStyles" /> 值。  
  
- 或 - 
 <paramref name="style" /> 包括 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 值。</exception>
        <altmember cref="M:System.Double.ToString" />
        <related type="Article" href="/dotnet/standard/base-types/parsing-numeric">分析 .NET 中的数字字符串</related>
      </Docs>
    </Member>
  </Members>
</Type>
