<Type Name="Delegate" FullName="System.Delegate">
  <Metadata><Meta Name="ms.openlocfilehash" Value="40829bae240cbf1233733eee1ed4500617df25d0" /><Meta Name="ms.sourcegitcommit" Value="8fab45da9f77f8bbc3ae5817515b40ac6ff205a2" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="01/20/2021" /><Meta Name="ms.locfileid" Value="98617058" /></Metadata><TypeSignature Language="C#" Value="public abstract class Delegate" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Delegate extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="DocId" Value="T:System.Delegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="F#" Value="type Delegate = class" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate&#xA;Implements ICloneable, ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract : ICloneable, System::Runtime::Serialization::ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Delegate = class&#xA;    interface ICloneable&#xA;    interface ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示一个委托，该委托是表示某一静态方法或某一类实例和该类的实例方法的数据结构。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Delegate>类是委托类型的基类。 但是，只有系统和编译器才能显式从 <xref:System.Delegate> 类或 <xref:System.MulticastDelegate> 类派生。 也不允许从委托类型派生新类型。 <xref:System.Delegate>类不被视为委托类型; 它是用于派生委托类型的类。  
  
 大多数语言都实现 `delegate` 关键字，这些语言的编译器可以从 <xref:System.MulticastDelegate> 类派生; 因此，用户应使用 `delegate` 语言提供的关键字。  
  
> [!NOTE]
>  公共语言运行时为 `Invoke` 每个委托类型提供了一个方法，其签名与委托的签名相同。 无需从 c #、Visual Basic 或 Visual C++ 显式调用此方法，因为编译器会自动调用此方法。 `Invoke`当您想要查找委托类型的签名时，方法在[反射](/dotnet/framework/reflection-and-codedom/reflection)中很有用。  
  
 公共语言运行时为每个委托类型提供 `BeginInvoke` 和 `EndInvoke` 方法，以启用委托的异步调用。 有关这些方法的详细信息，请参阅 [异步调用同步方法](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously)。  
  
 委托类型的声明建立一个协定，该协定指定一个或多个方法的签名。 委托是引用了的委托类型的实例：  
  
-   类型的实例方法和可分配给该类型的目标对象。  
  
-   类型的实例方法，其中的隐藏 `this` 参数在形参表中公开。 委托称为开放实例委托。  
  
-   静态方法。  
  
-   一个静态方法和一个目标对象，可分配给该方法的第一个参数。 委托被认为是在其第一个参数上关闭。  
  
 有关委托绑定的详细信息，请参阅 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> 方法重载。  
  
> [!NOTE]
>  在 .NET Framework 版本1.0 和1.1 中，委托只能表示方法的签名与委托类型指定的签名完全匹配。 因此，只支持前面列表中的第一个和第三个项目符号，而第一个项目符号需要完全类型匹配。  
  
 当某个委托表示在最常见的情况) 下，在其第一个参数 (关闭的实例方法时，该委托将存储对该方法入口点的引用以及对该对象的引用，该对象的类型为可分配给定义此方法的类型的类型。 当委托表示开放式实例方法时，它存储对该方法的入口点的引用。 委托签名必须 `this` 在其形参表中包含 hidden 参数; 在这种情况下，该委托不具有对目标对象的引用，并且在调用委托时必须提供目标对象。  
  
 如果委托表示静态方法，则委托存储对方法的入口点的引用。 如果委托表示在其第一个参数上关闭的静态方法，则该委托存储对方法的入口点的引用，并存储对可分配给该方法的第一个参数类型的目标对象的引用。 调用委托时，静态方法的第一个参数将接收目标对象。  
  
 委托的调用列表是一组有序委托，其中列表的每个元素都只调用由委托表示的方法之一。 调用列表可以包含重复的方法。 在调用期间，将按照调用列表中出现的顺序调用方法。 委托尝试调用其调用列表中的每个方法;对于每次出现在调用列表中的重复项，都会调用一次。 委托是不可变的;一旦创建，委托的调用列表将不会更改。  
  
 委托称为多播，或者是可组合的，因为委托可以调用一个或多个方法，并且可以在组合操作中使用。  
  
 组合操作（如 <xref:System.Delegate.Combine%2A> 和 <xref:System.Delegate.Remove%2A> ）不会改变现有委托。 相反，此类操作返回一个新委托，其中包含操作的结果、未更改的委托或 `null` 。 `null`当操作的结果是一个委托，该委托未引用至少一个方法时，组合操作返回。 当请求的操作不起作用时，组合操作返回未更改的委托。  
  
> [!NOTE]
>  托管语言使用 <xref:System.Delegate.Combine%2A> 和 <xref:System.Delegate.Remove%2A> 方法来实现委托操作。 例如，在 `AddHandler` `RemoveHandler` c # 中的委托类型上 Visual Basic 和 + = 和-= 运算符中包含和语句。  
  
 从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ，泛型委托类型可以具有变体类型参数。 逆变类型参数可用作委托的参数类型，协变类型参数可用作返回类型。 此功能允许从同一泛型类型定义构造的泛型委托类型成为赋值兼容的泛型委托类型（如果其类型参数是具有继承关系的引用类型），如 [协变和逆变](/dotnet/standard/generics/covariance-and-contravariance)中所述。  
  
> [!NOTE]
>  与赋值兼容的泛型委托不一定是可组合的。 要使其可组合，类型必须完全匹配。 例如，假设名为的类 `Derived` 派生自名为的类 `Base` 。 `Action<Base>`Visual Basic) 中 (类型的委托 `Action(Of Base)` 可以分配给类型的变量 `Action<Derived>` ，但由于类型不完全匹配，因此不能组合这两个委托。  
  
 如果调用的方法引发异常，则方法将停止执行，异常将被传递回委托的调用方，并且不会调用调用列表中的其余方法。 捕获调用方中的异常不会改变此行为。  
  
 当委托调用的方法的签名包含返回值时，该委托将返回调用列表中最后一个元素的返回值。 如果签名包含通过引用传递的参数，则参数的最终值将是按顺序执行的调用列表中的每个方法的结果，并且更新参数的值。  
  
 最接近 C 的委托的等效项是函数指针。 委托可以表示静态方法或实例方法。 如果委托表示实例方法，则委托不仅存储对方法入口点的引用，还存储对类实例的引用。 与函数指针不同，委托是面向对象的和类型安全的。  
  
   
  
## Examples  
 下面的示例演示如何定义名为的委托 `myMethodDelegate` 。 此委托的实例是为实例方法和嵌套类的静态方法创建的 `mySampleClass` 。 实例方法的委托需要的实例 `mySampleClass` 。 `mySampleClass`实例保存在一个名为的变量中 `mySC` 。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Delegate Example/CPP/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Delegate Example/CS/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Delegate Example/VB/source.vb" id="Snippet1":::

 ]]></format>
    </remarks>
    <altmember cref="T:System.MulticastDelegate" />
    <related type="Article" href="/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously">使用异步方式调用同步方法</related>
    <related type="Article" href="/dotnet/csharp/programming-guide/delegates/">委托（C# 编程指南）</related>
    <related type="Article" href="/dotnet/visual-basic/programming-guide/language-features/delegates/">委托 (Visual Basic)</related>
    <related type="Article" href="/cpp/dotnet/how-to-define-and-use-delegates-cpp-cli">如何：定义和使用委托 (C++/CLI)</related>
    <related type="Article" href="/dotnet/standard/events/">处理和引发事件</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化一个新委托。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : obj * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="method" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="target">类实例，委托对其调用 <paramref name="method" />。</param>
        <param name="method">委托表示的实例方法的名称。</param>
        <summary>初始化一个委托，该委托对指定的类实例调用指定的实例方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不能在应用程序代码中使用此构造函数。 若要通过指定实例方法的名称来创建委托，请使用方法的重载， <xref:System.Delegate.CreateDelegate%2A> 该重载指定方法名称和目标对象。 例如， <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29> 方法重载为具有指定名称的实例方法创建委托。  
  
 此构造函数仅创建实例方法的委托。 实例方法是与类的实例关联的方法;静态方法是与类自身相关联的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="method" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">绑定到目标方法时出错。</exception>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : Type * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="method" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Type" /> 表示用于定义 <paramref name="method" /> 的类。</param>
        <param name="method">委托表示的静态方法的名称。</param>
        <summary>初始化一个委托，该委托从指定的类调用指定的静态方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不能在应用程序代码中使用此构造函数。 若要通过指定静态方法的名称来创建委托，请使用方法的重载， <xref:System.Delegate.CreateDelegate%2A> 该重载指定方法名称，但不指定目标对象。 例如， <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29> 方法重载为具有指定名称的方法创建静态委托。  
  
 此构造函数只为静态方法创建委托。 实例方法是与类的实例关联的方法;静态方法是与类自身相关联的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="method" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> 不是 <see langword="RuntimeType" />。 请参阅[反射中的运行时类型](/previous-versions/dotnet/netframework-4.0/ms172329(v=vs.100))。  
  
- 或 - 
 <paramref name="target" /> 表示开放式泛型类型。</exception>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="delegate.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建委托的浅表副本。</summary>
        <returns>委托的浅表副本。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 克隆与原始委托具有相同的 <xref:System.Type> 目标、方法和调用列表。  
  
 浅表复制创建与原始对象具有相同类型的新实例，然后复制原始对象的非静态字段。 如果该字段是值类型，则执行字段的逐位副本。 如果该字段是引用类型，则会复制引用，但不会复制引用的对象;因此，原始对象中的引用和克隆点中对同一对象的引用。 相反，对象的深层副本会复制对象中的字段直接或间接引用的所有内容。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将指定的多路广播（可组合）委托的调用列表连接起来。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (params Delegate[] delegates);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate[] delegates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray delegates As Delegate()) As Delegate" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(... cli::array &lt;Delegate ^&gt; ^ delegates);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate[] -&gt; Delegate" Usage="System.Delegate.Combine delegates" />
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate[] delegates);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (delegates As Delegate()) As Delegate" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(cli::array &lt;Delegate ^&gt; ^ delegates);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegates">要组合的委托的数组。</param>
        <summary>将委托数组的调用列表连接在一起。</summary>
        <returns>新的委托，该委托的调用列表将 <paramref name="delegates" /> 数组中的委托的调用列表串联在一起。 如果 <paramref name="delegates" /> 为 <see langword="null" />，<paramref name="delegates" /> 包含零个元素，或 <paramref name="delegates" /> 中的每个条目均为 <see langword="null" />，则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `delegates` 数组包含的条目为 `null` ，则忽略这些条目。  
  
 调用列表可以包含重复项;也就是说，引用相同对象上的同一方法的条目。  
  
> [!NOTE]
>  与赋值兼容的泛型委托不一定是可组合的。 要使其可组合，类型必须完全匹配。 例如，假设名为的类 `Derived` 派生自名为的类 `Base` 。 `Action<Base>` `Action(Of Base)` 如协变和逆变中所述，可将 Visual Basic) 中 (类型的委托分配给类型的变量， `Action<Derived>` 但这两个委托无法组合，因为这些类型不完全匹配。 [](/dotnet/standard/generics/covariance-and-contravariance)  
  
 <xref:System.Delegate.Combine%2A> 适用于创建每次发生事件时调用多个方法的事件处理程序。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">不是所有 <paramref name="delegates" /> 中的非 null 项都是同一委托类型的实例。</exception>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate a, class System.Delegate b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (a As Delegate, b As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(Delegate ^ a, Delegate ^ b);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Combine (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="a">最先出现其调用列表的委托。</param>
        <param name="b">最后出现其调用列表的委托。</param>
        <summary>将两个委托的调用列表连接在一起。</summary>
        <returns>新的委托，它的调用列表将 <paramref name="a" /> 和 <paramref name="b" /> 的调用列表按该顺序连接在一起。 如果 <paramref name="b" /> 为 <see langword="null" />，则返回 <paramref name="a" />；如果 <paramref name="a" /> 为 null 引用，则返回 <paramref name="b" />；如果 <paramref name="a" /> 和 <paramref name="b" /> 均为 null 引用，则返回 null 引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用列表可以包含重复项;也就是说，引用相同对象上的同一方法的条目。  
  
> [!NOTE]
>  与赋值兼容的泛型委托不一定是可组合的。 要使其可组合，类型必须完全匹配。 例如，假设名为的类 `Derived` 派生自名为的类 `Base` 。 `Action<Base>` `Action(Of Base)` 如协变和逆变中所述，可将 Visual Basic) 中 (类型的委托分配给类型的变量， `Action<Derived>` 但这两个委托无法组合，因为这些类型不完全匹配。 [](/dotnet/standard/generics/covariance-and-contravariance)  
  
 <xref:System.Delegate.Combine%2A> 适用于创建每次发生事件时调用多个方法的事件处理程序。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="a" /> 和 <paramref name="b" /> 均不为 <see langword="null" />，且 <paramref name="a" /> 和 <paramref name="b" /> 不是相同委托类型的实例。</exception>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate? d);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate CombineImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CombineImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ CombineImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member CombineImpl : Delegate -&gt; Delegate&#xA;override this.CombineImpl : Delegate -&gt; Delegate" Usage="delegate.CombineImpl d" />
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="d">多路广播（可组合）委托，其调用列表要追加到当前多路广播（可组合）委托的调用列表的结尾。</param>
        <summary>将指定多路广播（可组合）委托和当前多路广播（可组合）委托的调用列表连接起来。</summary>
        <returns>新的多路广播（可组合）委托，其调用列表将当前多路广播（可组合）委托的调用列表和 <paramref name="d" /> 的调用列表连接在一起；或者如果 <paramref name="d" /> 为 <see langword="null" />，则返回当前多路广播（可组合）委托。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法仅适用于当前委托 (可组合) 的多播。  
  
 当前实现只引发一个 <xref:System.MulticastNotSupportedException> 。  
  
 调用列表可以包含重复项;也就是说，引用相同对象上的同一方法的条目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MulticastNotSupportedException">始终引发。</exception>
        <altmember cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建指定类型的委托。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDelegate (type As Type, method As MethodInfo) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="type">要创建的委托的 <see cref="T:System.Type" />。</param>
        <param name="method">描述该委托要表示的静态或实例方法的 <see cref="T:System.Reflection.MethodInfo" />。 .NET Framework 1.0 和 1.1 版中仅支持静态方法。</param>
        <summary>创建指定类型的委托以表示指定的静态方法。</summary>
        <returns>表示指定静态方法的指定类型的委托。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 .NET Framework 版本1.0 和1.1 中，此方法重载仅为静态方法创建委托。 在 .NET Framework 版本2.0 中，此方法重载还可以创建开放式实例方法委托;也就是说，显式提供实例方法的隐藏第一个参数的委托。 有关详细说明，请参阅更通用的 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> 方法重载，该重载允许您为实例或静态方法创建开放或关闭委托的所有组合，还可以选择指定第一个参数。  
  
> [!NOTE]
>  如果委托未通过其第一个参数关闭，则应使用此方法重载，因为在这种情况下，该委托的速度稍快。  
  
 此方法重载等效于调用 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> 方法重载，并为指定 `true` `throwOnBindFailure` 。  
  
> [!NOTE]
>  从开始 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] ，此方法可用于访问非公共方法，前提是已向调用方授予了 <xref:System.Security.Permissions.ReflectionPermission> 标志， <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 并且非公共方法的授予集限制为调用方的授予集或其子集。  (参阅 [反射的安全注意事项](/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection))   
>   
>  若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
## <a name="compatible-parameter-types-and-return-type"></a>兼容的参数类型和返回类型  
 在 .NET Framework 版本2.0 中，使用此方法重载创建的委托的参数类型和返回类型必须与委托表示的方法的参数类型和返回类型兼容;类型不必完全匹配。 这表示 .NET Framework 版本1.0 和1.1 中绑定行为的 relaxation，其中类型必须完全匹配。  
  
 如果委托参数的类型的限制性强于方法参数的类型，则该委托的参数与该方法的相应参数兼容，因为这可保证传递给委托的参数可以安全地传递给方法。  
  
 同样，如果方法的返回类型的限制性强于委托的返回类型，则该委托的返回类型与该方法的返回类型兼容，因为这可保证方法的返回值可以安全地强制转换为委托的返回类型。  
  
 例如，具有类型为的参数 <xref:System.Collections.Hashtable> 和返回类型的委托 <xref:System.Object> 可以表示具有类型的参数 <xref:System.Object> 和类型的返回值的方法 <xref:System.Collections.Hashtable> 。  
  
   
  
## Examples  
 本部分包含两个代码示例。 第一个示例演示可使用此方法重载创建的两种委托：通过实例方法打开并通过静态方法打开。  
  
 第二个代码示例演示兼容的参数类型和返回类型。  
  
 **示例 1**  
  
 下面的代码示例演示了使用此方法重载可以创建委托的两种方法 <xref:System.Delegate.CreateDelegate%2A> 。  
  
> [!NOTE]
>  方法有两个重载 <xref:System.Delegate.CreateDelegate%2A> ，它指定 <xref:System.Reflection.MethodInfo> 但不指定第一个参数; 其功能是相同的，但前者允许您指定是否要在绑定失败时引发，另一个始终引发。 此代码示例使用两个重载。  
  
 该示例 `C` 使用静态方法 `M2` 、实例方法 `M1` 和两个委托类型来声明类： `D1` 使用实例 `C` 和字符串，并 `D2` 使用字符串。  
  
 名为的第二个类 `Example` 包含创建委托的代码。  
  
-   为 `D1` 实例方法创建表示开放式实例方法的类型为的委托 `M1` 。 调用委托时，必须传递一个实例。  
  
-   为 `D2` 静态方法创建一个表示 open 静态方法的类型的委托 `M2` 。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb" id="Snippet1":::

 **示例 2**  
  
 下面的代码示例演示参数类型和返回类型的兼容性。  
  
 此代码示例定义一个名为 `Base` 的基类和一个名为 `Derived` 的类，该类派生自 `Base` 。 派生类具有一个 `static` `Shared` 名为 Visual Basic) 方法的 (`MyMethod` ，该方法使用一个类型的参数 `Base` 和返回类型进行命名 `Derived` 。 此代码示例还定义了一个名为 `Example` 的委托，该委托具有一个类型为的参数 `Derived` 和一个返回类型 `Base` 。  
  
 此代码示例演示了 `Example` 可用于表示方法的名为的委托 `MyMethod` 。 方法可以绑定到委托，原因如下：  
  
-   委托 () 的参数类型 `Derived` 比 () 的参数类型具有更强的 `MyMethod` 限制 `Base` ，因此，将委托的参数传递到始终是安全的 `MyMethod` 。  
  
-    () 的返回 `MyMethod` 类型 `Derived` 比委托)  (的参数类型的限制更严格 `Base` ，因此，将方法的返回类型强制转换为委托的返回类型始终是安全的。  
  
 此代码示例不生成输出。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="method" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> 不继承 <see cref="T:System.MulticastDelegate" />。  
  
- 或 - 
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 请参阅[反射中的运行时类型](/previous-versions/dotnet/netframework-4.0/ms172329(v=vs.100))。  
  
- 或 - 
 <paramref name="method" /> 不是一种静态方法，并且 .NET Framework 版本为 1.0 或 1.1。  
  
- 或 - 
 无法绑定 <paramref name="method" />。  
  
- 或 - 
 <paramref name="method" /> 不是 <see langword="RuntimeMethodInfo" />。 请参阅[反射中的运行时类型](/previous-versions/dotnet/netframework-4.0/ms172329(v=vs.100))。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有访问 <paramref name="method" /> 所必需的权限。</exception>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object? firstArgument, System.Reflection.MethodInfo method);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDelegate (type As Type, firstArgument As Object, method As MethodInfo) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method)" />
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="firstArgument" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="type">要创建的委托的 <see cref="T:System.Type" />。</param>
        <param name="firstArgument">委托要绑定到的对象，若要将 <paramref name="method" /> 作为 <see langword="static" />（在 Visual Basic 中为 <see langword="Shared" />），则为 <see langword="null" />。</param>
        <param name="method">描述该委托要表示的静态或实例方法的 <see cref="T:System.Reflection.MethodInfo" />。</param>
        <summary>使用指定的第一个参数创建指定类型的委托，该委托表示指定的静态方法或实例方法。</summary>
        <returns>指定类型的委托，表示指定的静态或实例方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法重载等效于调用 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> 方法重载并为指定 `true` `throwOnBindFailure` 。 这两个重载提供最灵活的方法来创建委托。 您可以使用它们为静态方法或实例方法创建委托，还可以选择指定第一个参数。  
  
> [!NOTE]
>  如果不提供第一个参数，请使用 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> 方法重载以获得更好的性能。  
  
 委托类型和方法必须具有兼容的返回类型。 也就是说，的返回类型 `method` 必须可分配给的返回类型 `type` 。  
  
 如果 `firstArgument` 提供了，则在每次调用委托时将其传递到 `method` ; 称为 `firstArgument` 绑定到委托，并且委托被认为是在其第一个自变量上关闭的。 如果 `method` `static` `Shared` 在 Visual Basic) 中 (，则调用委托时提供的自变量列表包含除第一个参数之外的所有参数; 如果 `method` 为实例方法，则 `firstArgument` 将传递到由 `this` c # 中的或 Visual Basic) 中的隐藏实例参数 (`Me` 。  
  
 如果 `firstArgument` 提供了，则的第一个参数 `method` 必须是引用类型，并且 `firstArgument` 必须与该类型兼容。  
  
> [!IMPORTANT]
>  如果 `method` `static` `Shared` 在 Visual Basic) 中 (，并且其第一个参数的类型为 <xref:System.Object> 或 <xref:System.ValueType> ，则 `firstArgument` 可以是值类型。 在这种情况下 `firstArgument` ，会自动装箱。 对于任何其他参数，都不会进行自动装箱，就像在 c # 或 Visual Basic 函数调用中一样。  
  
 如果 `firstArgument` 是 null 引用并且 `method` 是实例方法，则结果取决于委托类型 `type` 和的签名 `method` ：  
  
-   如果的签名 `type` 显式包含隐藏的第一个参数 `method` ，则称委托表示一个开放式实例方法。 调用委托时，将参数列表中的第一个自变量传递给的隐藏实例参数 `method` 。  
  
-   如果和的签名 `method` `type` 匹配 (即，所有参数类型都) 兼容，则将委托视为通过空引用来关闭。 调用委托类似于在 null 实例上调用实例方法，这并不是特别有用的操作。  
  
 如果 `firstArgument` 是 null 引用并且 `method` 是静态的，则结果取决于委托类型 `type` 和的签名 `method` ：  
  
-   如果和的签名 `method` `type` 匹配 (即，所有参数类型都) 兼容，则委托称为表示开放式静态方法。 这是静态方法最常见的情况。 在这种情况下，可以使用方法重载获得略微更好的性能 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> 。  
  
-   如果的签名 `type` 以的第二个参数开始， `method` 而其余的参数类型是兼容的，则认为该委托是通过空引用关闭的。 调用委托时，空引用将传递给的第一个参数 `method` 。  
  
> [!NOTE]
>  从开始 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] ，此方法可用于访问非公共方法，前提是已向调用方授予了 <xref:System.Security.Permissions.ReflectionPermission> 标志， <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 并且非公共方法的授予集限制为调用方的授予集或其子集。  (参阅 [反射的安全注意事项](/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection))   
>   
>  若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
## <a name="compatible-parameter-types-and-return-type"></a>兼容的参数类型和返回类型  
 委托的参数类型和返回类型必须与委托表示的方法的参数类型和返回类型兼容;类型不必完全匹配。  
  
> [!NOTE]
>  在 .NET Framework 版本1.0 和1.1 中，类型必须完全匹配。  
  
 如果委托参数的类型的限制性强于方法参数的类型，则该委托的参数与该方法的相应参数兼容，因为这可保证传递给委托的参数可以安全地传递给方法。  
  
 同样，如果方法的返回类型的限制性强于委托的返回类型，则该委托的返回类型与该方法的返回类型兼容，因为这可保证方法的返回值可以安全地强制转换为委托的返回类型。  
  
 例如，具有类型为的参数 <xref:System.Collections.Hashtable> 和返回类型的委托 <xref:System.Object> 可以表示具有类型的参数 <xref:System.Object> 和类型的返回值的方法 <xref:System.Collections.Hashtable> 。  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>确定委托可以表示的方法  
 考虑此重载提供的灵活性的另一种有用方法 <xref:System.Delegate.CreateDelegate%2A> 是，任何给定的委托可以表示方法签名和方法类型的四种不同组合 (静态与实例) 。 请考虑一个 `D` 具有类型为的参数的委托类型 `C` 。 下面描述了方法 `D` 可以表示的方法，忽略返回类型，因为它在所有情况下都必须匹配：  
  
-   `D` 可以表示任何具有一个类型为的参数的任何实例方法 `C` ，而不考虑该实例方法所属的类型。 当 <xref:System.Delegate.CreateDelegate%2A> 调用时， `firstArgument` 是该类型的一个实例 `method` ，而所生成的委托则被称为关闭该实例。  (完全， `D` 如果为 null 引用，也可以通过空引用关闭 `firstArgument` 。 )   
  
-   `D` 可以表示没有参数的实例方法 `C` 。 <xref:System.Delegate.CreateDelegate%2A>调用时， `firstArgument` 为空引用。 生成的委托表示开放式实例方法， `C` 必须在每次调用时提供实例。  
  
-   `D` 可以表示静态方法，该方法采用一个类型的参数 `C` ，该方法可以属于任何类型。 <xref:System.Delegate.CreateDelegate%2A>调用时， `firstArgument` 为空引用。 生成的委托表示开放式静态方法， `C` 必须在每次调用时提供实例。  
  
-   `D` 可以表示属于类型 `F` 且具有两个类型为的参数和类型的静态方法 `F` `C` 。 当 <xref:System.Delegate.CreateDelegate%2A> 调用时， `firstArgument` 是的实例 `F` 。 生成的委托表示在该实例上关闭的静态方法 `F` 。 请注意，在和的 `F` 类型相同的情况下 `C` ，静态方法具有该类型的两个参数。 在这种情况下， `D` 如果为 null 引用，则 (在空引用上关闭 `firstArgument` 。 )   
  
   
  
## Examples  
 本部分包含三个代码示例。 第一个示例演示了可创建的四种委托：通过实例方法关闭、在实例方法上打开、通过静态方法打开和通过静态方法关闭。  
  
 第二个代码示例演示兼容的参数类型和返回类型。  
  
 第三个代码示例定义了一个委托类型，并显示委托类型可以表示的所有方法。  
  
 **示例 1**  
  
 下面的代码示例演示了使用此方法重载可以创建委托的四种方法 <xref:System.Delegate.CreateDelegate%2A> 。  
  
> [!NOTE]
>  方法有两个重载 <xref:System.Delegate.CreateDelegate%2A> ，它指定 `firstArgument` 和 a <xref:System.Reflection.MethodInfo> ; 其功能相同，不同之处在于，它允许您指定是否要在绑定失败时引发，另一个始终引发。 此代码示例使用两个重载。  
  
 该示例 `C` 使用一个静态方法 `M2` 和一个实例方法声明一个类 `M1` ，并使用三个委托类型： `D1` 使用的实例 `C` 和一个字符串， `D2` 并且 `D3` 没有参数。  
  
 名为的第二个类 `Example` 包含创建委托的代码。  
  
-   为实例方法创建了一个类型的委托，该委托在的 `D2` 实例上关闭 `C` `M1` 。 它使用不同的字符串调用，以表示始终使用的绑定实例 `C` 。  
  
-   为 `D1` 实例方法创建表示开放式实例方法的类型为的委托 `M1` 。 调用委托时，必须传递一个实例。  
  
-   为 `D2` 静态方法创建一个表示 open 静态方法的类型的委托 `M2` 。  
  
-   最后，为 `D3` 静态方法创建一个在字符串上关闭的类型的委托 `M2` 。 调用方法以显示它使用绑定的字符串。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb" id="Snippet1":::

 **示例 2**  
  
 下面的代码示例演示参数类型和返回类型的兼容性。  
  
> [!NOTE]
>  此代码示例使用 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> 方法重载。 使用采用的其他重载 <xref:System.Reflection.MethodInfo> 类似。  
  
 此代码示例定义一个名为 `Base` 的基类和一个名为 `Derived` 的类，该类派生自 `Base` 。 派生类具有一个 `static` `Shared` 名为 Visual Basic) 方法的 (`MyMethod` ，该方法使用一个类型的参数 `Base` 和返回类型进行命名 `Derived` 。 此代码示例还定义了一个名为 `Example` 的委托，该委托具有一个类型为的参数 `Derived` 和一个返回类型 `Base` 。  
  
 此代码示例演示了 `Example` 可用于表示方法的名为的委托 `MyMethod` 。 方法可以绑定到委托，原因如下：  
  
-   委托 () 的参数类型 `Derived` 比 () 的参数类型具有更强的 `MyMethod` 限制 `Base` ，因此，将委托的参数传递到始终是安全的 `MyMethod` 。  
  
-    () 的返回 `MyMethod` 类型 `Derived` 比委托)  (的参数类型的限制更严格 `Base` ，因此，将方法的返回类型强制转换为委托的返回类型始终是安全的。  
  
 此代码示例不生成输出。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **示例 3**  
  
 下面的代码示例演示一个委托类型可以表示的所有方法， <xref:System.Delegate.CreateDelegate%2A> 并使用方法来创建委托。  
  
> [!NOTE]
>  方法有两个重载 <xref:System.Delegate.CreateDelegate%2A> ，它指定 `firstArgument` 和 a <xref:System.Reflection.MethodInfo> ; 其功能相同，不同之处在于，它允许您指定是否要在绑定失败时引发，另一个始终引发。 此代码示例使用两个重载。  
  
 此代码示例定义了两个类： `C` 和，以及一个 `F` 类型为的参数的委托类型 `D` `C` 。 类具有匹配的静态和实例方法 `M1` 、 `M3` 和 `M4` ，并且类 `C` 还具有一个 `M2` 不带参数的实例方法。  
  
 第三个名为的类 `Example` 包含创建委托的代码。  
  
-   为类型和类型的实例方法创建委托 `M1` `C` ; 每个委托都在 `F` 各自类型的实例上关闭。 类型为的方法 `M1` `C` 显示 `ID` 绑定实例和参数的属性。  
  
-   为类型的方法创建委托 `M2` `C` 。 这是一个打开的实例委托，其中委托的参数表示实例方法上隐藏的第一个参数。 方法没有其他参数。 它被称为静态方法。  
  
-   为类型和类型的静态方法创建委托 `M3` `C` `F` ; 这些是开放式静态委托。  
  
-   最后，为类型和类型的静态方法创建委托 `M4` `C` `F` ; 每个方法都将声明类型作为其第一个参数，并提供类型的实例，因此这些委托在其第一个参数上关闭。 类型为的方法 `M4` `C` 显示 `ID` 绑定实例和参数的属性。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="method" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> 不继承 <see cref="T:System.MulticastDelegate" />。  
  
- 或 - 
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 请参阅[反射中的运行时类型](/previous-versions/dotnet/netframework-4.0/ms172329(v=vs.100))。  
  
- 或 - 
 无法绑定 <paramref name="method" />。  
  
- 或 - 
 <paramref name="method" /> 不是 <see langword="RuntimeMethodInfo" />。 请参阅[反射中的运行时类型](/previous-versions/dotnet/netframework-4.0/ms172329(v=vs.100))。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有访问 <paramref name="method" /> 所必需的权限。</exception>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDelegate (type As Type, target As Object, method As String) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="type">要创建的委托的 <see cref="T:System.Type" />。</param>
        <param name="target">类实例，对其调用 <paramref name="method" />。</param>
        <param name="method">委托要表示的实例方法的名称。</param>
        <summary>创建指定类型的委托，该委托表示要对指定的类实例调用的指定实例方法。</summary>
        <returns>指定的类型的委托，表示要对指定的类实例调用的指定的实例方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法只为实例方法创建委托。 实例方法是与类的实例关联的方法;静态方法是与类自身相关联的方法。  
  
 此方法重载等效于调用 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> 方法重载，并为指定 `false` `ignoreCase` 和 `true` `throwOnBindFailure` 。  
  
> [!NOTE]
>  从开始 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] ，此方法可用于访问非公共方法，前提是已向调用方授予了 <xref:System.Security.Permissions.ReflectionPermission> 标志， <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 并且非公共方法的授予集限制为调用方的授予集或其子集。  (参阅 [反射的安全注意事项](/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection))   
>   
>  若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="target" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="method" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> 不继承 <see cref="T:System.MulticastDelegate" />。  
  
- 或 - 
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 请参阅[反射中的运行时类型](/previous-versions/dotnet/netframework-4.0/ms172329(v=vs.100))。  
  
- 或 - 
 <paramref name="method" /> 不是实例方法。  
  
- 或 - 
 无法绑定 <paramref name="method" />，例如因为找不到它。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有访问 <paramref name="method" /> 所必需的权限。</exception>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate? CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDelegate (type As Type, method As MethodInfo, throwOnBindFailure As Boolean) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method, throwOnBindFailure)" />
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="type">要创建的委托的 <see cref="T:System.Type" />。</param>
        <param name="method">描述该委托要表示的静态或实例方法的 <see cref="T:System.Reflection.MethodInfo" />。</param>
        <param name="throwOnBindFailure">如果无法绑定 <paramref name="method" /> 时引发异常，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>使用针对绑定失败的指定行为，创建用于表示指定静态方法的指定类型的委托。</summary>
        <returns>表示指定静态方法的指定类型的委托。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重载可以创建开放式静态方法委托和开放式实例方法委托，即公开实例方法的隐藏第一个参数的委托。 有关详细说明，请参阅更通用的 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> 方法重载，该重载允许您为实例或静态方法创建开放式或封闭式委托的所有组合。  
  
> [!NOTE]
>  如果委托未通过其第一个参数关闭，则应使用此方法重载，因为在这种情况下，该委托的速度稍快。  
  
> [!NOTE]
>  从开始 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] ，此方法可用于访问非公共方法，前提是已向调用方授予了 <xref:System.Security.Permissions.ReflectionPermission> 标志， <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 并且非公共方法的授予集限制为调用方的授予集或其子集。  (参阅 [反射的安全注意事项](/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection))   
>   
>  若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
## <a name="compatible-parameter-types-and-return-type"></a>兼容的参数类型和返回类型  
 委托的参数类型和返回类型必须与委托表示的方法的参数类型和返回类型兼容;类型不必完全匹配。  
  
> [!NOTE]
>  在 .NET Framework 版本1.0 和1.1 中，类型必须完全匹配。  
  
 如果委托参数的类型的限制性强于方法参数的类型，则该委托的参数与该方法的相应参数兼容，因为这可保证传递给委托的参数可以安全地传递给方法。  
  
 同样，如果方法的返回类型的限制性强于委托的返回类型，则该委托的返回类型与该方法的返回类型兼容，因为这可保证方法的返回值可以安全地强制转换为委托的返回类型。  
  
 例如，具有类型为的参数 <xref:System.Collections.Hashtable> 和返回类型的委托 <xref:System.Object> 可以表示具有类型的参数 <xref:System.Object> 和类型的返回值的方法 <xref:System.Collections.Hashtable> 。  
  
   
  
## Examples  
 本部分包含两个代码示例。 第一个示例演示可使用此方法重载创建的两种委托：通过实例方法打开并通过静态方法打开。  
  
 第二个代码示例演示兼容的参数类型和返回类型。  
  
 **示例 1**  
  
 下面的代码示例演示了使用此方法重载可以创建委托的两种方法 <xref:System.Delegate.CreateDelegate%2A> 。  
  
> [!NOTE]
>  方法有两个重载 <xref:System.Delegate.CreateDelegate%2A> ，它指定 <xref:System.Reflection.MethodInfo> 但不指定第一个参数; 其功能是相同的，但前者允许您指定是否要在绑定失败时引发，另一个始终引发。 此代码示例使用两个重载。  
  
 该示例 `C` 使用静态方法 `M2` 、实例方法 `M1` 和两个委托类型来声明类： `D1` 使用实例 `C` 和字符串，并 `D2` 使用字符串。  
  
 名为的第二个类 `Example` 包含创建委托的代码。  
  
-   为 `D1` 实例方法创建表示开放式实例方法的类型为的委托 `M1` 。 调用委托时，必须传递一个实例。  
  
-   为 `D2` 静态方法创建一个表示 open 静态方法的类型的委托 `M2` 。  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb" id="Snippet1":::

 **示例 2**  
  
 下面的代码示例演示参数类型和返回类型的兼容性。  
  
> [!NOTE]
>  此代码示例使用 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> 方法重载。 使用采用的其他重载 <xref:System.Reflection.MethodInfo> 类似。  
  
 此代码示例定义一个名为 `Base` 的基类和一个名为 `Derived` 的类，该类派生自 `Base` 。 派生类具有一个 `static` `Shared` 名为 Visual Basic) 方法的 (`MyMethod` ，该方法使用一个类型的参数 `Base` 和返回类型进行命名 `Derived` 。 此代码示例还定义了一个名为 `Example` 的委托，该委托具有一个类型为的参数 `Derived` 和一个返回类型 `Base` 。  
  
 此代码示例演示了 `Example` 可用于表示方法的名为的委托 `MyMethod` 。 方法可以绑定到委托，原因如下：  
  
-   委托 () 的参数类型 `Derived` 比 () 的参数类型具有更强的 `MyMethod` 限制 `Base` ，因此，将委托的参数传递到始终是安全的 `MyMethod` 。  
  
-    () 的返回 `MyMethod` 类型 `Derived` 比委托)  (的参数类型的限制更严格 `Base` ，因此，将方法的返回类型强制转换为委托的返回类型始终是安全的。  
  
 此代码示例不生成输出。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="method" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> 不继承 <see cref="T:System.MulticastDelegate" />。  
  
- 或 - 
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 请参阅[反射中的运行时类型](/previous-versions/dotnet/netframework-4.0/ms172329(v=vs.100))。  
  
- 或 - 
 无法绑定 <paramref name="method" />，且 <paramref name="throwOnBindFailure" /> 为 <see langword="true" />。  
  
- 或 - 
 <paramref name="method" /> 不是 <see langword="RuntimeMethodInfo" />。 请参阅[反射中的运行时类型](/previous-versions/dotnet/netframework-4.0/ms172329(v=vs.100))。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有访问 <paramref name="method" /> 所必需的权限。</exception>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDelegate (type As Type, target As Type, method As String) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="type">要创建的委托的 <see cref="T:System.Type" />。</param>
        <param name="target">表示实现 <paramref name="method" /> 的类的 <see cref="T:System.Type" />。</param>
        <param name="method">委托要表示的静态方法的名称。</param>
        <summary>创建指定类型的委托，该委托表示指定类的指定静态方法。</summary>
        <returns>指定类型的委托，该委托表示指定类的指定静态方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法仅为静态方法创建委托。 实例方法是与类的实例关联的方法;静态方法是与类自身相关联的方法。  
  
 此方法重载等效于调用 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> 方法重载，并为指定 `false` `ignoreCase` 和 `true` `throwOnBindFailure` 。  
  
> [!NOTE]
>  从开始 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] ，此方法可用于访问非公共方法，前提是已向调用方授予了 <xref:System.Security.Permissions.ReflectionPermission> 标志， <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 并且非公共方法的授予集限制为调用方的授予集或其子集。  (参阅 [反射的安全注意事项](/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection))   
>   
>  若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="target" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="method" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> 不继承 <see cref="T:System.MulticastDelegate" />。  
  
- 或 - 
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 请参阅[反射中的运行时类型](/previous-versions/dotnet/netframework-4.0/ms172329(v=vs.100))。  
  
- 或 - 
 <paramref name="target" /> 不是 <see langword="RuntimeType" />。  
  
- 或 - 
 <paramref name="target" /> 为开放式泛型类型。 也就是说，其 <see cref="P:System.Type.ContainsGenericParameters" /> 属性为 <see langword="true" />。  
  
- 或 - 
 <paramref name="method" /> 不是 <see langword="static" /> 方法（在 Visual Basic 中为 <see langword="Shared" /> 方法）。  
  
- 或 - 
 无法绑定 <paramref name="method" />，例如因为找不到它，并且 <paramref name="throwOnBindFailure" /> 为 <see langword="true" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有访问 <paramref name="method" /> 所必需的权限。</exception>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate? CreateDelegate (Type type, object? firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDelegate (type As Type, firstArgument As Object, method As MethodInfo, throwOnBindFailure As Boolean) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method, throwOnBindFailure)" />
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="firstArgument" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="type">一个 <see cref="T:System.Type" />，表示要创建的委托类型。</param>
        <param name="firstArgument">一个 <see cref="T:System.Object" />，它是委托表示的方法的第一个自变量。 对于实例方法，它必须与实例类型兼容。</param>
        <param name="method">描述该委托要表示的静态或实例方法的 <see cref="T:System.Reflection.MethodInfo" />。</param>
        <param name="throwOnBindFailure">如果无法绑定 <paramref name="method" /> 时引发异常，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>使用指定的第一个自变量和针对绑定失败的指定行为，创建表示指定的静态方法或实例方法的指定类型的委托。</summary>
        <returns>表示指定静态方法或实例方法的指定类型的委托；如果 <paramref name="throwOnBindFailure" /> 为 <see langword="false" />，并且委托无法绑定到 <paramref name="method" />，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重载和 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> 方法重载（始终在绑定失败时引发）提供了最灵活的方法来创建委托。 可以使用这些方法为静态方法或实例方法创建委托，无论是使用第一个参数还是不使用第一个参数。  
  
> [!NOTE]
>  如果不提供第一个参数，请使用 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> 方法重载以获得更好的性能。  
  
 委托类型和方法必须具有兼容的返回类型。 也就是说，的返回类型 `method` 必须可分配给的返回类型 `type` 。  
  
 如果 `firstArgument` 提供了，则在每次调用委托时将其传递到 `method` ; 称为 `firstArgument` 绑定到委托，并且委托被认为是在其第一个自变量上关闭的。 如果 `method` `static` `Shared` 在 Visual Basic) 中 (，则调用委托时提供的自变量列表包含除第一个参数之外的所有参数; 如果 `method` 为实例方法，则 `firstArgument` 将传递到由 `this` c # 中的或 Visual Basic) 中的隐藏实例参数 (`Me` 。  
  
 如果 `firstArgument` 提供了，则的第一个参数 `method` 必须是引用类型，并且 `firstArgument` 必须与该类型兼容。  
  
> [!IMPORTANT]
>  如果 `method` `static` `Shared` 在 Visual Basic) 中 (，并且其第一个参数的类型为 <xref:System.Object> 或 <xref:System.ValueType> ，则 `firstArgument` 可以是值类型。 在这种情况下 `firstArgument` ，会自动装箱。 对于任何其他参数，都不会进行自动装箱，就像在 c # 或 Visual Basic 函数调用中一样。  
  
 如果 `firstArgument` 是 null 引用并且 `method` 是实例方法，则结果取决于委托类型 `type` 和的签名 `method` ：  
  
-   如果的签名 `type` 显式包含隐藏的第一个参数 `method` ，则称委托表示一个开放式实例方法。 调用委托时，将参数列表中的第一个自变量传递给的隐藏实例参数 `method` 。  
  
-   如果和的签名 `method` `type` 匹配 (即，所有参数类型都) 兼容，则将委托视为通过空引用来关闭。 调用委托类似于在 null 实例上调用实例方法，这并不是特别有用的操作。  
  
 如果 `firstArgument` 是 null 引用并且 `method` 是静态的，则结果取决于委托类型 `type` 和的签名 `method` ：  
  
-   如果和的签名 `method` `type` 匹配 (即，所有参数类型都) 兼容，则委托称为表示开放式静态方法。 这是静态方法最常见的情况。 在这种情况下，可以使用方法重载获得略微更好的性能 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> 。  
  
-   如果的签名 `type` 以的第二个参数开始， `method` 而其余的参数类型是兼容的，则认为该委托是通过空引用关闭的。 调用委托时，空引用将传递给的第一个参数 `method` 。  
  
> [!NOTE]
>  从开始 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] ，此方法可用于访问非公共方法，前提是已向调用方授予了 <xref:System.Security.Permissions.ReflectionPermission> 标志， <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 并且非公共方法的授予集限制为调用方的授予集或其子集。  (参阅 [反射的安全注意事项](/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection))   
>   
>  若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
## <a name="compatible-parameter-types-and-return-type"></a>兼容的参数类型和返回类型  
 委托的参数类型和返回类型必须与委托表示的方法的参数类型和返回类型兼容;类型不必完全匹配。  
  
> [!NOTE]
>  在 .NET Framework 版本1.0 和1.1 中，类型必须完全匹配。  
  
 如果委托参数的类型的限制性强于方法参数的类型，则该委托的参数与该方法的相应参数兼容，因为这可保证传递给委托的参数可以安全地传递给方法。  
  
 同样，如果方法的返回类型的限制性强于委托的返回类型，则该委托的返回类型与该方法的返回类型兼容，因为这可保证方法的返回值可以安全地强制转换为委托的返回类型。  
  
 例如，具有类型为的参数 <xref:System.Collections.Hashtable> 和返回类型的委托 <xref:System.Object> 可以表示具有类型的参数 <xref:System.Object> 和类型的返回值的方法 <xref:System.Collections.Hashtable> 。  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>确定委托可以表示的方法  
 考虑此重载提供的灵活性的另一种有用方法 <xref:System.Delegate.CreateDelegate%2A> 是，任何给定的委托可以表示方法签名和方法类型的四种不同组合 (静态与实例) 。 请考虑一个 `D` 具有类型为的参数的委托类型 `C` 。 下面描述了方法 `D` 可以表示的方法，忽略返回类型，因为它在所有情况下都必须匹配：  
  
-   `D` 可以表示任何具有一个类型为的参数的任何实例方法 `C` ，而不考虑该实例方法所属的类型。 当 <xref:System.Delegate.CreateDelegate%2A> 调用时， `firstArgument` 是该类型的一个实例 `method` ，而所生成的委托则被称为关闭该实例。  (完全， `D` 如果为，还可以通过空引用关闭 `firstArgument` `null` 。 )   
  
-   `D` 可以表示没有参数的实例方法 `C` 。 <xref:System.Delegate.CreateDelegate%2A>调用时， `firstArgument` 为空引用。 生成的委托表示开放式实例方法， `C` 必须在每次调用时提供实例。  
  
-   `D` 可以表示静态方法，该方法采用一个类型的参数 `C` ，该方法可以属于任何类型。 <xref:System.Delegate.CreateDelegate%2A>调用时， `firstArgument` 为空引用。 生成的委托表示开放式静态方法， `C` 必须在每次调用时提供实例。  
  
-   `D` 可以表示属于类型 `F` 且具有两个类型为的参数和类型的静态方法 `F` `C` 。 当 <xref:System.Delegate.CreateDelegate%2A> 调用时， `firstArgument` 是的实例 `F` 。 生成的委托表示在该实例上关闭的静态方法 `F` 。 请注意，在和的 `F` 类型相同的情况下 `C` ，静态方法具有该类型的两个参数。 在这种情况下， `D` 如果为，则 (通过空引用关闭 `firstArgument` `null` 。 )   
  
   
  
## Examples  
 本部分包含三个代码示例。 第一个示例演示了可创建的四种委托：通过实例方法关闭、在实例方法上打开、通过静态方法打开和通过静态方法关闭。  
  
 第二个代码示例演示兼容的参数类型和返回类型。  
  
 第三个代码示例定义了一个委托类型，并显示委托类型可以表示的所有方法。  
  
 **示例 1**  
  
 下面的代码示例演示了使用此方法重载可以创建委托的四种方法 <xref:System.Delegate.CreateDelegate%2A> 。  
  
> [!NOTE]
>  方法有两个重载 <xref:System.Delegate.CreateDelegate%2A> ，它指定 `firstArgument` 和 a <xref:System.Reflection.MethodInfo> ; 其功能相同，不同之处在于，它允许您指定是否要在绑定失败时引发，另一个始终引发。 此代码示例使用两个重载。  
  
 该示例 `C` 使用一个静态方法 `M2` 和一个实例方法声明一个类 `M1` ，并使用三个委托类型： `D1` 使用的实例 `C` 和一个字符串， `D2` 并且 `D3` 没有参数。  
  
 名为的第二个类 `Example` 包含创建委托的代码。  
  
-   为实例方法创建了一个类型的委托，该委托在的 `D2` 实例上关闭 `C` `M1` 。 它使用不同的字符串调用，以表示始终使用的绑定实例 `C` 。  
  
-   为 `D1` 实例方法创建表示开放式实例方法的类型为的委托 `M1` 。 调用委托时，必须传递一个实例。  
  
-   为 `D2` 静态方法创建一个表示 open 静态方法的类型的委托 `M2` 。  
  
-   最后，为 `D3` 静态方法创建一个在字符串上关闭的类型的委托 `M2` 。 调用方法以显示它使用绑定的字符串。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb" id="Snippet1":::

 **示例 2**  
  
 下面的代码示例演示参数类型和返回类型的兼容性。  
  
> [!NOTE]
>  此代码示例使用 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> 方法重载。 使用采用的其他重载 <xref:System.Reflection.MethodInfo> 类似。  
  
 此代码示例定义一个名为 `Base` 的基类和一个名为 `Derived` 的类，该类派生自 `Base` 。 派生类具有一个 `static` `Shared` 名为 Visual Basic) 方法的 (`MyMethod` ，该方法使用一个类型的参数 `Base` 和返回类型进行命名 `Derived` 。 此代码示例还定义了一个名为 `Example` 的委托，该委托具有一个类型为的参数 `Derived` 和一个返回类型 `Base` 。  
  
 此代码示例演示了 `Example` 可用于表示方法的名为的委托 `MyMethod` 。 方法可以绑定到委托，原因如下：  
  
-   委托 () 的参数类型 `Derived` 比 () 的参数类型具有更强的 `MyMethod` 限制 `Base` ，因此，将委托的参数传递到始终是安全的 `MyMethod` 。  
  
-    () 的返回 `MyMethod` 类型 `Derived` 比委托)  (的参数类型的限制更严格 `Base` ，因此，将方法的返回类型强制转换为委托的返回类型始终是安全的。  
  
 此代码示例不生成输出。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **示例 3**  
  
 下面的代码示例演示一个委托类型可以表示的所有方法。  
  
> [!NOTE]
>  方法有两个重载 <xref:System.Delegate.CreateDelegate%2A> ，它指定 `firstArgument` 和 a <xref:System.Reflection.MethodInfo> ; 其功能相同，不同之处在于，它允许您指定是否要在绑定失败时引发，另一个始终引发。 此代码示例使用两个重载。  
  
 此代码示例定义了两个类： `C` 和，以及一个 `F` 类型为的参数的委托类型 `D` `C` 。 类具有匹配的静态和实例方法 `M1` 、 `M3` 和 `M4` ，并且类 `C` 还具有一个 `M2` 不带参数的实例方法。  
  
 第三个名为的类 `Example` 包含创建委托的代码。  
  
-   为类型和类型的实例方法创建委托 `M1` `C` ; 每个委托都在 `F` 各自类型的实例上关闭。 类型为的方法 `M1` `C` 显示 `ID` 绑定实例和参数的属性。  
  
-   为类型的方法创建委托 `M2` `C` 。 这是一个打开的实例委托，其中委托的参数表示实例方法上隐藏的第一个参数。 方法没有其他参数。  
  
-   为类型和类型的静态方法创建委托 `M3` `C` `F` ; 这些是开放式静态委托。  
  
-   最后，为类型和类型的静态方法创建委托 `M4` `C` `F` ; 每个方法都将声明类型作为其第一个参数，并提供类型的实例，因此这些委托在其第一个参数上关闭。 类型为的方法 `M4` `C` 显示 `ID` 绑定实例和参数的属性。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="method" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> 不继承 <see cref="T:System.MulticastDelegate" />。  
  
- 或 - 
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 请参阅[反射中的运行时类型](/previous-versions/dotnet/netframework-4.0/ms172329(v=vs.100))。  
  
- 或 - 
 无法绑定 <paramref name="method" />，且 <paramref name="throwOnBindFailure" /> 为 <see langword="true" />。  
  
- 或 - 
 <paramref name="method" /> 不是 <see langword="RuntimeMethodInfo" />。 请参阅[反射中的运行时类型](/previous-versions/dotnet/netframework-4.0/ms172329(v=vs.100))。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有访问 <paramref name="method" /> 所必需的权限。</exception>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDelegate (type As Type, target As Object, method As String, ignoreCase As Boolean) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="type">要创建的委托的 <see cref="T:System.Type" />。</param>
        <param name="target">类实例，对其调用 <paramref name="method" />。</param>
        <param name="method">委托要表示的实例方法的名称。</param>
        <param name="ignoreCase">一个布尔值，它指示在比较方法名称时是否忽略大小写。</param>
        <summary>创建指定类型的委托，该委托表示要按指定的大小写敏感度对指定类实例调用的指定实例方法。</summary>
        <returns>指定的类型的委托，表示要对指定的类实例调用的指定的实例方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法只为实例方法创建委托。 实例方法是与类的实例关联的方法;静态方法是与类自身相关联的方法。  
  
 此方法重载等效于调用 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> 方法重载，并为指定 `true` `throwOnBindFailure` 。  
  
> [!NOTE]
>  从开始 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] ，此方法可用于访问非公共方法，前提是已向调用方授予了 <xref:System.Security.Permissions.ReflectionPermission> 标志， <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 并且非公共方法的授予集限制为调用方的授予集或其子集。  (参阅 [反射的安全注意事项](/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection))   
>   
>  若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="target" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="method" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> 不继承 <see cref="T:System.MulticastDelegate" />。  
  
- 或 - 
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 请参阅[反射中的运行时类型](/previous-versions/dotnet/netframework-4.0/ms172329(v=vs.100))。  
  
- 或 - 
 <paramref name="method" /> 不是实例方法。  
  
- 或 - 
 无法绑定 <paramref name="method" />，例如因为找不到它。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有访问 <paramref name="method" /> 所必需的权限。</exception>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDelegate (type As Type, target As Type, method As String, ignoreCase As Boolean) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="type">要创建的委托的 <see cref="T:System.Type" />。</param>
        <param name="target">表示实现 <paramref name="method" /> 的类的 <see cref="T:System.Type" />。</param>
        <param name="method">委托要表示的静态方法的名称。</param>
        <param name="ignoreCase">一个布尔值，它指示在比较方法名称时是否忽略大小写。</param>
        <summary>使用用于指定是否区分大小写的值创建指定类型的委托，该委托表示指定类的指定静态方法。</summary>
        <returns>指定类型的委托，该委托表示指定类的指定静态方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法仅为静态方法创建委托。 实例方法是与类的实例关联的方法;静态方法是与类自身相关联的方法。  
  
 此方法重载等效于调用 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> 方法重载，并为指定 `true` `throwOnBindFailure` 。  
  
> [!NOTE]
>  从开始 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] ，此方法可用于访问非公共方法，前提是已向调用方授予了 <xref:System.Security.Permissions.ReflectionPermission> 标志， <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 并且非公共方法的授予集限制为调用方的授予集或其子集。  (参阅 [反射的安全注意事项](/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection))   
>   
>  若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="target" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="method" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> 不继承 <see cref="T:System.MulticastDelegate" />。  
  
- 或 - 
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 请参阅[反射中的运行时类型](/previous-versions/dotnet/netframework-4.0/ms172329(v=vs.100))。  
  
- 或 - 
 <paramref name="target" /> 不是 <see langword="RuntimeType" />。  
  
- 或 - 
 <paramref name="target" /> 为开放式泛型类型。 也就是说，其 <see cref="P:System.Type.ContainsGenericParameters" /> 属性为 <see langword="true" />。  
  
- 或 - 
 <paramref name="method" /> 不是 <see langword="static" /> 方法（在 Visual Basic 中为 <see langword="Shared" /> 方法）。  
  
- 或 - 
 无法绑定 <paramref name="method" />，例如因为找不到它。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有访问 <paramref name="method" /> 所必需的权限。</exception>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate? CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDelegate (type As Type, target As Object, method As String, ignoreCase As Boolean, throwOnBindFailure As Boolean) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="type">要创建的委托的 <see cref="T:System.Type" />。</param>
        <param name="target">类实例，对其调用 <paramref name="method" />。</param>
        <param name="method">委托要表示的实例方法的名称。</param>
        <param name="ignoreCase">一个布尔值，它指示在比较方法名称时是否忽略大小写。</param>
        <param name="throwOnBindFailure">如果无法绑定 <paramref name="method" /> 时引发异常，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>使用用于指定是否区分大小写的值和针对绑定失败的指定行为，创建指定类型的委托，该委托表示要对指定类实例调用的指定实例方法。</summary>
        <returns>指定的类型的委托，表示要对指定的类实例调用的指定的实例方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法只为实例方法创建委托。 实例方法是与类的实例关联的方法;静态方法是与类自身相关联的方法。  
  
> [!NOTE]
>  从开始 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] ，此方法可用于访问非公共方法，前提是已向调用方授予了 <xref:System.Security.Permissions.ReflectionPermission> 标志， <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 并且非公共方法的授予集限制为调用方的授予集或其子集。  (参阅 [反射的安全注意事项](/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection))   
>   
>  若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="target" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="method" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> 不继承 <see cref="T:System.MulticastDelegate" />。  
  
- 或 - 
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 请参阅[反射中的运行时类型](/previous-versions/dotnet/netframework-4.0/ms172329(v=vs.100))。  
  
- 或 - 
 <paramref name="method" /> 不是实例方法。  
  
- 或 - 
 无法绑定 <paramref name="method" />，例如因为找不到它，并且 <paramref name="throwOnBindFailure" /> 为 <see langword="true" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有访问 <paramref name="method" /> 所必需的权限。</exception>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate? CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDelegate (type As Type, target As Type, method As String, ignoreCase As Boolean, throwOnBindFailure As Boolean) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="type">要创建的委托的 <see cref="T:System.Type" />。</param>
        <param name="target">表示实现 <paramref name="method" /> 的类的 <see cref="T:System.Type" />。</param>
        <param name="method">委托要表示的静态方法的名称。</param>
        <param name="ignoreCase">一个布尔值，它指示在比较方法名称时是否忽略大小写。</param>
        <param name="throwOnBindFailure">如果无法绑定 <paramref name="method" /> 时引发异常，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>使用用于指定是否区分大小写的值和针对绑定失败的指定行为，创建指定类型的委托，该委托表示指定类的指定静态方法。</summary>
        <returns>指定类型的委托，该委托表示指定类的指定静态方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法仅为静态方法创建委托。 实例方法是与类的实例关联的方法;静态方法是与类自身相关联的方法。  
  
> [!NOTE]
>  从开始 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] ，此方法可用于访问非公共方法，前提是已向调用方授予了 <xref:System.Security.Permissions.ReflectionPermission> 标志， <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 并且非公共方法的授予集限制为调用方的授予集或其子集。  (参阅 [反射的安全注意事项](/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection))   
>   
>  若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="target" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="method" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> 不继承 <see cref="T:System.MulticastDelegate" />。  
  
- 或 - 
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 请参阅[反射中的运行时类型](/previous-versions/dotnet/netframework-4.0/ms172329(v=vs.100))。  
  
- 或 - 
 <paramref name="target" /> 不是 <see langword="RuntimeType" />。  
  
- 或 - 
 <paramref name="target" /> 为开放式泛型类型。 也就是说，其 <see cref="P:System.Type.ContainsGenericParameters" /> 属性为 <see langword="true" />。  
  
- 或 - 
 <paramref name="method" /> 不是 <see langword="static" /> 方法（在 Visual Basic 中为 <see langword="Shared" /> 方法）。  
  
- 或 - 
 无法绑定 <paramref name="method" />，例如因为找不到它，并且 <paramref name="throwOnBindFailure" /> 为 <see langword="true" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有访问 <paramref name="method" /> 所必需的权限。</exception>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="C#" Value="public object DynamicInvoke (params object[] args);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object DynamicInvoke(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvoke(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (ParamArray args As Object()) As Object" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(... cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.DynamicInvoke : obj[] -&gt; obj" Usage="delegate.DynamicInvoke args" />
      <MemberSignature Language="C#" Value="public object DynamicInvoke (object[] args);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (args As Object()) As Object" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">作为自变量传递给当前委托所表示的方法的对象数组。  
  
- 或 - 
 如果当前委托所表示的方法不需要参数，则为 <see langword="null" />。</param>
        <summary>动态调用（后期绑定）由当前委托所表示的方法。</summary>
        <returns>委托所表示的方法返回的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法调用 <xref:System.Delegate.DynamicInvokeImpl%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">调用方不能访问由委托表示的方法（例如，在方法为私有方法的情况下）。  
  
- 或 - 
<paramref name="args" /> 中列出的参数的数目、顺序或类型无效。</exception>
        <exception cref="T:System.ArgumentException">对对象或类调用委托所表示的方法，但该对象或类不支持这种方法。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">委托所表示的方法是实例方法，目标对象为 <see langword="null" />。  
  
- 或 - 
封装的方法之一引发异常。</exception>
        <altmember cref="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member DynamicInvokeImpl : obj[] -&gt; obj&#xA;override this.DynamicInvokeImpl : obj[] -&gt; obj" Usage="delegate.DynamicInvokeImpl args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="args">作为自变量传递给当前委托所表示的方法的对象数组。  
  
- 或 - 
 如果当前委托所表示的方法不需要参数，则为 <see langword="null" />。</param>
        <summary>动态调用（后期绑定）由当前委托所表示的方法。</summary>
        <returns>委托所表示的方法返回的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法实现 <xref:System.Delegate.DynamicInvoke%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">调用方不能访问由委托表示的方法（例如，在方法为私有方法的情况下）。  
  
- 或 - 
<paramref name="args" /> 中列出的参数的数目、顺序或类型无效。</exception>
        <exception cref="T:System.ArgumentException">对对象或类调用委托所表示的方法，但该对象或类不支持这种方法。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">委托所表示的方法是实例方法，目标对象为 <see langword="null" />。  
  
- 或 - 
封装的方法之一引发异常。</exception>
        <altmember cref="M:System.Delegate.DynamicInvoke(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="delegate.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要与当前委托进行比较的对象。</param>
        <summary>确定指定的对象和当前委托的类型是否相同，是否共享相同的目标、方法和调用列表。</summary>
        <returns>如果 <paramref name="obj" /> 和当前委托具有相同的目标、方法和调用列表，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果两个委托的类型不同，则不会将它们视为相等。  
  
> [!IMPORTANT]
>  在 .NET Framework 版本1.0 和1.1 中，如果两个委托的目标、方法和调用列表相等，即使这些委托属于不同类型，也被视为相等。  
  
 比较方法和目标的相等性，如下所示：  
  
-   如果所比较的两个方法都是静态的，并且在同一类上是相同的方法，则这些方法被视为相等，并且目标也被视为相等。  
  
-   如果所比较的两个方法是实例方法，并且在同一对象上是相同的方法，则这些方法被视为相等，并且目标也被视为相等。  
  
-   否则，这些方法不会被视为相等，也不会将目标视为相等。  
  
 仅当两个调用列表具有相同的顺序，并且两个列表中的相应元素表示相同的方法和目标时，两个调用列表才被视为相同。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">调用方不能访问由委托表示的方法（例如，在方法为私有方法的情况下）。</exception>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="delegate.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回委托的哈希代码。</summary>
        <returns>委托的哈希代码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由于两个原因，此方法的返回值不能持久保存。 首先，可能会改变类的哈希函数，以生成更好的分布，从而使旧哈希函数中的所有值都无用。 其次，此类的默认实现不保证不同的实例将返回相同的值。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberSignature Language="F#" Value="abstract member GetInvocationList : unit -&gt; Delegate[]&#xA;override this.GetInvocationList : unit -&gt; Delegate[]" Usage="delegate.GetInvocationList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回委托的调用列表。</summary>
        <returns>委托构成的数组，表示当前委托的调用列表。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 数组中的每个委托只表示一个方法。  
  
 数组中的委托顺序与当前委托调用这些委托所表示的方法的顺序相同。  
  
   
  
## Examples  
 下面的示例将三个方法分配给一个委托。 然后，它会调用  <xref:System.Delegate.GetInvocationList%2A> 方法来获取分配给该委托的方法的总计数，并按相反顺序执行这些委托，并执行其名称不包括子字符串 "File" 的方法。  
  
 [!code-csharp[System.Delegate.GetInvocationList#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/cs/GetInvocationList1.cs#1)]
 [!code-vb[System.Delegate.GetInvocationList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/vb/GetInvocationList1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : unit -&gt; System.Reflection.MethodInfo" Usage="delegate.GetMethodImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取当前委托所表示的静态方法。</summary>
        <returns>描述当前委托表示的静态方法的 <see cref="T:System.Reflection.MethodInfo" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 仅当当前委托表示静态方法时，此方法才适用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">调用方不能访问由委托表示的方法（例如，在方法为私有方法的情况下）。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Delegate.Method" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="delegate.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="info">不支持。</param>
        <param name="context">不支持。</param>
        <summary>不支持。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">不支持此方法。</exception>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo Method" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Method" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Method As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodInfo ^ Method { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Method : System.Reflection.MethodInfo" Usage="System.Delegate.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取委托所表示的方法。</summary>
        <value>描述委托所表示的方法的 <see cref="T:System.Reflection.MethodInfo" />。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">调用方不能访问由委托表示的方法（例如，在方法为私有方法的情况下）。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Delegate.GetMethodImpl" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Delegate * Delegate -&gt; bool" Usage="d1 = d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">要比较的第一个委托。</param>
        <param name="d2">要比较的第二个委托。</param>
        <summary>确定指定的委托是否相等。</summary>
        <returns>如果 <see langword="true" /> 等于 <paramref name="d1" />，则为 <paramref name="d2" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 同一类型的两个具有相同的目标、方法和调用列表的委托被视为相等。  
  
 如果两个委托的类型不同，则不会将它们视为相等。  
  
> [!IMPORTANT]
>  在 .NET Framework 版本1.0 和1.1 中，如果两个委托的目标、方法和调用列表相等，即使这些委托属于不同类型，也被视为相等。  
  
 比较方法和目标的相等性，如下所示：  
  
-   如果所比较的两个方法都是静态的，并且在同一类上是相同的方法，则这些方法被视为相等，并且目标也被视为相等。  
  
-   如果所比较的两个方法是实例方法，并且在同一对象上是相同的方法，则这些方法被视为相等，并且目标也被视为相等。  
  
-   否则，这些方法不会被视为相等，也不会将目标视为相等。  
  
 如果两个调用列表具有相同的顺序，并且两个列表中的相应元素表示相同的方法和目标，则两个调用列表将视为相同。  
  
 此运算符的等效方法是 <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Delegate * Delegate -&gt; bool" Usage="System.Delegate.op_Inequality (d1, d2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">要比较的第一个委托。</param>
        <param name="d2">要比较的第二个委托。</param>
        <summary>确定指定的委托是否不相等。</summary>
        <returns>如果 <see langword="true" /> 不等于 <paramref name="d1" />，则为 <paramref name="d2" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果两个委托的类型不同，或者具有不同的方法、不同的目标或不同的调用列表，则这两个委托被视为不相等。  
  
 如果两个委托的类型不同，则不会将它们视为相等。  
  
> [!IMPORTANT]
>  在 .NET Framework 版本1.0 和1.1 中，如果两个委托的目标、方法和调用列表相等（即使这些委托属于不同类型），则将它们视为相等。  
  
 比较方法和目标的相等性，如下所示：  
  
-   如果所比较的两个方法都是静态的，并且在同一类上是相同的方法，则这些方法被视为相等，并且目标也被视为相等。  
  
-   如果所比较的两个方法是实例方法，并且在同一对象上是相同的方法，则这些方法被视为相等，并且目标也被视为相等。  
  
-   否则，这些方法不会被视为相等，也不会将目标视为相等。  
  
 如果两个调用列表具有不同的大小（如果它们的排序方式不同），或者一个列表中至少有一个元素表示一个方法或目标，而该方法或目标不同于另一个列表中其对应元素所表示的方法或目标，则两个调用列表不相等。  
  
 此运算符的等效方法是 <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Remove(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remove (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Remove(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member Remove : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Remove (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">委托，将从中移除 <paramref name="value" /> 的调用列表。</param>
        <param name="value">委托，它提供将从其中移除 <paramref name="source" /> 的调用列表的调用列表。</param>
        <summary>从一个委托的调用列表中移除另一个委托的最后一个调用列表。</summary>
        <returns>一个新委托，其调用列表的构成方法为：获取 <paramref name="source" /> 的调用列表，如果在 <paramref name="value" /> 的调用列表中找到了 <paramref name="value" /> 的调用列表，则从中移除 <paramref name="source" /> 的最后一个调用列表。 如果 <paramref name="source" /> 为 <see langword="null" />，或在 <paramref name="value" /> 的调用列表中没有找到 <paramref name="value" /> 的调用列表，则返回 <paramref name="source" />。 如果 <paramref name="value" /> 的调用列表等于 <paramref name="source" /> 的调用列表，或 <paramref name="source" /> 为空引用，则返回空引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果的调用列表 `value` 与的调用列表中的一组连续元素相匹配，则在的 `source` 调用列表 `value` 中将出现的调用列表 `source` 。 如果的调用列表 `value` 在的调用列表中出现多次 `source` ，则将删除最后一个匹配项。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">调用方不能访问由委托表示的方法（例如，在方法为私有方法的情况下）。</exception>
        <exception cref="T:System.ArgumentException">委托类型不匹配。</exception>
        <altmember cref="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveAll (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ RemoveAll(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveAll : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.RemoveAll (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">委托，将从中移除 <paramref name="value" /> 的调用列表。</param>
        <param name="value">委托，它提供将从其中移除 <paramref name="source" /> 的调用列表的调用列表。</param>
        <summary>从一个委托的调用列表中移除另一个委托的所有调用列表。</summary>
        <returns>一个新委托，其调用列表的构成方法为：获取 <paramref name="source" /> 的调用列表，如果在 <paramref name="value" /> 的调用列表中找到了 <paramref name="value" /> 的调用列表，则从中移除 <paramref name="source" /> 的所有调用列表。 如果 <paramref name="source" /> 为 <see langword="null" />，或在 <paramref name="value" /> 的调用列表中没有找到 <paramref name="value" /> 的调用列表，则返回 <paramref name="source" />。 如果 <paramref name="value" /> 的调用列表等于 <paramref name="source" /> 的调用列表，如果 <paramref name="source" /> 只包含等于 <paramref name="value" /> 的调用列表的一系列调用列表，或者如果 <paramref name="source" /> 为空引用，则返回空引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果的调用列表 `value` 与的调用列表中的一组连续元素相匹配，则在的 `source` 调用列表 `value` 中将出现的调用列表 `source` 。 如果的调用列表 `value` 在的调用列表中出现多次 `source` ，则将删除所有匹配项。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">调用方不能访问由委托表示的方法（例如，在方法为私有方法的情况下）。</exception>
        <exception cref="T:System.ArgumentException">委托类型不匹配。</exception>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate? RemoveImpl (Delegate d);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate RemoveImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function RemoveImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ RemoveImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member RemoveImpl : Delegate -&gt; Delegate&#xA;override this.RemoveImpl : Delegate -&gt; Delegate" Usage="delegate.RemoveImpl d" />
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="d">委托，它提供要从当前委托的调用列表中移除的调用列表。</param>
        <summary>从一个委托的调用列表中移除另一个委托的调用列表。</summary>
        <returns>一个新委托，其调用列表的构成方法为：获取当前委托的调用列表，如果在当前委托的调用列表中找到了 <paramref name="value" /> 的调用列表，则从中移除 <paramref name="value" /> 的调用列表。 如果 <paramref name="value" /> 为 <see langword="null" />，或者在当前委托的调用列表中没有找到 <paramref name="value" /> 的调用列表，则返回当前委托。 如果 <paramref name="value" /> 的调用列表等于当前委托的调用列表，则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果的调用列表 `value` 与当前委托的调用列表中的一组连续元素相匹配，则在 `value` 当前委托的调用列表中，就会出现调用列表。 如果的调用列表 `value` 在当前委托的调用列表中出现多次，则将删除最后一个匹配项。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">调用方不能访问由委托表示的方法（例如，在方法为私有方法的情况下）。</exception>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public object Target { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Target" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Target { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target : obj" Usage="System.Delegate.Target" />
      <MemberSignature Language="C#" Value="public object? Target { get; }" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取类实例，当前委托将对其调用实例方法。</summary>
        <value>如果委托表示实例方法，则为当前委托对其调用实例方法的对象；如果委托表示静态方法，则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 实例方法是与类的实例关联的方法;静态方法是与类自身相关联的方法。  
  
 如果委托调用一个或多个实例方法，此属性将返回调用列表中最后一个实例方法的目标。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>