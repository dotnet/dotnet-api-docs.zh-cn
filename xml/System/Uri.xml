<Type Name="Uri" FullName="System.Uri">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e0ad59fbb25830e4813f596075f97c89e09d86a9" /><Meta Name="ms.sourcegitcommit" Value="943c8cdbe5b47c6c296a6f4b73038bbd43da0dd2" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="02/12/2021" /><Meta Name="ms.locfileid" Value="100307595" /></Metadata><TypeSignature Language="C#" Value="public class Uri" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Uri extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="DocId" Value="T:System.Uri" />
  <TypeSignature Language="VB.NET" Value="Public Class Uri" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C++ CLI" Value="public ref class Uri" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="F#" Value="type Uri = class" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C#" Value="public class Uri : System.Runtime.Serialization.ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Uri extends System.Object implements class System.Runtime.Serialization.ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="VB.NET" Value="Public Class Uri&#xA;Implements ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class Uri : System::Runtime::Serialization::ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Uri = class&#xA;    interface ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C#" Value="public class Uri : MarshalByRefObject, System.Runtime.Serialization.ISerializable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Uri extends System.MarshalByRefObject implements class System.Runtime.Serialization.ISerializable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="VB.NET" Value="Public Class Uri&#xA;Inherits MarshalByRefObject&#xA;Implements ISerializable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class Uri : MarshalByRefObject, System::Runtime::Serialization::ISerializable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="F#" Value="type Uri = class&#xA;    inherit MarshalByRefObject&#xA;    interface ISerializable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Uri extends System.Object implements class System.Runtime.Serialization.ISerializable" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="System" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.ComponentModel.TypeConverter(typeof(System.UriTypeConverter))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter(typeof(System.UriTypeConverter))&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供统一资源标识符 (URI) 的对象表示形式和对 URI 各部分的轻松访问。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URI 是可用于 intranet 或 internet 上的应用程序的资源的精简表示形式。 <xref:System.Uri>类定义了用于处理 uri 的属性和方法，包括分析、比较和组合。 <xref:System.Uri>类属性是只读的; 若要创建可修改的对象，请使用 <xref:System.UriBuilder> 类。  
  
 相对 Uri (例如，"/new/index.htm" ) 必须相对于基 URI 展开，以便它们是绝对的。 <xref:System.Uri.MakeRelative%2A>提供方法以在必要时将绝对 uri 转换为相对 uri。  
  
 <xref:System.Uri>如果字符串是格式正确的 uri （包括方案标识符），则构造函数不会转义 uri 字符串。  
  
 <xref:System.Uri>属性以转义编码返回规范化数据表示形式，其 Unicode 值大于127的所有字符都将替换为其十六进制等效项。 为了以规范形式放置 URI， <xref:System.Uri> 构造函数执行以下步骤：  
  
-   将 URI 方案转换为小写。  
  
-   将主机名转换为小写。  
  
-   如果主机名是 IPv6 地址，则使用规范的 IPv6 地址。 ScopeId 和其他可选 IPv6 数据已删除。  
  
-   删除默认端口号和空端口号。
  
-   转换不包含 file://方案的隐式文件路径 (例如，将 "C:\my\file" ) 为带有 file://方案的显式文件路径。
  
-   转义字符 (也称为百分号编码的八进制数) ，这些字节不具有保留用途 (也称为非转义) 。 这些非保留字符包括大写和小写字母 (% 41-% 5A 和 %61-% 7A) ，十进制数字 (% 30-%39) ，连字符 (% 2D) ，期间 (% 2E) ，下划线 (% 5F) ，和波形符 (% 7E) 。

-   通过压缩序列（如/./、/），Canonicalizes 层次结构 Uri 的路径。/、和// (是否) 转义序列。 请注意，在某些方案中，这些序列不会压缩。
  
-   对于分层 Uri，如果主机未以正斜杠 (/) 终止，则会添加一个。  
  
-   默认情况下，URI 中的任何保留字符都根据 RFC 2396 进行转义。 如果启用了国际资源标识符或国际域名解析，则会更改该行为，在这种情况下，URI 中的保留字符将根据 RFC 3986 和 RFC 3987 进行转义。

 作为某些方案的构造函数中的规范化的一部分，用点段和空段 (`/./` 、 `/../` 和 `//`) 进行压缩 (换言之，它们将被删除) 。 <xref:System.Uri>压缩段包含 http、https、tcp、net.pipe 和 net.tcp 的方案。 对于某些其他方案，这些序列不会进行压缩。 下面的代码段演示如何进行压缩。 如有必要，转义序列会进行非转义，然后压缩。
  
```csharp
var uri = new Uri("http://myUrl/../.."); // http scheme, unescaped
OR
var uri = new Uri("http://myUrl/%2E%2E/%2E%2E"); // http scheme, escaped
OR
var uri = new Uri("ftp://myUrl/../.."); // ftp scheme, unescaped
OR
var uri = new Uri("ftp://myUrl/%2E%2E/%2E%2E"); // ftp scheme, escaped

Console.WriteLine($"AbsoluteUri: {uri.AbsoluteUri}");
Console.WriteLine($"PathAndQuery: {uri.PathAndQuery}");
```  

执行此代码时，它将返回类似于以下文本的输出。

```  
AbsoluteUri: http://myurl/
PathAndQuery: /
```  
  
 可以 <xref:System.Uri> 通过使用方法，将类的内容从转义编码的 uri 引用转换为可读的 uri 引用 <xref:System.Uri.ToString%2A> 。 请注意，某些保留字符可能仍会在方法的输出中进行转义 <xref:System.Uri.ToString%2A> 。 这是为了支持从返回的值明确地重构 URI <xref:System.Uri.ToString%2A> 。  
  
 某些 Uri 包含片段标识符或查询，或同时包含两者。 片段标识符是跟在数字符号后 ( # ) 的任何文本，不包括数字符号;片段文本存储在 <xref:System.Uri.Fragment%2A> 属性中。 查询信息是在 URI 中跟在问号 (？ ) 后面的任何文本。查询文本存储在 <xref:System.Uri.Query%2A> 属性中。  
  
 在 .NET Framework 版本1.1 中，如果指定给构造函数的字符串包含未知方案和 "c： \\ "，则 Uri 类将在冒号后插入 "//"。 例如，URI `xyz:c:\abc` 转换为 `xyz://c:/abc` 。 在 .NET Framework 版本2.0 中，此行为已被移除，示例字符串已转换为 `xyz:c:/abc` 。  
  
> [!NOTE]
> URI 类支持在 IPv4 协议的四位表示法中使用 IP 地址，对 IPv6 协议支持使用冒号十六进制。 请记住用方括号将 IPv6 地址括起来，如 http：//[：： 1]。  
  
## <a name="international-resource-identifier-support"></a>国际资源标识符支持  
 Web 地址通常使用由一组非常有限的字符组成的统一资源标识符来表示：  
  
-   英文字母表中的大小写 ASCII 字母。  
  
-   从 0 到 9 的数字。  
  
-   少量的其他 ASCII 符号。  
  
 RFC 2396、RFC 2732、RFC 3986 以及 Internet 工程任务组 (IETF) 发布的 rfc 3987 中记录了 Uri 规范。  
  
 随着 Internet 的发展，越来越需要使用英语以外的语言识别资源。 标识符满足了这种需求，并且使得非 ASCII 字符（Unicode 中的字符/ISO 10646 字符集）被称为国际资源标识符（IRI）。 IETF 发布的 RFC 3987 记录了 IRI 的规格。 使用 IRI 允许 URL 包含 Unicode 字符。  
  
 已 <xref:System.Uri> 在 .NET Framework v 3.5、3.0 SP1 和 2.0 SP1 中扩展了现有类，以便基于 RFC 3987 提供 IRI 支持。 除非专门启用 IRI，否则版本4.5 之前的 .NET Framework 版本的用户将看不到 .NET Framework 2.0 行为中的任何更改。 这确保了 NET Framework 以前版本的应用程序兼容性。  
  
 若要启用对 IRI 的支持，需要进行以下更改：  
  
-   指定是否要将国际化域名 (IDN) 应用于域名的分析以及是否应该应用 IRI 分析规则。 这可以在 *machine.config* 或 *app.config* 文件中完成。 例如，添加以下内容：

    ```xml  
    <configuration>  
      <uri>  
      <idn enabled="All" />  
      <iriParsing enabled="true" />  
      </uri>  
    </configuration>  
    ```  
  
 .NET Framework 4.5 和更高版本的用户始终启用了 IRI。 不能使用 *.config* 文件更改 IRI 分析。  
  
 启用 IDN 可以将域名中所有 Unicode 标签转换成标签的 Punycode 等同项。 Punycode 名称只包含 ASCII 字符，并且始终以 xn-- 前缀开头。 这样是为了支持 Internet 上的 DNS 服务器，因为大部分 DNS 服务器仅支持 ASCII 字符（参见 RFC 3940）。  
  
 启用 IRI 和 IDN 会影响 <xref:System.Uri.DnsSafeHost%2A?displayProperty=nameWithType> 属性的值。 启用 IRI 和 IDN 还可能更改 <xref:System.Uri.Equals%2A>、<xref:System.Uri.OriginalString%2A>、<xref:System.Uri.GetComponents%2A> 和 <xref:System.Uri.IsWellFormedOriginalString%2A> 方法的行为。  
  
根据所使用的 DNS 服务器，IDN 有三个可能的值：  
  
- 已启用 idn = 全部

  此值会将所有 Unicode 域名转换为它们的 Punycode 等效项（IDN 名称）。  
  
- 启用 idn = AllExceptIntranet

  此值将转换本地 Intranet 以外的所有 Unicode 域名，以使用)  (IDN 名称的 Punycode 等效项。 在这种情况下，为了处理本地 Intranet 上的国际名称，用于 Intranet 的 DNS 服务器应该支持 Unicode 名称解析。  
  
- 启用 idn = 无

  此值不会将任何 Unicode 域名转换为使用 Punycode。 这是与 .NET Framework 2.0 行为一致的默认值。  
  
 启用 IRI 分析后 (启用 Iriparsing> = `true` 根据 rfc 3986 和 rfc 3987 中的最新 IRI 规则执行) 规范化和字符检查。 禁用 IRI 分析后，将根据 RFC 2396 和 RFC 2732 (为 IPv6 文本) 执行规范化和字符检查。  在版本4.5 之前的 .NET Framework 版本中，默认值为 `false` 。 在 .NET Framework 版本4.5 及更高版本中，默认值为 `true` ，并且在 *.config* 文件中，不能修改启用了 IRI 分析功能的状态。  
  
 <xref:System.Uri>还可以使用 <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> 、 <xref:System.Configuration.IdnElement?displayProperty=nameWithType> 和 <xref:System.Configuration.UriSection?displayProperty=nameWithType> 配置设置类控制类中的 IRI 和 IDN 处理。 <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> 设置启用或禁用 <xref:System.Uri> 类中的 IRI 处理。 <xref:System.Configuration.IdnElement?displayProperty=nameWithType> 设置启用或禁用 <xref:System.Uri> 类中的 IDN 处理。 <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> 也可间接控制 IDN。 必须启用 IRI 处理才能进行 IDN 处理。 如果禁用 IRI，IDN 处理将被设置为默认值，这时 NET Framework 2.0 行为用于兼容性，并且 IDN 名称不可用。  
  
 <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> <xref:System.Configuration.IdnElement?displayProperty=nameWithType> 当构造第一个类时，和的配置设置将被读取一次 <xref:System.Uri?displayProperty=nameWithType> 。 忽略时间后更改为默认设置。  
  
 <xref:System.GenericUriParser?displayProperty=nameWithType> 类已得到扩展，允许创建支持 IRI 和 IDN 的自定义分析。 通过将枚举中可用值的按位组合传递给 <xref:System.GenericUriParserOptions?displayProperty=nameWithType> 构造函数 <xref:System.GenericUriParser?displayProperty=nameWithType> 来指定 <xref:System.GenericUriParser?displayProperty=nameWithType> 对象的行为。 <xref:System.GenericUriParserOptions.IriParsing?displayProperty=nameWithType> 类型表示分析程序支持 RFC 3987 中为国际资源标识符 (IRI) 指定的分析规则。 是否使用 IRI 由前面讨论过的配置值决定。  
  
 <xref:System.GenericUriParserOptions.Idn?displayProperty=nameWithType> 类型表示分析程序支持主机名的国际化域名 (IDN) 分析。 是否使用 IDN 由前面讨论过的配置值决定。  
  
## <a name="implicit-file-path-support"></a>隐式文件路径支持

 <xref:System.Uri> 还可用于表示本地文件系统路径。 这些路径可以在以 file://方案开头的 Uri 中 *显式* 表示，而在没有 file://方案的 uri 中 *隐式* 表示。 作为具体示例，下面两个 Uri 都是有效的，并且表示相同的文件路径：
 
```csharp
Uri uri1 = new Uri("C:/test/path/file.txt") // Implicit file path.
Uri uri2 = new Uri("file:///C:/test/path/file.txt") // Explicit file path.
```
 这些隐式文件路径不符合 URI 规范，应尽可能避免这样的情况。 在基于 Unix 的系统上使用 .NET Core 时，隐式文件路径可能会特别出现问题，因为绝对的隐式文件路径与相对路径没有 *区别* 。 如果存在这种含糊性，则 <xref:System.Uri> 默认为将路径解释为绝对 URI。

## <a name="security-considerations"></a>安全注意事项

出于安全方面的考虑，应用程序在接受 <xref:System.Uri> 来自不受信任源的实例，并 `dontEscape` `true` 在 [构造函数](xref:System.Uri.%23ctor(System.String,System.Boolean))中将设置为时，应小心。 可以通过调用方法来检查 URI 字符串的有效性 <xref:System.Uri.IsWellFormedOriginalString%2A> 。

处理不受信任的用户输入时，请先确认有关新创建的实例的假设， `Uri` 然后再对其属性进行信任。
可以通过以下方式完成此操作：

```csharp
string userInput = ...;

Uri baseUri = new Uri("https://myWebsite/files/");

if (!Uri.TryCreate(baseUri, userInput, out Uri newUri))
{
    // Fail: invalid input.
}

if (!baseUri.IsBaseOf(newUri))
{
    // Fail: the Uri base has been modified - the created Uri is not rooted in the original directory.
}
```

此验证可在其他情况下使用，例如处理 UNC 路径时，只需更改 `baseUri` ：

```csharp
Uri baseUri = new Uri(@"\\host\share\some\directory\name\");
```

## <a name="performance-considerations"></a>性能注意事项  
 如果使用包含 Uri 的 * Web.config * 文件来初始化应用程序，则需要额外的时间来处理 Uri （如果它们的方案标识符是非标准的）。 在这种情况下，在需要 Uri 时（而不是在启动时）初始化应用程序受影响的部分。
  
## Examples

下面的示例创建类的一个实例 <xref:System.Uri> ，并使用它来创建 <xref:System.Net.WebRequest> 实例。  
  
 [!code-cpp[Classic Uri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri Example/VB/source.vb#1)]

下面的代码片段显示了类中各种属性的示例值。

[!code-csharp[Classic Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri Example/CS/source.cs#2)]

 ]]></format>
    </remarks>
    <threadsafe>的所有成员 <see cref="T:System.Uri" /> 都是线程安全的，可从多个线程同时使用。</threadsafe>
    <altmember cref="T:System.Configuration.IdnElement" />
    <altmember cref="T:System.Configuration.IriParsingElement" />
    <altmember cref="T:System.Configuration.UriSection" />
    <altmember cref="P:System.Uri.DnsSafeHost" />
    <altmember cref="M:System.Uri.MakeRelative(System.Uri)" />
    <altmember cref="M:System.Uri.IsWellFormedOriginalString" />
    <altmember cref="T:System.UriBuilder" />
    <related type="Article" href="/dotnet/framework/network-programming/changes-to-the-system-uri-namespace-in-version-2-0">对 2.0 版中的 System.Uri 命名空间的更改</related>
    <related type="Article" href="/dotnet/framework/network-programming/international-resource-identifier-support-in-system-uri">UriSystem 中的国际资源标识符支持</related>
    <related type="Article" href="/dotnet/framework/network-programming/">.NET Framework 中的网络编程</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Uri" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (uriString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString);" />
      <MemberSignature Language="F#" Value="new Uri : string -&gt; Uri" Usage="new System.Uri uriString" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uriString">标识将由 <see cref="T:System.Uri" /> 实例表示的资源的字符串。 请注意，必须用括号将字符串形式的 IPv6 地址括起来。 例如，“http://[2607:f8b0:400d:c06::69]”。</param>
        <summary>用指定的 URI 初始化 <see cref="T:System.Uri" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数 <xref:System.Uri> 从 URI 字符串创建实例。 它分析 URI，使其采用规范格式，并进行任何所需的转义编码。  
  
 此构造函数不确保 <xref:System.Uri> 引用辅助资源。  
  
 此构造函数假设 `string` 参数引用了一个绝对 URI，并且等效于在设置为的情况下调用 <xref:System.Uri.%23ctor%2A> 构造函数 <xref:System.UriKind> <xref:System.UriKind.Absolute> 。 如果 `string` 传递给构造函数的参数是相对 URI，则此构造函数将引发 <xref:System.UriFormatException> 。
  
## Examples  
 下面的示例创建一个 <xref:System.Uri> 具有 URI 的实例 `http://www.contoso.com/` 。  
  
 [!code-cpp[Classic Uri.Uri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="uriString" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.UriFormatException">注意：在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.FormatException" />。

<paramref name="uriString" /> 为空。  
  
- 或 - 
<paramref name="uriString" /> 中指定的方案格式不正确。 请参阅 <see cref="M:System.Uri.CheckSchemeName(System.String)" />。  
  
- 或 - 
 <paramref name="uriString" /> 包含过多斜杠。  
  
- 或 - 
<paramref name="uriString" /> 中指定的密码无效。  
  
- 或 - 
<paramref name="uriString" /> 中指定的主机名无效。  
  
- 或 - 
<paramref name="uriString" /> 中指定的文件名无效。  
  
- 或 - 
<paramref name="uriString" /> 中指定的用户名无效。  
  
- 或 - 
<paramref name="uriString" /> 中指定的主机名或证书颁发机构名称不能以反斜杠结尾。  
  
- 或 - 
<paramref name="uriString" /> 中指定的端口号无效或无法分析。  
  
- 或 - 
<paramref name="uriString" /> 的长度超过 65519 个字符。  
  
- 或 - 
<paramref name="uriString" /> 中指定的方案的长度超过 1023 个字符。  
  
- 或 - 
<paramref name="uriString" /> 中存在无效的字符序列。  
  
- 或 - 
<paramref name="uriString" /> 中指定的 MS-DOS 路径必须以 c:\\\\ 开头。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Uri (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (serializationInfo As SerializationInfo, streamingContext As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Uri(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="new Uri : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; Uri" Usage="new System.Uri (serializationInfo, streamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="serializationInfo"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> 类的实例，包含序列化新的 <see cref="T:System.Uri" /> 实例所需的信息。</param>
        <param name="streamingContext"><see cref="T:System.Runtime.Serialization.StreamingContext" /> 类的实例，包含与新的 <see cref="T:System.Uri" /> 实例关联的序列化流的源。</param>
        <summary>从 <see cref="T:System.Uri" /> 和 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 类的指定实例初始化 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数实现 <xref:System.Runtime.Serialization.ISerializable> 类的接口 <xref:System.Uri> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="serializationInfo" /> 参数包含 <see langword="null" /> URI。</exception>
        <exception cref="T:System.UriFormatException"><paramref name="serializationInfo" /> 参数包含一个为空的 URI。  
  
- 或 - 
指定的方案形式不正确。 请参阅 <see cref="M:System.Uri.CheckSchemeName(System.String)" />。  
  
- 或 - 
该 URI 包含过多斜杠。  
  
- 或 - 
URI 中指定的密码无效。  
  
- 或 - 
URI 中指定的主机名无效。  
  
- 或 - 
URI 中指定的文件名无效。  
  
- 或 - 
URI 中指定的用户名无效。  
  
- 或 - 
URI 中指定的主机名或证书颁发机构名称不能以反斜杠结尾。  
  
- 或 - 
URI 中指定的端口号无效或无法分析。  
  
- 或 - 
URI 的长度超过 65519 个字符。  
  
- 或 - 
URI 中指定的方案的长度超过 1023 个字符。  
  
- 或 - 
URI 中存在无效的字符序列。  
  
- 或 - 
URI 中指定的 MS-DOS 路径必须以 c:\\\\ 开头。</exception>
        <related type="Article" href="/dotnet/standard/serialization/xml-and-soap-serialization">XML 和 SOAP 序列化</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString, bool dontEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString, bool dontEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (uriString As String, dontEscape As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString, bool dontEscape);" />
      <MemberSignature Language="F#" Value="new Uri : string * bool -&gt; Uri" Usage="new System.Uri (uriString, dontEscape)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.Obsolete("The constructor has been deprecated. Please use new Uri(string). The dontEscape parameter is deprecated and is always false. https://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("The constructor has been deprecated. Please use new Uri(string). The dontEscape parameter is deprecated and is always false. https://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Obsolete("The constructor has been deprecated. Please use new Uri(string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("The constructor has been deprecated. Please use new Uri(string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="dontEscape" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="uriString">标识将由 <see cref="T:System.Uri" /> 实例表示的资源的字符串。 请注意，必须用括号将字符串形式的 IPv6 地址括起来。 例如，“http://[2607:f8b0:400d:c06::69]”。</param>
        <param name="dontEscape">如果 <paramref name="uriString" /> 已完全转义，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>用指定的 URI 初始化 <see cref="T:System.Uri" /> 类的新实例，并对字符转义进行显式控制。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数 <xref:System.Uri> 从 URI 字符串创建实例。 它分析 URI 并将其采用规范格式。  
  
 `dontEscape`参数控制是否将保留字符转换为转义序列。 `true`仅当你确定 URI 中的所有保留字符都已转义时，才应将此参数设置为。 对于未完全转义的 URI，将值设置为会 `true` 导致意外的行为。 强烈建议您始终将此参数设置为 `false` 。  
  
 如果 `dontEscape` 设置为 `false` ，则构造函数将通过检查% (% ) 的所有匹配项后跟有效的转义序列来转义任何保留字符。 如果百分号后面的字符序列无效，则百分比将替换为 %25。  
  
 此构造函数不确保 <xref:System.Uri> 引用辅助资源。
  
## Examples  
 下面的示例创建 <xref:System.Uri> URI 的实例 `http://www.contoso.com/Hello%20World.htm` 。 由于包含的 URI 已完全转义并且采用规范格式，因此 `dontEscape` 可以将参数设置为 `true` 。  
  
 [!code-cpp[Classic Uri.Uri1 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri1 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri1 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="uriString" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.UriFormatException"><paramref name="uriString" /> 为空或只包含空格。  
  
- 或 - 
在 <paramref name="uriString" /> 中指定的方案无效。  
  
- 或 - 
 <paramref name="uriString" /> 包含过多斜杠。  
  
- 或 - 
<paramref name="uriString" /> 中指定的密码无效。  
  
- 或 - 
<paramref name="uriString" /> 中指定的主机名无效。  
  
- 或 - 
<paramref name="uriString" /> 中指定的文件名无效。  
  
- 或 - 
<paramref name="uriString" /> 中指定的用户名无效。  
  
- 或 - 
<paramref name="uriString" /> 中指定的主机名或证书颁发机构名称不能以反斜杠结尾。  
  
- 或 - 
<paramref name="uriString" /> 中指定的端口号无效或无法分析。  
  
- 或 - 
<paramref name="uriString" /> 的长度超过 65519 个字符。  
  
- 或 - 
<paramref name="uriString" /> 中指定的方案的长度超过 1023 个字符。  
  
- 或 - 
<paramref name="uriString" /> 中存在无效的字符序列。  
  
- 或 - 
<paramref name="uriString" /> 中指定的 MS-DOS 路径必须以 c:\\\\ 开头。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString, UriKind uriKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString, valuetype System.UriKind uriKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String,System.UriKind)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (uriString As String, uriKind As UriKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString, UriKind uriKind);" />
      <MemberSignature Language="F#" Value="new Uri : string * UriKind -&gt; Uri" Usage="new System.Uri (uriString, uriKind)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="uriKind" Type="System.UriKind" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="uriString">标识将由 <see cref="T:System.Uri" /> 实例表示的资源的字符串。 请注意，必须用括号将字符串形式的 IPv6 地址括起来。 例如，“http://[2607:f8b0:400d:c06::69]”。</param>
        <param name="uriKind">指定 URI 字符串是相对 URI、绝对 URI 还是不确定。</param>
        <summary>用指定的 URI 初始化 <see cref="T:System.Uri" /> 类的新实例。 此构造函数允许指定 URI 字符串是相对 URI、绝对 URI 还是不确定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 相对和绝对 Uri 对其格式具有不同的限制。 例如，相对 URI 不需要方案或颁发机构。 在中指定的值 `uriKind` 必须与传入的 URI 类型匹配 `uriString` 。 但是，如果 <xref:System.UriKind.RelativeOrAbsolute> 指定了，则 URI 字符串可以是相对的，也可以是绝对的。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="uriKind" /> 无效。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="uriString" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.UriFormatException">注意：在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.FormatException" />。

<paramref name="uriString" /> 包含相对 URI，而 <paramref name="uriKind" /> 为 <see cref="F:System.UriKind.Absolute" />。  
  
or 
 <paramref name="uriString" /> 包含绝对 URI，而 <paramref name="uriKind" /> 为 <see cref="F:System.UriKind.Relative" />。  
  
or 
 <paramref name="uriString" /> 为空。  
  
- 或 - 
<paramref name="uriString" /> 中指定的方案格式不正确。 请参阅 <see cref="M:System.Uri.CheckSchemeName(System.String)" />。  
  
- 或 - 
 <paramref name="uriString" /> 包含过多斜杠。  
  
- 或 - 
<paramref name="uriString" /> 中指定的密码无效。  
  
- 或 - 
<paramref name="uriString" /> 中指定的主机名无效。  
  
- 或 - 
<paramref name="uriString" /> 中指定的文件名无效。  
  
- 或 - 
<paramref name="uriString" /> 中指定的用户名无效。  
  
- 或 - 
<paramref name="uriString" /> 中指定的主机名或证书颁发机构名称不能以反斜杠结尾。  
  
- 或 - 
<paramref name="uriString" /> 中指定的端口号无效或无法分析。  
  
- 或 - 
<paramref name="uriString" /> 的长度超过 65519 个字符。  
  
- 或 - 
<paramref name="uriString" /> 中指定的方案的长度超过 1023 个字符。  
  
- 或 - 
<paramref name="uriString" /> 中存在无效的字符序列。  
  
- 或 - 
<paramref name="uriString" /> 中指定的 MS-DOS 路径必须以 c:\\\\ 开头。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string relativeUri);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, string relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, System::String ^ relativeUri);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * string -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri)" />
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string? relativeUri);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="baseUri">基 URI。</param>
        <param name="relativeUri">要添加到基 URI 的相对 URI。</param>
        <summary>根据指定的基 URI 和相对 URI 字符串，初始化 <see cref="T:System.Uri" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数 <xref:System.Uri> 通过组合和来创建一个实例 `baseUri` `relativeUri` 。 如果 `relativeUri` 是一个绝对 URI (包含方案、主机名，并且可以选择) 端口号，则 <xref:System.Uri> 仅使用创建实例 `relativeUri` 。  
 
 如果 `baseUri` (如) 有相对部分 `/api` ，则必须以斜杠 (（如) ）终止相对部分， `/api/` 前提 `baseUri` 是要在构造中保留的相关部分 <xref:System.Uri> 。 

 此外，如果 `relativeUri` 以斜杠开头，则它将替换 `baseUri`

 此构造函数不确保 <xref:System.Uri> 引用辅助资源。
  
## Examples  
 下面的示例 <xref:System.Uri> 通过组合相对 uri `http://www.contoso.com` 并 `catalog/shownew.htm` 形成绝对 URI 来创建类的新实例 `http://www.contoso.com/catalog/shownew.htm` 。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri3 Example/CPP/source.cpp" id="Snippet1"::: 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri3 Example/CS/source.cs" interactive="try-dotnet-method" id="Snippet1"::: 
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri3 Example/VB/source.vb" id="Snippet1"::: 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="baseUri" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="baseUri" /> 不是绝对的 <see cref="T:System.Uri" /> 实例。</exception>
        <exception cref="T:System.UriFormatException">注意：在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.FormatException" />。

通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 为空或仅包含空格。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 中指定的方案无效。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 包含过多的斜杠。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 中指定的密码无效。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 中指定的主机名无效。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 中指定的文件名无效。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 中指定的用户名无效。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 中指定的主机名或证书颁发机构名称不能以反斜杠终止。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 中指定的端口号无效或无法分析。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 的长度超过 65519 个字符。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 中指定的方案长度超过 1023 个字符。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 中存在无效字符序列。  
  
- 或 - 
<paramref name="uriString" /> 中指定的 MS-DOS 路径必须以 c:\\\\ 开头。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, Uri relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, class System.Uri relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, Uri ^ relativeUri);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * Uri -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="relativeUri" Type="System.Uri" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="baseUri">作为新 <see cref="T:System.Uri" /> 实例的基的绝对 <see cref="T:System.Uri" />。</param>
        <param name="relativeUri">与 <see cref="T:System.Uri" /> 组合的相对 <paramref name="baseUri" /> 实例。</param>
        <summary>根据指定的基 <see cref="T:System.Uri" /> 实例和相对 <see cref="T:System.Uri" /> 实例的组合，初始化 <see cref="T:System.Uri" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数 <xref:System.Uri> 通过 <xref:System.Uri> 将绝对实例 `baseUri` 与相对实例结合起来来创建一个新的实例 <xref:System.Uri> `relativeUri` 。 如果 `relativeUri` 是一个绝对 <xref:System.Uri> 实例 (包含方案、主机名，并且可以选择) 端口号，则 <xref:System.Uri> 仅使用创建实例 `relativeUri` 。  
 
 如果 `baseUri` (如) 有相对部分 `/api` ，则必须以斜杠 (（如) ）终止相对部分， `/api/` 前提 `baseUri` 是要在构造中保留的相关部分 <xref:System.Uri> 。 

 此外，如果 `relativeUri` 以斜杠开头，则它将替换 `baseUri`
 
 此构造函数不确保 <xref:System.Uri> 引用辅助资源。
  
## Examples  
 此示例将创建一个绝对 <xref:System.Uri> 实例、 `absoluteUri` 和一个相对 <xref:System.Uri> 实例 `relativeUri` 。 然后，将 <xref:System.Uri> `combinedUri` 从这两个实例创建一个新的实例。  
    
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp" id="Snippet2":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb" id="Snippet2":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="baseUri" /> 不是绝对的 <see cref="T:System.Uri" /> 实例。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="baseUri" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="baseUri" /> 不是绝对的 <see cref="T:System.Uri" /> 实例。</exception>
        <exception cref="T:System.UriFormatException">注意：在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.FormatException" />。

通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 为空或仅包含空格。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 中指定的方案无效。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 包含过多的斜杠。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 中指定的密码无效。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 中指定的主机名无效。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 中指定的文件名无效。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 中指定的用户名无效。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 中指定的主机名或证书颁发机构名称不能以反斜杠终止。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 中指定的端口号无效或无法分析。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 的长度超过 65519 个字符。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 中指定的方案长度超过 1023 个字符。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 中存在无效字符序列。  
  
- 或 - 
<paramref name="uriString" /> 中指定的 MS-DOS 路径必须以 c:\\\\ 开头。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string? relativeUri, bool dontEscape);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, string relativeUri, bool dontEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As String, dontEscape As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, System::String ^ relativeUri, bool dontEscape);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * string * bool -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri, dontEscape)" />
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string relativeUri, bool dontEscape);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.Obsolete("The constructor has been deprecated. Please new Uri(Uri, string). The dontEscape parameter is deprecated and is always false. https://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("The constructor has been deprecated. Please new Uri(Uri, string). The dontEscape parameter is deprecated and is always false. https://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Obsolete("The constructor has been deprecated. Please new Uri(Uri, string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("The constructor has been deprecated. Please new Uri(Uri, string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="relativeUri" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="dontEscape" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="baseUri">基 URI。</param>
        <param name="relativeUri">要添加到基 URI 的相对 URI。</param>
        <param name="dontEscape">如果 <paramref name="uriString" /> 已完全转义，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>根据指定的基 URI 和相对 URI，初始化 <see cref="T:System.Uri" /> 类的新实例，并对字符转义进行显式控制。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数 <xref:System.Uri> 通过组合和来创建一个实例 `baseUri` `relativeUri` 。 如果传递的 URI `relativeUri` 是一个绝对 URI (包含方案、主机名以及（可选）端口号) ，则 <xref:System.Uri> 仅使用创建实例 `relativeUri` 。  
  
 `dontEscape`参数控制是否将保留字符转换为转义序列。 `true`仅当你确定 URI 中的所有保留字符都已转义时，才应将此参数设置为。 对于未完全转义的 URI，将值设置为会 `true` 导致意外的行为。 强烈建议您始终将此参数设置为 `false` 。 如果 `dontEscape` 设置为 `false` ，则构造函数将通过检查% (% ) 的所有匹配项后跟有效的转义序列来转义任何保留字符。 如果百分号后面的字符序列无效，则百分比将替换为 %25。  
  
 此构造函数不确保 <xref:System.Uri> 引用辅助资源。
  
## Examples  
 下面的示例 <xref:System.Uri> 通过组合相对 uri `http://www.contoso.com` 并 `Hello%20World.htm` 形成一个绝对 URI 来创建类的新实例。  
  
 [!code-cpp[Classic Uri.Uri4 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri4 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri4 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="baseUri" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="baseUri" /> 不是绝对的 <see cref="T:System.Uri" /> 实例。</exception>
        <exception cref="T:System.UriFormatException">通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 为空或仅包含空格。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 中指定的方案无效。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 包含过多的斜杠。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 中指定的密码无效。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 中指定的主机名无效。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 中指定的文件名无效。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 中指定的用户名无效。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 中指定的主机名或证书颁发机构名称不能以反斜杠终止。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 中指定的端口号无效或无法分析。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 的长度超过 65519 个字符。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 中指定的方案长度超过 1023 个字符。  
  
- 或 - 
通过组合 <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 而构成的 URI 中存在无效字符序列。  
  
- 或 - 
<paramref name="uriString" /> 中指定的 MS-DOS 路径必须以 c:\\\\ 开头。</exception>
        <block subset="none" type="usage"><para>出于安全方面的考虑，应用程序不应从不受信任的源中的 URI 字符串调用此构造函数，并 <paramref name="dontEscape" /> 将设置为 <see langword="true" /> 。 或者，您可以在 <see cref="M:System.Uri.IsWellFormedOriginalString" /> 调用此构造函数之前通过调用方法来检查 URI 字符串的有效性。</para></block>
      </Docs>
    </Member>
    <Member MemberName="AbsolutePath">
      <MemberSignature Language="C#" Value="public string AbsolutePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AbsolutePath" />
      <MemberSignature Language="DocId" Value="P:System.Uri.AbsolutePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AbsolutePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AbsolutePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AbsolutePath : string" Usage="System.Uri.AbsolutePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 URI 的绝对路径。</summary>
        <value>资源的绝对路径。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.AbsolutePath%2A>属性包含服务器用于解析信息请求的路径信息。 通常，这是服务器文件系统上所需信息的路径，但它还可以指示服务器必须运行的应用程序或脚本以提供信息。  
  
 路径信息不包括方案、主机名或 URI 的查询部分。
  
## Examples  
 下面的示例将路径写入 `/catalog/shownew.htm` 控制台。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/CPP/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/CS/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/VB/source.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="AbsoluteUri">
      <MemberSignature Language="C#" Value="public string AbsoluteUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AbsoluteUri" />
      <MemberSignature Language="DocId" Value="P:System.Uri.AbsoluteUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AbsoluteUri As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AbsoluteUri { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AbsoluteUri : string" Usage="System.Uri.AbsoluteUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取绝对 URI。</summary>
        <value>整个 URI。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.AbsoluteUri%2A>属性包括存储在实例中的整个 URI <xref:System.Uri> ，包括所有片段和查询字符串。
  
## Examples  
 下面的示例将实例的完整内容写入 <xref:System.Uri> 控制台。 在显示的示例中， `http://www.contoso.com/catalog/shownew.htm?date=today` 将写入控制台。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/CPP/source.cpp" id="Snippet1"::: 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/CS/source.cs" interactive="try-dotnet-method" id="Snippet1"::: 
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/VB/source.vb" id="Snippet1"::: 
 
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="Authority">
      <MemberSignature Language="C#" Value="public string Authority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Authority" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Authority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authority As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Authority { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Authority : string" Usage="System.Uri.Authority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取服务器的域名系统 (DNS) 主机名或 IP 地址和端口号。</summary>
        <value>此实例所表示的 URI 的颁发机构组件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Authority%2A>属性通常是服务器 DNS 主机名或 IP 地址。 此属性可能包括服务端口号（如果它不同于 URI 的默认端口）。 如果 <xref:System.Uri.Authority%2A> 组件包含保留字符，则会在此属性返回的字符串值中对这些字符进行转义。
  
## Examples  
 下面的示例将服务器的主机名 (`www.contoso.com`) 和端口号写入控制台 (8080) 。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Authority Example/CPP/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Authority Example/CS/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Authority Example/VB/source.vb" id="Snippet1":::
 
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="Canonicalize">
      <MemberSignature Language="C#" Value="protected virtual void Canonicalize ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Canonicalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Canonicalize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Canonicalize ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Canonicalize();" />
      <MemberSignature Language="F#" Value="abstract member Canonicalize : unit -&gt; unit&#xA;override this.Canonicalize : unit -&gt; unit" Usage="uri.Canonicalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.Obsolete("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将内部存储的 URI 转换为规范化格式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在内部存储 URI 的规范版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此方法仅对绝对 URI 有效。</exception>
        <exception cref="T:System.UriFormatException">URI 的格式不正确。</exception>
      </Docs>
    </Member>
    <Member MemberName="CheckHostName">
      <MemberSignature Language="C#" Value="public static UriHostNameType CheckHostName (string name);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UriHostNameType CheckHostName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckHostName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CheckHostName (name As String) As UriHostNameType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UriHostNameType CheckHostName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member CheckHostName : string -&gt; UriHostNameType" Usage="System.Uri.CheckHostName name" />
      <MemberSignature Language="C#" Value="public static UriHostNameType CheckHostName (string? name);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriHostNameType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要验证的主机名。 可以是 IPv4 或 IPv6 地址或 Internet 主机名。</param>
        <summary>确定指定的主机名是否为有效的 DNS 名称。</summary>
        <returns>主机名的类型。 如果无法确定主机名的类型，或者主机名为 <see langword="null" /> 或零长度字符串，则此方法返回 <see cref="F:System.UriHostNameType.Unknown" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.CheckHostName%2A>方法检查提供的主机名是否满足有效 Internet 主机名的要求。 但是，它不会执行主机名查找来验证主机是否存在。
  
## Examples  
 下面的示例将检查主机名是否有效。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/CPP/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/CS/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/VB/source.vb" id="Snippet1"::: 

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSchemeName">
      <MemberSignature Language="C#" Value="public static bool CheckSchemeName (string schemeName);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CheckSchemeName(string schemeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckSchemeName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CheckSchemeName (schemeName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool CheckSchemeName(System::String ^ schemeName);" />
      <MemberSignature Language="F#" Value="static member CheckSchemeName : string -&gt; bool" Usage="System.Uri.CheckSchemeName schemeName" />
      <MemberSignature Language="C#" Value="public static bool CheckSchemeName (string? schemeName);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="schemeName">要验证的方案名。</param>
        <summary>确定指定的方案名是否有效。</summary>
        <returns>如果方案名有效，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，此方法根据 RFC 2396 检查方案名称的有效性。 如果国际资源标识符 (IRIs) 或国际化域名 (IDN) 分析已启用，则此方法根据 RFC 3986 检查方案名称的有效性。 方案名称必须以字母开头，并且必须仅包含字母、数字和字符 "."、"+" 或 "-"。  
  
 有关 IRI 支持的详细信息，请参阅类的 "备注" 部分 <xref:System.Uri> 。
  
## Examples  
 下面的示例创建一个 <xref:System.Uri> 实例，并检查方案名是否有效。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet9":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs" interactive="try-dotnet-method" id="Snippet9":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet9":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSecurity">
      <MemberSignature Language="C#" Value="protected virtual void CheckSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CheckSecurity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckSecurity" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CheckSecurity ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CheckSecurity();" />
      <MemberSignature Language="F#" Value="abstract member CheckSecurity : unit -&gt; unit&#xA;override this.CheckSecurity : unit -&gt; unit" Usage="uri.CheckSecurity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.Obsolete("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>调用此方法不起任何作用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (Uri uri1, Uri uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(class System.Uri uri1, class System.Uri uri2, valuetype System.UriComponents partsToCompare, valuetype System.UriFormat compareFormat, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Compare(System.Uri,System.Uri,System.UriComponents,System.UriFormat,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (uri1 As Uri, uri2 As Uri, partsToCompare As UriComponents, compareFormat As UriFormat, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(Uri ^ uri1, Uri ^ uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : Uri * Uri * UriComponents * UriFormat * StringComparison -&gt; int" Usage="System.Uri.Compare (uri1, uri2, partsToCompare, compareFormat, comparisonType)" />
      <MemberSignature Language="C#" Value="public static int Compare (Uri? uri1, Uri? uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="uri2" Type="System.Uri" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="partsToCompare" Type="System.UriComponents" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="compareFormat" Type="System.UriFormat" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="4" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="uri1">第一个 URI。</param>
        <param name="uri2">第二个 URI。</param>
        <param name="partsToCompare"><see cref="T:System.UriComponents" /> 值的按位组合，它指定要比较的 <paramref name="uri1" /> 和 <paramref name="uri2" /> 的部分。</param>
        <param name="compareFormat">枚举值之一，它指定在比较 URI 部分时使用的字符转义。</param>
        <param name="comparisonType">枚举值之一，用于指定比较的区域性、大小写和排序规则。</param>
        <summary>使用指定的比较规则比较两个 URI 的指定部分。</summary>
        <returns>一个值，指示进行比较的 <see cref="T:System.Uri" /> 部分之间的词法关系。  
  
 <list type="table"><listheader><term> “值” 
 </term><description> 含义 
 </description></listheader><item><term> 小于零 
 </term><description><paramref name="uri1" /> 小于 <paramref name="uri2" />。  
  
 </description></item><item><term> 零 
 </term><description><paramref name="uri1" /> 等于 <paramref name="uri2" />。  
  
 </description></item><item><term> 大于零 
 </term><description><paramref name="uri1" /> 大于 <paramref name="uri2" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `uri1` 和 `uri2` 均为 `null` ，则此方法返回0。 比较 URI 值时，相对 URI 始终小于绝对 URI，非 null URI 总是大于 null URI。 对于 `uri1` 和 `uri2` 均不是并且既 `null` 是相对 uri，也不是这两个绝对 uri 的情况， <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> 方法将执行比较。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</exception>
      </Docs>
    </Member>
    <Member MemberName="DnsSafeHost">
      <MemberSignature Language="C#" Value="public string DnsSafeHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DnsSafeHost" />
      <MemberSignature Language="DocId" Value="P:System.Uri.DnsSafeHost" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DnsSafeHost As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DnsSafeHost { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DnsSafeHost : string" Usage="System.Uri.DnsSafeHost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获得可安全用于 DNS 解析的未转义主机名（如必要）。</summary>
        <value>URI 的主机部分，格式适用于 DNS 解析;如果它已适用于解析，则为原始主机字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于 IPv6 地址，会删除方括号 ( [] ) 并 <xref:System.Net.IPAddress.ScopeId%2A> 设置属性（如果在构造此实例时指定了一个属性）。

如果你使用转义字符串构造此实例 (例如 `"http://[fe80::200:39ff:fe36:1a2d%254]/temp/example.htm"`) ，则 uri.dnssafehost 将返回一个转义字符串。 Unescape 在 `DnsSafeHost` 使用该字符串进行 DNS 解析之前返回的任何转义字符串 (参见示例) 。 如果使用无效的非转义字符串构造此实例 (例如，"http：//[fe80：：200：39ff： fe36： 1a2d %4]/temp/example.htm" ") ，则 Uri.dnssafehost 将返回一个未转义的字符串。
  
 <xref:System.Uri.DnsSafeHost%2A>此属性依赖于配置设置，如本主题后面所述。 Windows 应用商店应用程序无法更改配置设置，这可能会在使用时导致不一致的结果 <xref:System.Uri.DnsSafeHost%2A> 。 <xref:System.Uri.IdnHost%2A>提供的属性是使用的首选替代方法 <xref:System.Uri.DnsSafeHost%2A> ，因为无论 <xref:System.Uri.IdnHost%2A> 当前 *app.config* 的设置如何，都可以保证始终是 DNS 安全的。  
  
 该 <xref:System.Uri.DnsSafeHost%2A> 属性已在 .NET Framework v 3.5、3.0 SP1 和 2.0 SP1 中进行了扩展，可根据 RFC 3987 提供 (IRI) 支持的国际资源标识符。 除非当前用户专门启用 IRI，否则他们看不到任何 NET Framework 2.0 行为的改变。 这确保了 NET Framework 以前版本的应用程序兼容性。  
  
 若要启用对 IRI 的支持，需要以下两项更改：  
  
1.  将以下行添加到 .NET Framework 2.0 目录下的 *machine.config* 文件  \<section name="uri" type="System.Configuration.UriSection, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />  
  
2.  指定是否要将国际化域名 (IDN) 应用于域名的分析以及是否应该应用 IRI 分析规则。 这可以在 *machine.config* 或 *app.config* 文件中完成。 例如，添加以下内容：

    ```xml  
    <configuration>  
      <uri>  
      <idn enabled="All" />  
      <iriParsing enabled="true" />  
      </uri>  
    </configuration>  
    ```  
  
 启用 IDN 可以将域名中所有 Unicode 标签转换成标签的 Punycode 等同项。 Punycode 名称只包含 ASCII 字符，并且始终以 xn-- 前缀开头。 这样是为了支持 Internet 上的 DNS 服务器，因为大部分 DNS 服务器仅支持 ASCII 字符（参见 RFC 3940）。  
  
 启用 IDN 只会影响属性的值 <xref:System.Uri.DnsSafeHost%2A> 。  
  
 根据所使用的 DNS 服务器，IDN 有三个可能的值：  
  
- 已启用 idn = 全部

  此值会将所有 Unicode 域名转换为它们的 Punycode 等效项（IDN 名称）。  
  
- 启用 idn = AllExceptIntranet

  此值会将所有外部 Unicode 域名转换为使用 Punycode 等效项（IDN 名称）。 在这种情况下，若要处理本地 Intranet 上的国际化名称，用于 Intranet 的 DNS 服务器应该支持 Unicode 名称。  
  
- 启用 idn = 无

  此值不会将任何 Unicode 域名转换为使用 Punycode。 这是与 .NET Framework 2.0 行为一致的默认值。  
  
 启用 IRI 分析 (Iriparsing> enabled = `true`) 将根据 RFC 3987 中的最新 IRI 规则执行规范化和字符检查。 默认值为 `false` ，将根据 rfc 2396 和 rfc 2732 (为 IPv6 文本) 执行规范化和字符检查。  
  
 有关 IRI 支持的详细信息，请参阅类的 "备注" 部分 <xref:System.Uri> 。
  
## Examples  
 下面的示例 <xref:System.Uri> 从字符串创建实例。 它说明了从返回的值 <xref:System.Uri.Host%2A> （返回 URI 中指定的主机名或地址）与从返回的值之间的差异， <xref:System.Uri.DnsSafeHost%2A> 后者返回在 DNS 解析中可安全使用的地址。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp" id="Snippet4":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs" interactive="try-dotnet-method" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb" id="Snippet4":::

 如 "备注" 中所述，在解析之前 unescape 主机名。 你可以使用 <xref:System.Uri.UnescapeDataString%2A> 方法 unescape 主机名，并且可以通过调用方法来解决该问题 <xref:System.Net.Dns.GetHostEntry%2A> 。

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object comparand);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (comparand As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ comparand);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="uri.Equals comparand" />
      <MemberSignature Language="C#" Value="public override bool Equals (object? comparand);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="comparand">与当前实例相比较的 URI 或 URI 标识符。</param>
        <summary>比较两个 <see cref="T:System.Uri" /> 实例是否相等。</summary>
        <returns>如果两个实例表示相同的 URI，则该值为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Equals%2A>方法对两个实例进行比较，而不考虑用户信息 (<xref:System.Uri.UserInfo%2A>) 和片段 (<xref:System.Uri.Fragment%2A> 它们可能包含的) 部分。 例如，给定 Uri `http://www.contoso.com/index.htm#search` 和 `http://user:password@www.contoso.com/index.htm` ，则 <xref:System.Uri.Equals%2A> 方法将返回 `true` 。  
  
 如果一个 <xref:System.Uri> 实例的格式为 Unicode 主机名，而 `comparand` 参数包含 <xref:System.Uri> 使用具有等效的 Punycode 主机名的主机名构成的实例或标识符，则 <xref:System.Uri.Equals%2A> `true` 仅 (当) 和国际化域名 (启用了 IDN) 支持时，才会返回。 Punycode 名称只包含 ASCII 字符，并且始终以 xn-- 前缀开头。  
  
 有关 IRI 支持的详细信息，请参阅类的 "备注" 部分 <xref:System.Uri> 。  
  
> [!NOTE]
>  在 .NET Framework 版本1.0 和1.1 中， <xref:System.Uri.Query%2A> 也将忽略。  
  
> [!NOTE]
>  <xref:System.Uri.Equals%2A>方法可在派生类中重写; 请小心，因为恶意实体可以修改方法。 除非您知道此实例来自受信任的源，否则不应使用此方法来执行安全检查。
  
## Examples  
 此示例从字符串创建两个 <xref:System.Uri> 实例并对它们进行比较，以确定它们是否表示相同的值。 `address1` 和 `address2` 都是相同的，因为 <xref:System.Uri.Fragment%2A> 此部分在此比较中被忽略。 结果将写入控制台。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet8":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs" interactive="try-dotnet-method" id="Snippet8":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet8":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="protected virtual void Escape ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Escape() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Escape" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Escape ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Escape();" />
      <MemberSignature Language="F#" Value="abstract member Escape : unit -&gt; unit&#xA;override this.Escape : unit -&gt; unit" Usage="uri.Escape " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.Obsolete("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将路径部分中的任何不安全字符或保留字符转换为对应的十六进制字符表示形式。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UriFormatException">从构造函数传来的 URI 无效。 如果 URI 字符太多或 URI 是相对的，则会发生这种异常。</exception>
      </Docs>
    </Member>
    <Member MemberName="EscapeDataString">
      <MemberSignature Language="C#" Value="public static string EscapeDataString (string stringToEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EscapeDataString(string stringToEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeDataString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EscapeDataString (stringToEscape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ EscapeDataString(System::String ^ stringToEscape);" />
      <MemberSignature Language="F#" Value="static member EscapeDataString : string -&gt; string" Usage="System.Uri.EscapeDataString stringToEscape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToEscape" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="stringToEscape">要转义的字符串。</param>
        <summary>将字符串转换为它的转义表示形式。</summary>
        <returns><paramref name="stringToEscape" /> 的转义表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下， <xref:System.Uri.EscapeDataString%2A> 方法将除 RFC 2396 未保留字符之外的所有字符都转换为其十六进制表示形式。 如果 (IRIs) 或国际化域名 (IDN) 解析启用了国际资源标识符，则该 <xref:System.Uri.EscapeDataString%2A> 方法将除 RFC 3986 不保留字符之外的所有字符都转换为其十六进制表示形式。 在转义之前，所有 Unicode 字符都将转换为 UTF-8 格式。  
  
 此方法假定 `stringToEscape` 它中没有转义序列。  
  
 默认情况下，根据 RFC 2396 对字符串进行转义。 如果国际资源标识符 (IRIs) 或国际化域名 (IDN) 分析已启用，则根据 RFC 3986 和 RFC 3987 对该字符串进行转义。 有关保留和未保留字符的定义，请参阅这些 Rfc。  
  
 有关 IRI 支持的详细信息，请参阅类的 "备注" 部分 <xref:System.Uri> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stringToEscape" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.UriFormatException">注意：在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.FormatException" />。
  
<paramref name="stringToEscape" /> 的长度超过 32766 个字符。</exception>
      </Docs>
    </Member>
    <Member MemberName="EscapeString">
      <MemberSignature Language="C#" Value="protected static string EscapeString (string? str);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig string EscapeString(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function EscapeString (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::String ^ EscapeString(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member EscapeString : string -&gt; string" Usage="System.Uri.EscapeString str" />
      <MemberSignature Language="C#" Value="protected static string EscapeString (string str);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.Obsolete("The method has been deprecated. Please use GetComponents() or static EscapeUriString() to escape a Uri component or a string. https://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("The method has been deprecated. Please use GetComponents() or static EscapeUriString() to escape a Uri component or a string. https://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Obsolete("The method has been deprecated. Please use GetComponents() or static EscapeUriString() to escape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("The method has been deprecated. Please use GetComponents() or static EscapeUriString() to escape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="str">要转换为它的转义表示形式的字符串。</param>
        <summary>将字符串转换为它的转义表示形式。</summary>
        <returns>字符串的转义表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.EscapeString%2A>方法将 RFC 2396 保留字符和字符值大于127的所有字符转换为十六进制表示形式。 在转义之前，所有 Unicode 字符都将转换为 UTF-8 格式。  
  
 默认情况下，根据 RFC 2396 对字符串进行转义。 如果国际资源标识符 (IRIs) 或国际化域名 (IDN) 分析已启用，则根据 RFC 3986 和 RFC 3987 对该字符串进行转义。  
  
 有关 IRI 支持的详细信息，请参阅类的 "备注" 部分 <xref:System.Uri> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapeUriString">
      <MemberSignature Language="C#" Value="public static string EscapeUriString (string stringToEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EscapeUriString(string stringToEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeUriString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EscapeUriString (stringToEscape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ EscapeUriString(System::String ^ stringToEscape);" />
      <MemberSignature Language="F#" Value="static member EscapeUriString : string -&gt; string" Usage="System.Uri.EscapeUriString stringToEscape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToEscape" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="stringToEscape">要转义的字符串。</param>
        <summary>将 URI 字符串转换为它的转义表示形式。</summary>
        <returns><paramref name="stringToEscape" /> 的转义表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Uri.EscapeUriString%2A> 方法可将非转义 URI 字符串准备为 <xref:System.Uri.%23ctor%2A> 构造函数的参数。  
  
 默认情况下， <xref:System.Uri.EscapeUriString%2A> 方法将除 RFC 2396 不保留字符之外的所有字符转换为其十六进制表示形式。 如果 (IRIs) 或国际化域名 (IDN) 解析启用了国际资源标识符，则该 <xref:System.Uri.EscapeUriString%2A> 方法将除 RFC 3986 不保留字符之外的所有字符都转换为其十六进制表示形式。 在转义之前，所有 Unicode 字符都将转换为 UTF-8 格式。  
  
 此方法假定 `stringToEscape` 它中没有转义序列。  
  
 默认情况下，根据 RFC 2396 对字符串进行转义。 如果国际资源标识符 (IRIs) 或国际化域名 (IDN) 分析已启用，则根据 RFC 3986 和 RFC 3987 对该字符串进行转义。 有关保留和未保留字符的定义，请参阅这些 Rfc。  
  
 有关 IRI 支持的详细信息，请参阅类的 "备注" 部分 <xref:System.Uri> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stringToEscape" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.UriFormatException">注意：在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.FormatException" />。

<paramref name="stringToEscape" /> 的长度超过 32766 个字符。</exception>
      </Docs>
    </Member>
    <Member MemberName="Fragment">
      <MemberSignature Language="C#" Value="public string Fragment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Fragment" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Fragment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Fragment As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Fragment { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Fragment : string" Usage="System.Uri.Fragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取转义 URI 片段。</summary>
        <value>URI 片段信息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Fragment%2A>属性将获取 URI 中 ( # ) 之后的片段标记后面的任何文本，包括片段标记本身。 给定 URI `http://www.contoso.com/index.htm#main` ， <xref:System.Uri.Fragment%2A> 属性将返回 #main。  
  
 <xref:System.Uri.Fragment%2A>任何比较中都不考虑该属性 <xref:System.Uri.Equals%2A> 。
  
## Examples  
 下面的示例创建一个 <xref:System.Uri> 实例，并将片段信息写入控制台。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet4":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs" interactive="try-dotnet-method" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet4":::

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="FromHex">
      <MemberSignature Language="C#" Value="public static int FromHex (char digit);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FromHex(char digit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.FromHex(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHex (digit As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FromHex(char digit);" />
      <MemberSignature Language="F#" Value="static member FromHex : char -&gt; int" Usage="System.Uri.FromHex digit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="digit" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="digit">要转换的十六进制数字（0-9、a-f、A-F）。</param>
        <summary>获取十六进制数字的十进制值。</summary>
        <returns>与指定的十六进制数字对应的介于 0 到 15 之间的数字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.FromHex%2A>方法将表示十六进制数字 (0-9，a-f，a-f) 的字符转换为其十进制值 (0 到 15) 。 如果不是 `digit` 有效的十六进制数字，则 <xref:System.ArgumentException> 会引发异常。
  
## Examples  
 下面的示例确定字符是否为十六进制字符，如果为，则将相应的十进制值写入控制台。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet1"::: 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="digit" /> 不是有效的十六进制数字（0-9、a-f、A-F）。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetComponents">
      <MemberSignature Language="C#" Value="public string GetComponents (UriComponents components, UriFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetComponents(valuetype System.UriComponents components, valuetype System.UriFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetComponents(System.UriComponents,System.UriFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetComponents (components As UriComponents, format As UriFormat) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetComponents(UriComponents components, UriFormat format);" />
      <MemberSignature Language="F#" Value="member this.GetComponents : UriComponents * UriFormat -&gt; string" Usage="uri.GetComponents (components, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="components" Type="System.UriComponents" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.UriFormat" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="components"><see cref="T:System.UriComponents" /> 值的按位组合，它指定当前实例中要返回到调用方的部分。</param>
        <param name="format">枚举值之一，它控制如何转义特殊字符。</param>
        <summary>使用特殊字符的指定转义，获取当前实例的指定部分。</summary>
        <returns>当前实例的组件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 、、、、 <xref:System.UriComponents.Query> <xref:System.UriComponents.Fragment> <xref:System.UriComponents.Scheme> <xref:System.UriComponents.UserInfo> <xref:System.UriComponents.Host> 、 <xref:System.UriComponents.Port> 和 <xref:System.UriComponents.Path> 组件不包含分隔符。 您可以 <xref:System.UriComponents.KeepDelimiter> 使用按位 "或" 运算符) 将标志 (为使用分隔符获取值。 对于所有其他 <xref:System.UriComponents> 值和值的组合，分隔符包含在返回值中。  
  
 组件按照其在 URI 中出现的顺序返回。 例如，如果 <xref:System.UriComponents.Scheme> 指定了，则它将首先出现。  
  
 当国际资源标识符 (IRI) 和国际化域名 (启用 IDN) 支持时，返回的字符数将 <xref:System.String> 增加。 用于支持 IRI 的 Punycode 名称只包含 ASCII 字符，并且始终以 xn--前缀开头。 启用 IRI 和 IDN 后，方法将正确处理 Unicode 代理项字符 <xref:System.Uri.GetComponents%2A> 。  
  
 有关 IRI 支持的详细信息，请参阅类的 "备注" 部分 <xref:System.Uri> 。  
  
> [!NOTE]
> 如果在 <xref:System.Uri.GetComponents%2A> 设置为的情况 `format` 下调用方法 <xref:System.UriFormat.Unescaped> ，则不能将返回值用作构造函数的自变量 <xref:System.Uri.%23ctor%2A> 来创建等效的 <xref:System.Uri> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="components" /> 不是有效 <see cref="T:System.UriComponents" /> 值的组合。</exception>
        <exception cref="T:System.InvalidOperationException">当前 <see cref="T:System.Uri" /> 不是绝对 URI。 相对 URI 不能和此方法一起使用。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="uri.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取 URI 的哈希代码。</summary>
        <returns>为此 URI 生成的哈希值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例创建一个 <xref:System.Uri> 实例，并将哈希代码写入控制台。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet4":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs" interactive="try-dotnet-method" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet4":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLeftPart">
      <MemberSignature Language="C#" Value="public string GetLeftPart (UriPartial part);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetLeftPart(valuetype System.UriPartial part) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetLeftPart(System.UriPartial)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLeftPart (part As UriPartial) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetLeftPart(UriPartial part);" />
      <MemberSignature Language="F#" Value="member this.GetLeftPart : UriPartial -&gt; string" Usage="uri.GetLeftPart part" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="part" Type="System.UriPartial" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="part">枚举值之一，指定要返回的 URI 部分的结尾。</param>
        <summary>获取 <see cref="T:System.Uri" /> 实例的指定部分。</summary>
        <returns><see cref="T:System.Uri" /> 实例的指定部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.GetLeftPart%2A>方法返回一个字符串，该字符串包含 URI 字符串的最左边部分，以指定的部分结束 `part` 。  
  
 <xref:System.Uri.GetLeftPart%2A> 在以下情况下包括分隔符：  
  
-   <xref:System.UriPartial.Scheme> 包含方案分隔符。  
  
-   <xref:System.UriPartial.Authority> 不包括路径分隔符。  
  
-   <xref:System.UriPartial.Path> 在原始 URI 中包括查询或片段分隔符之前的所有分隔符。  
  
-   <xref:System.UriPartial.Query> 包括 <xref:System.UriPartial.Path> 、查询及其分隔符。  
  
 下面的示例演示了如何 <xref:System.Uri.GetLeftPart%2A> 使用 <xref:System.UriPartial.Scheme> 、 <xref:System.UriPartial.Authority> 、 <xref:System.UriPartial.Path> 或调用的 URI 和结果 <xref:System.UriPartial.Query> 。  
  
|URI|方案|颁发机构|路径|查询|  
|---------|------------|---------------|----------|-----------|  
|`http://www.contoso.com/index.htm?date=today`|`http://`|`http://www.contoso.com`|`http://www.contoso.com/index.htm`|`http://www.contoso.com/index.htm?date=today`|  
|`http://www.contoso.com/index.htm#main`|`http://`|`http://www.contoso.com`|`http://www.contoso.com/index.htm`|`http://www.contoso.com/index.htm`|  
|`mailto:user@contoso.com?subject=uri`|`mailto:`|`mailto:user@contoso.com`|`mailto:user@contoso.com?subject=uri`|`<none>`|  
|`nntp://news.contoso.com/123456@contoso.com`|`nntp://`|`nntp://news.contoso.com`|`nntp://news.contoso.com/123456@contoso.com`|`nntp://news.contoso.com/123456@contoso.com`|  
|`news:123456@contoso.com`|`news:`|`news:123456@contoso.com`|`news:123456@contoso.com`|`<none>`|  
|`file://server/filename.ext`|`file://`|`file://server`|`file://server/filename.ext`|`file://server/filename.ext`|
  
## Examples  
 下面的示例创建一个 <xref:System.Uri> 实例，并将路径写入控制台。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet4":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs" interactive="try-dotnet-method" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet4":::

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前 <see cref="T:System.Uri" /> 实例不是绝对实例。</exception>
        <exception cref="T:System.ArgumentException">指定的 <paramref name="part" /> 无效。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub GetObjectData (serializationInfo As SerializationInfo, streamingContext As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="member this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="uri.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">序列化 <see cref="T:System.Uri" /> 所需的信息。</param>
        <param name="streamingContext">一个对象，包含与 <see cref="T:System.Uri" /> 关联的序列化流的源和目标。</param>
        <summary>返回序列化当前实例所需的数据。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HexEscape">
      <MemberSignature Language="C#" Value="public static string HexEscape (char character);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string HexEscape(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.HexEscape(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HexEscape (character As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ HexEscape(char character);" />
      <MemberSignature Language="F#" Value="static member HexEscape : char -&gt; string" Usage="System.Uri.HexEscape character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="character">要转换为十六进制表示形式的字符。</param>
        <summary>将指定的字符转换为它的等效十六进制字符。</summary>
        <returns>指定字符的十六进制表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例将字符转换为其十六进制等效项，并将其写入控制台。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="character" /> 大于 255。</exception>
      </Docs>
    </Member>
    <Member MemberName="HexUnescape">
      <MemberSignature Language="C#" Value="public static char HexUnescape (string pattern, ref int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char HexUnescape(string pattern, int32&amp; index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.HexUnescape(System.String,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HexUnescape (pattern As String, ByRef index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char HexUnescape(System::String ^ pattern, int % index);" />
      <MemberSignature Language="F#" Value="static member HexUnescape : string * int -&gt; char" Usage="System.Uri.HexUnescape (pattern, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="index" Type="System.Int32" RefType="ref" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="pattern">字符的十六进制表示形式。</param>
        <param name="index"><paramref name="pattern" /> 中字符的十六进制表示形式开始的位置。</param>
        <summary>将字符的指定十六进制表示形式转换为字符。</summary>
        <returns>用十六进制编码表示的位于 <paramref name="index" /> 的字符。 如果位于 <paramref name="index" /> 的字符不是用十六进制编码的，则返回位于 <paramref name="index" /> 的字符。 <paramref name="index" /> 的值递增以指向跟在返回的字符后面的字符。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下面的代码示例确定字符是否为十六进制编码，如果是，则将等效字符写入控制台。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet2":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet2":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 0，或大于等于 <paramref name="pattern" /> 中的字符数。</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Host" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Host : string" Usage="System.Uri.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例的主机部分。</summary>
        <value>主机名。 这通常是服务器的 DNS 主机名或 IP 地址。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与 <xref:System.Uri.Authority%2A> 属性不同，此属性值不包括端口号。
  
## Examples  
 下面的示例将服务器的主机名 (`www.contoso.com`) 写入控制台。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Host Example/CPP/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Host Example/CS/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Host Example/VB/source.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="HostNameType">
      <MemberSignature Language="C#" Value="public UriHostNameType HostNameType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.UriHostNameType HostNameType" />
      <MemberSignature Language="DocId" Value="P:System.Uri.HostNameType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HostNameType As UriHostNameType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property UriHostNameType HostNameType { UriHostNameType get(); };" />
      <MemberSignature Language="F#" Value="member this.HostNameType : UriHostNameType" Usage="System.Uri.HostNameType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriHostNameType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 URI 中指定的主机名的类型。</summary>
        <value><see cref="T:System.UriHostNameType" /> 枚举的一个成员。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例创建一个 <xref:System.Uri> 实例，并将写入 <xref:System.Uri.HostNameType%2A> 到控制台。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet9":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs" interactive="try-dotnet-method" id="Snippet9":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet9"::: 

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="IdnHost">
      <MemberSignature Language="C#" Value="public string IdnHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string IdnHost" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IdnHost" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IdnHost As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ IdnHost { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IdnHost : string" Usage="System.Uri.IdnHost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>根据需要使用 Punycode，获取主机的符合 RFC 3490 标准的国际域名。 该字符串在不进行转义的情况下（如必要）可安全用于 DNS 解析。</summary>
        <value>根据 IDN 标准，用 Punycode 格式化的主机名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此属性是为了使用需要以 Punycode 形式使用域名的更低级别网络协议。 如果你的代码不需要该特定格式，则将 <xref:System.Uri.Host%2A> 用于主机名。  
  
 不推荐使用的 <xref:System.Uri.DnsSafeHost%2A> 属性依赖于 *app.config* 设置，Windows 应用商店应用程序无法更改这些设置。 IdnHost 作为首选的替代方法提供 <xref:System.Uri.DnsSafeHost%2A> ，因为无论 <xref:System.Uri.IdnHost%2A> 当前 *app.config* 设置如何，都可以保证始终是 DNS 安全的。  

 如果你使用转义字符串构造此实例 (例如 `"http://[fe80::200:39ff:fe36:1a2d%254]/temp/example.htm"`) ，则 IdnHost 将返回一个转义字符串。 应在使用该字符串进行 DNS 解析之前，unescape 从 IdnHost 返回的任何转义字符串。 请注意，如果使用无效的非转义字符串构造此实例 (例如，"http：//[fe80：：200：39ff： fe36： 1a2d %4]/temp/example.htm" ") ，则 IdnHost 返回一个未转义的字符串。

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAbsoluteUri">
      <MemberSignature Language="C#" Value="public bool IsAbsoluteUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbsoluteUri" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsAbsoluteUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbsoluteUri As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbsoluteUri { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbsoluteUri : bool" Usage="System.Uri.IsAbsoluteUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Uri" /> 实例是否为绝对实例。</summary>
        <value><see langword="true" /> 如果该 <see cref="T:System.Uri" /> 实例为绝对实例，则为; 否则为 <see langword="false" /> 。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true`如果 <xref:System.Uri> 传递到构造函数的字符串或实例可分析为绝对 <xref:System.Uri> 实例（其中包含方案、颁发机构和路径），则此属性为。 否则， <xref:System.Uri> 实例将被视为相对，并可能省略方案或其他 URI 组件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBadFileSystemCharacter">
      <MemberSignature Language="C#" Value="protected virtual bool IsBadFileSystemCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsBadFileSystemCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsBadFileSystemCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsBadFileSystemCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsBadFileSystemCharacter(char character);" />
      <MemberSignature Language="F#" Value="abstract member IsBadFileSystemCharacter : char -&gt; bool&#xA;override this.IsBadFileSystemCharacter : char -&gt; bool" Usage="uri.IsBadFileSystemCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.Obsolete("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="character">要测试的 <see cref="T:System.Char" />。</param>
        <summary>指示字符是否在文件系统名称中无效。</summary>
        <returns>如果指定的字符无效，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根据 NTFS 文件系统的规则对字符进行分析。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBaseOf">
      <MemberSignature Language="C#" Value="public bool IsBaseOf (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsBaseOf(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsBaseOf(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsBaseOf (uri As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsBaseOf(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="member this.IsBaseOf : Uri -&gt; bool" Usage="uri.IsBaseOf uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="uri">要测试的指定 URI。</param>
        <summary>确定当前的 <see cref="T:System.Uri" /> 实例是否为指定 <see cref="T:System.Uri" /> 实例的基。</summary>
        <returns>如果当前 <see langword="true" /> 实例是 <see cref="T:System.Uri" /> 的基，则为 <paramref name="uri" />；否则，为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsBaseOf%2A> 用于将当前 <xref:System.Uri> 实例与指定的进行比较， <xref:System.Uri> 以确定此 URI 是否为指定的的基 <xref:System.Uri> 。 在比较两个 <xref:System.Uri> 对象以确定基本关系时， <xref:System.Uri.UserInfo%2A> 不会计算用户信息 () 。 在将两个 Uri (uri1 和 uri2) 进行比较时，uri1 是 uri2 的基数。如果在最后一个斜杠 (/) 后忽略 uri2 中的所有内容，则这两个 Uri 是相同的。 http://host/path/path/file?query下表使用作为基 URI，显示了它是否是其他 uri 的基础。  
  
|URI|http://host/path/path/file?query 基数为|  
|---------|------------------------------------------------------|  
|http://host/path/path/file/|是|  
|http://host/path/path/#fragment|是|  
|http://host/path/path/MoreDir/"|是|  
|http://host/path/path/OtherFile?Query|是|  
|http://host/path/path/|是|  
|http://host/path/path/file|是|  
|http://host/path/path|否|  
|http://host/path/path?query|否|  
|http://host/path/path#Fragment|否|  
|http://host/path/path2/|否|  
://host/path/path2/MoreDir|否|  
|http://host/path/File|否|
  
## Examples  
 此示例创建一个 <xref:System.Uri> 表示基实例的实例 <xref:System.Uri> 。 然后，它通过字符串创建第二个 <xref:System.Uri> 实例。 它调用 <xref:System.Uri.IsBaseOf%2A> 来确定基实例是否为第二个实例的基。 结果将写入控制台。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp" id="Snippet6":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs" interactive="try-dotnet-method" id="Snippet6":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb" id="Snippet6":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="uri" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefaultPort">
      <MemberSignature Language="C#" Value="public bool IsDefaultPort { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefaultPort" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsDefaultPort" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDefaultPort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDefaultPort { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDefaultPort : bool" Usage="System.Uri.IsDefaultPort" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 URI 的端口值是否为此方案的默认值。</summary>
        <value><see langword="true" /> 如果属性中的值 <see cref="P:System.Uri.Port" /> 是此方案的默认端口，则为; 否则为 <see langword="false" /> 。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例创建一个 <xref:System.Uri> 实例，并检查它是否使用默认端口。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet4":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs" interactive="try-dotnet-method" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet4":::

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsExcludedCharacter">
      <MemberSignature Language="C#" Value="protected static bool IsExcludedCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig bool IsExcludedCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsExcludedCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function IsExcludedCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static bool IsExcludedCharacter(char character);" />
      <MemberSignature Language="F#" Value="static member IsExcludedCharacter : char -&gt; bool" Usage="System.Uri.IsExcludedCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.Obsolete("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="character">要测试的字符。</param>
        <summary>确定是否应转义指定的字符。</summary>
        <returns>如果应转义指定的字符，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFile">
      <MemberSignature Language="C#" Value="public bool IsFile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFile" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsFile" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFile As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFile { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFile : bool" Usage="System.Uri.IsFile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示指定的 <see cref="T:System.Uri" /> 是否为文件 URI。</summary>
        <value><see langword="true" /> 如果 <see cref="T:System.Uri" /> 是文件 URI，则为; 否则为 <see langword="false" /> 。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsFile%2A> `true` 当属性等于时，属性为 <xref:System.Uri.Scheme%2A> <xref:System.Uri.UriSchemeFile> 。
  
## Examples  
 下面的示例创建一个 <xref:System.Uri> 实例，并确定它是否为文件 URI。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet6":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs"  id="Snippet6":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet6":::

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsHexDigit">
      <MemberSignature Language="C#" Value="public static bool IsHexDigit (char character);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHexDigit(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsHexDigit(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHexDigit (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHexDigit(char character);" />
      <MemberSignature Language="F#" Value="static member IsHexDigit : char -&gt; bool" Usage="System.Uri.IsHexDigit character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="character">要验证的字符。</param>
        <summary>确定指定的字符是否为有效的十六进制数字。</summary>
        <returns>如果字符是有效的十六进制数字，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 十六进制数字是0到9的数字，字母 A-f 或 a-f。
  
## Examples  
 下面的示例确定字符是否为十六进制字符，如果为，则将相应的十进制值写入控制台。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHexEncoding">
      <MemberSignature Language="C#" Value="public static bool IsHexEncoding (string pattern, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHexEncoding(string pattern, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsHexEncoding(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHexEncoding (pattern As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHexEncoding(System::String ^ pattern, int index);" />
      <MemberSignature Language="F#" Value="static member IsHexEncoding : string * int -&gt; bool" Usage="System.Uri.IsHexEncoding (pattern, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="pattern">要检查的字符串。</param>
        <param name="index">检查十六进制编码的 <paramref name="pattern" /> 中的位置。</param>
        <summary>确定字符串中的一个字符是否为十六进制编码。</summary>
        <returns>如果 <paramref name="pattern" /> 在指定位置进行了十六进制编码，则该值为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此 <xref:System.Uri.IsHexEncoding%2A> 方法检查字符串中是否存在模式 "% hexhex" 的十六进制编码，其中 "hex" 是从0到9的数字或从-F (不区分大小写的) 中的一个字母。
  
## Examples  
 下面的代码示例确定字符是否为十六进制编码，如果是，则将等效字符写入控制台。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet2":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet2":::
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoopback">
      <MemberSignature Language="C#" Value="public bool IsLoopback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsLoopback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoopback { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoopback : bool" Usage="System.Uri.IsLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示指定的 <see cref="T:System.Uri" /> 是否引用本地主机。</summary>
        <value><see langword="true" /> 如果此 <see cref="T:System.Uri" /> 引用了本地主机，则为; 否则为 <see langword="false" /> 。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsLoopback%2A>`true`如果创建此实例时指定的 uri 是127.0.0.1、环回或 localhost，或者 uri 未指定主机信息 (例如，file:///c:Dir/file.txt) ，则返回。 所有其他 Uri 返回 `false` 。
  
## Examples  
 下面的示例创建一个 <xref:System.Uri> 实例，并确定它是否引用了本地主机。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet6":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs" id="Snippet6":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet6":::

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReservedCharacter">
      <MemberSignature Language="C#" Value="protected virtual bool IsReservedCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsReservedCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsReservedCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsReservedCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsReservedCharacter(char character);" />
      <MemberSignature Language="F#" Value="abstract member IsReservedCharacter : char -&gt; bool&#xA;override this.IsReservedCharacter : char -&gt; bool" Usage="uri.IsReservedCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.Obsolete("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="character">要测试的字符。</param>
        <summary>确定指定的字符是否为保留字符。</summary>
        <returns>如果指定的字符是保留字符，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnc">
      <MemberSignature Language="C#" Value="public bool IsUnc { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnc" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsUnc" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnc As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnc { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnc : bool" Usage="System.Uri.IsUnc" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示指定的 <see cref="T:System.Uri" /> 是否为统一命名约定 (UNC) 路径。</summary>
        <value><see langword="true" /> 如果 <see cref="T:System.Uri" /> 是 UNC 路径，则为; 否则为 <see langword="false" /> 。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsUnc%2A> `true` 如果指定的 <xref:System.Uri> 实例是 UNC 路径 (如 `\\server\folder` 、//server 或) ，则属性为 `file://server/folder` 。 `true`如果 URI 具有 file://方案并且指定了主机组件，则此属性始终返回。
  
## Examples  
 下面的示例创建一个 <xref:System.Uri> 实例，并确定它是否为 UNC 路径。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet6":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs" interactive="try-dotnet-method" id="Snippet6":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet6":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedOriginalString">
      <MemberSignature Language="C#" Value="public bool IsWellFormedOriginalString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsWellFormedOriginalString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsWellFormedOriginalString" />
      <MemberSignature Language="VB.NET" Value="Public Function IsWellFormedOriginalString () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsWellFormedOriginalString();" />
      <MemberSignature Language="F#" Value="member this.IsWellFormedOriginalString : unit -&gt; bool" Usage="uri.IsWellFormedOriginalString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>指示用于构造此 <see cref="T:System.Uri" /> 的字符串是否格式良好，以及它是否不需要进一步转义。</summary>
        <returns>如果该字符串格式正确，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，根据 RFC 2396 和 RFC 2732，此字符串被视为格式正确。 如果国际资源标识符 (IRIs) 或国际化域名 (IDN) 分析已启用，则根据 RFC 3986 和 RFC 3987，将该字符串视为格式正确  
  
 如果出现下列任一情况，则认为字符串格式不正确，导致方法返回 false。  
  
|错误|示例|  
|-----------|-------------|  
|字符串未正确转义。|`http://www.contoso.com/path???/file name`|  
|字符串是 <xref:System.Uri> 表示隐式文件的绝对 <xref:System.Uri> 。|`c:\\directory\filename`|  
|字符串是一个绝对 URI，它在路径之前缺少一个斜杠。|`file://c:/directory/filename`|  
|该字符串包含非转义反斜杠，即使它们被视为正斜杠也是如此。|`http:\\\host/path/file`|  
|该字符串表示层次结构的绝对路径 <xref:System.Uri> ，并且不包含 "：//"。|`www.contoso.com/path/file`|  
|的分析器 <xref:System.Uri.Scheme%2A?displayProperty=nameWithType> 指示原始字符串格式不正确。|该示例取决于 URI 的方案。|  
  
 默认情况下， <xref:System.Uri> 根据 rfc 2396 和 rfc 2732，用来构造此的字符串被视为格式正确。  
  
 如果) 和国际化域名 (IRI 和国际化域名 (启用了 IDN) 支持，则用于构造此的字符串 <xref:System.Uri> 根据 rfc 3986 和 rfc 3987 被视为格式正确。 用于支持 IRI 的 Punycode 名称只包含 ASCII 字符，并且始终以 xn--前缀开头。  
  
 有关 IRI 支持的详细信息，请参阅类的 "备注" 部分 <xref:System.Uri> 。  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://www.ietf.org/">Internet 工程任务组 (IETF)</related>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedUriString">
      <MemberSignature Language="C#" Value="public static bool IsWellFormedUriString (string uriString, UriKind uriKind);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWellFormedUriString(string uriString, valuetype System.UriKind uriKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsWellFormedUriString(System.String,System.UriKind)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsWellFormedUriString (uriString As String, uriKind As UriKind) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsWellFormedUriString(System::String ^ uriString, UriKind uriKind);" />
      <MemberSignature Language="F#" Value="static member IsWellFormedUriString : string * UriKind -&gt; bool" Usage="System.Uri.IsWellFormedUriString (uriString, uriKind)" />
      <MemberSignature Language="C#" Value="public static bool IsWellFormedUriString (string? uriString, UriKind uriKind);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="uriKind" Type="System.UriKind" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="uriString">用于尝试构造 <see cref="T:System.Uri" /> 的字符串。</param>
        <param name="uriKind"><see cref="T:System.Uri" /> 中的 <paramref name="uriString" /> 的类型。</param>
        <summary>通过尝试用字符串构造一个 URI 来指示字符串是否为格式良好的，并确保字符串不需要进一步转义。</summary>
        <returns>如果该字符串格式正确，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在版本4.5 之前的 .NET 版本中，默认情况下，根据 RFC 2396 和 RFC 2732，将字符串视为格式正确。 如果国际资源标识符 (IRIs) 或国际化域名 (IDN) 分析已启用，则根据 RFC 3986 和 RFC 3987，字符串被视为格式正确。  
  
 从 .NET 4.5 开始，无论是否启用了 IRI 或 IDN，字符串始终根据 RFC 3986 和 RFC 3987 被视为格式正确。 但请注意，这仅适用于面向 .NET 4.5 或更高版本的应用程序。 面向 .NET 4.0 的应用将调用兼容性代码，并体验旧 (4.5 之前) 的行为。  
  
 如果出现下列任一情况，字符串将被视为格式不正确，从而导致方法返回 false  
  
|错误|示例|  
|-----------|-------------|  
|字符串未正确转义。|`http://www.contoso.com/path???/file name`|  
|字符串是 <xref:System.Uri> 表示隐式文件的绝对 <xref:System.Uri> 。|`c:\\directory\filename`|  
|字符串是一个绝对 URI，它在路径之前缺少一个斜杠。|`file://c:/directory/filename`|  
|该字符串包含非转义反斜杠，即使它们将被视为正斜杠|`http:\\\host/path/file`|  
|该字符串表示层次结构的绝对路径 <xref:System.Uri> ，并且不包含 "：//"|`www.contoso.com/path/file`|  
|的分析器 <xref:System.Uri.Scheme%2A> 指示原始字符串格式不正确。|该示例取决于 URI 的方案。|  
|从 .NET 4.5 开始，其第一段中 ) 带有冒号 ( "：" 的相对 Uri 不被视为格式正确。|`2013.05.29_14:33:41`|  
  
 有关 IRI 支持的详细信息，请参阅类的 "备注" 部分 <xref:System.Uri> 。  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://www.ietf.org/">Internet 工程任务组 (IETF)</related>
      </Docs>
    </Member>
    <Member MemberName="LocalPath">
      <MemberSignature Language="C#" Value="public string LocalPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalPath" />
      <MemberSignature Language="DocId" Value="P:System.Uri.LocalPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LocalPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalPath : string" Usage="System.Uri.LocalPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取文件名的本地操作系统表示形式。</summary>
        <value>文件名的本地操作系统表示形式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回的值未转义。 如果路径被识别为 Windows 文件路径，则所有正斜杠 (/) 将被) 的反斜杠 (替换 \\ 。  
  
 对于 URI `file://computer/file.ext` ，绝对路径为 `/file.ext` ，本地路径为 `\\computer\file.ext` 。
  
## Examples  
 下面的示例创建一个 <xref:System.Uri> 实例，并将本地路径写入控制台。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet6":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs"  id="Snippet6":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet6"::: 

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeRelative">
      <MemberSignature Language="C#" Value="public string MakeRelative (Uri toUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MakeRelative(class System.Uri toUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.MakeRelative(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function MakeRelative (toUri As Uri) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MakeRelative(Uri ^ toUri);" />
      <MemberSignature Language="F#" Value="member this.MakeRelative : Uri -&gt; string" Usage="uri.MakeRelative toUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.Obsolete("The method has been deprecated. Please use MakeRelativeUri(Uri uri). https://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("The method has been deprecated. Please use MakeRelativeUri(Uri uri). https://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Obsolete("The method has been deprecated. Please use MakeRelativeUri(Uri uri). http://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("The method has been deprecated. Please use MakeRelativeUri(Uri uri). http://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toUri" Type="System.Uri" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="toUri">与当前 URI 进行比较的 URI。</param>
        <summary>确定两个 <see cref="T:System.Uri" /> 实例之间的差异。</summary>
        <returns>如果此 URI 实例与 <paramref name="toUri" /> 的主机名和方案相同，则此方法返回一个表示相对 URI 的 <see cref="T:System.String" />。若将此相对 URI 追加到当前 URI 实例，就可以得到 <paramref name="toUri" /> 参数。  
  
如果主机名或方案不同，则此方法返回一个表示 <see cref="T:System.String" /> 参数的 <paramref name="toUri" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表显示了 URI 实例、 `toUri` 和调用的结果 <xref:System.Uri.MakeRelative%2A> 。  
  
|当前 URI 实例|`toUri`|返回值|  
|--------------------------|-------------|------------------|  
|`http://www.contoso.com/`|`http://www.contoso.com/test/test.htm`|`test/test.htm`|  
|`http://www.contoso.com/test1/`|`http://www.contoso.com/`|`../`|  
|`http://www.contoso.com:8000/`|`http://www.contoso.com/test/test.htm`|`http://www.contoso.com/test/test.htm`|  
|`http://username@www.contoso.com/`|`http://www.contoso.com/test1/test1.txt`|`test1/test1.txt`|  
  
 如果在 URI 中存在，则忽略用户信息。
  
## Examples  
 下面的示例创建两个 <xref:System.Uri> 实例。 路径信息中的差异写入控制台。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet3":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs" interactive="try-dotnet-method" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet3":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="toUri" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此方法仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeRelativeUri">
      <MemberSignature Language="C#" Value="public Uri MakeRelativeUri (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Uri MakeRelativeUri(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.MakeRelativeUri(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function MakeRelativeUri (uri As Uri) As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri ^ MakeRelativeUri(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="member this.MakeRelativeUri : Uri -&gt; Uri" Usage="uri.MakeRelativeUri uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="uri">与当前 URI 进行比较的 URI。</param>
        <summary>确定两个 <see cref="T:System.Uri" /> 实例之间的差异。</summary>
        <returns>如果此 URI 实例与 <paramref name="uri" /> 的主机名和方案相同，则此方法返回一个相对 <see cref="T:System.Uri" />。若将此相对 URI 追加到当前 URI 实例，就可以得到 <paramref name="uri" />。  
  
如果主机名或方案不同，则此方法返回一个表示 <see cref="T:System.Uri" /> 参数的 <paramref name="uri" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表显示了 URI 实例、 `toUri` 和调用的结果 <xref:System.Uri.MakeRelativeUri%2A> 。  
  
|当前 URI 实例|`toUri`|返回值|  
|--------------------------|-------------|------------------|  
|`http://www.contoso.com/`|`http://www.contoso.com/test/test.htm`|`test/test.htm`|  
|`http://www.contoso.com/test1/`|`http://www.contoso.com/`|`../`|  
|`http://www.contoso.com:8000/`|`http://www.contoso.com/test/test.htm`|`http://www.contoso.com/test/test.htm`|  
|`http://username@www.contoso.com/`|`http://www.contoso.com/test1/test1.txt`|`test1/test1.txt`|  
  
 如果在 URI 中存在，则忽略用户信息。
  
## Examples  
 下面的示例创建两个 <xref:System.Uri> 实例。 路径信息中的差异写入控制台。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet3":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs" interactive="try-dotnet-method" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet3":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="uri" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Uri uri1, Uri uri2);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Uri uri1, class System.Uri uri2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.op_Equality(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (uri1 As Uri, uri2 As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Uri ^ uri1, Uri ^ uri2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Uri * Uri -&gt; bool" Usage="uri1 = uri2" />
      <MemberSignature Language="C#" Value="public static bool operator == (Uri? uri1, Uri? uri2);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="uri2" Type="System.Uri" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="uri1">要与 <paramref name="uri2" /> 进行比较的 URI。</param>
        <param name="uri2">要与 <paramref name="uri1" /> 进行比较的 URI。</param>
        <summary>确定两个 <see cref="T:System.Uri" /> 实例是否具有相同的值。</summary>
        <returns>如果 <see cref="T:System.Uri" /> 实例等效，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载使用 <xref:System.Uri.Equals%2A> 方法来确定两个实例是否 <xref:System.Uri> 相等。 <xref:System.Uri.UserInfo%2A><xref:System.Uri.Fragment%2A>进行此比较时，将忽略和内容。
  
## Examples  
 此示例从字符串创建三个 <xref:System.Uri> 实例并对它们进行比较，以确定它们是否表示相同的值。 `Address1` 和 `Address2` 都是相同的，因为 <xref:System.Uri.Fragment%2A> 此部分在此比较中被忽略。 结果将写入控制台。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp" id="Snippet5":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs" interactive="try-dotnet-method" id="Snippet5":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb" id="Snippet5"::: 

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Uri uri1, Uri uri2);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Uri uri1, class System.Uri uri2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.op_Inequality(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (uri1 As Uri, uri2 As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Uri ^ uri1, Uri ^ uri2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Uri * Uri -&gt; bool" Usage="System.Uri.op_Inequality (uri1, uri2)" />
      <MemberSignature Language="C#" Value="public static bool operator != (Uri? uri1, Uri? uri2);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="uri2" Type="System.Uri" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="uri1">要与 <paramref name="uri2" /> 进行比较的 URI。</param>
        <param name="uri2">要与 <paramref name="uri1" /> 进行比较的 URI。</param>
        <summary>确定两个 <see cref="T:System.Uri" /> 实例是否具有不同的值。</summary>
        <returns>如果这两个 <see cref="T:System.Uri" /> 实例不相等，则为 <see langword="true" />；否则为 <see langword="false" />。 如果两者中任意一个参数为 <see langword="null" />，则此方法返回 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载使用 <xref:System.Uri.Equals%2A> 方法来确定两个实例是否 <xref:System.Uri> 不等效。 <xref:System.Uri.UserInfo%2A><xref:System.Uri.Fragment%2A>进行此比较时，将忽略和内容。
  
## Examples  
 此示例从字符串创建三个 <xref:System.Uri> 实例并对它们进行比较，以确定它们是否表示相同的值。 `Address2` 和 `Address3` 不相同，因为 `Address3` 包含 <xref:System.Uri.Query%2A> 在中找不到的 `Address2` 。 结果将写入控制台。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp" id="Snippet5":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs" interactive="try-dotnet-method" id="Snippet5":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb" id="Snippet5"::: 

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OriginalString">
      <MemberSignature Language="C#" Value="public string OriginalString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OriginalString" />
      <MemberSignature Language="DocId" Value="P:System.Uri.OriginalString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalString As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OriginalString { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalString : string" Usage="System.Uri.OriginalString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取传递给 <see cref="T:System.Uri" /> 构造函数的原始 URI 字符串。</summary>
        <value>构造此实例时指定的确切 URI;否则为 <see cref="F:System.String.Empty" /> 。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果为构造函数指定的 URI 包含前导空格或尾随空格，则会保留这些空格。  
  
 此属性返回的值不同于 <xref:System.Uri.ToString%2A> 和 <xref:System.Uri.AbsoluteUri%2A> 。 <xref:System.Uri.ToString%2A> 返回 URI 的规范非转义形式。 <xref:System.Uri.AbsoluteUri%2A> 返回 URI 的规范转义形式。  
  
 如果启用了国际资源标识符 (IRI) 并启用了国际化域名 (IDN) 支持，则 <xref:System.Uri.OriginalString%2A> 将返回具有 Punycode 主机名的原始非规范化字符串（如果用来初始化 <xref:System.Uri> 实例）。 Punycode 名称只包含 ASCII 字符，并且始终以 xn-- 前缀开头。  
  
 有关 IRI 支持的详细信息，请参阅类的 "备注" 部分 <xref:System.Uri> 。  
  
 <xref:System.Uri>序列化对象时， <xref:System.Uri.OriginalString%2A> 不会保留。 序列化时，序列化过程使用完全转义和规范化 <xref:System.Uri.AbsoluteUri%2A> 属性。 对于 <xref:System.Uri> 包含 ipv6 地址的，ipv6 地址和作用域 ID 包括在序列化的 <xref:System.Uri> 对象中。
  
## Examples  
 下面的示例从字符串创建一个新的 <xref:System.Uri> 实例。 它阐释了从返回的值 <xref:System.Uri.OriginalString%2A> （返回传递到构造函数的字符串）和对的调用 <xref:System.Uri.ToString%2A> （返回字符串的规范形式）之间的差异。  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp" id="Snippet3":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs" interactive="try-dotnet-method" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb" id="Snippet3":::
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="protected virtual void Parse ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Parse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Parse" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Parse ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Parse();" />
      <MemberSignature Language="F#" Value="abstract member Parse : unit -&gt; unit&#xA;override this.Parse : unit -&gt; unit" Usage="uri.Parse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.Obsolete("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("The method has been deprecated. It is not used by the system. https://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>分析当前实例的 URI 以确保它包含有效 URI 所需的所有部分。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UriFormatException">从构造函数传来的 URI 无效。</exception>
      </Docs>
    </Member>
    <Member MemberName="PathAndQuery">
      <MemberSignature Language="C#" Value="public string PathAndQuery { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PathAndQuery" />
      <MemberSignature Language="DocId" Value="P:System.Uri.PathAndQuery" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathAndQuery As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PathAndQuery { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PathAndQuery : string" Usage="System.Uri.PathAndQuery" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用问号 (?) 分隔的 <see cref="P:System.Uri.AbsolutePath" /> 和 <see cref="P:System.Uri.Query" /> 属性。</summary>
        <value><see cref="P:System.Uri.AbsolutePath" />和 <see cref="P:System.Uri.Query" /> 属性由问号分隔 (？ ) 。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.PathAndQuery%2A>属性包含服务器上的绝对路径，以及与请求一起发送的查询信息。 与串联和属性完全相同 <xref:System.Uri.AbsolutePath%2A> <xref:System.Uri.Query%2A> 。  
  
 <xref:System.Uri.PathAndQuery%2A>默认情况下，根据 RFC 2396 对属性进行转义。 如果国际资源标识符 (IRIs) 或国际化域名 (IDN) 分析已启用，则 <xref:System.Uri.PathAndQuery%2A> 根据 rfc 3986 和 rfc 3987 对属性进行转义。  
  
 有关 IRI 支持的详细信息，请参阅类的 "备注" 部分 <xref:System.Uri> 。
  
## Examples  
 下面的示例将 URI 路径 (`/catalog/shownew.htm`) 和查询 (`?date=today`) 信息写入控制台。
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CPP/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CS/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/VB/source.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="Port">
      <MemberSignature Language="C#" Value="public int Port { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Port" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Port" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Port As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Port { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Port : int" Usage="System.Uri.Port" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此 URI 的端口号。</summary>
        <value>此 URI 的端口号。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 端口号定义用于联系 URI 中引用的服务器的协议端口。 如果未将端口指定为 URI 的一部分，则属性将 <xref:System.Uri.Port%2A> 返回协议的默认值。 如果没有默认端口号，则此属性返回-1。
  
## Examples  
 下面的示例将 URI 端口号写入控制台。 在这种情况下，值为 HTTP 端口80的默认端口号。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Port Example/CPP/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Port Example/CS/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Port Example/VB/source.vb" id="Snippet1":::
 
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="Query">
      <MemberSignature Language="C#" Value="public string Query { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Query" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Query" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Query As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Query { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Query : string" Usage="System.Uri.Query" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指定 URI 中包括的任何查询信息。</summary>
        <value>指定的 URI 中包括的任何查询信息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Query%2A>属性包含 URI 中包括的任何查询信息。 查询信息通过问号 (？ ) 与路径信息分开，并继续到 URI 的末尾。 返回的查询信息包括前导问号。  
  
 默认情况下，根据 RFC 2396 对查询信息进行转义。 如果国际资源标识符 (IRIs) 或国际化域名 (IDN) 分析已启用，则根据 RFC 3986 和 RFC 3987 对查询信息进行转义。  
  
 有关 IRI 支持的详细信息，请参阅类的 "备注" 部分 <xref:System.Uri> 。
  
## Examples  
 下面的示例将查询写入 `?date=today` 控制台。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CPP/source.cpp" id="Snippet2":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CS/source.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/VB/source.vb" id="Snippet2":::

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="Scheme">
      <MemberSignature Language="C#" Value="public string Scheme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Scheme" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Scheme" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Scheme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Scheme { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scheme : string" Usage="System.Uri.Scheme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此 URI 的方案名称。</summary>
        <value>此 URI 的方案（已转换为小写形式）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Scheme%2A>属性返回用于初始化实例的方案 <xref:System.Uri> 。 此属性不指示已识别用于初始化实例的方案 <xref:System.Uri> 。  
  
 下表显示了属性返回的一些可能值的示例 <xref:System.Uri.Scheme%2A> 。  
  
|方案|描述|  
|------------|-----------------|  
|文件|资源是本地计算机上的文件。|  
|ftp|资源通过 FTP 访问。|  
|gopher|资源可通过 Gopher 协议进行访问。|  
|http|资源可通过 HTTP 访问。|  
|https|资源通过 SSL 加密的 HTTP 访问。|  
|ldap|资源通过 LDAP 协议进行访问。|  
|mailto|该资源是一个电子邮件地址，可通过 SMTP 协议进行访问。|  
|net.pipe|通过命名管道访问资源。|  
|net.tcp|可从 TCP 终结点访问该资源。|  
|news|资源可通过 NNTP 协议进行访问。|  
|nntp|资源可通过 NNTP 协议进行访问。|  
|telnet|资源可通过 TELNET 协议进行访问。|  
|uuid|资源是通过用于与服务进行通信的唯一 UUID 终结点名称访问的。|
  
## Examples  
 下面的示例将 (http) 的方案名称写入 URI 的控制台 `http://www.contoso.com/` 。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Scheme Example/CPP/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Scheme Example/CS/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Scheme Example/VB/source.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="SchemeDelimiter">
      <MemberSignature Language="C#" Value="public static readonly string SchemeDelimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string SchemeDelimiter" />
      <MemberSignature Language="DocId" Value="F:System.Uri.SchemeDelimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SchemeDelimiter As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ SchemeDelimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable SchemeDelimiter : string" Usage="System.Uri.SchemeDelimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定将通讯协议方案同 URI 的地址部分分开的字符。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例从 <xref:System.Uri.UriSchemeHttp> 、和地址创建一个字符串 <xref:System.Uri.SchemeDelimiter> 。 <xref:System.Uri>然后从字符串创建实例。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet17":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs" interactive="try-dotnet-method" id="Snippet17":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet17":::
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Segments">
      <MemberSignature Language="C#" Value="public string[] Segments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Segments" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Segments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Segments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ Segments { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Segments : string[]" Usage="System.Uri.Segments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取包含构成指定 URI 的路径段的数组。</summary>
        <value>构成指定 URI 的路径段。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Segments%2A>属性返回一个字符串数组，其中包含 (子字符串的 "段") 构成 URI 的绝对路径。 第一段是通过分析其第一个字符的绝对路径获取的，直到达到斜杠 (/) 或路径的末尾。 每个附加段都从前面段之后的第一个字符开始，并以路径的下一个斜杠或末尾结束。  (URI 的绝对路径包含主机和端口之后以及查询和片段之前的所有内容。 )   
  
 下面的示例显示了两个 Uri 的绝对路径和段。 第二个示例说明片段和查询不是绝对路径的一部分，因此不是段。  
  
 绝对 URI：  
 `http://www.contoso.com/Chapters/Chapter1/Sections/Section1.htm`
  
 绝对路径：  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 边  
 - /
 - 关于
 - Chapter1.txt
 - 个
 - Section1.htm  
  
 绝对 URI：  
 `http://www.contoso.com/Chapters/Chapter1/Sections/Section1.htm#page1?answer=NO`
  
 绝对路径：  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 边  
 - /
 - 关于
 - Chapter1.txt
 - 个
 - Section1.htm  
  
 请注意，因为绝对路径以 "/" 开头，所以第一个段包含它，而不包含任何其他内容。
  
## Examples  
 下面的示例创建一个 <xref:System.Uri> 具有3个段的实例，并在屏幕上显示这些段。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet5":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs" interactive="try-dotnet-method" id="Snippet5":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet5":::

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (serializationInfo As SerializationInfo, streamingContext As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.Serialization.ISerializable.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.System.Runtime.Serialization.ISerializable.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="uri.System.Runtime.Serialization.ISerializable.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">序列化 <see cref="T:System.Uri" /> 所需的信息。</param>
        <param name="streamingContext">一个对象，该对象包含与 <see cref="T:System.Uri" /> 相关联的序列化流的源和目标。</param>
        <summary>返回序列化当前实例所需的数据。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="uri.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取指定的 <see cref="T:System.Uri" /> 实例的规范化字符串表示形式。</summary>
        <returns><see cref="T:System.Uri" /> 实例的非转义规范化表示形式。 除了 #、? 和 %，所有字符均为非转义字符。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当端口为方案的默认端口时，此方法返回的字符串不包含端口信息。  
  
> [!NOTE]
> 方法返回的字符串 <xref:System.Uri.ToString%2A> 可能包含控制字符，这些字符可能会损坏控制台应用程序的状态。 可以将 <xref:System.Uri.GetComponents%2A> 方法与格式一起使用 <xref:System.UriFormat.SafeUnescaped?displayProperty=nameWithType> ，以从返回的字符串中删除控制字符。
  
## Examples  
 下面的示例从字符串创建一个新的 <xref:System.Uri> 实例。 它阐释了从返回的值 <xref:System.Uri.OriginalString%2A> （返回传递到构造函数的字符串）和对的调用 <xref:System.Uri.ToString%2A> （返回字符串的规范形式）之间的差异。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet7":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs" interactive="try-dotnet-method" id="Snippet7":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet7":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryCreate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建一个新的 <see cref="T:System.Uri" />。 在无法创建 <see cref="T:System.Uri" /> 时不引发异常。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (string uriString, UriKind uriKind, out Uri result);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(string uriString, valuetype System.UriKind uriKind, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.String,System.UriKind,System.Uri@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (uriString As String, uriKind As UriKind, ByRef result As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(System::String ^ uriString, UriKind uriKind, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : string * UriKind * Uri -&gt; bool" Usage="System.Uri.TryCreate (uriString, uriKind, result)" />
      <MemberSignature Language="C#" Value="public static bool TryCreate (string? uriString, UriKind uriKind, out Uri? result);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="uriKind" Type="System.UriKind" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Uri" RefType="out" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="uriString"><see cref="T:System.Uri" /> 的字符串表示形式。</param>
        <param name="uriKind">URI 的类型。</param>
        <param name="result">此方法返回时，包含构造的 <see cref="T:System.Uri" />。</param>
        <summary>使用指定的 <see cref="T:System.Uri" /> 实例和 <see cref="T:System.String" /> 创建一个新的 <see cref="T:System.UriKind" />。</summary>
        <returns>如果成功创建了 <see cref="T:System.Uri" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此方法返回 `true` ，则新的 <xref:System.Uri> 处于中 `result` 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri baseUri, string relativeUri, out Uri result);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(class System.Uri baseUri, string relativeUri, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.Uri,System.String,System.Uri@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (baseUri As Uri, relativeUri As String, ByRef result As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(Uri ^ baseUri, System::String ^ relativeUri, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : Uri * string * Uri -&gt; bool" Usage="System.Uri.TryCreate (baseUri, relativeUri, result)" />
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri? baseUri, string? relativeUri, out Uri? result);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="relativeUri" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Uri" RefType="out" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="baseUri">基 URI。</param>
        <param name="relativeUri">要添加到基 <see cref="T:System.Uri" /> 的相对 URI 的字符串表示形式。</param>
        <param name="result">此方法返回时，包含从 <see cref="T:System.Uri" /> 和 <paramref name="baseUri" /> 构造的 <paramref name="relativeUri" />。 此参数未经初始化即被传递。</param>
        <summary>使用指定基和相对 <see cref="T:System.Uri" /> 实例创建一个新的 <see cref="T:System.String" />。</summary>
        <returns>如果成功创建了 <see cref="T:System.Uri" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此方法返回 `true` ，则新的 <xref:System.Uri> 处于中 `result` 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri baseUri, Uri relativeUri, out Uri result);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(class System.Uri baseUri, class System.Uri relativeUri, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.Uri,System.Uri,System.Uri@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (baseUri As Uri, relativeUri As Uri, ByRef result As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(Uri ^ baseUri, Uri ^ relativeUri, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : Uri * Uri * Uri -&gt; bool" Usage="System.Uri.TryCreate (baseUri, relativeUri, result)" />
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri? baseUri, Uri? relativeUri, out Uri? result);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="relativeUri" Type="System.Uri" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Uri" RefType="out" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="baseUri">基 URI。</param>
        <param name="relativeUri">要添加到基 <see cref="T:System.Uri" /> 的相对 URI。</param>
        <param name="result">此方法返回时，包含从 <see cref="T:System.Uri" /> 和 <paramref name="baseUri" /> 构造的 <paramref name="relativeUri" />。 此参数未经初始化即被传递。</param>
        <summary>使用指定基和相对 <see cref="T:System.Uri" /> 实例创建一个新的 <see cref="T:System.Uri" />。</summary>
        <returns>如果成功创建了 <see cref="T:System.Uri" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此方法返回 `true` ，则新的 <xref:System.Uri> 处于中 `result` 。  
  
 此方法构造 URI，将其置于规范形式中，并对其进行验证。 如果发生未处理的异常，则此方法将捕获该异常。 如果要创建 <xref:System.Uri> 并获取异常，请使用其中一个 <xref:System.Uri.%23ctor%2A> 构造函数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="baseUri" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="protected virtual string Unescape (string path);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string Unescape(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Unescape (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ Unescape(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member Unescape : string -&gt; string&#xA;override this.Unescape : string -&gt; string" Usage="uri.Unescape path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.Obsolete("The method has been deprecated. Please use GetComponents() or static UnescapeDataString() to unescape a Uri component or a string. https://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("The method has been deprecated. Please use GetComponents() or static UnescapeDataString() to unescape a Uri component or a string. https://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Obsolete("The method has been deprecated. Please use GetComponents() or static UnescapeDataString() to unescape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("The method has been deprecated. Please use GetComponents() or static UnescapeDataString() to unescape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="path">要转换的字符串。</param>
        <summary>转换指定的字符串，方法是将任何转义序列替换为相应的未转义表示形式。</summary>
        <returns><paramref name="path" /> 参数的非转义值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnescapeDataString">
      <MemberSignature Language="C#" Value="public static string UnescapeDataString (string stringToUnescape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string UnescapeDataString(string stringToUnescape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.UnescapeDataString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnescapeDataString (stringToUnescape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ UnescapeDataString(System::String ^ stringToUnescape);" />
      <MemberSignature Language="F#" Value="static member UnescapeDataString : string -&gt; string" Usage="System.Uri.UnescapeDataString stringToUnescape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToUnescape" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="stringToUnescape">要恢复原义的字符串。</param>
        <summary>将字符串转换为它的非转义表示形式。</summary>
        <returns><paramref name="stringToUnescape" /> 的非转义表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你应谨慎使用此方法。 取消转义以前未转义的字符串会导致歧义和错误。  
  
 许多 Web 浏览器将 Uri 内的空格转义为加号 ( "+" ) 字符;但是，System.uri.unescapedatastring 方法不会将加字符转换为空格，因为此行为在所有 URI 方案中都不是标准的。
  
## Examples  
 下面的代码示例 unescapes URI，然后将 ( "+" ) 的任何加号字符转换为空格。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs" interactive="try-dotnet-method" id="Snippet19"::: 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stringToUnescape" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Uri.EscapeDataString(System.String)" />
        <altmember cref="M:System.Uri.EscapeUriString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="UriSchemeFile">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeFile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeFile" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeFile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeFile As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeFile;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeFile : string" Usage="System.Uri.UriSchemeFile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定 URI 是指向文件的指针。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 .NET Framework 版本1.1 中，将 " `file:///path` " URI 转换为 " `file:/path` "。 这已在版本2.0 中得到更正。
  
## Examples  
 下面的示例创建一个 <xref:System.Uri> 实例，并确定该方案是否为 <xref:System.Uri.UriSchemeFile> 。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet10":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs" interactive="try-dotnet-method" id="Snippet10":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet10":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeFtp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeFtp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeFtp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeFtp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeFtp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeFtp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeFtp : string" Usage="System.Uri.UriSchemeFtp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定通过文件传输协议 (FTP) 访问 URI。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例创建一个 <xref:System.Uri> 实例，并确定该方案是否为 <xref:System.Uri.UriSchemeFtp> 。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet15":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs" interactive="try-dotnet-method" id="Snippet15":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet15":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeGopher">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeGopher;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeGopher" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeGopher" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeGopher As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeGopher;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeGopher : string" Usage="System.Uri.UriSchemeGopher" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定通过 Gopher 协议访问 URI。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例创建一个 <xref:System.Uri> 实例，并确定该方案是否为 <xref:System.Uri.UriSchemeGopher> 。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet14":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs" interactive="try-dotnet-method" id="Snippet14":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet14":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeHttp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeHttp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeHttp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeHttp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeHttp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeHttp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeHttp : string" Usage="System.Uri.UriSchemeHttp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定通过超文本传输协议 (HTTP) 访问 URI。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例创建一个 <xref:System.Uri> 实例，并确定该方案是否为 <xref:System.Uri.UriSchemeHttp> 。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet9":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs" interactive="try-dotnet-method" id="Snippet9":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet9"::: 

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeHttps">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeHttps;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeHttps" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeHttps" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeHttps As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeHttps;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeHttps : string" Usage="System.Uri.UriSchemeHttps" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定通过安全超文本传输协议 (HTTPS) 访问 URI。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例创建一个 <xref:System.Uri> 实例，并确定该方案是否为 <xref:System.Uri.UriSchemeHttps> 。  
    
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet16":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs" interactive="try-dotnet-method" id="Snippet16":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet16":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeMailto">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeMailto;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeMailto" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeMailto" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeMailto As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeMailto;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeMailto : string" Usage="System.Uri.UriSchemeMailto" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定 URI 是一个电子邮件地址，需通过简单邮件传输协议 (SMTP) 访问。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例创建一个 <xref:System.Uri> 实例，并确定该方案是否为 <xref:System.Uri.UriSchemeMailto> 。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet11":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs" interactive="try-dotnet-method" id="Snippet11":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet11":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNetPipe">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNetPipe;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNetPipe" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNetPipe" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNetPipe As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNetPipe;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNetPipe : string" Usage="System.Uri.UriSchemeNetPipe" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指明通过 Windows Communication Foundation (WCF) 使用的 NetPipe 方案访问该 URI。 此字段为只读。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNetTcp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNetTcp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNetTcp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNetTcp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNetTcp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNetTcp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNetTcp : string" Usage="System.Uri.UriSchemeNetTcp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指明通过 Windows Communication Foundation (WCF) 使用的 NetTcp 方案访问该 URI。 此字段为只读。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNews">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNews;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNews" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNews" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNews As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNews;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNews : string" Usage="System.Uri.UriSchemeNews" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定 URI 是 Internet 新闻组，而且可以通过 Network 新闻传输协议 (NNTP) 进行访问。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例创建一个 <xref:System.Uri> 实例，并确定该方案是否为 <xref:System.Uri.UriSchemeNews> 。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet12":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs" interactive="try-dotnet-method" id="Snippet12":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet12":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNntp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNntp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNntp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNntp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNntp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNntp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNntp : string" Usage="System.Uri.UriSchemeNntp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定 URI 是 Internet 新闻组，而且可以通过 Network 新闻传输协议 (NNTP) 进行访问。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri>.NET Framework 版本1.1 中的 NNTP 分析错误已更正。
  
## Examples  
 下面的示例创建一个 <xref:System.Uri> 实例，并确定该方案是否为 <xref:System.Uri.UriSchemeNntp> 。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet13"::: 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs" interactive="try-dotnet-method" id="Snippet13":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet13":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserEscaped">
      <MemberSignature Language="C#" Value="public bool UserEscaped { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UserEscaped" />
      <MemberSignature Language="DocId" Value="P:System.Uri.UserEscaped" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserEscaped As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UserEscaped { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UserEscaped : bool" Usage="System.Uri.UserEscaped" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 URI 字符串是否在创建 <see cref="T:System.Uri" /> 实例之前已被完全转义。</summary>
        <value><see langword="true" /> 如果在 <paramref name="dontEscape" /> <see langword="true" /> 创建实例时参数设置为 <see cref="T:System.Uri" /> ，则为; 否则为 <see langword="false" /> 。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将 <xref:System.Uri.UserEscaped%2A> 属性设置为 `true` ，以指示用于创建实例的字符串 <xref:System.Uri> 在传递到构造函数之前已完全转义; 即 `dontEscape` 构造函数调用的参数设置为 `true` 。
  
## Examples  
 下面的示例创建一个 <xref:System.Uri> 实例，并确定它在创建后是否已完全转义。  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet18":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs" interactive="try-dotnet-method" id="Snippet18":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet18":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserInfo">
      <MemberSignature Language="C#" Value="public string UserInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserInfo" />
      <MemberSignature Language="DocId" Value="P:System.Uri.UserInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserInfo As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserInfo { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserInfo : string" Usage="System.Uri.UserInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用户名、密码或其他与指定 URI 关联的特定于用户的信息。</summary>
        <value>与 URI 关联的用户信息。 返回值不包括“@”字符，该字符是一个保留字符，用于分隔 URI 的用户信息部分。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回的值的格式通常为 "userName： password"。
  
## Examples  
 下面的示例创建一个 <xref:System.Uri> 实例，并将用户信息写入控制台。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp" id="Snippet18":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs" interactive="try-dotnet-method" id="Snippet18":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb" id="Snippet18"::: 

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
