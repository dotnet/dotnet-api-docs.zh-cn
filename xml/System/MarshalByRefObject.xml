<Type Name="MarshalByRefObject" FullName="System.MarshalByRefObject">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c7b684e8690ecc61f52a698abd2e7f278f906a6a" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86687438" /></Metadata><TypeSignature Language="C#" Value="public abstract class MarshalByRefObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit MarshalByRefObject extends System.Object" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.MarshalByRefObject" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MarshalByRefObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class MarshalByRefObject abstract" />
  <TypeSignature Language="F#" Value="type MarshalByRefObject = class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit MarshalByRefObject extends System.Object" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit MarshalByRefObject extends System.Object" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="abb99-101">在支持远程处理的应用程序中，允许跨应用程序域边界访问对象。</span><span class="sxs-lookup"><span data-stu-id="abb99-101">Enables access to objects across application domain boundaries in applications that support remoting.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="abb99-102">应用程序域是在一个或多个应用程序所驻留的操作系统进程中的分区。</span><span class="sxs-lookup"><span data-stu-id="abb99-102">An application domain is a partition in an operating system process where one or more applications reside.</span></span> <span data-ttu-id="abb99-103">同一应用程序域中的对象直接通信。</span><span class="sxs-lookup"><span data-stu-id="abb99-103">Objects in the same application domain communicate directly.</span></span> <span data-ttu-id="abb99-104">不同应用程序域中的对象通过跨应用程序域边界传输对象的副本或通过使用代理交换消息进行通信。</span><span class="sxs-lookup"><span data-stu-id="abb99-104">Objects in different application domains communicate either by transporting copies of objects across application domain boundaries, or by using a proxy to exchange messages.</span></span>  
  
 <span data-ttu-id="abb99-105"><xref:System.MarshalByRefObject> 对象的基类，这些对象通过使用代理交换消息来跨应用程序域边界进行通信。</span><span class="sxs-lookup"><span data-stu-id="abb99-105"><xref:System.MarshalByRefObject> is the base class for objects that communicate across application domain boundaries by exchanging messages using a proxy.</span></span> <span data-ttu-id="abb99-106">不从继承的对象 <xref:System.MarshalByRefObject> 通过值隐式封送。</span><span class="sxs-lookup"><span data-stu-id="abb99-106">Objects that do not inherit from <xref:System.MarshalByRefObject> are implicitly marshal by value.</span></span> <span data-ttu-id="abb99-107">当远程应用程序按值对象引用封送时，将跨应用程序域边界传递对象的副本。</span><span class="sxs-lookup"><span data-stu-id="abb99-107">When a remote application references a marshal by value object, a copy of the object is passed across application domain boundaries.</span></span>  
  
 <span data-ttu-id="abb99-108"><xref:System.MarshalByRefObject> 直接在本地应用程序域的边界内访问对象。</span><span class="sxs-lookup"><span data-stu-id="abb99-108"><xref:System.MarshalByRefObject> objects are accessed directly within the boundaries of the local application domain.</span></span> <span data-ttu-id="abb99-109">当远程应用程序域中的应用程序第一次访问时 <xref:System.MarshalByRefObject> ，代理将被传递到远程应用程序。</span><span class="sxs-lookup"><span data-stu-id="abb99-109">The first time an application in a remote application domain accesses a <xref:System.MarshalByRefObject>, a proxy is passed to the remote application.</span></span> <span data-ttu-id="abb99-110">对代理的后续调用将封送回位于本地应用程序域中的对象。</span><span class="sxs-lookup"><span data-stu-id="abb99-110">Subsequent calls on the proxy are marshaled back to the object residing in the local application domain.</span></span>  
  
 <span data-ttu-id="abb99-111"><xref:System.MarshalByRefObject>当跨应用程序域边界使用类型时，类型必须从继承，而不能复制对象的状态，因为对象的成员在创建它们的应用程序域之外不可用。</span><span class="sxs-lookup"><span data-stu-id="abb99-111">Types must inherit from <xref:System.MarshalByRefObject> when the type is used across application domain boundaries, and the state of the object must not be copied because the members of the object are not usable outside the application domain where they were created.</span></span>  
  
 <span data-ttu-id="abb99-112">从派生对象 <xref:System.MarshalByRefObject> 以供跨应用程序域边界使用时，不应重写其任何成员，也不应直接调用其方法。</span><span class="sxs-lookup"><span data-stu-id="abb99-112">When you derive an object from <xref:System.MarshalByRefObject> for use across application domain boundaries, you should not override any of its members, nor should you call its methods directly.</span></span> <span data-ttu-id="abb99-113">运行时识别派生自的类  <xref:System.MarshalByRefObject> 应跨应用程序域边界进行封送处理。</span><span class="sxs-lookup"><span data-stu-id="abb99-113">The runtime recognizes that classes derived from  <xref:System.MarshalByRefObject> should be marshaled across app domain boundaries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="abb99-114">本部分包含两个代码示例。</span><span class="sxs-lookup"><span data-stu-id="abb99-114">This section contains two code examples.</span></span> <span data-ttu-id="abb99-115">第一个代码示例演示如何在另一个应用程序域中创建类的实例。</span><span class="sxs-lookup"><span data-stu-id="abb99-115">The first code example shows how to create an instance of a class in another application domain.</span></span> <span data-ttu-id="abb99-116">第二个代码示例演示可用于远程处理的简单类。</span><span class="sxs-lookup"><span data-stu-id="abb99-116">The second code example shows a simple class that can be used for remoting.</span></span>  
  
 <span data-ttu-id="abb99-117">**示例 1**</span><span class="sxs-lookup"><span data-stu-id="abb99-117">**Example 1**</span></span>  
  
 <span data-ttu-id="abb99-118">下面的代码示例演示了在其他应用程序域中执行代码的最简单方法。</span><span class="sxs-lookup"><span data-stu-id="abb99-118">The following code example shows the simplest way to execute code in another application domain.</span></span> <span data-ttu-id="abb99-119">该示例定义一个名为的类，该类 `Worker` 继承 <xref:System.MarshalByRefObject> ，其中包含一个方法，该方法显示了在其中执行它的应用程序域的名称。</span><span class="sxs-lookup"><span data-stu-id="abb99-119">The example defines a class named `Worker` that inherits <xref:System.MarshalByRefObject>, with a method that displays the name of the application domain in which it is executing.</span></span> <span data-ttu-id="abb99-120">该示例 `Worker` 在默认应用程序域和新的应用程序域中创建的实例。</span><span class="sxs-lookup"><span data-stu-id="abb99-120">The example creates instances of `Worker` in the default application domain and in a new application domain.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="abb99-121">必须将包含的程序集 `Worker` 加载到这两个应用程序域中，但它可能会加载仅存在于新应用程序域中的其他程序集。</span><span class="sxs-lookup"><span data-stu-id="abb99-121">The assembly that contains `Worker` must be loaded into both application domains, but it could load other assemblies that would exist only in the new application domain.</span></span>  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 <span data-ttu-id="abb99-122">**示例 2**</span><span class="sxs-lookup"><span data-stu-id="abb99-122">**Example 2**</span></span>  
  
 <span data-ttu-id="abb99-123">下面的示例演示一个派生自 <xref:System.MarshalByRefObject> 的类，该类稍后将在远程处理中使用。</span><span class="sxs-lookup"><span data-stu-id="abb99-123">The following example demonstrates a class derived from <xref:System.MarshalByRefObject> that is used later in remoting.</span></span>  
  
 [!code-cpp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/cpp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CPP/source.cpp#1)]
 [!code-csharp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/csharp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CS/source.cs#1)]
 [!code-vb[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MarshalByRefObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MarshalByRefObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="abb99-124">初始化 <see cref="T:System.MarshalByRefObject" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="abb99-124">Initializes a new instance of the <see cref="T:System.MarshalByRefObject" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjRef">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.Remoting.ObjRef CreateObjRef (Type requestedType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjRef CreateObjRef(class System.Type requestedType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.CreateObjRef(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateObjRef (requestedType As Type) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjRef ^ CreateObjRef(Type ^ requestedType);" />
      <MemberSignature Language="F#" Value="abstract member CreateObjRef : Type -&gt; System.Runtime.Remoting.ObjRef&#xA;override this.CreateObjRef : Type -&gt; System.Runtime.Remoting.ObjRef" Usage="marshalByRefObject.CreateObjRef requestedType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestedType" Type="System.Type" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="requestedType"><span data-ttu-id="abb99-125">新的 <see cref="T:System.Type" /> 将引用的对象的 <see cref="T:System.Runtime.Remoting.ObjRef" />。</span><span class="sxs-lookup"><span data-stu-id="abb99-125">The <see cref="T:System.Type" /> of the object that the new <see cref="T:System.Runtime.Remoting.ObjRef" /> will reference.</span></span></param>
        <summary><span data-ttu-id="abb99-126">创建一个对象，该对象包含生成用于与远程对象进行通信的代理所需的全部相关信息。</span><span class="sxs-lookup"><span data-stu-id="abb99-126">Creates an object that contains all the relevant information required to generate a proxy used to communicate with a remote object.</span></span></summary>
        <returns><span data-ttu-id="abb99-127">生成代理所需要的信息。</span><span class="sxs-lookup"><span data-stu-id="abb99-127">Information required to generate a proxy.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="abb99-128"><xref:System.MarshalByRefObject.CreateObjRef%2A>方法由远程对象创建方法（如和）调用 <xref:System.AppDomain.CreateInstance%2A?displayProperty=nameWithType> <xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="abb99-128">The <xref:System.MarshalByRefObject.CreateObjRef%2A> method is called by remote object creation methods such as <xref:System.AppDomain.CreateInstance%2A?displayProperty=nameWithType> and <xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="abb99-129">在大多数情况下，不需要重写此方法。</span><span class="sxs-lookup"><span data-stu-id="abb99-129">In most cases, there is no need to override this method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException"><span data-ttu-id="abb99-130">此实例不是有效的远程处理对象。</span><span class="sxs-lookup"><span data-stu-id="abb99-130">This instance is not a valid remoting object.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="abb99-131">直接调用方没有基础结构权限。</span><span class="sxs-lookup"><span data-stu-id="abb99-131">The immediate caller does not have infrastructure permission.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetLifetimeService">
      <MemberSignature Language="C#" Value="public object GetLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetLifetimeService() cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.GetLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetLifetimeService();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.GetLifetimeService : unit -&gt; obj" Usage="marshalByRefObject.GetLifetimeService " FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetLifetimeService() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetLifetimeService();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetLifetimeService : unit -&gt; obj&#xA;override this.GetLifetimeService : unit -&gt; obj" Usage="marshalByRefObject.GetLifetimeService " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="abb99-132">检索控制此实例的生存期策略的当前生存期服务对象。</span><span class="sxs-lookup"><span data-stu-id="abb99-132">Retrieves the current lifetime service object that controls the lifetime policy for this instance.</span></span></summary>
        <returns><span data-ttu-id="abb99-133"><see cref="T:System.Runtime.Remoting.Lifetime.ILease" /> 类型的对象，用于控制此实例的生存期策略。</span><span class="sxs-lookup"><span data-stu-id="abb99-133">An object of type <see cref="T:System.Runtime.Remoting.Lifetime.ILease" /> used to control the lifetime policy for this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="abb99-134">有关生存期服务的详细信息，请参阅 <xref:System.Runtime.Remoting.Lifetime.LifetimeServices> 类。</span><span class="sxs-lookup"><span data-stu-id="abb99-134">For more information about lifetime services, see the <xref:System.Runtime.Remoting.Lifetime.LifetimeServices> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="abb99-135">直接调用方没有基础结构权限。</span><span class="sxs-lookup"><span data-stu-id="abb99-135">The immediate caller does not have infrastructure permission.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public virtual object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InitializeLifetimeService();" />
      <MemberSignature Language="F#" Value="abstract member InitializeLifetimeService : unit -&gt; obj&#xA;override this.InitializeLifetimeService : unit -&gt; obj" Usage="marshalByRefObject.InitializeLifetimeService " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="abb99-136">获取生存期服务对象来控制此实例的生存期策略。</span><span class="sxs-lookup"><span data-stu-id="abb99-136">Obtains a lifetime service object to control the lifetime policy for this instance.</span></span></summary>
        <returns><span data-ttu-id="abb99-137"><see cref="T:System.Runtime.Remoting.Lifetime.ILease" /> 类型的对象，用于控制此实例的生存期策略。</span><span class="sxs-lookup"><span data-stu-id="abb99-137">An object of type <see cref="T:System.Runtime.Remoting.Lifetime.ILease" /> used to control the lifetime policy for this instance.</span></span> <span data-ttu-id="abb99-138">这是此实例当前的生存期服务对象（如果存在）；否则为初始化为 <see cref="P:System.Runtime.Remoting.Lifetime.LifetimeServices.LeaseManagerPollTime" /> 属性的值的新生存期服务对象。</span><span class="sxs-lookup"><span data-stu-id="abb99-138">This is the current lifetime service object for this instance if one exists; otherwise, a new lifetime service object initialized to the value of the <see cref="P:System.Runtime.Remoting.Lifetime.LifetimeServices.LeaseManagerPollTime" /> property.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="abb99-139">有关生存期服务的详细信息，请参阅 <xref:System.Runtime.Remoting.Lifetime.LifetimeServices> 类。</span><span class="sxs-lookup"><span data-stu-id="abb99-139">For more information about lifetime services, see the <xref:System.Runtime.Remoting.Lifetime.LifetimeServices> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="abb99-140">下面的代码示例演示如何创建租约。</span><span class="sxs-lookup"><span data-stu-id="abb99-140">The following code example demonstrates creating a lease.</span></span>  
  
 [!code-cpp[Classic MarshalByRefObject.InitializeLifetimeService Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MarshalByRefObject.InitializeLifetimeService Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MarshalByRefObject.InitializeLifetimeService Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MarshalByRefObject.InitializeLifetimeService Example/CS/source.cs#1)]
 [!code-vb[Classic MarshalByRefObject.InitializeLifetimeService Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MarshalByRefObject.InitializeLifetimeService Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="abb99-141">直接调用方没有基础结构权限。</span><span class="sxs-lookup"><span data-stu-id="abb99-141">The immediate caller does not have infrastructure permission.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberwiseClone">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="abb99-142">创建当前对象的卷影副本。</span><span class="sxs-lookup"><span data-stu-id="abb99-142">Creates a shallow copy of the current object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected MarshalByRefObject MemberwiseClone (bool cloneIdentity);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.MarshalByRefObject MemberwiseClone(bool cloneIdentity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.MemberwiseClone(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone (cloneIdentity As Boolean) As MarshalByRefObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MarshalByRefObject ^ MemberwiseClone(bool cloneIdentity);" />
      <MemberSignature Language="F#" Value="override this.MemberwiseClone : bool -&gt; MarshalByRefObject" Usage="marshalByRefObject.MemberwiseClone cloneIdentity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.MarshalByRefObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cloneIdentity" Type="System.Boolean" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="cloneIdentity"><span data-ttu-id="abb99-143">如果要删除当前 <see cref="T:System.MarshalByRefObject" /> 对象的标识，则为 <see langword="false" />，这使该对象在跨远程边界封送时分配一个新标识。</span><span class="sxs-lookup"><span data-stu-id="abb99-143"><see langword="false" /> to delete the current <see cref="T:System.MarshalByRefObject" /> object's identity, which will cause the object to be assigned a new identity when it is marshaled across a remoting boundary.</span></span> <span data-ttu-id="abb99-144">值 <see langword="false" /> 通常比较合适。</span><span class="sxs-lookup"><span data-stu-id="abb99-144">A value of <see langword="false" /> is usually appropriate.</span></span> <span data-ttu-id="abb99-145">如果为 <see langword="true" />，则将当前 <see cref="T:System.MarshalByRefObject" /> 对象的标识复制到它的克隆项，这会将远程客户端调用路由到远程服务器对象。</span><span class="sxs-lookup"><span data-stu-id="abb99-145"><see langword="true" /> to copy the current <see cref="T:System.MarshalByRefObject" /> object's identity to its clone, which will cause remoting client calls to be routed to the remote server object.</span></span></param>
        <summary><span data-ttu-id="abb99-146">创建当前 <see cref="T:System.MarshalByRefObject" /> 对象的浅表副本。</span><span class="sxs-lookup"><span data-stu-id="abb99-146">Creates a shallow copy of the current <see cref="T:System.MarshalByRefObject" /> object.</span></span></summary>
        <returns><span data-ttu-id="abb99-147">当前 <see cref="T:System.MarshalByRefObject" /> 对象的浅表副本。</span><span class="sxs-lookup"><span data-stu-id="abb99-147">A shallow copy of the current <see cref="T:System.MarshalByRefObject" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="abb99-148">方法创建一个 <xref:System.MarshalByRefObject.MemberwiseClone%28System.Boolean%29> 浅表副本，方法是创建一个新的 <xref:System.MarshalByRefObject> 对象，然后将当前对象的非静态字段复制 <xref:System.MarshalByRefObject> 到新的对象。</span><span class="sxs-lookup"><span data-stu-id="abb99-148">The <xref:System.MarshalByRefObject.MemberwiseClone%28System.Boolean%29> method creates a shallow copy by creating a new <xref:System.MarshalByRefObject> object, and then copying the nonstatic fields of the current <xref:System.MarshalByRefObject> object to the new object.</span></span> <span data-ttu-id="abb99-149">如果字段是值类型，则执行字段的逐位副本。</span><span class="sxs-lookup"><span data-stu-id="abb99-149">If a field is a value type, a bit-by-bit copy of the field is performed.</span></span> <span data-ttu-id="abb99-150">如果字段是引用类型，则会复制引用，但不会复制引用的对象;因此，原始对象及其复本引用相同的对象。</span><span class="sxs-lookup"><span data-stu-id="abb99-150">If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.</span></span>  
  
 <span data-ttu-id="abb99-151">例如，假设有一个 <xref:System.MarshalByRefObject> 名为 X 的对象引用对象 a 和 b。对象 b 反过来引用对象 C。X 的浅表副本创建新的对象 X2，后者同时引用对象 A 和 B。与之相比，X 的深层副本会创建一个新的对象 X2，该对象引用作为 A 和 B 的副本的新对象 A2 和 B2，进而引用新的对象 C2，这是一个副本 C。使用一个实现接口的类 <xref:System.ICloneable> 来执行对象的深层或浅表复制。</span><span class="sxs-lookup"><span data-stu-id="abb99-151">For example, consider a <xref:System.MarshalByRefObject> object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy C. Use a class that implements the <xref:System.ICloneable> interface to perform a deep or shallow copy of an object.</span></span>  
  
 <span data-ttu-id="abb99-152">对象的标识 <xref:System.MarshalByRefObject> 定义为作为远程处理客户端调用目标的远程服务器对象。</span><span class="sxs-lookup"><span data-stu-id="abb99-152">The identity of a <xref:System.MarshalByRefObject> object is defined as the remote server object that is the target of a remoting client call.</span></span> <span data-ttu-id="abb99-153">默认情况下，对象的按成员克隆 <xref:System.MarshalByRefObject> 具有与原始对象相同的标识，对于跨远程处理边界封送到客户端的服务器端对象的克隆，这通常不是正确的行为。</span><span class="sxs-lookup"><span data-stu-id="abb99-153">By default, the memberwise clone of a <xref:System.MarshalByRefObject> object has the same identity as the original object, which is typically not the correct behavior for clones of server-side objects that are marshaled across a remoting boundary to the client side.</span></span> <span data-ttu-id="abb99-154">指定 `false` 通常情况下，如果要删除克隆的标识并导致在跨远程处理边界封送克隆时分配新标识，或者 `true` 使克隆保留原始对象的标识，这通常是适当的。 <xref:System.MarshalByRefObject></span><span class="sxs-lookup"><span data-stu-id="abb99-154">Specify `false`, which is usually appropriate, to delete the identity of the clone and cause a new identity to be assigned when the clone is marshaled across a remoting boundary, or `true` to cause the clone to retain the identity of the original <xref:System.MarshalByRefObject> object.</span></span> <span data-ttu-id="abb99-155"><xref:System.MarshalByRefObject.MemberwiseClone%28System.Boolean%29>方法旨在供实现远程服务器对象的开发人员使用。</span><span class="sxs-lookup"><span data-stu-id="abb99-155">The <xref:System.MarshalByRefObject.MemberwiseClone%28System.Boolean%29> method is intended to be used by developers implementing remote server objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
