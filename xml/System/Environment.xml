<Type Name="Environment" FullName="System.Environment">
  <Metadata><Meta Name="ms.openlocfilehash" Value="60ac0541005ca81317b7cb9da69ff8d4c12794ae" /><Meta Name="ms.sourcegitcommit" Value="ff93f301301180af9a0213650c5b4edb28570fd0" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/18/2020" /><Meta Name="ms.locfileid" Value="88557091" /></Metadata><TypeSignature Language="C#" Value="public static class Environment" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Environment extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="DocId" Value="T:System.Environment" />
  <TypeSignature Language="VB.NET" Value="Public Class Environment" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class Environment abstract sealed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Environment = class" />
  <TypeSignature Language="C#" Value="public sealed class Environment" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Environment extends System.Object" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Environment" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class Environment sealed" FrameworkAlternate="netframework-1.1" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime.Extensions" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Runtime.Extensions" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供有关当前环境和平台的信息以及操作它们的方法。 此类不能被继承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Environment> 类可以检索信息，如命令行参数、退出代码、环境变量设置、调用堆栈的内容、自上次系统启动以来的时间和公共语言运行时的版本。
  
## Examples  
 下面的示例演示如何显示有关当前环境的信息列表。  
  
 [!code-cpp[environment.class#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.class/CPP/env0.cpp#1)]
 [!code-csharp[environment.class#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.class/CS/env0.cs#1)]
 [!code-vb[environment.class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.class/VB/env0.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CommandLine">
      <MemberSignature Language="C#" Value="public static string CommandLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommandLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CommandLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommandLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommandLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommandLine : string" Usage="System.Environment.CommandLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取该进程的命令行。</summary>
        <value>包含命令行参数的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性提供对程序名称和当前进程启动时在命令行上指定的任何参数的访问。  
  
 程序名称可以包含路径信息，但这不是必需的。 使用 <xref:System.Environment.GetCommandLineArgs%2A> 方法检索已分析并存储在字符串数组中的命令行信息。  
  
 命令行缓冲区的最大大小未设置为特定数量的字符;这取决于计算机上运行的 Windows 操作系统。
  
## Examples  
 下面的示例显示其自己的命令行。  
  
 [!code-cpp[environment.commandline#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.CommandLine/CPP/commandline.cpp#1)]
 [!code-csharp[environment.commandline#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.CommandLine/CS/commandline.cs#1)]
 [!code-vb[environment.commandline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.CommandLine/VB/commandline.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public static string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDirectory : string with get, set" Usage="System.Environment.CurrentDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前工作目录的完全限定路径。</summary>
        <value>目录路径。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 按照定义，如果此进程在本地或网络驱动器的根目录下启动，则此属性的值为驱动器名称后跟尾随斜杠 (例如，"C： \\ " ) 。 如果此过程在子目录中启动，则此属性的值为驱动器和子目录路径，无尾随斜杠 (例如，"C:\mySubDirectory" ) 。
  
## Examples  
 下面的示例演示如何设置 <xref:System.Environment.CurrentDirectory%2A> 属性。  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">已尝试设置为空字符串 ("")。</exception>
        <exception cref="T:System.ArgumentNullException">已尝试设置为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">已尝试设置一个找不到的本地路径。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有相应的权限。</exception>
      </Docs>
    </Member>
    <Member MemberName="CurrentManagedThreadId">
      <MemberSignature Language="C#" Value="public static int CurrentManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CurrentManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CurrentManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentManagedThreadId : int" Usage="System.Environment.CurrentManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前托管线程的唯一标识符。</summary>
        <value>此托管线程的唯一标识符。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.Exit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(int exitCode);" />
      <MemberSignature Language="F#" Value="static member Exit : int -&gt; unit" Usage="System.Environment.Exit exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DoesNotReturn]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DoesNotReturn&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="exitCode">返回到操作系统的退出代码。 使用 0（零）指示处理已成功完成。</param>
        <summary>终止此进程，并将退出代码返回到操作系统。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于 `exitCode` 参数，请使用非零数字来指示错误。 在应用程序中，你可以在枚举中定义自己的错误代码，并根据方案返回相应的错误代码。 例如，返回的值为1，表示所需的文件不存在，值为2，表示该文件的格式不正确。 有关 Windows 操作系统使用的退出代码的列表，请参阅 Windows 文档中的 " [系统错误代码](/windows/win32/debug/system-error-codes) "。  
  
 调用 <xref:System.Environment.Exit%2A> 方法不同于通过以下方式使用编程语言的 `return` 语句：  
  
-   <xref:System.Environment.Exit%2A> 始终终止应用程序。 `return`仅当应用程序入口点（例如方法）中使用了应用程序时，才能使用该语句终止应用程序 `Main` 。  
  
-   <xref:System.Environment.Exit%2A> 立即终止应用程序，即使其他线程正在运行也是如此。 如果 `return` 在应用程序入口点调用该语句，则会使应用程序仅在所有前台线程终止后终止。  
  
-   <xref:System.Environment.Exit%2A> 要求调用方具有调用非托管代码的权限。 `return`语句不会。  
  
-   如果 <xref:System.Environment.Exit%2A> 从 `try` 或 `catch` 块调用，则 `finally` 不会执行任何块中的代码。 如果 `return` 使用语句，则块中的代码 `finally` 执行。  
  
-   如果在 <xref:System.Environment.Exit%2A> [受约束的执行区域](/dotnet/framework/performance/constrained-execution-regions) 中的代码 (CER) 正在运行时调用，则 cer 将不会完成执行。 如果 `return` 使用语句，则 CER 将完成执行。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用方没有足够的安全权限来执行此函数。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public static int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.Environment.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[set: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置进程的退出代码。</summary>
        <value>包含退出代码的 32 位有符号整数。 默认值为 0（零），这指示已成功完成处理。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果该 `Main` 方法返回 `void` ，则可以使用此属性来设置将返回到调用环境中的退出代码。 如果 `Main` 未返回 `void` ，则忽略此属性。 此属性的初始值为零。  
  
> [!WARNING]
>  该 <xref:System.Environment.ExitCode%2A> 属性是一个有符号的32位整数。 若要防止属性返回一个负的退出代码，则不应使用大于或等于0x80000000 的值。  
  
 使用非零值表示错误。 在应用程序中，你可以在枚举中定义自己的错误代码，并根据方案返回相应的错误代码。 例如，返回的值为1，表示所需的文件不存在，值为2，表示该文件的格式不正确。 有关 Windows 操作系统使用的退出代码的列表，请参阅 Windows 文档中的 " [系统错误代码](/windows/win32/debug/system-error-codes) "。
  
## Examples  
 下面是一个名为 Double.exe 的简单应用，它将作为命令行参数传递给它的整数值加倍。 值将错误代码分配给 <xref:System.Environment.ExitCode%2A> 属性，以指示错误条件。 请注意，必须添加对 System.Numerics.dll 程序集的引用才能成功编译此示例。  
  
 [!code-csharp[System.Environment.ExitCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double.cs#1)]
 [!code-vb[System.Environment.ExitCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double.vb#1)]  
  
 然后，可以从如下所示的批处理文件中调用该示例，这使其错误代码可以通过使用命令来访问 `ERRORLEVEL` 。  
  
```
echo off  
Double.exe %1  
If errorlevel 1639 goto NoArg   
if errorlevel 534 goto Overflow  
if errorlevel 160 goto BadArg  
if errorlevel 0 echo Completed Successfully   
goto :EOF  
  
:NoArg  
echo Missing argument  
goto :EOF  
  
: Overflow  
echo Arithmetic overflow  
goto :EOF  
  
:BadArg  
echo Invalid argument  
goto :EOF
```
  
 下面显示了通过调用批处理文件而产生的一些示例输出。  
  
```
>getdouble 123>echo offResult: 246Completed Successfully>getdouble 5912323109093>echo offArithmetic overflow>getdouble>echo offMissing argument>getdouble "a string">echo offInvalid argument
```
  
 请注意，Double.exe 的代码在函数中与下面的示例相同，不同之处在于前者定义了一个名为 `Main` 且没有返回值的入口点，而此示例定义了一个名为的入口点， `Main` 它返回整数。  
  
 [!code-csharp[System.Environment.ExitCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double1.cs#2)]
 [!code-vb[System.Environment.ExitCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpandEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static string ExpandEnvironmentVariables (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ExpandEnvironmentVariables(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.ExpandEnvironmentVariables(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExpandEnvironmentVariables (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ExpandEnvironmentVariables(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member ExpandEnvironmentVariables : string -&gt; string" Usage="System.Environment.ExpandEnvironmentVariables name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">包含零个或多个环境变量名的字符串。 每个环境变量都用百分号 (%) 引起来。</param>
        <summary>将嵌入到指定字符串中的每个环境变量的名称替换为该变量的值的等效字符串，然后返回结果字符串。</summary>
        <returns>一个字符串，其中的每个环境变量均被替换为该变量的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 COM 互操作用于从操作系统检索环境变量。 如果由于 COM 错误而无法检索环境变量，则将使用用于说明失败原因的 HRESULT 来生成几个可能的异常之一;也就是说，异常依赖于 HRESULT。 有关如何处理 HRESULT 的详细信息，请参阅方法的 "备注" 部分 <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A?displayProperty=nameWithType> 。  
  
 仅对设置的环境变量进行替换。 例如，假设 `name` 为 "MyENV =% MyENV%"。 如果环境变量 MyENV 设置为42，则此方法将返回 "MyENV = 42"。 如果未设置 MyENV，则不进行任何更改;此方法返回 "MyENV =% MyENV%"。  
  
 返回值的大小限制为32K。
  
## Examples  
 下面的示例演示如何获取系统驱动器和系统根变量。  
  
 [!code-cpp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CPP/expandenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CS/expandenvironmentvariables.cs#1)]
 [!code-vb[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/VB/expandenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FailFast">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向 Windows 的应用程序事件日志写入消息后立即终止进程，然后在发往 Microsoft 的错误报告中加入该消息和可选的异常信息。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FailFast (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member FailFast : string -&gt; unit" Usage="System.Environment.FailFast message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DoesNotReturn]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DoesNotReturn&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="message">一条解释进程终止原因的消息；如果未提供解释，则为 <see langword="null" />。</param>
        <summary>向 Windows 的应用程序事件日志写入消息后立即终止进程，然后在发往 Microsoft 的错误报告中加入该消息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法终止进程，而不运行任何活动 `try` / `finally` 的块或终结器。
  
 `Environment.FailFast`方法将字符串写入 `message` Windows 应用程序事件日志，创建应用程序的转储，然后终止当前进程。 此 `message` 字符串也包含在向 Microsoft 报告错误。  
  
 使用 `Environment.FailFast` 方法而不是 <xref:System.Environment.Exit%2A> 方法来终止应用程序，前提是应用程序的状态已损坏，无法修复，执行应用程序的 `try` / `finally` 块和终结器将损坏程序资源。  
  
 使用 Windows 错误报告向 Microsoft 报告信息。 有关详细信息，请参阅 [Windows 错误报告：入门](/windows-hardware/drivers/dashboard/)。  

调用 `Environment.FailFast` 方法以终止在 Visual Studio 调试器中运行的应用程序的执行会引发 <xref:System.ExecutionEngineException> ，并自动触发 [fatalExecutionEngineError 托管调试助手 (MDA) ](https://github.com/dotnet/docs/blob/master/docs/framework/debug-trace-profile/fatalexecutionengineerror-mda.md)。
  
## Examples  
 下面的示例向 Windows 应用程序事件日志中写入一个日志项，并终止当前进程。  
  
 [!code-csharp[environment.FailFast#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.FailFast/cs/ff.cs#1)]
 [!code-vb[environment.FailFast#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.FailFast/vb/ff.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message, Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message, class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FailFast (message As String, exception As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message, Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FailFast : string * Exception -&gt; unit" Usage="System.Environment.FailFast (message, exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DoesNotReturn]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DoesNotReturn&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="exception" Type="System.Exception" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="message">一条解释进程终止原因的消息；如果未提供解释，则为 <see langword="null" />。</param>
        <param name="exception">一个异常，表示导致终止的错误。 通常这是 <see langword="catch" /> 块中的异常。</param>
        <summary>向 Windows 的应用程序事件日志写入消息后立即终止进程，然后在发往 Microsoft 的错误报告中加入该消息和异常信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法终止进程，而不运行任何活动 `try` / `finally` 的块或终结器。  
  
 `Environment.FailFast`方法将字符串写入 `message` Windows 应用程序事件日志，创建应用程序的转储，然后终止当前进程。  
  
 使用 Windows 错误报告向 Microsoft 报告信息。 有关详细信息，请参阅 [Windows 错误报告：入门](/windows-hardware/drivers/dashboard/)。 向 Microsoft 提供错误报告包括 `message` 和 `exception` 信息，其中提供了用于分类错误的详细信息。 尽管 `exception` 因为进程已终止而未进行处理，但仍会获取引发异常的上下文信息。  
  
 如果 `exception` 为 `null` ，或者 `exception` 不引发，则此方法与方法重载的操作相同 <xref:System.Environment.FailFast%28System.String%29> 。  
  
 使用 `Environment.FailFast` 方法而不是 <xref:System.Environment.Exit%2A> 方法来终止应用程序，前提是应用程序的状态已损坏，无法修复，执行应用程序的 `try` / `finally` 块和终结器将损坏程序资源。  

调用 `Environment.FailFast` 方法以终止在 Visual Studio 调试器中运行的应用程序的执行会引发 <xref:System.ExecutionEngineException> ，并自动触发 [fatalExecutionEngineError 托管调试助手 (MDA) ](https://github.com/dotnet/docs/blob/master/docs/framework/debug-trace-profile/fatalexecutionengineerror-mda.md)。
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCommandLineArgs">
      <MemberSignature Language="C#" Value="public static string[] GetCommandLineArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetCommandLineArgs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetCommandLineArgs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCommandLineArgs () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetCommandLineArgs();" />
      <MemberSignature Language="F#" Value="static member GetCommandLineArgs : unit -&gt; string[]" Usage="System.Environment.GetCommandLineArgs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回包含当前进程的命令行自变量的字符串数组。</summary>
        <returns>字符串数组，其中的每个元素都包含一个命令行自变量。 第一个元素是可执行文件名，后面的零个或多个元素包含其余的命令行自变量。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 数组中的第一个元素包含执行程序的文件名。 如果文件名不可用，则第一个元素等于 <xref:System.String.Empty?displayProperty=nameWithType> 。 剩余的元素包含在命令行中输入的任何其他标记。  
  
 程序文件名称可以（但不需要）包含路径信息。  
  
 命令行参数由空格分隔。 您可以使用双引号 ( ") 在参数内包括空格。 但单引号 ( ") 不提供此功能。  
  
 如果双引号后跟两个或偶数个反斜杠，则每个后续反斜杠对将替换为一个反斜杠，并删除双引号。 如果双引号后跟奇数个反斜杠（仅包括一个反斜杠），则前面的每个配对都将替换为一个反斜杠，并删除其余反斜杠;但在这种情况下，不会删除双引号。  
  
 下表显示了如何分隔命令行参数，并将其假定 `MyApp` 为当前正在执行的应用程序。  
  
|命令行中的输入|生成的命令行参数|  
|-------------------------------|--------------------------------------|  
|`MyApp alpha beta`|`MyApp, alpha, beta`|  
|`MyApp "alpha with spaces" "beta with spaces"`|`MyApp, alpha with spaces, beta with spaces`|  
|`MyApp 'alpha with spaces' beta`|`MyApp, 'alpha, with, spaces', beta`|  
|`MyApp \\\alpha \\\\"beta`|`MyApp, \\\alpha, \\beta`|  
|`MyApp \\\\\"alpha \"beta`|`MyApp, \\"alpha, "beta`|  
  
 若要以单个字符串的形式获取命令行，请使用 <xref:System.Environment.CommandLine%2A> 属性。
  
## Examples  
 下面的示例显示应用程序的命令行参数。  
  
 [!code-cpp[Environment.GetCommandLineArgs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CPP/getcommandlineargs.cpp#1)]
 [!code-csharp[Environment.GetCommandLineArgs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CS/getcommandlineargs.cs#1)]
 [!code-vb[Environment.GetCommandLineArgs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetCommandLineArgs/VB/getcommandlineargs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">系统不支持命令行参数。</exception>
        <altmember cref="P:System.Environment.CommandLine" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>检索环境变量的值。</summary>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string -&gt; string" Usage="System.Environment.GetEnvironmentVariable variable" />
      <MemberSignature Language="C#" Value="public static string? GetEnvironmentVariable (string variable);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="variable">环境变量名。</param>
        <summary>从当前进程检索环境变量的值。</summary>
        <returns><paramref name="variable" /> 指定的环境变量的值；或者如果找不到环境变量，则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<xref:System.Environment.GetEnvironmentVariable%28System.String%29>方法只从当前进程的环境块中检索环境变量。 它等效于 <xref:System.Environment.GetEnvironmentVariable%28System.String%2CSystem.EnvironmentVariableTarget%29> 使用值调用方法 `target` <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> 。 

若要检索所有环境变量及其值，请调用 <xref:System.Environment.GetEnvironmentVariables%2A> 方法。  
  
环境变量名称在 Linux 和 macOS 上区分大小写，但在 Windows 上不区分大小写。  
 
### <a name="on-windows-systems"></a>在 Windows 系统上

 在 Windows 系统中，当前进程的环境块包括：
 
- 由创建它的父进程为其提供的所有环境变量。 例如，从控制台窗口启动的 .NET 应用程序继承了控制台窗口的所有环境变量。 

  如果没有父进程，则改用每个计算机和每个用户的环境变量。 例如，新的控制台窗口包含启动时定义的每个计算机和每个用户的环境变量。

- 当进程正在运行时，通过 <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> 使用值调用方法或方法，添加到进程块的任何变量 <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> `target` <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> 。 这些环境变量将一直保持到 .NET 应用程序终止为止。  
  
如果在进程启动之后创建环境变量，则可以使用此方法只检索通过调用 <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> 方法或 <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> 使用 `target` 值的方法创建的那些 <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> 变量。  

### <a name="on-macos-and-linux-systems"></a>在 macOS 和 Linux 系统上

在 macOS 和 Linux 上，当前进程的环境块包含以下环境变量：

- 由创建它的父进程为其提供的所有环境变量。 对于从 shell 启动的 .NET 应用程序，这包括 shell 中定义的所有环境变量。

- 当进程正在运行时，通过 <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> 使用值调用方法或方法，添加到进程块的任何变量 <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> `target` <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> 。 这些环境变量将一直保持到 .NET 应用程序终止为止。  

MacOS 和 Linux 上的 .NET Core 不支持每计算机或每用户环境变量。   
  
## Examples  
 下面的示例使用 <xref:System.Environment.GetEnvironmentVariable%2A> 方法来检索 `windir` 包含 Windows 目录路径的环境变量。  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 下面的示例尝试 `Test1` 从进程环境块中检索名为的环境变量的值。 如果该变量不存在，则该示例将创建其并检索其值。 该示例显示变量的值。 如果该示例创建了变量，它还将对 <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> 枚举的每个成员调用方法， <xref:System.EnvironmentVariableTarget> 以确定只能从当前进程环境块检索变量。 最后，如果该示例创建了变量，则将其删除。  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有执行此操作所需的权限。</exception>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string? GetEnvironmentVariable (string variable, EnvironmentVariableTarget target);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String, target As EnvironmentVariableTarget) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string * EnvironmentVariableTarget -&gt; string" Usage="System.Environment.GetEnvironmentVariable (variable, target)" />
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable, EnvironmentVariableTarget target);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="variable">环境变量名。</param>
        <param name="target"><see cref="T:System.EnvironmentVariableTarget" /> 值之一。 在基于 Unix 的系统上运行的 .NET Core 仅支持 <see cref="F:System.EnvironmentVariableTarget.Process" />。</param>
        <summary>从当前进程或者从当前用户或本地计算机的 Windows 操作系统注册表项检索环境变量的值。</summary>
        <returns><paramref name="variable" /> 和 <paramref name="target" /> 参数指定的环境变量的值；或者如果找不到环境变量，则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks 

若要检索所有环境变量及其值，请调用 <xref:System.Environment.GetEnvironmentVariables%2A> 方法。  
  
环境变量名称在 Linux 和 macOS 上区分大小写，但在 Windows 上不区分大小写。 

### <a name="on-windows-systems"></a>在 Windows 系统上

在 Windows 上， `target` 参数指定是从当前进程还是从当前用户或本地计算机的 Windows 操作系统注册表项检索环境变量。 所有基于用户和每台计算机的环境变量都将自动复制到当前进程的环境块中，这与创建 .NET 进程的父进程可用的任何其他环境变量一样。 但是，通过在 <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> 进程的持续时间内调用方法或方法（其 `target` 值 <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> 仅为持久性），只会将环境变量添加到当前进程的环境块。  
  
### <a name="on-macos-and-linux-systems"></a>在 macOS 和 Linux 系统上

在 macOS 和 Linux 上， `GetEnvironmentVariable(String, EnvironmentVariableTarget)` 方法只支持 `target` 值 <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> 。 `target`不支持值为或的调用 <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> ，返回 `null` 。 

每进程环境变量为：

- 继承自父进程的那些对象，通常是用于调用 `dotnet.exe` 或启动 .net 应用程序的 shell。

- 通过 <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> 使用值调用方法或方法定义的 <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> `target` <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> 。 这些环境变量仅在 `dotnet` 进程或 .net 应用程序终止之前保持。   
  
## Examples

下面的示例为 <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> 、和目标创建环境变量 <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> <xref:System.EnvironmentVariableTarget.Machine> ，检查操作系统注册表是否包含用户和计算机环境变量，然后删除环境变量。 由于基于 Unix 的系统上的 .NET 不支持每用户和每台计算机的环境变量，因此只有 <xref:System.Environment.SetEnvironmentVariable(System.String,System.String)> 和 <xref:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)> 值才能 <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> 成功地将环境变量存储到进程环境块。

[!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs)]
[!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> 不是有效的 <see cref="T:System.EnvironmentVariableTarget" /> 值。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有执行此操作所需的权限。</exception>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariables">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>检索所有环境变量名及其值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables () As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables();" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : unit -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从当前进程检索所有环境变量名及其值。</summary>
        <returns>包含所有环境变量名及其值的字典；如果找不到任何环境变量，则返回空字典。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 环境变量的名称和值作为键值对存储在返回的中 <xref:System.Collections.IDictionary> 。  
  
### <a name="on-windows-systems"></a>在 Windows 系统上

在 Windows 系统上，此 `GetEnvironmentVariables` 方法返回以下环境变量：
  
- 创建进程时定义的每个计算机环境变量及其值。  
  
- 创建进程时定义的所有每用户环境变量及其值。  

- 从父进程继承的任何变量，从该进程中启动 .NET 应用程序，或在进程运行时将其添加到进程块。 通过调用 <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> 方法或 <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> `target` 值为的方法，在进程运行时添加环境变量 <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> 。  

### <a name="on-macos-and-linux-systems"></a>在 macOS 和 Linux 系统上

在 MacOS 和 Linux 上， `GetEnvironmentVariables` 方法会检索从启动进程的父进程中继承的 `dotnet` 或在进程本身的作用域内定义的所有环境变量的名称和值 `dotnet` 。 `dotnet`进程结束后，后面的后一种环境变量将停止存在。 

在基于 Unix 的系统上运行的 .NET Core 不支持每计算机或每用户环境变量。   
  
## Examples  
 下面的示例演示 <xref:System.Environment.GetEnvironmentVariables%2A> 方法。  
  
 [!code-cpp[Environment.GetEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CPP/getenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.GetEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CS/getenvironmentvariables.cs#1)]
 [!code-vb[Environment.GetEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetEnvironmentVariables/VB/getenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用方没有执行此操作所需的权限。</exception>
        <exception cref="T:System.OutOfMemoryException">缓冲区内存不足。</exception>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables (EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables(valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables (target As EnvironmentVariableTarget) As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables(EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : EnvironmentVariableTarget -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.EnvironmentVariableTarget" /> 值之一。 在基于 Unix 的系统上运行的 .NET Core 仅支持 <see cref="F:System.EnvironmentVariableTarget.Process" />。</param>
        <summary>从当前进程或者从当前用户或本地计算机的 Windows 操作系统注册表项检索所有环境变量名及其值。</summary>
        <returns>包含 <paramref name="target" /> 参数所指定的源中所有环境变量名及其值的字典；否则，如果找不到任何环境变量，则返回空字典。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

环境变量的名称和值作为键/值对存储在返回的 <xref:System.Collections.IDictionary> 对象中。  

### <a name="on-windows-systems"></a>在 Windows 系统上

在 Windows 系统上， `target` 参数指定源是否为当前进程、当前用户的注册表项或本地计算机的注册表项。  

### <a name="on-macos-and-linux-systems"></a>在 macOS 和 Linux 系统上

在 macOS 和 Linux 上，只 `target` 支持值 <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> 。 每个进程的环境变量都继承自父进程 (通常是用来启动进程的 shell) ， `dotnet` 还是在进程本身的作用域内定义的 `dotnet` 。 Dotnet 进程结束后，后面的后一种环境变量将停止存在。  

不支持每计算机和每用户环境变量。 `target`值 <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> 或 <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> 返回空数组。
  
## Examples

下面的示例为 <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> 、和目标创建环境变量 <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> <xref:System.EnvironmentVariableTarget.Machine> ，检查操作系统注册表是否包含用户和计算机环境变量，然后删除环境变量。 由于基于 Unix 的系统上的 .NET 不支持每用户和每台计算机的环境变量，因此只有 <xref:System.Environment.SetEnvironmentVariable(System.String,System.String)> 和 <xref:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)> 值才能 <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> 成功地将环境变量存储到进程环境块。

[!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs)]
[!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用方不具有针对 <paramref name="target" /> 的指定值执行此操作的所需权限。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> 包含非法值。</exception>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFolderPath">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取由指定枚举标识的系统特殊文件夹的路径。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder -&gt; string" Usage="System.Environment.GetFolderPath folder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="folder">标识系统特殊文件夹的枚举值之一。</param>
        <summary>获取由指定枚举标识的系统特殊文件夹的路径。</summary>
        <returns>如果指定的系统特殊文件夹实际存在于您的计算机上，则为到该文件夹的路径；否则为空字符串 ("")。  
  
 如果系统未创建文件夹、已删除现有文件夹，或者文件夹是不对应物理路径的虚拟目录（例如"我的电脑"），则该文件夹不会实际存在。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法检索系统特殊文件夹的路径，例如，可用于访问常见信息的程序文件、程序、系统或启动。 默认情况下，特殊文件夹由系统设置，或在安装 Windows 版本时由用户显式设置。  
  
 `folder`参数指定要检索的特殊文件夹，并且必须是枚举中的值之一 <xref:System.Environment.SpecialFolder> ; 其他任何值都会引发异常。  
  
 有关特殊文件夹的详细信息，请参阅 [CSIDL](https://go.microsoft.com/fwlink/?LinkId=116664) 值主题。
  
## Examples  
 下面的示例演示如何使用 <xref:System.Environment.GetFolderPath%2A> 方法返回并显示与参数关联的路径 `folder` 。  
  
 [!code-cpp[Environment.GetFolderPath#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetFolderPath/CPP/getfolderpath.cpp#1)]
 [!code-csharp[Environment.GetFolderPath#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetFolderPath/CS/getfolderpath.cs#1)]
 [!code-vb[Environment.GetFolderPath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetFolderPath/VB/getfolderpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="folder" /> 不是 <see cref="T:System.Environment.SpecialFolder" /> 的成员。</exception>
        <exception cref="T:System.PlatformNotSupportedException">不支持当前平台。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder, Environment.SpecialFolderOption option);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder, valuetype System.Environment/SpecialFolderOption option) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder,System.Environment.SpecialFolderOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder, option As Environment.SpecialFolderOption) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder, Environment::SpecialFolderOption option);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder * Environment.SpecialFolderOption -&gt; string" Usage="System.Environment.GetFolderPath (folder, option)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="option" Type="System.Environment+SpecialFolderOption" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="folder">标识系统特殊文件夹的枚举值之一。</param>
        <param name="option">指定用于访问特殊文件夹的选项的枚举值之一。</param>
        <summary>获取由指定枚举标识的系统特殊文件夹的路径，并使用用于访问特殊文件夹的指定选项。</summary>
        <returns>如果指定的系统特殊文件夹实际存在于您的计算机上，则为到该文件夹的路径；否则为空字符串 ("")。  
  
 如果系统未创建文件夹、已删除现有文件夹，或者文件夹是不对应物理路径的虚拟目录（例如"我的电脑"），则该文件夹不会实际存在。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法检索系统特殊文件夹的路径，例如，可用于访问常见信息的程序文件、程序、系统或启动。 默认情况下，特殊文件夹由系统设置，或在安装 Windows 版本时由用户显式设置。  
  
 `folder`参数指定要检索的特殊文件夹，并且必须是枚举中的值之一 <xref:System.Environment.SpecialFolder> ; 其他任何值都会引发异常。  
  
 有关特殊文件夹的详细信息，请参阅 [CSIDL](https://go.microsoft.com/fwlink/?LinkId=116664) 值主题。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="folder" /> 不是 <see cref="T:System.Environment.SpecialFolder" /> 的成员。
- 或 -

<paramref name="options" /> 不是 <see cref="T:System.Environment.SpecialFolderOption" /> 的成员。</exception>
        <exception cref="T:System.PlatformNotSupportedException">不支持当前平台。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberSignature Language="F#" Value="static member GetLogicalDrives : unit -&gt; string[]" Usage="System.Environment.GetLogicalDrives " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回包含当前计算机中的逻辑驱动器名称的字符串数组。</summary>
        <returns>字符串数组，其中的每个元素都包含逻辑驱动器名称。 例如，如果计算机的硬盘是第一个逻辑驱动器，则返回的第一个元素是“C:\\”。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示如何使用方法显示当前计算机的逻辑驱动器 <xref:System.Environment.GetLogicalDrives%2A> 。  
  
 [!code-cpp[Environment.GetLogicalDrives#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetLogicalDrives/CPP/getlogicaldrives.cpp#1)]
 [!code-csharp[Environment.GetLogicalDrives#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetLogicalDrives/CS/getlogicaldrives.cs#1)]
 [!code-vb[Environment.GetLogicalDrives#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetLogicalDrives/VB/getlogicaldrives.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所需的权限。</exception>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownStarted">
      <MemberSignature Language="C#" Value="public static bool HasShutdownStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool HasShutdownStarted" />
      <MemberSignature Language="DocId" Value="P:System.Environment.HasShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property HasShutdownStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool HasShutdownStarted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownStarted : bool" Usage="System.Environment.HasShutdownStarted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前的应用程序域是否正在卸载或者公共语言运行时 (CLR) 是否正在关闭。</summary>
        <value><see langword="true" /> 如果当前的应用程序域正在卸载或者 CLR 正在关闭，则为;否则为 <see langword="false" /> 。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **仅 .NET Framework**：当 CLR 卸载应用程序域时，它将对在该应用程序域中具有终结器方法的所有对象运行终结器。 CLR 关闭时，它将在具有终结器方法的所有对象上启动终结器线程。 <xref:System.Environment.HasShutdownStarted%2A>属性仅在 `true` 终结器线程启动后返回。 当属性返回时 `true` ，可以通过调用方法来确定应用程序域是否正在卸载或者 CLR 本身是否正在关闭 <xref:System.AppDomain.IsFinalizingForUnload%2A?displayProperty=nameWithType> 。 `true`如果因为应用程序域正在卸载或者 CLR 正在关闭而调用终结器，则此方法返回 `false` 。  
  
 <xref:System.Environment.HasShutdownStarted%2A> `false` 如果终结器线程尚未启动，则属性将返回。  
  
 通过使用此属性，您可以确定是否在终止代码中访问静态变量。 如果应用程序域或 CLR 正在关闭，则无法可靠地访问包含终止方法并且由静态字段引用的任何对象。 这是因为这些对象可能已经完成了。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsFinalizingForUnload" />
      </Docs>
    </Member>
    <Member MemberName="Is64BitOperatingSystem">
      <MemberSignature Language="C#" Value="public static bool Is64BitOperatingSystem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitOperatingSystem" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitOperatingSystem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitOperatingSystem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitOperatingSystem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitOperatingSystem : bool" Usage="System.Environment.Is64BitOperatingSystem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前操作系统是否为 64 位操作系统。</summary>
        <value>如果操作系统为 64 位操作系统，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Is64BitProcess">
      <MemberSignature Language="C#" Value="public static bool Is64BitProcess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitProcess" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitProcess As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitProcess { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitProcess : bool" Usage="System.Environment.Is64BitProcess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前进程是否为 64 位进程。</summary>
        <value>如果进程为 64 位进程，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public static string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Environment.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此本地计算机的 NetBIOS 名称。</summary>
        <value>当前计算机的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在系统启动时，将在从注册表中读取名称时建立此计算机的名称。 如果此计算机是群集中的节点，则返回该节点的名称。
  
## Examples  
 下面的示例显示运行代码示例的计算机的名称。 出于安全原因，示例输出中省略了计算机名称 (。 )   
  
 [!code-cpp[environment.machinename#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.MachineName/CPP/machinename.cpp#1)]
 [!code-csharp[environment.machinename#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.MachineName/CS/machinename.cs#1)]
 [!code-vb[environment.machinename#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.MachineName/VB/machinename.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">无法获取此计算机的名称。</exception>
      </Docs>
    </Member>
    <Member MemberName="NewLine">
      <MemberSignature Language="C#" Value="public static string NewLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string NewLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.NewLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NewLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ NewLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NewLine : string" Usage="System.Environment.NewLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为此环境定义的换行字符串。</summary>
        <value><see langword="\r\n" /> 适用于非 Unix 平台或 <see langword="\n" /> unix 平台。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的属性值 <xref:System.Environment.NewLine%2A> 是专门为当前平台和实现 .NET Framework 而自定义的常量。 有关属性值中转义符的详细信息，请参阅 [字符转义](/dotnet/standard/base-types/character-escapes-in-regular-expressions)。  
  
 所提供的功能 <xref:System.Environment.NewLine%2A> 通常由字词换行符、换行符、换行符、回车符、CRLF 和行尾所指。  
  
 <xref:System.Environment.NewLine%2A> 可以与特定于语言的换行符（如 Microsoft c # 和 C/c + + 中的转义符和 "\n"）或 Microsoft Visual Basic 结合使用 `vbCrLf` 。  
  
 <xref:System.Environment.NewLine%2A> 自动追加到由和方法处理的文本上 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> <xref:System.Text.StringBuilder.AppendLine%2A?displayProperty=nameWithType> 。
  
## Examples  
 下面的示例显示了由换行符分隔的三行。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/Environment.NewLine/CPP/newline.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/Environment.NewLine/CS/newline.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.NewLine/VB/newline.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OSVersion">
      <MemberSignature Language="C#" Value="public static OperatingSystem OSVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.OperatingSystem OSVersion" />
      <MemberSignature Language="DocId" Value="P:System.Environment.OSVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSVersion As OperatingSystem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property OperatingSystem ^ OSVersion { OperatingSystem ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OSVersion : OperatingSystem" Usage="System.Environment.OSVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.OperatingSystem</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前平台标识符和版本号。</summary>
        <value>平台标识符和版本号。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

在 .NET 5.0 之前的 .NET 版本中，在 <xref:System.Environment.OSVersion?displayProperty=nameWithType> Windows 兼容模式下运行应用程序时，将返回可能不正确的操作系统版本。 有关详细信息，请参阅 [GetVersionExA 函数备注](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getversionexa#remarks)。 在 .NET 5.0 和更高 <xref:System.Environment.OSVersion?displayProperty=nameWithType> 版本中，始终返回实际的操作系统版本。 有关详细信息，请参阅 [环境。 OSVersion 返回正确的操作系统版本](/dotnet/core/compatibility/corefx#environmentosversion-returns-the-correct-operating-system-version)。

若要确定操作系统平台（如 Linux 或 Windows），可以使用 <xref:System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform%2A?displayProperty=nameWithType> 方法。

       ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此属性不能获得系统版本。  
  
- 或 - 
获得的平台标识符不是 <see cref="T:System.PlatformID" />的成员</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessorCount">
      <MemberSignature Language="C#" Value="public static int ProcessorCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ProcessorCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ProcessorCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProcessorCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ProcessorCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorCount : int" Usage="System.Environment.ProcessorCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前计算机上的处理器数。</summary>
        <value>指定当前计算机上处理器个数的 32 位有符号整数。 没有默认值。 如果当前计算机包含多个处理器组，则此属性返回可用的逻辑处理器数以供公共语言运行时 (CLR) 使用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关处理器组和逻辑处理器的详细信息，请参阅 [处理器组](/windows/win32/procthread/processor-groups)。
  
## Examples  
 下面的示例演示了 <xref:System.Environment.ProcessorCount%2A> 属性。  
  
 [!code-cpp[environment.processorcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.processorcount/CPP/pc.cpp#1)]
 [!code-csharp[environment.processorcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.processorcount/CS/pc.cs#1)]
 [!code-vb[environment.processorcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.processorcount/VB/pc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建、修改或删除环境变量。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value)" />
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string? value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="variable">环境变量名。</param>
        <param name="value">要分配给 <paramref name="variable" /> 的值。</param>
        <summary>创建、修改或删除当前进程中存储的环境变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法等效于 <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> 使用参数的值调用重载 <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> `target` 。  
  
 如果 `value` 参数不为空 (请参阅本节稍后部分中的 "为空值的定义删除环境变量) " 和参数命名的环境变量不 `variable` 存在，创建环境变量并为其分配内容 `value` 。 如果它存在，则修改其值。 由于环境变量是在当前进程的环境块中定义的，因此在进程结束后，它不会持久保存。  
  
 如果 `variable` 包含非初始的十六进制零字符，则在零字符之前的字符被视为环境变量名称，而所有后续字符都将被忽略。  
  
 如果 `value` 包含非初始的十六进制零字符，则零字符之前的字符将被分配给环境变量，并且所有后续字符都将被忽略。  
  
 如果 `value` 为空且名为的环境变量 `variable` 存在，则将删除环境变量。 如果不 `variable` 存在，即使无法执行该操作，也不会发生错误。 `value` 在下列任一情况下，都被视为空：  
  
-   它是 `null` 。  
  
-   它是 <xref:System.String.Empty?displayProperty=nameWithType> 。  
  
-   它包含值为 U + 0000 的单个字符。  
  
## Examples

下面的示例尝试 `Test1` 从进程环境块中检索名为的环境变量的值。 如果该变量不存在，则此示例将创建变量并检索其值。 该示例显示变量的值。 对于在 Windows 系统上运行的 .NET 实现，它还将调用 <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> 方法和枚举的每个成员， <xref:System.EnvironmentVariableTarget> 以确定只能从当前进程环境块检索变量。 基于 Unix 的系统上的 ( .NET 实现仅支持进程环境块中的变量。 ) 最后，如果该示例创建了该变量，则将删除该变量。  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="variable" /> 包含一个长度为零的字符串、一个初始十六进制零字符 (0x00) 或一个等号 ("=")。  
  
- 或 - 
<paramref name="variable" /> 或 <paramref name="value" /> 的长度大于或等于 32,767 个字符。  
  
- 或 - 
执行此操作期间出错。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有执行此操作所需的权限。</exception>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </Member>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string? value, EnvironmentVariableTarget target);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String, target As EnvironmentVariableTarget)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string * EnvironmentVariableTarget -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value, target)" />
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value, EnvironmentVariableTarget target);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="value" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="variable">环境变量名。</param>
        <param name="value">要分配给 <paramref name="variable" /> 的值。</param>
        <param name="target">一个用于指定环境变量的位置的枚举值。</param>
        <summary>创建、修改或删除当前进程中或者为当前用户或本地计算机保留的 Windows 操作系统注册表项中存储的环境变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

使用 <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> 方法，您可以定义一个可用于当前进程 () 值的环境变量 <xref:System.EnvironmentVariableTarget.Process> 。 当前进程环境块独有的环境变量仅在进程结束之前持久存在。

此外，在 Windows 系统上，该 <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> 方法允许您定义一个环境变量，该变量可用于在计算机上运行的所有进程 (<xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>) 的值和用户运行的所有进程 (<xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> 值) 。 每计算机和每用户环境变量将复制到当前进程的环境块中。  
 
在 macOS 和 Linux 系统上的 .NET Core 中，将  <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> 忽略值为或的对方法的调用 <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> 。 
  
 如果 `value` 参数不为空 (请参阅本节稍后部分中的 "为空值的定义删除环境变量") ，并为参数指定的环境变量不 `variable` 存在，将创建环境变量并为其分配内容 `value` 。  如果它存在，则修改其值。  
  
 如果 `variable` 包含非初始的十六进制零字符，则在零字符之前的字符被视为环境变量名称，而所有后续字符都将被忽略。  
  
 如果 `value` 包含非初始的十六进制零字符，则零字符之前的字符将被分配给环境变量，并且所有后续字符都将被忽略。  
  
 如果 `value` 为空且名为的环境变量 `variable` 存在，则将删除环境变量。 `value` 在下列任一情况下，都被视为空：  
  
-   它是 `null` 。  
  
-   它是 <xref:System.String.Empty?displayProperty=nameWithType> 。  
  
-   它包含值为 U + 0000 的单个字符。  
  
 如果不 `variable` 存在，则不会发生任何错误，但无法执行该操作。 当是时 `target` <xref:System.EnvironmentVariableTarget.Machine> ，请小心，因为你可能会意外删除影响整个本地计算机的环境变量，而不只是当前进程或用户。  

### <a name="environmentvariabletargetmachine-and-environmentvariabletargetuser-on-windows-systems"></a>Windows 系统上的 EnvironmentVariableTarget 和 EnvironmentVariableTarget

如果 `target` 为 <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> ，则将环境变量存储在本地计算机注册表的 HKEY_CURRENT_USER \environment 密钥中。 它还会复制到以当前用户身份运行的文件资源管理器实例。 然后，用户从文件资源管理器启动的任何新进程都将继承该环境变量。  
  
 同样，如果 `target` 为 <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> ，则将环境变量存储在本地计算机注册表的 HKEY_LOCAL_MACHINE \system\controlset001\control\session Manager\Environment 密钥中。 它还会复制到文件资源管理器的所有实例。 然后，环境变量由从文件资源管理器启动的任何新进程继承。  
  
 如果 `target` 为 <xref:System.EnvironmentVariableTarget.User> 或 <xref:System.EnvironmentVariableTarget.Machine> ，则由 Windows 消息通知其他应用程序的设置操作 `WM_SETTINGCHANGE` 。  
  
 如果 `target` 为 <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> 或 <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> ，则建议长度 `value` 小于2048个字符。  
  
## Examples

下面的示例为 <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> 、和目标创建环境变量 <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> <xref:System.EnvironmentVariableTarget.Machine> ，检查操作系统注册表是否包含用户和计算机环境变量，然后删除环境变量。 由于基于 Unix 的系统上的 .NET 不支持每用户和每台计算机的环境变量，因此只有 <xref:System.Environment.SetEnvironmentVariable(System.String,System.String)> 和 <xref:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)> 值才能 <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> 成功地将环境变量存储到进程环境块。
  
[!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs)]
[!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="variable" /> 包含一个长度为零的字符串、一个初始十六进制零字符 (0x00) 或一个等号 ("=")。  
  
- 或 - 
<paramref name="variable" /> 的长度大于或等于 32,767 个字符。  
  
- 或 - 
 <paramref name="target" /> 不是 <see cref="T:System.EnvironmentVariableTarget" /> 枚举的一个成员。  
  
- 或 - 
 <paramref name="target" /> 为 <see cref="F:System.EnvironmentVariableTarget.Machine" /> 或 <see cref="F:System.EnvironmentVariableTarget.User" />，且 <paramref name="variable" /> 的长度大于或等于 255。  
  
- 或 - 
 <paramref name="target" /> 为 <see cref="F:System.EnvironmentVariableTarget.Process" /> ，且 <paramref name="value" /> 的长度大于或等于 32767 个字符。  
  
- 或 - 
执行此操作期间出错。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有执行此操作所需的权限。</exception>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public static string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Environment.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Environment.StackTrace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前的堆栈跟踪信息。</summary>
        <value>包含堆栈跟踪信息的字符串。 此值可为 <see cref="F:System.String.Empty" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Environment.StackTrace%2A>属性以反向时间顺序列出方法调用，也就是说，最新的方法调用将首先进行描述，并为堆栈上的每个方法调用列出一条堆栈跟踪信息。 但是， <xref:System.Environment.StackTrace%2A> 由于优化期间发生的代码转换，属性可能不会按预期方式报告任意数量的方法调用。  
  
> [!NOTE]
>  对于类的堆栈跟踪信息，请使用 <xref:System.Diagnostics.StackTrace> 类。  
  
 <xref:System.Environment.StackTrace%2A>属性为每个方法调用设置堆栈跟踪信息的格式，如下所示：  
  
 "位置 `FullClassName` 。 `MethodName` (`MethodParams`) `FileName` ：行 `LineNumber` "  
  
 文本 "at" 前面有三个空格，如果调试符号不可用，则省略以 "in" 开头的整个子字符串。 占位符、、 `FullClassName` `MethodName` 、、 `MethodParams` `FileName` 和 `LineNumber` 将替换为实际值，并按如下所示定义：  
  
 `FullClassName`  
 类的完整名称，包括命名空间。  
  
 `MethodName`  
 方法的名称。  
  
 `MethodParams`  
 参数类型/名称对的列表。 每个对由逗号分隔 ( "，" ) 。 如果不使用参数，则忽略此信息 `MethodName` 。  
  
 `FileName`  
 声明方法的源文件的名称 `MethodName` 。 如果调试符号不可用，则忽略此信息。  
  
 `LineNumber`  
 中的行号 `FileName` ，其中包含 `MethodName` 调用堆栈上的指令的源代码。 如果调试符号不可用，则忽略此信息。  
  
 <xref:System.Environment.NewLine%2A?displayProperty=nameWithType>字符串终止堆栈跟踪的每一行。
  
## Examples  
 下面的示例演示了 <xref:System.Environment.StackTrace%2A> 属性。  
  
 [!code-cpp[environment.stacktrace#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.StackTrace/CPP/stacktrace.cpp#1)]
 [!code-csharp[environment.stacktrace#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.StackTrace/CS/stacktrace.cs#1)]
 [!code-vb[environment.stacktrace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.StackTrace/VB/stacktrace.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SystemDirectory">
      <MemberSignature Language="C#" Value="public static string SystemDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string SystemDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SystemDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemDirectory : string" Usage="System.Environment.SystemDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取系统目录的完全限定路径。</summary>
        <value>包含目录路径的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回的值的示例为字符串 "C:\WinNT\System32"。
  
## Examples  
 下面的示例显示运行代码示例的计算机的系统目录。 出于安全原因，示例输出中省略了系统目录 (。 )   
  
 [!code-cpp[environment.systemdirectory#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.SystemDirectory/CPP/systemdirectory.cpp#1)]
 [!code-csharp[environment.systemdirectory#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.SystemDirectory/CS/systemdirectory.cs#1)]
 [!code-vb[environment.systemdirectory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.SystemDirectory/VB/systemdirectory.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SystemPageSize">
      <MemberSignature Language="C#" Value="public static int SystemPageSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 SystemPageSize" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemPageSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemPageSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int SystemPageSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemPageSize : int" Usage="System.Environment.SystemPageSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取操作系统的内存页的字节数。</summary>
        <value>系统内存页中的字节数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当 <xref:System.IO.MemoryMappedFiles.MemoryMappedFileOptions.DelayAllocatePages?displayProperty=nameWithType> 你使用内存映射文件时，确定是否使用选项时，此信息很有用。  
  
 在 Windows 中，此值是 `dwPageSize` 结构中的成员 `SYSTEM_INFO` 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TickCount">
      <MemberSignature Language="C#" Value="public static int TickCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 TickCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.TickCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TickCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int TickCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TickCount : int" Usage="System.Environment.TickCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取系统启动后经过的毫秒数。</summary>
        <value>一个 32 位带符号整数，它包含自上次启动计算机以来所经过的时间（以毫秒为单位）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性的值派生自系统计时器，并存储为32位有符号整数。 请注意，因为它是从系统计时器派生的，所以，属性的分辨率 <xref:System.Environment.TickCount%2A> 限制为系统计时器的分辨率，这通常在10到16毫秒的范围内。  
  
> [!IMPORTANT]
> 由于属性值的值 <xref:System.Environment.TickCount%2A> 为32位有符号整数，因此，如果系统连续运行，则 <xref:System.Environment.TickCount%2A> 将从零递增到 <xref:System.Int32.MaxValue?displayProperty=nameWithType> 约24.9 天，然后跳转到 <xref:System.Int32.MinValue?displayProperty=nameWithType> ，该数字为负数，然后在下一个24.9 天内递增为零。 若要解决此问题，可以调用 Windows [GetTickCount](/windows/win32/api/sysinfoapi/nf-sysinfoapi-gettickcount) 函数，该函数在大约49.7 天后将重置为零，或调用 [GetTickCount64](/windows/win32/api/sysinfoapi/nf-sysinfoapi-gettickcount64) 函数。  
  
 <xref:System.Environment.TickCount%2A> 与 <xref:System.DateTime.Ticks%2A?displayProperty=nameWithType> 属性不同，后者是自1/1/0001，12： 00 (以来经过的100纳秒间隔数。  
  
 使用 <xref:System.DateTime.Now%2A?displayProperty=nameWithType> 属性可获取此计算机上的当前本地日期和时间。
  
## Examples  
 下面的示例演示如何检索由属性返回的值的正范围 <xref:System.Environment.TickCount%2A> 。 <xref:System.Environment.TickCount%2A>属性在之间循环 <xref:System.Int32.MinValue?displayProperty=nameWithType> ，这是一个负数， <xref:System.Int32.MaxValue?displayProperty=nameWithType> 每49.8 天一次。 此代码示例将删除符号位以产生一个介于零和 <xref:System.Int32.MaxValue> 每24.9 天之间循环一次的非负数。  
  
 [!code-cpp[environment.tickcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.TickCount/CPP/tickcount.cpp#1)]
 [!code-csharp[environment.tickcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.TickCount/CS/tickcount.cs#1)]
 [!code-vb[environment.tickcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.TickCount/VB/tickcount.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TickCount64">
      <MemberSignature Language="C#" Value="public static long TickCount64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TickCount64" />
      <MemberSignature Language="DocId" Value="P:System.Environment.TickCount64" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TickCount64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long TickCount64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.TickCount64 : int64" Usage="System.Environment.TickCount64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取系统启动后经过的毫秒数。</summary>
        <value>自系统启动以来经过的时间（毫秒）。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserDomainName">
      <MemberSignature Language="C#" Value="public static string UserDomainName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserDomainName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserDomainName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserDomainName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserDomainName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserDomainName : string" Usage="System.Environment.UserDomainName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与当前用户关联的网络域名。</summary>
        <value>与当前用户关联的网络域名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用户的域帐户凭据的格式为用户的域名、" \\ " 字符和用户名。 使用 <xref:System.Environment.UserDomainName%2A> 属性获取用户的域名而不使用用户名，并使用 <xref:System.Environment.UserName%2A> 属性获取不带域名的用户名。  例如，如果用户的域名和用户名为 CORPORATENETWORK\john，则 <xref:System.Environment.UserDomainName%2A> 属性将返回 "企业网络"。  
  
 <xref:System.Environment.UserDomainName%2A>属性首先尝试获取当前用户的 Windows 帐户名称的域名部分。 如果此尝试失败，则此属性将尝试获取与属性提供的用户名相关联的域名 <xref:System.Environment.UserName%2A> 。 如果此尝试失败，因为主机未加入域，则返回主机名。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">操作系统不支持检索网络域名。</exception>
        <exception cref="T:System.InvalidOperationException">无法检索的网络域名。</exception>
        <altmember cref="P:System.Environment.UserName" />
      </Docs>
    </Member>
    <Member MemberName="UserInteractive">
      <MemberSignature Language="C#" Value="public static bool UserInteractive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UserInteractive" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserInteractive" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserInteractive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UserInteractive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UserInteractive : bool" Usage="System.Environment.UserInteractive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，用以指示当前进程是否在用户交互模式中运行。</summary>
        <value>如果当前进程在用户交互模式中运行，则为<see langword="true" /> ；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此 <xref:System.Environment.UserInteractive%2A> 属性报告 `false` 的 Windows 进程或服务（如 IIS）在没有用户界面的情况下运行。 如果此属性为 `false` ，则不会显示模式对话框或消息框，因为没有可供用户与之交互的图形用户界面。
  
## Examples  
 下面的示例显示当前进程是否正在用户交互模式下运行。  
  
 [!code-cpp[Environment.UserInteractive#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserInteractive/CPP/userinteractive.cpp#1)]
 [!code-csharp[Environment.UserInteractive#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserInteractive/CS/userinteractive.cs#1)]
 [!code-vb[Environment.UserInteractive#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserInteractive/VB/userinteractive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UserName">
      <MemberSignature Language="C#" Value="public static string UserName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserName : string" Usage="System.Environment.UserName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与当前线程相关联的用户的用户名。</summary>
        <value>与当前线程关联的人员的用户名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用 <xref:System.Environment.UserName%2A> 属性将当前线程上的用户标识到系统和应用程序，以进行安全或访问。 还可用于为每个用户自定义特定的应用程序。  
 
 在 Windows 上， <xref:System.Environment.UserName%2A> 属性包装对 Windows [GetUserName](/windows/win32/api/winbase/nf-winbase-getusernamea) 函数的调用。 用户的域帐户凭据的格式为用户的域名、" \\ " 字符和用户名。 使用 <xref:System.Environment.UserDomainName%2A> 属性获取用户的域名和 <xref:System.Environment.UserName%2A> 属性以获取用户名。  
 
 在 Unix 平台上， <xref:System.Environment.UserName%2A> 属性包装对函数的调用 `getpwuid_r` 。
 
 如果在开发环境中运行 ASP.NET 应用程序，则 <xref:System.Environment.UserName%2A> 属性将返回当前用户的名称。 在已发布的 ASP.NET 应用程序中，此属性将返回 (的应用程序池帐户的名称，例如默认 AppPool) 。

## Examples  
 下面的示例显示了启动当前线程的人员的用户名。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserName/CPP/username.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserName/CS/username.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserName/VB/username.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Environment.UserDomainName" />
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public static Version Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Version Version" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Version" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Version As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Version ^ Version { Version ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Version : Version" Usage="System.Environment.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取由公共语言运行时的主要版本号、次要版本号、内部版本号和修订号组成的版本。</summary>
        <value>公共语言运行时的版本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于 .NET Framework 版本 4、4.5、4.5.1 和 4.5.2，<xref:System.Environment.Version%2A?displayProperty=nameWithType> 属性返回字符串表现形式具有窗体 `4.0.30319.xxxxx` 的 <xref:System.Version> 对象。 对于 .NET Framework 4.6 及更高版本，格式为 `4.0.30319.42000` 。  
  
> [!WARNING]
> 对于 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 和更高版本，我们不建议使用 <xref:System.Environment.Version%2A> 属性来检测运行时的版本; 相反，你可以通过查询注册表来确定公共语言运行时的版本。 有关详细信息，请参阅 [如何：确定安装了哪些 .NET Framework 版本](/dotnet/framework/migration-guide/how-to-determine-which-versions-are-installed)。  
  
 有关随每个版本的 .NET Framework 一起安装的公共语言运行时版本的详细信息，请参阅 [版本和依赖项](/dotnet/framework/migration-guide/versions-and-dependencies)。
  
## Examples  
 下面的示例显示公共语言运行时的版本。  (出于安全原因，示例输出中省略了版本。 )   
  
 [!code-cpp[Environment.Version#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.Version/CPP/version.cpp#1)]
 [!code-csharp[Environment.Version#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.Version/CS/version.cs#1)]
 [!code-vb[Environment.Version#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.Version/VB/version.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public static long WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Environment.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property WorkingSet As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long WorkingSet { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int64" Usage="System.Environment.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取映射到进程上下文的物理内存量。</summary>
        <value>一个 64 位带符号整数，包含映射到进程上下文的物理内存字节的数目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例显示运行代码示例的计算机的工作集的大小。  
  
 [!code-cpp[Environment.WorkingSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.WorkingSet/CPP/workingset.cpp#1)]
 [!code-csharp[Environment.WorkingSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.WorkingSet/CS/workingset.cs#1)]
 [!code-vb[Environment.WorkingSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.WorkingSet/VB/workingset.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
