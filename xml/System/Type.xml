<Type Name="Type" FullName="System.Type">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c6780b83922cb2cab78948eb62ecfa1c898e0ad2" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73383830" /></Metadata><TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <TypeSignature Language="F#" Value="type Type = class&#xA;    inherit MemberInfo&#xA;    interface _Type&#xA;    interface IReflect" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示类型声明：类类型、接口类型、数组类型、值类型、枚举类型、类型参数、泛型类型定义，以及开放或封闭构造的泛型类型。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Type` 是 <xref:System.Reflection> 功能的根，是访问元数据的主要方式。 使用 <xref:System.Type> 的成员获取有关类型声明的信息，有关类型的成员（如构造函数、方法、字段、属性和类的事件），以及部署类的模块和程序集。  
  
 无论其访问级别如何，代码都无需权限即可使用反射来获取有关类型及其成员的信息。 代码不需要任何权限即可使用反射来访问公共成员，或访问级别使其在正常编译过程中可见的其他成员。 但是，为了使代码能够使用反射来访问通常不可访问的成员（如私有或内部方法）或类未继承的类型的受保护字段，你的代码必须具有 <xref:System.Security.Permissions.ReflectionPermission>。 请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。  
  
 `Type` 是允许多个实现的抽象基类。 系统将始终 `RuntimeType`提供派生类。 在反射中，所有以 word 运行时开头的类在系统中只为每个对象创建一次，并支持比较运算。  
  
> [!NOTE]
>  在多线程方案中，不要锁定 <xref:System.Type> 对象以便同步对 `static` 数据的访问。 其他不能进行控制的代码也可能会锁定您的类类型。 这可能会导致死锁。 相反，通过锁定专用 `static` 对象来同步对静态数据的访问。  
  
> [!NOTE]
>  派生类可以访问调用代码的基类的受保护成员。 此外，还允许访问调用代码的程序集的程序集成员。 作为一种规则，如果允许在早期绑定代码中访问，则还允许在后期绑定代码中访问。  
  
> [!NOTE]
>  扩展其他接口的接口不会继承扩展接口中定义的方法。  
  
 本节内容：  
  
 [类型对象表示哪些类型？](#WhatTypes)   
 [检索类型对象](#Retrieve)   
 [比较类型对象是否相等](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a>类型对象表示哪些类型？  
 此类是线程安全的;多个线程可以同时从该类型的实例读取。 <xref:System.Type> 类的实例可以表示以下任意类型：  
  
-   类  
  
-   值类型  
  
-   数组  
  
-   接口  
  
-   枚举  
  
-   委托  
  
-   构造的泛型类型和泛型类型定义  
  
-   构造的泛型类型、泛型类型定义和泛型方法定义的类型参数和类型参数  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a>检索类型对象  
 可以通过以下方式获取与特定类型关联的 <xref:System.Type> 对象：  
  
-   实例 <xref:System.Object.GetType%2A?displayProperty=nameWithType> 方法返回表示实例类型的 <xref:System.Type> 对象。 由于所有托管类型都派生自 <xref:System.Object>，因此可以对任何类型的实例调用 <xref:System.Object.GetType%2A> 方法。  
  
     下面的示例调用 <xref:System.Object.GetType%2A?displayProperty=nameWithType> 方法来确定对象数组中每个对象的运行时类型。  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   静态 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 方法返回一个 <xref:System.Type> 对象，该对象表示由其完全限定名称指定的类型。  
  
-   <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>、<xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>和 <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> 方法返回 `Type` 对象，这些对象表示在模块中定义的类型。 第一种方法可用于获取模块中定义的所有公共和私有类型的 <xref:System.Type> 对象的数组。 （您可以通过 <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> 或 <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> 方法获取 `Module` 的实例，或通过 <xref:System.Type.Module%2A?displayProperty=nameWithType> 属性获取。）  
  
-   <xref:System.Reflection.Assembly?displayProperty=nameWithType> 对象包含多个检索程序集中定义的类的方法，包括 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>、<xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>和 <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>。  
  
-   <xref:System.Type.FindInterfaces%2A> 方法返回某个类型支持的接口类型的筛选列表。  
  
-   <xref:System.Type.GetElementType%2A> 方法返回表示元素的 `Type` 对象。  
  
-   <xref:System.Type.GetInterfaces%2A> 和 <xref:System.Type.GetInterface%2A> 方法返回 <xref:System.Type> 对象，这些对象表示类型支持的接口类型。  
  
-   <xref:System.Type.GetTypeArray%2A> 方法返回 <xref:System.Type> 对象的数组，这些对象表示由任意一组对象指定的类型。 对象是使用 <xref:System.Object>类型的数组指定的。  
  
-   提供 <xref:System.Type.GetTypeFromProgID%2A> 和 <xref:System.Type.GetTypeFromCLSID%2A> 方法用于 COM 互操作性。 它们返回一个 <xref:System.Type> 对象，该对象表示由 `ProgID` 或 `CLSID`指定的类型。  
  
-   提供 <xref:System.Type.GetTypeFromHandle%2A> 方法以实现互操作性。 它将返回一个 `Type` 对象，该对象表示由类句柄指定的类型。  
  
-   C# `typeof` 运算符、 C++ `typeid` 运算符和 Visual Basic `GetType` 运算符获取类型的 `Type` 对象。  
  
-   <xref:System.Type.MakeGenericType%2A> 方法返回表示构造泛型类型的 <xref:System.Type> 对象，如果其 <xref:System.Type.ContainsGenericParameters%2A> 属性返回 `true`，则为开放式构造类型，否则返回封闭式构造类型。 泛型类型只能在关闭时进行实例化。  
  
-   <xref:System.Type.MakeArrayType%2A>、<xref:System.Type.MakePointerType%2A>和 <xref:System.Type.MakeByRefType%2A> 方法返回 <xref:System.Type> 对象，分别表示指定类型的数组、指向指定类型的指针和引用参数的类型（`ref` 在C#`ByRef` 中）。  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a>比较类型对象是否相等  
 表示一个类型的 <xref:System.Type> 对象是唯一的;也就是说，当且仅当对象表示同一类型时，两个 <xref:System.Type> 对象引用引用相同的对象。 这允许使用引用相等性来比较 <xref:System.Type> 的对象。 下面的示例对表示若干整数值的 <xref:System.Type> 对象进行比较，以确定它们是否属于同一类型。  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 下面的示例演示了 <xref:System.Type>的几个典型功能。 C# `typeof` 运算符（Visual Basic 中`GetType` 运算符）用于获取表示 <xref:System.String>的 <xref:System.Type> 对象。 从此 <xref:System.Type> 对象中，<xref:System.Type.GetMethod%2A> 方法用于获取 <xref:System.Reflection.MethodInfo>，它表示采用起始位置和长度的 <xref:System.String.Substring%2A?displayProperty=nameWithType> 重载。
  
 为了标识重载签名，此代码示例创建一个临时数组，其中包含两个表示 `int` 的 <xref:System.Type> 对象（`Integer` Visual Basic）。  
  
> [!NOTE]
>  为精确起见，数组包含对表示当前应用程序域中 `int` 的 <xref:System.Type> 实例的两个引用。 对于任何类型，每个应用程序域只有一个 <xref:System.Type> 的实例。  
  
 此代码示例使用 <xref:System.Reflection.MethodInfo> 对字符串 "Hello，World！" 调用 <xref:System.String.Substring%2A> 方法，并显示结果。  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此类型是线程安全的。</threadsafe>
    <block subset="none" type="overrides"><para>从 <see langword="Type" />继承时，必须重写以下成员： 
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para></block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
    <related type="Article" href="~/docs/framework/reflection-and-codedom/viewing-type-information.md">查看类型信息</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Type" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数由派生类在类型对象的构造过程中调用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Type.Assembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在其中声明该类型的 <see cref="T:System.Reflection.Assembly" />。 对于泛型类型，则获取在其中定义该泛型类型的 <see cref="T:System.Reflection.Assembly" />。</summary>
        <value>描述包含当前类型的程序集的 <see cref="T:System.Reflection.Assembly" /> 实例。 对于泛型类型，该实例描述包含泛型类型定义的程序集，而不是创建和使用特定构造类型的程序集。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前 <xref:System.Type> 对象表示构造泛型类型，则此属性返回包含泛型类型定义的程序集。 例如，假设你创建了一个名为 MyGenerics 的程序集，该程序集包含 `MyGenericStack<T>` 的泛型类型定义（`MyGenericStack(Of T)` Visual Basic C++`generic<T> ref class MyGenericStack` 中的）。 如果在另一个程序集中创建 `MyGenericStack<int>` 的实例（Visual Basic 中`MyGenericStack(Of Integer)`），则构造的类型的 <xref:System.Type.Assembly%2A> 属性返回一个表示 MyGenerics 的 <xref:System.Reflection.Assembly> 对象。  
  
 同样，如果当前 <xref:System.Type> 对象表示未分配的泛型参数 `T`，则此属性将返回包含定义 `T`的泛型类型的程序集。  
  
 如果 <xref:System.Type.Assembly%2A?displayProperty=nameWithType> 属性在特定 .NET 实现（如 .NET Core 或通用 Windows 平台）上不可用，请改用 <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> 属性。      
  
 此属性是只读的。  
  
   
  
## Examples  
 下面的示例显示与类关联的程序集名称和该类型的完全限定名称。  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Type.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取类型的程序集限定名，其中包括从中加载 <see cref="T:System.Type" /> 的程序集的名称。</summary>
        <value><see cref="T:System.Type" /> 的程序集限定名，其中包括从中加载 <see cref="T:System.Type" /> 的程序集的名称；或者为 <see langword="null" />（如果当前实例表示泛型类型参数）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 类型的程序集限定名称包含类型名称（包括其命名空间），后跟一个逗号，然后是程序集的显示名称。 使用 <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> 属性获取程序集的显示名称。  
  
> [!NOTE]
>  在 .NET Framework 版本2.0 中，处理器体系结构添加到程序集标识，并可指定为程序集名称字符串的一部分。 例如，"ProcessorArchitecture = msil"。 不过，由于兼容性原因，它不包含在 <xref:System.Type.AssemblyQualifiedName%2A> 属性返回的字符串中。 请参阅 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。  
  
 所有支持公共语言运行时的编译器都发出嵌套类的简单名称，并且在查询时，反射将按照以下约定构造错位的名称。  
  
|后面|含义|  
|---------------|-------------|  
|反斜杠 (\\)|转义符。|  
|逗号（，）|在程序集名称之前。|  
|加号（+）|在嵌套类之前。|  
|Period （.）|表示命名空间标识符。|  
|方括号（[]）|在类型名称后，表示该类型的数组。<br /><br /> 或<br /><br /> 对于泛型类型，包含泛型类型参数列表。<br /><br /> 或<br /><br /> 在类型参数列表中，包含程序集限定的类型。|  
  
 例如，类的程序集限定名称可能如下所示：  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 如果命名空间包含加号（例如 TopNamespace + 命名空间），则加号（+）前面会有一个转义符（\\），以防止它被解释为嵌套分隔符。 反射会按如下所示发出此字符串：  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 "+ +" 变成 "\\+\\+"，而 "\\" 变成 "\\\\"。  
  
 此限定名称可以保留，以后用于加载 <xref:System.Type>。 若要搜索并加载 <xref:System.Type>，请将 <xref:System.Type.GetType%2A> 只与类型名称一起使用，或者使用程序集限定的类型名称。 仅 <xref:System.Type.GetType%2A> 类型名称将在调用方的程序集中查找 <xref:System.Type>，然后在系统程序集中查找。 具有程序集限定类型名称的 <xref:System.Type.GetType%2A> 将查找任何程序集中的 <xref:System.Type>。  
  
 类型名称可能包含表示类型附加信息的尾随字符，如类型是引用类型、指针类型还是数组类型。 若要检索不包含这些尾随字符的类型名称，请使用 `t.GetElementType().ToString()`，其中 `t` 为类型。  
  
 空格在除程序集名称之外的所有类型名称组件中都是相关的。 在程序集名称中，"，" 分隔符前面的空格是相关的，但 "，" 分隔符后面的空格将被忽略。  
  
 泛型类型的泛型参数本身由程序集名称限定。 例如，在 `MyGenericClass<int>` 的程序集限定类型名称中（`MyGenericClass(Of Integer)` 在 Visual Basic 中），`int` 扩展为 <xref:System.Int32>的程序集限定的类型名称。  
  
 如果当前 <xref:System.Type> 对象表示泛型参数，则此属性将返回 `null`。  
  
   
  
## Examples  
 下面的示例显示与类关联的程序集名称和该类型的完全限定名称。  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 下面的示例将 <xref:System.Type.ToString%2A> 方法返回的字符串与 `Name`、<xref:System.Type.FullName%2A>和 <xref:System.Type.AssemblyQualifiedName%2A> 属性进行比较。  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">指定完全限定的类型名称</related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Type.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与 <see cref="T:System.Type" /> 关联的属性。</summary>
        <value>表示 <see cref="T:System.Reflection.TypeAttributes" /> 的属性集的 <see cref="T:System.Type" /> 对象，除非 <see cref="T:System.Type" /> 表示泛型类型形参，在此情况下该值未指定。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes> 枚举的某些成员是表示一组值的掩码。 每个组都包含一个其基础值为零的成员。 例如，<xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 组中 <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> 成员的基础值为零，这与 <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> 组中的 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> 成员相同。 因此，在测试这些值之前，必须使用掩码。 说明如示例所示。  
  
> [!TIP]
>  大多数情况下，<xref:System.Type.IsClass%2A>、<xref:System.Type.IsAutoLayout%2A>和 <xref:System.Type.IsSpecialName%2A> 之类的属性比类型属性更易于使用。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此属性返回泛型类型定义的属性。 例如，为 `MyGenericClass<int>` 返回的属性（`MyGenericClass(Of Integer)` 在 Visual Basic 中）是 `MyGenericClass<T>` 的属性（`MyGenericClass(Of T)` 中的 Visual Basic）。  
  
 如果当前 <xref:System.Type> 表示泛型类型参数，即，如果 <xref:System.Type.IsGenericParameter%2A> 属性返回 `true`，则未指定此属性返回的 <xref:System.Reflection.TypeAttributes> 值。  
  
   
  
## Examples  
 下面的示例使用 <xref:System.Type.Attributes%2A> 属性。  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Type.BaseType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 直接从中继承的类型。</summary>
        <value>当前 <see cref="T:System.Type" /> 直接从中继承的 <see cref="T:System.Type" />；或者如果当前 <see langword="null" /> 表示 <see langword="Type" /> 类或一个接口，则为 <see cref="T:System.Object" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基类型是当前类型直接从中继承的类型。 <xref:System.Object> 是唯一没有基类型的类型，因此 `null` 作为 <xref:System.Object>的基类型返回。  
  
 接口从零个或多个基接口继承;因此，如果 `Type` 对象表示一个接口，则此属性将返回 `null`。 可以通过 <xref:System.Type.GetInterfaces%2A> 或 <xref:System.Type.FindInterfaces%2A>确定基接口。  
  
 如果当前 <xref:System.Type> 表示构造的泛型类型，则基类型将反映泛型参数。 以下面的声明为例：  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 对于构造类型 `C<int>` （`C(Of Integer)` 在 Visual Basic 中），<xref:System.Type.BaseType%2A> 属性返回 `B<int>`。  
  
 如果当前 <xref:System.Type> 表示泛型类型定义的类型参数，则 <xref:System.Type.BaseType%2A> 返回类约束，即类型参数必须继承的类。 如果没有类约束，<xref:System.Type.BaseType%2A> 将返回 <xref:System.Object?displayProperty=nameWithType>。  
  
 此属性是只读的。  
  
   
  
## Examples  
 下面的示例演示如何使用 <xref:System.Type.BaseType%2A> 属性。  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 下面的示例使用递归列出了在程序集中找到的每个类的完整继承层次结构。 该示例定义了一个名为 `C` 的类，该类派生自名为 `B`的类，后者又派生自名为 `A`的类。  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反射类型和泛型类型</related>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Type.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前 <see cref="T:System.Type" /> 对象是否具有尚未被特定类型替代的类型参数。</summary>
        <value>如果 <see langword="true" /> 对象本身是泛型类型形参或者具有尚未提供特定类型的类型形参，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要创建类型的实例，在类型本身的类型参数、任何封闭泛型类型或任何类型的元素中都不能有泛型类型定义或开放式构造类型。 另一种说法是，在递归检查时，类型不能包含泛型类型参数。  
  
 由于类型可能会很复杂，因此做出此决定非常困难。 为方便起见，若要减少出现错误的可能性，<xref:System.Type.ContainsGenericParameters%2A> 属性提供了一种标准方式来区分封闭式构造类型（可以实例化）和开放构造类型（不能是这样）。 如果 <xref:System.Type.ContainsGenericParameters%2A> 属性返回 `true`，则无法实例化该类型。  
  
 <xref:System.Type.ContainsGenericParameters%2A> 属性以递归方式搜索类型参数。 例如，它为元素类型为 `A<T>` 的数组（Visual Basic 中的`A(Of T)`）返回 `true`，即使数组本身不是泛型。 这与 <xref:System.Type.IsGenericType%2A> 属性的行为相反，后者返回数组的 `false`。  
  
 有关示例类的集合和显示 <xref:System.Type.ContainsGenericParameters%2A> 属性的值的表，请参阅 <xref:System.Type.IsGenericType%2A>。  
  
   
  
## Examples  
 下面的示例定义了一个具有两个类型参数的泛型类，然后定义了第一个派生自第一个类的泛型类。 派生类的基类具有两个类型参数：第一个是 <xref:System.Int32> 的，第二个是派生类型的类型参数。 该示例显示有关这些泛型类的信息，包括 <xref:System.Type.GenericParameterPosition%2A> 属性报告的位置。  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反射类型和泛型类型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反射检查和实例化泛型类型</related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Type.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个表示声明方法的 <see cref="T:System.Reflection.MethodBase" />（如果当前 <see cref="T:System.Type" /> 表示泛型方法的一个类型参数）。</summary>
        <value>如果当前 <see cref="T:System.Type" /> 表示泛型方法的一个类型参数，则为一个表示声明方法的 <see cref="T:System.Reflection.MethodBase" />；否则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 声明方法是泛型方法定义。 也就是说，如果 <xref:System.Type.DeclaringMethod%2A> 未返回 `null`，则 `DeclaringMethod.IsGenericMethodDefinition` 返回 `true`。  
  
 <xref:System.Type.DeclaringType%2A> 和 <xref:System.Type.DeclaringMethod%2A> 属性标识最初定义泛型类型参数的泛型类型定义或泛型方法定义：  
  
-   如果 <xref:System.Type.DeclaringMethod%2A> 属性返回一个 <xref:System.Reflection.MethodInfo>，则该 <xref:System.Reflection.MethodInfo> 表示一个泛型方法定义，而当前的 <xref:System.Type> 对象表示该泛型方法定义的类型参数。  
  
-   如果 <xref:System.Type.DeclaringMethod%2A> 属性返回 `null`，则 <xref:System.Type.DeclaringType%2A> 属性始终返回表示泛型类型定义的 <xref:System.Type> 对象，当前 <xref:System.Type> 对象表示该泛型类型定义的类型参数。  
  
-   获取 <xref:System.Type.IsGenericParameter%2A> 属性 `false` 的类型的 <xref:System.Type.DeclaringMethod%2A> 属性将引发 <xref:System.InvalidOperationException>。  
  
 <xref:System.Type.DeclaringMethod%2A> 属性返回的 <xref:System.Reflection.MethodBase> 是泛型方法的一个 <xref:System.Reflection.MethodInfo>，或者泛型构造函数的情况下为 <xref:System.Reflection.ConstructorInfo>。  
  
> [!NOTE]
>  在 .NET Framework 版本2.0 中，不支持泛型构造函数。  
  
 有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。  
  
   
  
## Examples  
 下面的代码示例定义一个具有泛型方法的类，为该方法分配一个类型自变量，并调用生成的构造泛型方法。 它还显示有关泛型方法定义和构造方法的信息。 显示泛型方法定义的类型参数的信息时，在 `DisplayGenericMethodInfo` 方法中，示例代码显示了该方法的泛型类型参数的 <xref:System.Type.DeclaringMethod%2A> 属性的值。  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反射类型和泛型类型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反射检查和实例化泛型类型</related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public abstract Type DeclaringType { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property DeclaringType As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ DeclaringType { Type ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Type.DeclaringType" />
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用来声明当前的嵌套类型或泛型类型参数的类型。</summary>
        <value>如果当前的类型是嵌套类型，则为表示封闭类型的 <see cref="T:System.Type" /> 对象；如果当前的类型是泛型类型的类型参数，则为泛型类型的定义；如果当前的类型是泛型方法的类型参数，则为用来声明泛型方法的类型；否则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前 <xref:System.Type> 对象表示泛型类型的类型参数，则此属性返回泛型类型定义。  
  
 如果当前 <xref:System.Type> 对象表示泛型方法的类型参数，则此属性返回包含泛型方法定义的类型。 如果类型为泛型，则返回泛型类型定义。 也就是说，以下代码返回 <xref:System.Collections.Generic.List%601> 泛型类的泛型类型定义，其中包含 <xref:System.Collections.Generic.List%601.ConvertAll%2A> 泛型方法：  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则 <xref:System.Type.DeclaringType%2A> 和 <xref:System.Type.DeclaringMethod%2A> 属性标识泛型类型定义或泛型方法定义，其中，泛型类型参数最初是明确  
  
-   如果 <xref:System.Type.DeclaringMethod%2A> 属性返回一个 <xref:System.Reflection.MethodInfo>，则该 <xref:System.Reflection.MethodInfo> 表示一个泛型方法定义，而当前的 <xref:System.Type> 对象表示该泛型方法定义的类型参数。  
  
-   如果 <xref:System.Type.DeclaringMethod%2A> 属性返回 `null`，则 <xref:System.Type.DeclaringType%2A> 属性始终返回表示泛型类型定义的 <xref:System.Type> 对象，当前 <xref:System.Type> 对象表示该泛型类型定义的类型参数。  
  
-   获取 <xref:System.Type.IsGenericParameter%2A> 属性 `false` 的类型的 <xref:System.Type.DeclaringType%2A> 属性将引发 <xref:System.InvalidOperationException>。  
  
   
  
## Examples  
 此示例显示派生类中方法的声明类型。  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBinder : System.Reflection.Binder" Usage="System.Type.DefaultBinder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取默认联编程序的引用，该程序实现的内部规则用于选择由 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> 调用的合适成员。</summary>
        <value>系统使用的默认联编程序的引用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 随公共语言运行时提供的默认联编程序适用于除最特殊的情况以外的所有情况。 如果需要遵循与所提供的默认联编程序不同的规则的联编程序，请定义一个派生自 <xref:System.Reflection.Binder> 类的类型，并使用 <xref:System.Type.InvokeMember%2A> 重载之一的 `binder` 参数传递该类型的实例。  
  
 反射对通用类型系统的可访问性规则建模。 例如，如果调用方在同一程序集中，则调用方不需要内部成员的特殊权限。 否则，调用方需要 <xref:System.Security.Permissions.ReflectionPermission>。 这与查找受保护的、私有的成员等的成员一致。  
  
 一般原则是，<xref:System.Reflection.Binder.ChangeType%2A> 只应执行不会丢失数据的扩大转换。 扩大转换的一个示例是将32位有符号整数的值转换为64位有符号整数的值。 这与收缩转换不同，后者可能会丢失数据。 收缩转换的一个示例是将64位有符号整数转换为32位有符号整数。  
  
 下表列出了默认联编程序支持的转换。  
  
|源类型|目标类型|  
|-----------------|-----------------|  
|任何类型|其基类型。|  
|任何类型|它实现的接口。|  
|Char|Unt16、UInt32、Int32、UInt64、Int64、Single、Double|  
|Byte|Char、Unt16、Int16、UInt32、Int32、UInt64、Int64、Single、Double|  
|SByte|Int16、Int32、Int64、Single、Double|  
|UInt16|UInt32、Int32、UInt64、Int64、Single、Double|  
|Int16|Int32、Int64、Single、Double|  
|UInt32|UInt64、Int64、Single、Double|  
|Int32|Int64、Single、Double|  
|UInt64|Single、Double|  
|Int64|Single、Double|  
|Single|Double|  
|非引用|按引用。|  
  
   
  
## Examples  
 下面的示例从 `DefaultBinder` 属性获取默认联编程序，并通过将 `DefaultBinder` 值作为参数传递给 <xref:System.Type.InvokeMember%2A>来调用 MyClass 的成员。  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Delimiter : char" Usage="System.Type.Delimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>分隔 <see cref="T:System.Type" /> 的命名空间中的名称。 此字段为只读。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberSignature Language="F#" Value=" staticval mutable EmptyTypes : Type[]" Usage="System.Type.EmptyTypes" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="T:System.Type" /> 类型的空数组。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示一个 `GetConstructor` 方法中使用的 `EmptyTypes` 字段，以获取不带参数的构造函数。  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定当前 <see cref="T:System.Type" /> 的基础系统类型是否与指定 <see cref="T:System.Object" /> 或 <see cref="T:System.Type" /> 的基础系统类型相同。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">该对象，其基础系统类型将与当前 <see cref="T:System.Type" /> 的基础系统类型相比较。 为了使比较成功，<paramref name="o" /> 必须能够被强制转换或转换为类型 <see cref="T:System.Type" /> 的一个对象。</param>
        <summary>确定当前 <see cref="T:System.Type" /> 的基础系统类型是否与指定 <see cref="T:System.Object" /> 的基础系统类型相同。</summary>
        <returns>如果 <see langword="true" /> 的基础系统类型与当前 <paramref name="o" /> 的基础系统类型相同，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。 如果 ：此方法也会返回 <see langword="false" />。  
  
-   <paramref name="o" /> 为 <see langword="null" />。  
  
-   <paramref name="o" /> 不能强制转换或转换为 <see cref="T:System.Type" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.Object.Equals%2A?displayProperty=nameWithType>。 它将 `o` 转换为类型 <xref:System.Type> 的对象，并调用 <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> 方法。  
  
   
  
## Examples  
 下面的示例使用 <xref:System.Type.Equals%28System.Object%29> 将各种 <xref:System.Type> 对象实例与各种 <xref:System.Object> 实例进行比较。  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 对于本示例，特别要注意以下两个方面：  
  
-   与表示整数返回 `true` 的 <xref:System.Reflection.TypeInfo> 对象表示整数的 <xref:System.Type> 对象的比较，因为 <xref:System.Reflection.TypeInfo> 是从 <xref:System.Type>派生的。  
  
-   将表示 <xref:System.Collections.Generic.IList%601> 对象的 <xref:System.Type> 对象（开放式泛型类型）与 `List(Of String)` 对象（封闭式泛型类型）进行比较将返回 `false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (Type o);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Type o) cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (o As Type) As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(Type ^ o);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="override this.Equals : Type -&gt; bool" Usage="type.Equals o" />
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">该对象，其基础系统类型将与当前 <see cref="T:System.Type" /> 的基础系统类型相比较。</param>
        <summary>确定当前 <see cref="T:System.Type" /> 的基础系统类型是否与指定 <see cref="T:System.Type" /> 的基础系统类型相同。</summary>
        <returns>如果 <see langword="true" /> 的基础系统类型与当前 <paramref name="o" /> 的基础系统类型相同，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例使用 `Equals` 比较两种类型。  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterAttribute : System.Reflection.MemberFilter" Usage="System.Type.FilterAttribute" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示用在特性上的成员筛选器。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此字段保存对 <xref:System.Type.FindMembers%2A> 方法使用的委托的引用。 此委托封装的方法采用两个参数：第一个是 <xref:System.Reflection.MemberInfo> 对象，第二个参数是 `Object`。 方法确定 `MemberInfo` 对象是否与 `Object`指定的条件相匹配。 可以为 `Object` 分配类 <xref:System.Reflection.FieldAttributes>、<xref:System.Reflection.MethodAttributes>或 <xref:System.Reflection.MethodImplAttributes>的任何一个字段的值。  
  
 例如，可以将 `Object` 中的字段的值分配 `FieldAttributes` 例如 Public。 在这种情况下，当调用 `FilterAttribute` 委托时，仅当 `MemberInfo` 对象表示的方法使用元数据中的公共字段特性修饰时，它才会返回 `true`。  
  
   
  
## Examples  
 下面的示例获取 `FilterAttribute` 委托，将其作为参数传递到 <xref:System.Type.FindMembers%2A> 方法，并显示指定的成员及其属性。  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterName : System.Reflection.MemberFilter" Usage="System.Type.FilterName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示用于名称的区分大小写的成员筛选器。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此字段保存对 <xref:System.Type.FindMembers%2A> 方法使用的委托的引用。 此委托封装的方法采用两个参数：第一个是 <xref:System.Reflection.MemberInfo> 对象，第二个参数是 `Object`。 方法确定 `MemberInfo` 对象是否与 `Object`指定的条件相匹配。 为 `Object` 分配一个字符串值，该字符串值可以包含后缀 "*" 通配符。 仅支持通配符结束字符串匹配。  
  
 例如，可以为 `Object` 分配值 "Byte *"。 在这种情况下，当调用 `FilterName` 委托时，只有当 `MemberInfo` 对象表示的方法具有以 "Byte" 开头的名称时，它才会返回 `true`。  
  
   
  
## Examples  
 下面的代码示例获取与用户定义的 `Application` 类型相关联的方法。  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterNameIgnoreCase : System.Reflection.MemberFilter" Usage="System.Type.FilterNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示用于名称的不区分大小写的成员筛选器。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此字段保存对 <xref:System.Type.FindMembers%2A> 方法使用的委托的引用。 此委托封装的方法采用两个参数：第一个是 <xref:System.Reflection.MemberInfo> 对象，第二个参数是 `Object`。 方法确定 `MemberInfo` 对象是否与 `Object`指定的条件相匹配。 为 `Object` 分配一个字符串值，该字符串值可以包含后缀 "*" 通配符。 仅支持通配符结束字符串匹配。  
  
 例如，可以为 `Object` 分配值 "ByTe *"。 在这种情况下，当调用 `FilterName` 委托时，只有当 `MemberInfo` 对象表示的方法具有以 "byte" 开头的名称（忽略大小写）时，它才返回 true。  
  
   
  
## Examples  
 下面的示例获取 `MemberFilter` 委托，将其作为参数传递给 <xref:System.Type.FindMembers%2A> 方法，并显示以字母 "c" 开头的 `String` 类的方法及其属性，忽略大小写。  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]&#xA;override this.FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]" Usage="type.FindInterfaces (filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filterCriteria" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="filter">对照 <paramref name="filterCriteria" /> 比较接口的委托。</param>
        <param name="filterCriteria">确定接口是否应包括在返回数组中的搜索判据。</param>
        <summary>返回表示接口（由当前 <see cref="T:System.Type" /> 所实现或继承）的筛选列表的 <see cref="T:System.Type" /> 对象数组。</summary>
        <returns>一个 <see cref="T:System.Type" /> 对象的数组，它表示由当前 <see cref="T:System.Type" /> 实现或继承的接口的已筛选的列表；如果当前 <see cref="T:System.Type" /> 未实现或继承与筛选器相匹配的接口，则为空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可由派生类重写。  
  
 <xref:System.Reflection.Module?displayProperty=nameWithType> 类提供的 <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> 和 <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> 委托也可以用来代替 <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> 委托。  
  
 此类实现的所有接口都是在搜索过程中考虑的，无论是由基类还是此类本身来声明。  
  
 此方法搜索基类层次结构，并返回每个类实现的每个匹配接口以及这些接口中每个接口实现的所有匹配接口（即，返回匹配接口的传递闭包）。 不返回重复的接口。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则 <xref:System.Type.FindInterfaces%2A> 将搜索在类型参数的约束中声明的所有接口，并通过在约束. 如果当前 <xref:System.Type> 表示泛型类型的类型参数，则 <xref:System.Type.FindInterfaces%2A> 会搜索该类型实现的所有接口，无论它们是否与约束匹配。  
  
> [!NOTE]
>  <xref:System.Type.FindInterfaces%2A> 可以返回泛型接口，即使是在非泛型类型上。 例如，非泛型类型可能实现 `IEnumerable<int>` （`IEnumerable(Of Integer)` Visual Basic）。  
  
   
  
## Examples  
 下面的示例查找指定类型实现或继承的指定接口，然后显示接口名称。  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filter" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">调用静态初始值设定项时引发了异常。</exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]&#xA;override this.FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]" Usage="type.FindMembers (memberType, bindingAttr, filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filterCriteria" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="memberType">枚举值的按位组合，它指示要搜索的成员的类型。</param>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
或 
 若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</param>
        <param name="filter">执行比较的委托，如果当前被检查的成员匹配 <see langword="true" />，则返回 <paramref name="filterCriteria" />；否则返回 <see langword="false" />。</param>
        <param name="filterCriteria">确定成员是否在 <see langword="MemberInfo" /> 对象数组中返回的搜索判据。  
  
<see langword="FieldAttributes" />、<see langword="MethodAttributes" /> 和 <see langword="MethodImplAttributes" /> 的字段可以和该类提供的 <see langword="FilterAttribute" /> 委托一起使用。</param>
        <summary>返回指定成员类型的 <see cref="T:System.Reflection.MemberInfo" /> 对象的筛选数组。</summary>
        <returns>指定成员类型的 <see cref="T:System.Reflection.MemberInfo" /> 对象的筛选数组。  
  
或 
如果当前 <see cref="T:System.Type" /> 没有与筛选条件相匹配的 <paramref name="memberType" /> 类型的成员，则为空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

此方法可由派生类重写。  
  
成员包括属性、方法、字段、事件等。  

要使 `FindMembers` 方法成功检索成员信息，`bindingAttr` 参数必须包含至少 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> 和 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>中的一个，以及至少 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 和 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>中的一个。 

 以下 <xref:System.Reflection.BindingFlags> 筛选器标志可用于定义要包括在搜索中的成员：  
  
-   指定 `BindingFlags.Instance` 以在搜索中包含实例成员。  
  
-   指定 `BindingFlags.Static` 以在搜索中包含静态成员。  
  
-   指定 `BindingFlags.Public` 以在搜索中包括公共成员。  
  
-   指定 `BindingFlags.NonPublic` 以在搜索中包括非公共成员（即，私有成员、内部成员和受保护成员）。  
  
 以下 <xref:System.Reflection.BindingFlags> 修饰符标志可用于更改搜索的工作方式：  
  
-   `BindingFlags.DeclaredOnly` 仅搜索 <xref:System.Type>上声明的成员，而不搜索简单继承的成员。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
若要使用此方法获取类初始值设定项（静态构造函数），必须&#124;指定 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> （<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 中的 Visual Basic）。 还可以使用 <xref:System.Type.TypeInitializer%2A> 属性获取类初始值设定项。  
  
如果当前 <xref:System.Type> 表示泛型类型或泛型方法的类型参数，则 <xref:System.Type.FindMembers%2A> 会处理由类约束或类型参数的接口约束声明的任何成员。  

`filter` 参数可以是 <xref:System.Reflection.MemberFilter>类型的自定义委托，也可以是以下预定义的委托之一：

- <xref:System.Type.FilterAttribute?displayProperty=nameWithType>，它使用<xref:System.Reflection.FieldAttributes>、<xref:System.Reflection.MethodAttributes>或 <xref:System.Reflection.MethodImplAttributes> 位掩码作为 `filterCriteria` 值。

- <xref:System.Type.FilterName?displayProperty=nameWithType>，它对每个成员名称执行区分大小写的比较，并将字符串传递到 `filterCriteria`。

- <xref:System.Type.FilterNameIgnoreCase?displayProperty=nameWithType>，它对每个成员名称执行不区分大小写的比较，并将字符串传递到 `filterCriteria`。

## Examples  
 下面的示例查找与指定的搜索条件匹配的类中的所有成员，然后显示匹配的成员。  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filter" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Type.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取该类型的完全限定名称，包括其命名空间，但不包括程序集。</summary>
        <value>该类型的完全限定名，包括其命名空间，但不包括程序集；如果当前实例表示泛型类型参数、数组类型、指针类型或基于类型参数的 <see langword="null" /> 类型，或表示不属于泛型类型定义但包含无法解析的类型参数的泛型类型，则为 <see langword="byref" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例如，`System.String`的 <xref:System.String> 类型的完全限定名称。 将此与 <xref:System.Type.AssemblyQualifiedName%2A> 属性返回的程序集限定名称相比较，其中包含全名和完整程序集名称。  
  
 如果当前类型表示封闭式泛型类型，则由 <xref:System.Type.FullName%2A> 属性返回的字符串中的类型参数由其完整程序集名称限定，即使泛型类型本身的字符串表示形式不是由它的完整程序集限定的路径名. 下面的示例演示了一个类型的 FullName 属性中的差异，该类型表示泛型类型定义，另一个表示封闭式泛型类型。  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 如果以下情况，此属性将返回 `null`：  
  
-   当前 <xref:System.Type> 对象表示泛型类型的类型参数。  
  
     下面的示例检索 <xref:System.Nullable%601> 类型的类型参数，并尝试显示它的 <xref:System.Type.FullName%2A> 属性。  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   当前 <xref:System.Type> 对象表示基于泛型类型参数的数组类型、指针类型或 `byref` 类型。  
  
     下面的示例定义一个泛型类型 `Generictype1<T>`，其中包含三个方法： `Display(T[])`，该方法传递类型为 T 的数组;`HandleT(T)`，它传递了 T 对象;和 `ChangeValue(ref T)`，它按引用传递 T 对象。 由于C#和 Visual Basic 不允许我们将 T 定义为 `HandleT` 方法中的指针，因此，必须对表示方法的参数类型的 <xref:System.Type> 对象调用 <xref:System.Type.MakePointerType%2A> 方法，以创建指向泛型类型的指针。 该示例的输出显示，在所有三种情况下，都将 `null`<xref:System.Type.FullName%2A> 属性。  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   当前类型包含尚未替换为特定类型的泛型类型参数（即，<xref:System.Type.ContainsGenericParameters%2A> 属性返回 `true`），但该类型不是泛型类型定义（也就是说，<xref:System.Type.IsGenericTypeDefinition%2A> 属性返回 `false`  
  
     在下面的示例中，`Derived<T>` 继承自 `Base<T>`。 <xref:System.Type.BaseType%2A> 属性获取表示 `Derived<T>`的基类型的 <xref:System.Type> 对象，其 <xref:System.Type.FullName%2A> 属性返回 `null`。  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     若要获取不 `null`的 <xref:System.Type.FullName%2A>，可以使用 <xref:System.Type.GetGenericTypeDefinition%2A> 方法获取泛型类型定义，如示例所示。  
  
 此属性是只读的。  
  
   
  
## Examples  
 下面的示例显示指定类型的全名。  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 下面的示例将 <xref:System.Type.ToString%2A> 方法返回的字符串与 `Name`、<xref:System.Type.FullName%2A>和 <xref:System.Type.AssemblyQualifiedName%2A> 属性进行比较。  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">指定完全限定的类型名称</related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Type.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取描述当前泛型类型参数的协变和特殊约束的 <see cref="T:System.Reflection.GenericParameterAttributes" /> 标志。</summary>
        <value><see cref="T:System.Reflection.GenericParameterAttributes" /> 值的按位组合，用于描述当前泛型类型参数的协变和特殊约束。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性的值包含一些标志，这些标志描述当前泛型类型参数是否是协变的，以及描述任何特殊约束的标志。 使用 <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> 值选择协变标志，并使用 <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> 值选择约束标志。  
  
 有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。  
  
   
  
## Examples  
 下面的代码示例定义一个泛型类型 `Test`，该类型参数具有两个具有不同约束的类型参数。 当程序执行时，将使用 <xref:System.Type.GenericParameterAttributes%2A> 属性和 <xref:System.Type.GetGenericParameterConstraints%2A> 方法检查约束。  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前 <see cref="T:System.Type" /> 对象不是泛型类型参数。 也就是说，<see cref="P:System.Type.IsGenericParameter" /> 属性将返回 <see langword="false" />。</exception>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。</exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反射类型和泛型类型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反射检查和实例化泛型类型</related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public abstract int GenericParameterPosition { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GenericParameterPosition As Integer" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int GenericParameterPosition { int get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Type.GenericParameterPosition" />
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="T:System.Type" /> 对象表示泛型类型或泛型方法的类型参数时，获取类型参数在声明它的泛型类型或方法的类型参数列表中的位置。</summary>
        <value>类型参数在定义它的泛型类型或方法的类型参数列表中的位置。 位置编号从 0 开始。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GenericParameterPosition%2A> 属性返回类型参数在最初定义该类型参数的泛型类型定义或泛型方法定义的参数列表中的位置。 <xref:System.Type.DeclaringType%2A> 和 <xref:System.Type.DeclaringMethod%2A> 属性标识泛型类型或方法定义：  
  
-   如果 <xref:System.Type.DeclaringMethod%2A> 属性返回一个 <xref:System.Reflection.MethodInfo>，则该 <xref:System.Reflection.MethodInfo> 表示一个泛型方法定义，而当前的 <xref:System.Type> 对象表示该泛型方法定义的类型参数。  
  
-   如果 <xref:System.Type.DeclaringMethod%2A> 属性返回 `null`，则 <xref:System.Type.DeclaringType%2A> 属性始终返回表示泛型类型定义的 <xref:System.Type> 对象，当前 <xref:System.Type> 对象表示该泛型类型定义的类型参数。  
  
 若要为 <xref:System.Type.GenericParameterPosition%2A> 属性的值提供正确的上下文，必须标识类型参数所属的泛型类型或方法。 例如，请考虑以下代码中 `GetSomething` 的泛型方法的返回值：  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 `GetSomething` 返回的类型取决于提供给类 `A` 和 `GetSomething` 自身的类型参数。 你可以获取 `GetSomething`的 <xref:System.Reflection.MethodInfo>，以及从中获取返回类型的。 检查返回类型的类型参数时，<xref:System.Type.GenericParameterPosition%2A> 为两者都返回0。 `V` 的位置为0，因为 `V` 是类 `A`的类型参数列表中的第一个类型参数。 `X` 的位置为0，因为 `X` 是 `GetSomething`的类型参数列表中的第一个类型参数。  
  
> [!NOTE]
>  如果当前 <xref:System.Type> 不表示类型参数，则调用 <xref:System.Type.GenericParameterPosition%2A> 属性会导致异常。 检查开放式构造类型的类型参数时，请使用 <xref:System.Type.IsGenericParameter%2A> 属性来告知哪些类型参数是类型参数和类型参数。 <xref:System.Type.IsGenericParameter%2A> 属性返回类型参数的 `true`;然后，可以使用 <xref:System.Type.GenericParameterPosition%2A> 方法获取其位置，并使用 <xref:System.Type.DeclaringMethod%2A> 和 <xref:System.Type.DeclaringType%2A> 属性来确定定义它的泛型方法或类型定义。  
  
   
  
## Examples  
 下面的示例定义了一个具有两个类型参数的泛型类，并定义了第一个派生自第一个类的泛型类。 派生类的基类具有两个类型参数：第一个是 <xref:System.Int32>的，第二个是派生类型的类型参数。 该示例显示有关这些泛型类的信息，包括 <xref:System.Type.GenericParameterPosition%2A> 属性报告的位置。  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前的类型不表示类型参数。 也就是说，<see cref="P:System.Type.IsGenericParameter" /> 返回 <see langword="false" />。</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反射类型和泛型类型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反射检查和实例化泛型类型</related>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public abstract Type[] GenericTypeArguments { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GenericTypeArguments As Type()" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Type.GenericTypeArguments" />
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此类型泛型类型参数的数组。</summary>
        <value>此类型的泛型类型参数的数组。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性仅获取泛型类型参数;也就是说，已为当前类型的泛型类型参数指定的类型。 如果当前类型是泛型类型定义，则此属性返回一个空数组。  
  
> [!NOTE]
>  如果泛型类型在泛型方法或其他泛型类型中使用，则它的某些泛型类型参数可能是封闭方法或类型的泛型类型参数。  
  
 若要获取表示泛型类型定义的类型的泛型类型参数，请使用 <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> 属性。 若要获取当前 <xref:System.Type> 对象的 <xref:System.Reflection.TypeInfo> 对象，请使用 <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> 扩展方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public abstract int GetArrayRank ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetArrayRank () As Integer" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetArrayRank();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int" Usage="type.GetArrayRank " FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int&#xA;override this.GetArrayRank : unit -&gt; int" Usage="type.GetArrayRank " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取数组中的维数。</summary>
        <returns>包含当前类型中维数的整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例显示数组中的维度数。  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">此方法的功能在基类中不受支持，并且必须改为在派生类中实现。</exception>
        <exception cref="T:System.ArgumentException">当前类型不是数组。</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="type.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，实现 <see cref="P:System.Type.Attributes" /> 属性，并获取枚举值的按位组合（它指示与 <see cref="T:System.Type" /> 关联的特性）。</summary>
        <returns>表示 <see cref="T:System.Reflection.TypeAttributes" /> 的属性集的 <see cref="T:System.Type" /> 对象。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的特定构造函数。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor types" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor types" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="types">表示需要的构造函数的参数个数、顺序和类型的 <see cref="T:System.Type" /> 对象的数组。  
  
或 
<see cref="T:System.Type" /> 对象的空数组，用于获取不带参数的构造函数。 这样的空数组由 <see langword="static" /> 字段 <see cref="F:System.Type.EmptyTypes" /> 提供。</param>
        <summary>搜索其参数与指定数组中的类型匹配的公共实例构造函数。</summary>
        <returns>为表示某个公共实例构造函数（该构造函数的参数与参数类型数组中的类型匹配）的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重载查找公共实例构造函数，不能用于获取类初始值设定项（静态构造函数）。 若要获取类初始值设定项，请使用采用 <xref:System.Reflection.BindingFlags>的重载，并&#124;指定 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> （<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`中的 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>）。 还可以使用 <xref:System.Type.TypeInitializer%2A> 属性获取类初始值设定项。  
  
 如果请求的构造函数是非公共的，则此方法返回 `null`。  
  
> [!NOTE]
>  在查找构造函数和方法时，不能忽略参数。 在调用时，只能省略参数。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法将返回类型参数替换为相应类型参数的 <xref:System.Reflection.ConstructorInfo>。 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法始终返回 `null`。  
  
   
  
## Examples  
 下面的示例获取 `MyClass`的类型，获取 <xref:System.Reflection.ConstructorInfo> 对象，并显示构造函数签名。  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> 为 <see langword="null" />。  
  
或 
<paramref name="types" /> 的其中一个元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> 是多维的。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, types, modifiers)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, types, modifiers)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
或 
 若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。  
  
或 
要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</param>
        <param name="types"><see cref="T:System.Type" /> 对象的数组，表示构造函数要获取的参数的个数、顺序和类型。  
  
或 
获取不使用参数的构造函数的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。  
  
或 
 <see cref="F:System.Type.EmptyTypes" />。</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与参数类型数组中的相应元素关联的特性。 默认的联编程序不处理此参数。</param>
        <summary>使用指定绑定约束搜索其参数与指定自变量类型和修饰符匹配的构造函数。</summary>
        <returns>表示符合指定需求的构造函数的 <see cref="T:System.Reflection.ConstructorInfo" /> 对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不存在完全匹配项，`binder` 将尝试强制转换 `types` 数组中指定的参数类型，以便选择匹配项。 如果 `binder` 无法选择匹配项，则返回 `null`。  
  
 以下 <xref:System.Reflection.BindingFlags> 筛选器标志可用于定义要包括在搜索中的构造函数：  
  
-   若要获取返回，必须指定 `BindingFlags.Instance` 或 `BindingFlags.Static`。  
  
-   指定 `BindingFlags.Public` 以在搜索中包括公共构造函数。  
  
-   指定 `BindingFlags.NonPublic` 以在搜索中包括非公共构造函数（即私有、内部和受保护的构造函数）。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 若要使用此方法重载获取类初始值设定项（静态构造函数），必须&#124;指定 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> （<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 中的 Visual Basic）。 还可以使用 <xref:System.Type.TypeInitializer%2A> 属性获取类初始值设定项。  
  
> [!NOTE]
>  在查找构造函数和方法时，不能忽略参数。 在调用时，只能省略参数。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法将返回类型参数替换为相应类型参数的 <xref:System.Reflection.ConstructorInfo>。 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法始终返回 `null`。  
  
   
  
## Examples  
 下面的程序获取 `MyClass1` 类的类型，获取与指定的绑定标志匹配的 <xref:System.Reflection.ConstructorInfo> 对象，并显示该构造函数的签名。  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> 为 <see langword="null" />。  
  
或 
<paramref name="types" /> 的其中一个元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> 是多维的。  
  
或 
 <paramref name="modifiers" /> 是多维的。  
  
或 
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的长度不相同。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
或 
 若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。  
  
或 
要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</param>
        <param name="callConvention">对象，用于指定要使用的一套规则，这些规则涉及参数的顺序和布局、传递返回值的方式、用于参数的寄存器和清理堆栈的方式。</param>
        <param name="types"><see cref="T:System.Type" /> 对象的数组，表示构造函数要获取的参数的个数、顺序和类型。  
  
或 
获取不使用参数的构造函数的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <paramref name="types" /> 数组中的相应元素关联的特性。 默认的联编程序不处理此参数。</param>
        <summary>用指定绑定约束和指定调用约定，搜索其参数与指定参数类型及修饰符匹配的构造函数。</summary>
        <returns>表示符合指定需求的构造函数的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管默认联编程序不处理 <xref:System.Reflection.ParameterModifier> （`modifiers` 参数），但你可以使用 abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> 类编写处理 `modifiers`的自定义联编程序。 仅当通过 COM 互操作进行调用时才使用 `ParameterModifier`，且仅处理通过引用传递的参数。  
  
 如果不存在完全匹配项，`binder` 将尝试强制转换 `types` 数组中指定的参数类型，以便选择匹配项。 如果 `binder` 无法选择匹配项，则返回 `null`。  
  
 以下 <xref:System.Reflection.BindingFlags> 筛选器标志可用于定义要包括在搜索中的构造函数：  
  
-   若要获取返回，必须指定 `BindingFlags.Instance` 或 `BindingFlags.Static`。  
  
-   指定 `BindingFlags.Public` 以在搜索中包括公共构造函数。  
  
-   指定 `BindingFlags.NonPublic` 以在搜索中包括非公共构造函数（即私有、内部和受保护的构造函数）。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 若要使用此方法获取类初始值设定项（静态构造函数），必须&#124;指定 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> （<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 中的 Visual Basic）。 还可以使用 <xref:System.Type.TypeInitializer%2A> 属性获取类初始值设定项。  
  
 下表显示了在类型上反射时，`Get` 方法返回基类的成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法（虚拟和非虚拟）可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|属性|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分，包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射，属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性，但派生类只有 get 访问器，则派生类属性将隐藏基类属性，并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
> [!NOTE]
>  在查找构造函数和方法时，不能忽略参数。 在调用时，只能省略参数。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法将返回类型参数替换为相应类型参数的 <xref:System.Reflection.ConstructorInfo>。 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法始终返回 `null`。  
  
   
  
## Examples  
 下面的示例获取 `MyClass1`的类型，获取与指定的绑定标志匹配的 <xref:System.Reflection.ConstructorInfo> 对象，并显示构造函数签名。  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> 为 <see langword="null" />。  
  
或 
<paramref name="types" /> 的其中一个元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> 是多维的。  
  
或 
 <paramref name="modifiers" /> 是多维的。  
  
或 
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的长度不相同。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
或 
若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。  
  
或 
要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</param>
        <param name="callConvention">对象，用于指定要使用的一套规则，这些规则涉及参数的顺序和布局、传递返回值的方式、用于参数的寄存器和清理堆栈的方式。</param>
        <param name="types"><see cref="T:System.Type" /> 对象的数组，表示构造函数要获取的参数的个数、顺序和类型。  
  
或 
获取不使用参数的构造函数的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <paramref name="types" /> 数组中的相应元素关联的特性。 默认的联编程序不处理此参数。</param>
        <summary>当在派生类中重写时，使用指定的绑定约束和指定的调用约定搜索其参数与指定的自变量类型和修饰符匹配的构造函数。</summary>
        <returns>表示符合指定需求的构造函数的 <see cref="T:System.Reflection.ConstructorInfo" /> 对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管默认联编程序不处理 <xref:System.Reflection.ParameterModifier> （`modifiers` 参数），但你可以使用 abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> 类编写处理 `modifiers`的自定义联编程序。 仅当通过 COM 互操作进行调用时才使用 `ParameterModifier`，且仅处理通过引用传递的参数。  
  
 如果不存在完全匹配项，`binder` 将尝试强制转换 `types` 数组中指定的参数类型，以便选择匹配项。 如果 `binder` 无法选择匹配项，则返回 `null`。  
  
 以下 <xref:System.Reflection.BindingFlags> 筛选器标志可用于定义要包括在搜索中的构造函数：  
  
-   若要获取返回，必须指定 `BindingFlags.Instance` 或 `BindingFlags.Static`。  
  
-   指定 `BindingFlags.Public` 以在搜索中包括公共构造函数。  
  
-   指定 `BindingFlags.NonPublic` 以在搜索中包括非公共构造函数（即私有、内部和受保护的构造函数）。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 此方法实现 <xref:System.Type.GetConstructor%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> 为 <see langword="null" />。  
  
或 
<paramref name="types" /> 的其中一个元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> 是多维的。  
  
或 
 <paramref name="modifiers" /> 是多维的。  
  
或 
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的长度不相同。</exception>
        <exception cref="T:System.NotSupportedException">当前的类型是 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 或 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的构造函数。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]&#xA;override this.GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回为当前 <see cref="T:System.Type" /> 定义的所有公共构造函数。</summary>
        <returns><see cref="T:System.Reflection.ConstructorInfo" /> 对象的数组，表示当前 <see cref="T:System.Type" /> 定义的所有公共实例构造函数，但不包括类型初始值设定项（静态构造函数）。 如果没有为当前 <see cref="T:System.Type" /> 定义公共实例构造函数，或者当前 <see cref="T:System.Type" /> 表示泛型类型或泛型方法的定义中的类型参数，则返回 <see cref="T:System.Reflection.ConstructorInfo" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetConstructors%2A> 方法不按特定顺序（如声明顺序）返回构造函数。 你的代码不能依赖于构造函数的返回顺序，因为该顺序会有所不同。  
  
 下表显示了在类型上反射时，`Get` 方法返回基类的成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法（虚拟和非虚拟）可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|属性|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分，包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射，属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性，但派生类只有 get 访问器，则派生类属性将隐藏基类属性，并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 此方法重载调用 <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> 方法重载，<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> （<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>`Or`中的 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> Visual Basic）。 它将找不到类初始值设定项（静态构造函数）。 若要查找类初始值设定项，请使用采用 <xref:System.Reflection.BindingFlags>的重载， &#124;并指定 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> （<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`中的 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>）。 还可以使用 <xref:System.Type.TypeInitializer%2A> 属性获取类初始值设定项。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法返回 <xref:System.Reflection.ConstructorInfo> 对象，这些对象的类型参数被替换为相应的类型参数。 例如，如果类 `C<T>` 具有构造函数 `C(T t1)` （在 Visual Basic 中为`Sub New(ByVal t1 As T)`），则对 <xref:System.Type.GetConstructors%2A> 调用 `C<int>` 将返回表示 <xref:System.Reflection.ConstructorInfo> 的C# `C(int t1)` （`Sub New(ByVal t1 As Integer)` 中的 Visual Basic）。  
  
 如果当前 <xref:System.Type> 表示泛型类型参数，则 <xref:System.Type.GetConstructors%2A> 方法返回空数组。  
  
   
  
## Examples  
 此示例显示具有两个实例构造函数和一个静态构造函数的类的 <xref:System.Type.GetConstructors%2A> 重载的输出。  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 此代码的输出为：  
  
 2  
  
 False  
  
 False  
  
 因为 <xref:System.Type.GetConstructors> 重载仅使用 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> 和 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>，所以静态构造函数既不由 `for` 表达式进行计数，也不由 `IsStatic`计算。  
  
 若要查找静态构造函数，请使用 <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> 重载，并传递 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>、<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>、<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>、<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>的组合（逻辑 `OR`），如下面的代码示例所示：  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 输出如下：  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
或 
若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回空数组。</param>
        <summary>当在派生类中重写时，使用指定 <see cref="T:System.Type" /> 搜索为当前 <see langword="BindingFlags" /> 定义的构造函数。</summary>
        <returns>表示为当前 <see cref="T:System.Reflection.ConstructorInfo" /> 定义的匹配指定绑定约束的所有构造函数的 <see cref="T:System.Type" /> 对象数组，包括类型初始值设定项（如果定义的话）。 如果当前 <see cref="T:System.Reflection.ConstructorInfo" /> 没有定义构造函数，或者定义的构造函数都不符合绑定约束，或者当前 <see cref="T:System.Type" /> 表示泛型类型或泛型方法定义的类型参数，则返回 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
`bindingAttr` 可用于指定是只返回公共构造函数还是返回公共和非公共构造函数。  
  
以下 <xref:System.Reflection.BindingFlags> 筛选器标志可用于定义要包括在搜索中的构造函数：  
  
- 指定 `BindingFlags.Static` 和 `BindingFlags.NonPublic` 以检索类初始值设定项（静态构造函数）。 还可以使用 <xref:System.Type.TypeInitializer%2A> 属性获取类初始值设定项。

- 指定 `BindingFlags.Instance` 以及用于检索实例构造函数的一个或两个 `BindingFlags.Public` 和 `BindingFlags.NonPublic`。   
  
有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  

<xref:System.Type.GetConstructors%2A> 方法不按特定顺序（如声明顺序）返回构造函数。 你的代码不能依赖于构造函数的返回顺序，因为该顺序会有所不同。  

如果当前 <xref:System.Type> 表示构造泛型类型，则此方法返回 <xref:System.Reflection.ConstructorInfo> 对象，这些对象的类型参数被替换为相应的类型参数。 例如，如果类 `C<T>` 具有构造函数 `C(T t1)` （在 Visual Basic 中为`Sub New(ByVal t1 As T)`），则对 <xref:System.Type.GetConstructors%2A> 调用 `C<int>` 将返回表示 <xref:System.Reflection.ConstructorInfo> 的C# `C(int t1)` （`Sub New(ByVal t1 As Integer)` 中的 Visual Basic）。  
  
如果当前 <xref:System.Type> 表示泛型类型参数，则 <xref:System.Type.GetConstructors%2A> 方法返回空数组。  
  
## Examples  

此示例显示具有两个实例构造函数和一个静态构造函数的类的 <xref:System.Type.GetConstructors> 重载的输出。  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 此代码的输出为：  
  
 2  
  
 False  
  
 False  
  
 因为 <xref:System.Type.GetConstructors%2A> 重载仅使用 <xref:System.Reflection.BindingFlags.Public> 和 <xref:System.Reflection.BindingFlags.Instance>，所以静态构造函数既不由 `for` 表达式进行计数，也不由 `IsStatic`计算。  
  
 若要查找静态构造函数，请使用 <xref:System.Type.GetConstructors%2A> 重载，并向其传递 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>、<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>、<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>、<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>的组合（逻辑或），如下面的代码示例所示：  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 输出如下：  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetDefaultMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>搜索为设置了 <see cref="T:System.Type" /> 的当前 <see cref="T:System.Reflection.DefaultMemberAttribute" /> 定义的成员。</summary>
        <returns>表示当前 <see cref="T:System.Reflection.MemberInfo" /> 的所有默认成员的 <see cref="T:System.Type" /> 对象数组。  
  
或 
如果当前 <see cref="T:System.Reflection.MemberInfo" /> 没有默认成员，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetDefaultMembers%2A> 方法不按特定顺序（如字母顺序或声明顺序）返回成员。 你的代码不能依赖于成员的返回顺序，因为该顺序会有所不同。  
  
 此方法可由派生类重写。  
  
 成员包括属性、方法、字段、事件等。  
  
 下表显示了在类型上反射时，`Get` 方法返回基类的成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法（虚拟和非虚拟）可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|属性|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分，包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射，属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性，但派生类只有 get 访问器，则派生类属性将隐藏基类属性，并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法返回 <xref:System.Reflection.MemberInfo> 对象，这些对象的类型参数被替换为相应的类型参数。 例如，如果类 `C<T>` 具有返回 `T`的属性 `P`，则在 `C<int>` 上调用 <xref:System.Type.GetDefaultMembers%2A> 将返回中C#的 `int P` （`Property P As Integer` 中的 Visual Basic）。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的成员，或者在没有类约束的情况下搜索 <xref:System.Object> 的成员。  
  
   
  
## Examples  
 下面的示例获取 `MyClass` 的默认成员信息并显示默认成员。  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="abstract member GetElementType : unit -&gt; Type" Usage="type.GetElementType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中重写时，返回当前数组、指针或引用类型包含的或引用的对象的 <see cref="T:System.Type" />。</summary>
        <returns>当前数组、指针或引用类型包含或引用的对象的 <see cref="T:System.Type" />；如果当前 <see langword="null" /> 不是数组或指针，不是按引用传递，或者表示泛型类型或泛型方法的定义中的泛型类型或类型参数，则为 <see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回 <xref:System.Array> 类 `null`。  
  
   
  
## Examples  
 下面的示例演示如何使用 `GetElementType` 方法。  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member GetEnumName : obj -&gt; string&#xA;override this.GetEnumName : obj -&gt; string" Usage="type.GetEnumName value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">要检索其名称的值。</param>
        <summary>返回当前枚举类型中具有指定值的常数的名称。</summary>
        <returns>当前枚举类型中具有指定值的成员的名称；如果未找到这样的常数，则为 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">当前类型不是一个枚举。  
  
或 
 <paramref name="value" /> 既不是当前类型，也不具有与当前类型相同的基础类型。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumNames : unit -&gt; string[]&#xA;override this.GetEnumNames : unit -&gt; string[]" Usage="type.GetEnumNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回当前枚举类型中各个成员的名称。</summary>
        <returns>一个数组，其中包含枚举中各个成员的名称。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回值数组的元素按枚举常量的二进制值（即无符号值）排序。 如果数组包含具有相同值的枚举常量，则不指定其对应名称的顺序。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前类型不是一个枚举。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumUnderlyingType : unit -&gt; Type&#xA;override this.GetEnumUnderlyingType : unit -&gt; Type" Usage="type.GetEnumUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回当前枚举类型的基础类型。</summary>
        <returns>当前枚举的基础类型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，和中C#的枚举的基础类型 <xref:System.Int32>Visual Basic。 可以指定其他整数类型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前类型不是一个枚举。  
  
 或  
  
 枚举类型无效，因为它包含多个实例字段。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumValues : unit -&gt; Array&#xA;override this.GetEnumValues : unit -&gt; Array" Usage="type.GetEnumValues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回当前枚举类型中各个常数的值组成的数组。</summary>
        <returns>包含值的数组。 该数组的元素按枚举常量的二进制值（无符号值）排序。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">当前类型不是一个枚举。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取由当前 <see cref="T:System.Type" /> 声明或继承的特定事件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.EventInfo GetEvent(string name) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetEvent : string -&gt; System.Reflection.EventInfo" Usage="type.GetEvent name" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string -&gt; System.Reflection.EventInfo&#xA;override this.GetEvent : string -&gt; System.Reflection.EventInfo" Usage="type.GetEvent name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">该字符串包含事件名称，该事件是由当前 <see cref="T:System.Type" /> 声明或继承的。</param>
        <summary>返回表示指定的公共事件的 <see cref="T:System.Reflection.EventInfo" /> 对象。</summary>
        <returns>如找到，则为表示由当前 <see cref="T:System.Type" /> 声明或继承的指定公共事件的对象；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果某个事件至少有一个公共方法或访问器，则该事件将被视为 "公共"。 否则，该事件将被视为私有事件，并且你&#124;必须&#124;使用 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> （在 Visual Basic 中，使用 `Or`组合值）来获取它。  
  
 搜索 `name` 区分大小写。 搜索包括公共静态和公共实例事件。  
  
 下表显示了在类型上反射时，`Get` 方法返回基类的成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法（虚拟和非虚拟）可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|属性|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分，包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射，属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性，但派生类只有 get 访问器，则派生类属性将隐藏基类属性，并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法将返回类型参数替换为相应类型参数的 <xref:System.Reflection.EventInfo>。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的事件。  
  
   
  
## Examples  
 下面的示例创建一个 <xref:System.Reflection.EventInfo> 对象，并为指定的事件获取按钮类的事件。  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="type.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">字符串包含由当前的 <see cref="T:System.Type" /> 声明或继承的事件的名称。</param>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
或 
 若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</param>
        <summary>当在派生类中重写时，使用指定绑定约束，返回表示指定事件的 <see cref="T:System.Reflection.EventInfo" /> 对象。</summary>
        <returns>如找到，则为表示由当前 <see cref="T:System.Type" /> 声明或继承的指定公共事件的对象；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 以下 <xref:System.Reflection.BindingFlags> 筛选器标志可用于定义要包括在搜索中的事件：  
  
-   若要获取返回，必须指定 `BindingFlags.Instance` 或 `BindingFlags.Static`。  
  
-   指定 `BindingFlags.Public` 以在搜索中包括公共事件。  
  
-   指定 `BindingFlags.NonPublic` 以在搜索中包括非公共事件（即，私有事件、内部事件和受保护事件）。  
  
-   指定 `BindingFlags.FlattenHierarchy` 包括层次结构中的 `public` 和 `protected` 静态成员;不包括继承类中 `private` 静态成员。  
  
 以下 <xref:System.Reflection.BindingFlags> 修饰符标志可用于更改搜索的工作方式：  
  
-   `BindingFlags.IgnoreCase` 忽略 `name`的大小写。  
  
-   `BindingFlags.DeclaredOnly` 仅搜索 <xref:System.Type>上声明的事件，而不搜索仅继承的事件。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果某个事件至少有一个公共方法或访问器，则该事件将被视为 "公共"。 否则，该事件将被视为私有事件，并且你&#124;必须&#124;使用 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> （在 Visual Basic 中，使用 `Or`组合值）来获取它。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法将返回类型参数替换为相应类型参数的 <xref:System.Reflection.EventInfo>。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的事件。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> 方法在类型中搜索名为 "单击" 的公共或非公共事件，该事件不 `static` （`Shared` Visual Basic）。  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取由当前 <see cref="T:System.Type" /> 声明或继承的事件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : unit -&gt; System.Reflection.EventInfo[]&#xA;override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回由当前 <see cref="T:System.Type" /> 声明或继承的所有公共事件。</summary>
        <returns>表示由当前 <see cref="T:System.Reflection.EventInfo" /> 声明或继承的所有公共事件的 <see cref="T:System.Type" /> 对象数组。  
  
或 
如果当前 <see cref="T:System.Reflection.EventInfo" /> 没有默认成员，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果某个事件至少有一个公共方法或访问器，则该事件将被视为 "公共"。 否则，该事件将被视为私有事件，并且你&#124;必须&#124;使用 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> （在 Visual Basic 中，使用 `Or`组合值）来获取它。  
  
 <xref:System.Type.GetEvents%2A> 方法不按特定顺序返回事件，如字母顺序或声明顺序。 你的代码不能依赖于事件的返回顺序，因为该顺序会有所不同。  
  
 此方法可由派生类重写。  
  
 下表显示了在类型上反射时，`Get` 方法返回基类的成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法（虚拟和非虚拟）可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|属性|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分，包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射，属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性，但派生类只有 get 访问器，则派生类属性将隐藏基类属性，并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法返回 <xref:System.Reflection.EventInfo> 对象，这些对象的类型参数被替换为相应的类型参数。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的事件。  
  
   
  
## Examples  
 下面的示例获取 <xref:System.Reflection.EventInfo> 对象的数组，获取 `Button` 类的所有事件，并显示事件名称。 若要编译 Visual Basic 示例，请使用以下命令行：  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。

或

 若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回空数组。</param>
        <summary>当在派生类中重写时，使用指定绑定约束，搜索由当前 <see cref="T:System.Type" /> 声明或继承的事件。</summary>
        <returns><see cref="T:System.Reflection.EventInfo" /> 对象的数组，表示当前 <see cref="T:System.Type" /> 所声明或继承的与指定绑定约束匹配的所有事件。  
  
或 
如果当前 <see cref="T:System.Reflection.EventInfo" /> 没有事件，或者如果没有一个事件匹配绑定约束，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetEvents%2A> 方法不按特定顺序返回事件，如字母顺序或声明顺序。 你的代码不能依赖于事件的返回顺序，因为该顺序会有所不同。  
  
 以下 <xref:System.Reflection.BindingFlags> 筛选器标志可用于定义要包括在搜索中的事件：  
  
-   若要获取返回，必须指定 `BindingFlags.Instance` 或 `BindingFlags.Static`。  
  
-   指定 `BindingFlags.Public` 以在搜索中包括公共事件。  
  
-   指定 `BindingFlags.NonPublic` 以在搜索中包括非公共事件（即，私有事件、内部事件和受保护事件）。 仅返回基类的受保护事件和内部事件;不返回基类上的私有事件。  
  
-   指定 `BindingFlags.FlattenHierarchy` 包括层次结构中的 `public` 和 `protected` 静态成员;不包括继承类中 `private` 静态成员。  
  
 以下 <xref:System.Reflection.BindingFlags> 修饰符标志可用于更改搜索的工作方式：  
  
-   `BindingFlags.DeclaredOnly` 仅搜索 <xref:System.Type>上声明的事件，而不搜索仅继承的事件。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果某个事件至少有一个公共方法或访问器，则该事件将被视为 "公共"。 否则，该事件将被视为私有事件，并且你&#124;必须&#124;使用 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> （在 Visual Basic 中，使用 `Or`组合值）来获取它。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法返回 <xref:System.Reflection.EventInfo> 对象，这些对象的类型参数被替换为相应的类型参数。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的事件。  
  
   
  
## Examples  
 下面的示例获取与指定绑定标志匹配的 <xref:System.Reflection.EventInfo> 对象的数组，获取 `Button` 类的所有事件，并显示事件名称。 若要编译 Visual Basic 示例，请使用以下命令行：  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的特定字段。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo GetField(string name) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::FieldInfo ^ GetField(System::String ^ name);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="type.GetField name" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetField : string -&gt; System.Reflection.FieldInfo&#xA;override this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="type.GetField name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的数据字段的名称的字符串。</param>
        <summary>搜索具有指定名称的公共字段。</summary>
        <returns>如找到，则为表示具有指定名称的公共字段的对象；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜索 `name` 区分大小写。 搜索包括公共静态和公共实例字段。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法将返回类型参数替换为相应类型参数的 <xref:System.Reflection.FieldInfo>。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的字段。  
  
   
  
## Examples  
 下面的示例获取指定类的 `Type` 对象，获取该字段的 <xref:System.Reflection.FieldInfo> 对象，并显示该字段的值。  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">此 <see cref="T:System.Type" /> 对象是尚未调用其 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 方法的 <see cref="T:System.Reflection.Emit.TypeBuilder" />。</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="type.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的数据字段的名称的字符串。</param>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
或 
 若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</param>
        <summary>使用指定绑定约束搜索指定字段。</summary>
        <returns>表示符合指定要求的字段的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表显示了在类型上反射时，`Get` 方法返回基类的成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法（虚拟和非虚拟）可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|属性|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分，包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射，属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性，但派生类只有 get 访问器，则派生类属性将隐藏基类属性，并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 以下 <xref:System.Reflection.BindingFlags> 筛选器标志可用于定义要包括在搜索中的字段：  
  
-   若要获取返回，必须指定 `BindingFlags.Instance` 或 `BindingFlags.Static`。  
  
-   指定 `BindingFlags.Public` 以在搜索中包括公共字段。  
  
-   指定 `BindingFlags.NonPublic` 以在搜索中包括非公共字段（即，私有字段、内部字段和受保护字段）。  
  
-   指定 `BindingFlags.FlattenHierarchy` 包括层次结构中的 `public` 和 `protected` 静态成员;不包括继承类中 `private` 静态成员。  
  
 以下 <xref:System.Reflection.BindingFlags> 修饰符标志可用于更改搜索的工作方式：  
  
-   `BindingFlags.IgnoreCase` 忽略 `name`的大小写。  
  
-   `BindingFlags.DeclaredOnly` 仅搜索 <xref:System.Type>上声明的字段，而不搜索仅继承的字段。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法将返回类型参数替换为相应类型参数的 <xref:System.Reflection.FieldInfo>。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的字段。  
  
   
  
## Examples  
 下面的示例获取指定类的 `Type` 对象，获取与指定绑定标志匹配的字段的 <xref:System.Reflection.FieldInfo> 对象，并显示该字段的值。  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的字段。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo[] GetFields() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetFields : unit -&gt; System.Reflection.FieldInfo[]&#xA;override this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回当前 <see cref="T:System.Type" /> 的所有公共字段。</summary>
        <returns>表示为当前 <see cref="T:System.Reflection.FieldInfo" /> 定义的所有公共字段的 <see cref="T:System.Type" /> 对象数组。  
  
或 
如果没有为当前 <see cref="T:System.Reflection.FieldInfo" /> 定义的公共字段，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetFields%2A> 方法不按特定顺序（如字母顺序或声明顺序）返回字段。 你的代码不能依赖于字段的返回顺序，因为该顺序会有所不同。  
  
 下表显示了在类型上反射时，`Get` 方法返回基类的成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法（虚拟和非虚拟）可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|属性|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分，包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射，属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性，但派生类只有 get 访问器，则派生类属性将隐藏基类属性，并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法返回 <xref:System.Reflection.FieldInfo> 对象，这些对象的类型参数被替换为相应的类型参数。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的公共字段。  
  
   
  
## Examples  
 下面的示例演示如何使用 `GetFields()` 方法。  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。

或

 若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回空数组。</param>
        <summary>当在派生类中重写时，使用指定绑定约束，搜索为当前 <see cref="T:System.Type" /> 定义的字段。</summary>
        <returns>表示为当前 <see cref="T:System.Reflection.FieldInfo" /> 定义的匹配指定绑定约束的所有字段的 <see cref="T:System.Type" /> 对象数组。  
  
或 
如果没有为当前 <see cref="T:System.Reflection.FieldInfo" /> 定义的字段，或者如果没有一个定义的字段匹配绑定约束，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

为了使 `GetFields(BindingFlags)` 重载成功检索属性信息，`bindingAttr` 参数必须包含至少一个 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> 和 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>，同时至少包含 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 和 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>中的一个。 

以下 <xref:System.Reflection.BindingFlags> 筛选器标志可用于定义要包括在搜索中的字段：  
  
- 指定 `BindingFlags.Instance` 以包含实例方法。 

- 指定 `BindingFlags.Static` 以包含静态方法。 
    
- 指定 `BindingFlags.Public` 以在搜索中包括公共字段。  
  
- 指定 `BindingFlags.NonPublic` 以在搜索中包括非公共字段（即，私有字段、内部字段和受保护字段）。 仅返回基类的受保护字段和内部字段;不返回基类上的私有字段。  
  
- 指定 `BindingFlags.FlattenHierarchy` 包括层次结构中的 `public` 和 `protected` 静态成员;不包括继承类中 `private` 静态成员。  

- 单独指定 `BindingFlags.Default` 以返回空的 <xref:System.Reflection.PropertyInfo> 数组。

以下 <xref:System.Reflection.BindingFlags> 修饰符标志可用于更改搜索的工作方式：  
  
- `BindingFlags.DeclaredOnly` 仅搜索 <xref:System.Type>上声明的字段，而不搜索仅继承的字段。  
  
有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
<xref:System.Type.GetFields%2A> 方法不按特定顺序（如字母顺序或声明顺序）返回字段。 你的代码不能依赖于字段的返回顺序，因为该顺序会有所不同。  

 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法返回 <xref:System.Reflection.FieldInfo> 对象，这些对象的类型参数被替换为相应的类型参数。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的公共字段。  
  
## Examples  
 下面的示例演示如何使用 `GetFields(BindingFlags)` 方法。  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericArguments : unit -&gt; Type[]&#xA;override this.GetGenericArguments : unit -&gt; Type[]" Usage="type.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示封闭式泛型类型的类型参数或泛型类型定义的类型参数的 <see cref="T:System.Type" /> 对象的数组。</summary>
        <returns>表示泛型类型的类型实参的 <see cref="T:System.Type" /> 对象的数组。 如果当前类型不是泛型类型，则返回一个空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 数组元素按它们出现在泛型类型的类型参数列表中的顺序返回。  
  
-   如果当前类型是封闭式构造类型（即，<xref:System.Type.ContainsGenericParameters%2A> 属性返回 `false`），则 <xref:System.Type.GetGenericArguments%2A> 方法返回的数组包含已分配给泛型类型定义的泛型类型参数的类型。  
  
-   如果当前类型是泛型类型定义，则数组包含类型参数。  
  
-   如果当前类型为开放式构造类型（即，<xref:System.Type.ContainsGenericParameters%2A> 属性返回 `true`），其中特定类型尚未分配给封闭泛型类型或方法的所有类型参数和类型参数，则数组同时包含类型和类型参数。 使用 <xref:System.Type.IsGenericParameter%2A> 属性将它们区分开来。 有关此方案的演示，请参阅 <xref:System.Type.ContainsGenericParameters%2A> 属性的代码示例。  
  
 有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Type.GetGenericArguments%2A> 方法来显示构造类型的类型参数及其泛型类型定义的类型参数。  
  
 此代码示例是为 <xref:System.Type.IsGenericTypeDefinition%2A> 属性提供的更大示例的一部分。 请参阅示例输出的更大示例。  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。 派生类必须提供一个实现。</exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反射类型和泛型类型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反射检查和实例化泛型类型</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericParameterConstraints : unit -&gt; Type[]&#xA;override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="type.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示当前泛型类型参数约束的 <see cref="T:System.Type" /> 对象的数组。</summary>
        <returns>表示当前泛型类型参数上的约束的 <see cref="T:System.Type" /> 对象的数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 泛型类型参数上的每个约束都表示为一个 <xref:System.Type> 对象。 使用 <xref:System.Type.IsClass%2A> 属性来确定约束是否为基类约束;如果属性返回 `false`，则约束是一个接口约束。 如果类型参数没有类约束，并且没有接口约束，则返回空数组。  
  
 有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。  
  
   
  
## Examples  
 下面的代码示例定义一个泛型类型 `Test`，该类型参数具有两个具有不同约束的类型参数。 当程序执行时，将使用 <xref:System.Type.GenericParameterAttributes%2A> 属性和 <xref:System.Type.GetGenericParameterConstraints%2A> 方法检查约束。  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前 <see cref="T:System.Type" /> 对象不是泛型类型参数。 也就是说，<see cref="P:System.Type.IsGenericParameter" /> 属性将返回 <see langword="false" />。</exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反射检查和实例化泛型类型</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public abstract Type GetGenericTypeDefinition ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetGenericTypeDefinition () As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetGenericTypeDefinition();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member GetGenericTypeDefinition : unit -&gt; Type" Usage="type.GetGenericTypeDefinition " FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetGenericTypeDefinition : unit -&gt; Type&#xA;override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="type.GetGenericTypeDefinition " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个表示可用于构造当前泛型类型的泛型类型定义的 <see cref="T:System.Type" /> 对象。</summary>
        <returns>表示可用于构造当前类型的泛型类型的 <see cref="T:System.Type" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 泛型类型定义是可以从中构造其他类型的模板。 例如，从泛型类型定义 `G<T>` （用C#语法表示; `G(Of T)` 在 Visual Basic 中或在中C++`generic <typename T> ref class G`），可以构造并实例化类型 `G<int>` （`G(Of Integer)` 中的 Visual Basic）。 给定表示此构造类型的 <xref:System.Type> 对象，<xref:System.Type.GetGenericTypeDefinition%2A> 方法返回泛型类型定义。  
  
 如果两种构造类型是使用相同的类型参数从同一泛型类型定义创建的，则 <xref:System.Type.GetGenericTypeDefinition%2A> 方法为这两种类型返回相同的 <xref:System.Type> 对象。  
  
 如果对已表示泛型类型定义的 <xref:System.Type> 对象调用 <xref:System.Type.GetGenericTypeDefinition%2A> 方法，则它将返回当前 <xref:System.Type>。  
  
> [!IMPORTANT]
>  泛型类型的数组本身不是泛型。 在C#代码 `A<int>[] v;` 或 Visual Basic 代码 `Dim v() As A(Of Integer)`中，变量 `v` 的类型不是泛型。 在调用 <xref:System.Type.GetGenericTypeDefinition%2A>之前，请使用 <xref:System.Type.IsGenericType%2A> 来确定类型是否为泛型。  
  
 有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。  
  
   
  
## Examples  
 下面的代码示例使用普通实例创建创建构造类型的实例，然后使用 <xref:System.Type.GetType%2A> 和 <xref:System.Type.GetGenericTypeDefinition%2A> 方法检索构造类型和泛型类型定义。 此示例使用泛型 <xref:System.Collections.Generic.Dictionary%602> 类型;构造类型表示具有字符串键的 `Test` 对象的 <xref:System.Collections.Generic.Dictionary%602>。  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前类型不是泛型类型。  也就是说，<see cref="P:System.Type.IsGenericType" /> 返回 <see langword="false" />。</exception>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。 派生类必须提供一个实现。</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反射类型和泛型类型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反射检查和实例化泛型类型</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="type.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此实例的哈希代码。</summary>
        <returns>此实例的哈希代码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的示例显示 `System.Windows.Forms.Button` 类的哈希代码。  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取由当前 <see cref="T:System.Type" /> 实现或继承的特定接口。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetInterface(string name) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetInterface(System::String ^ name);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetInterface : string -&gt; Type" Usage="type.GetInterface name" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string -&gt; Type&#xA;override this.GetInterface : string -&gt; Type" Usage="type.GetInterface name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的接口名称的字符串。 对于泛型接口，这是重整名称。</param>
        <summary>搜索具有指定名称的接口。</summary>
        <returns>表示具有指定名称且由当前的 <see cref="T:System.Type" /> 实现或继承的接口的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜索 `name` 区分大小写。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法将返回类型参数替换为相应类型参数的 <xref:System.Type>。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索接口约束以及从类或接口约束继承的任何接口。  
  
> [!NOTE]
>  对于泛型接口，`name` 参数是错位的名称，以抑音符（\`）和类型参数数目结尾。 这对于泛型接口定义和构造泛型接口都是如此。 例如，若要查找 `IExample<T>` （`IExample(Of T)` 在 Visual Basic 中）或 `IExample<string>` （`IExample(Of String)` 中的 Visual Basic），请搜索 "``"IExample`1"``"。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Type.GetInterface%28System.String%29> 方法在 <xref:System.Collections.Hashtable> 类中搜索 <xref:System.Runtime.Serialization.IDeserializationCallback> 接口，并列出接口的方法。  
  
 此代码示例还演示 <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> 方法重载和 <xref:System.Type.GetInterfaceMap%2A> 方法。  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">当前 <see cref="T:System.Type" /> 表示实现具有不同类型参数的相同泛型接口的类型。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string * bool -&gt; Type" Usage="type.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的接口名称的字符串。 对于泛型接口，这是重整名称。</param>
        <param name="ignoreCase"><see langword="true" /> 表示对于用来指定简单接口名称的 <paramref name="name" /> 部分（该部分指定命名空间大小写必须正确）忽略其大小写。  
  
或 
 <see langword="false" /> 表示对 <paramref name="name" /> 的所有部分执行区分大小写的搜索。</param>
        <summary>当在派生类中重写时，搜索指定的接口，指定是否要对接口名称执行不区分大小写的搜索。</summary>
        <returns>表示具有指定名称且由当前的 <see cref="T:System.Type" /> 实现或继承的接口的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ignoreCase` 参数仅适用于简单接口名称，而不适用于命名空间。 指定命名空间的 `name` 部分必须具有正确的大小写，否则将找不到该接口。 例如，字符串 "system.icomparable" 查找 <xref:System.IComparable> 接口，但字符串 "system.icomparable" 不会。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法将返回类型参数替换为相应类型参数的 <xref:System.Type>。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索接口约束以及从类或接口约束继承的任何接口。  
  
> [!NOTE]
>  对于泛型接口，`name` 参数是错位的名称，以抑音符（\`）和类型参数数目结尾。 这对于泛型接口定义和构造泛型接口都是如此。 例如，若要查找 `IExample<T>` （`IExample(Of T)` 在 Visual Basic 中）或 `IExample<string>` （`IExample(Of String)` 中的 Visual Basic），请搜索 `"IExample`1 ""。  
  
   
  
## Examples  
 下面的代码示例使用 <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> 方法对 <xref:System.Collections.IEnumerable> 接口执行 <xref:System.Collections.Hashtable> 类的不区分大小写的搜索。  
  
 此代码示例还演示 <xref:System.Type.GetInterface%28System.String%29> 方法重载和 <xref:System.Type.GetInterfaceMap%2A> 方法。  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">当前 <see cref="T:System.Type" /> 表示实现具有不同类型参数的相同泛型接口的类型。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping&#xA;override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="type.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="interfaceType">要检索其映射的接口类型。</param>
        <summary>返回指定接口类型的接口映射。</summary>
        <returns>表示 <paramref name="interfaceType" /> 的接口映射的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接口映射表示接口如何映射到实现该接口的类上的实际成员。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则在此方法返回的 <xref:System.Reflection.InterfaceMapping> 的元素中，类型参数将替换为相应的类型参数。  
  
   
  
## Examples  
 下面的示例调用 <xref:System.Type.GetInterfaceMap%2A> 方法，以确定 <xref:System.IFormatProvider> 接口如何映射到 <xref:System.Globalization.CultureInfo> 方法，以及 <xref:System.IAppDomainSetup> 接口如何映射到 <xref:System.AppDomainSetup> 属性。 请注意，由于 <xref:System.IAppDomainSetup> 接口定义了一组属性，因此返回的 <xref:System.Reflection.InterfaceMapping> 对象包含属性的 get 和 set 访问器的单独 <xref:System.Reflection.MethodInfo> 对象。  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前类型未实现 <paramref name="interfaceType" />。  
  
或 
<paramref name="interfaceType" /> 参数未引用接口。  
  
或

当前实例或 <paramref name="interfaceType" /> 参数是开放式泛型类型；即，<see cref="P:System.Type.ContainsGenericParameters" /> 属性将返回 <see langword="true" />。

或


 <paramref name="interfaceType" /> 是一个泛型接口，而当前类型是一个数组类型。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="interfaceType" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">当前 <see cref="T:System.Type" /> 表示泛型类型参数；即， <see cref="P:System.Type.IsGenericParameter" /> 为 <see langword="true" />。</exception>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。 派生类必须提供一个实现。</exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaces : unit -&gt; Type[]" Usage="type.GetInterfaces " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中重写时，获取由当前 <see cref="T:System.Type" /> 实现或继承的所有接口。</summary>
        <returns>表示由当前 <see cref="T:System.Type" /> 实现或继承的所有接口的 <see cref="T:System.Type" />对象数组。  
  
或 
如果没有由当前 <see cref="T:System.Type" /> 实现或继承的接口，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetInterfaces%2A> 方法不按特定顺序（如字母顺序或声明顺序）返回接口。 你的代码不能依赖于接口的返回顺序，因为该顺序会有所不同。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法返回 <xref:System.Type> 对象，这些对象的类型参数被替换为相应的类型参数。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索接口约束以及从类或接口约束继承的任何接口。  
  
   
  
## Examples  
 下面的示例获取指定类的类型并显示该类型实现或继承的所有接口。 若要编译 Visual Basic 示例，请使用以下编译器命令：  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">调用静态初始值设定项时引发了异常。</exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的指定成员。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember name" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的公共成员名称的字符串。</param>
        <summary>搜索具有指定名称的公共成员。</summary>
        <returns>一个表示具有指定名称的公共成员的 <see cref="T:System.Reflection.MemberInfo" /> 对象数组（如果找到的话）；否则为空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜索 `name` 区分大小写。 搜索包括公共静态和公共实例成员。  
  
 成员包括属性、方法、字段、事件等。  
  
 <xref:System.Type.GetMember%2A> 方法不按特定顺序（如字母顺序或声明顺序）返回成员。 你的代码不能依赖于成员的返回顺序，因为该顺序会有所不同。  
  
 此方法重载将找不到类初始值设定项（静态构造函数）。 若要查找类初始值设定项，请使用采用 <xref:System.Reflection.BindingFlags>的重载， &#124;并指定 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> （<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`中的 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>）。 还可以使用 <xref:System.Type.TypeInitializer%2A> 属性获取类初始值设定项。  
  
 下表显示了在类型上反射时，`Get` 方法返回基类的成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法（虚拟和非虚拟）可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|属性|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分，包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射，属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性，但派生类只有 get 访问器，则派生类属性将隐藏基类属性，并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法将返回类型参数替换为相应类型参数的 <xref:System.Reflection.MemberInfo>。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的成员，或者在没有类约束的情况下搜索 <xref:System.Object> 的成员。  
  
> [!NOTE]
>  对于泛型方法，请不要在 `name`中包括类型参数。 例如， C#代码 `GetMember("MyMethod<int>")` 搜索文本名称为 "`MyMethod<int>`" 的成员，而不是使用一个名为 `int`类型的泛型参数的名为 `MyMethod` 的方法。  
  
   
  
## Examples  
 下面的示例显示以字母 C 开头的 `String` 类的所有成员。  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的成员的名称的字符串。</param>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
或 
 若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回空数组。</param>
        <summary>使用指定绑定约束搜索指定成员。</summary>
        <returns>一个表示具有指定名称的公共成员的 <see cref="T:System.Reflection.MemberInfo" /> 对象数组（如果找到的话）；否则为空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可由派生类重写。  
  
 成员包括属性、方法、字段、事件等。  
  
 <xref:System.Type.GetMember%2A> 方法不按特定顺序（如字母顺序或声明顺序）返回成员。 你的代码不能依赖于成员的返回顺序，因为该顺序会有所不同。  
  
 以下 <xref:System.Reflection.BindingFlags> 筛选器标志可用于定义要包括在搜索中的成员：  
  
-   若要获取返回，必须指定 `BindingFlags.Instance` 或 `BindingFlags.Static`。  
  
-   指定 `BindingFlags.Public` 以在搜索中包括公共成员。  
  
-   指定 `BindingFlags.NonPublic` 以在搜索中包括非公共成员（即，私有成员、内部成员和受保护成员）。  
  
-   指定 `BindingFlags.FlattenHierarchy` 包括层次结构中的 `public` 和 `protected` 静态成员;不包括继承类中 `private` 静态成员。  
  
 以下 <xref:System.Reflection.BindingFlags> 修饰符标志可用于更改搜索的工作方式：  
  
-   `BindingFlags.IgnoreCase` 忽略 `name`的大小写。  
  
-   `BindingFlags.DeclaredOnly` 仅搜索 <xref:System.Type>上声明的成员，而不搜索简单继承的成员。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 若要使用此方法重载获取类初始值设定项（静态构造函数），您必须为 `name`指定 "静态构造函数&#124; "，并为 `Or`<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> （<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType><xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual Basic）。`bindingAttr` 还可以使用 <xref:System.Type.TypeInitializer%2A> 属性获取类初始值设定项。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法将返回类型参数替换为相应类型参数的 <xref:System.Reflection.MemberInfo>。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的成员，或者在没有类约束的情况下搜索 <xref:System.Object> 的成员。  
  
> [!NOTE]
>  对于泛型方法，请不要在 `name`中包括类型参数。 例如， C#代码 `GetMember("MyMethod<int>")` 搜索文本名称为 "`MyMethod<int>`" 的成员，而不是使用一个名为 `int`类型的泛型参数的名为 `MyMethod` 的方法。  
  
   
  
## Examples  
 下面的示例显示以字母 C 开头的 `myString` 类的所有公共静态成员。  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的成员的名称的字符串。</param>
        <param name="type">要搜索的值。</param>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
或 
 若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回空数组。</param>
        <summary>使用指定绑定约束搜索指定成员类型的指定成员。</summary>
        <returns>一个表示具有指定名称的公共成员的 <see cref="T:System.Reflection.MemberInfo" /> 对象数组（如果找到的话）；否则为空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 成员包括属性、方法、字段、事件等。  
  
 <xref:System.Type.GetMember%2A> 方法不按特定顺序（如字母顺序或声明顺序）返回成员。 你的代码不能依赖于成员的返回顺序，因为该顺序会有所不同。  
  
 以下 <xref:System.Reflection.BindingFlags> 筛选器标志可用于定义要包括在搜索中的成员：  
  
-   若要获取返回，必须指定 `BindingFlags.Instance` 或 `BindingFlags.Static`。  
  
-   指定 `BindingFlags.Public` 以在搜索中包括公共成员。  
  
-   指定 `BindingFlags.NonPublic` 以在搜索中包括非公共成员（即，私有成员、内部成员和受保护成员）。  
  
-   指定 `BindingFlags.FlattenHierarchy` 包括层次结构中的 `public` 和 `protected` 静态成员;不包括继承类中 `private` 静态成员。  
  
 以下 <xref:System.Reflection.BindingFlags> 修饰符标志可用于更改搜索的工作方式：  
  
-   `BindingFlags.IgnoreCase` 忽略 `name`的大小写。  
  
-   `BindingFlags.DeclaredOnly` 仅搜索 <xref:System.Type>上声明的成员，而不搜索简单继承的成员。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 若要使用此方法重载获取类初始值设定项（静态构造函数），必须为 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 指定 `name`的 "静态构造函数"、`type`&#124;的 <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> 和 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType><xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>（`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual Basic）。`bindingAttr` 还可以使用 <xref:System.Type.TypeInitializer%2A> 属性获取类初始值设定项。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法将返回类型参数替换为相应类型参数的 <xref:System.Reflection.MemberInfo>。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的成员，或者在没有类约束的情况下搜索 <xref:System.Object> 的成员。  
  
> [!NOTE]
>  对于泛型方法，请不要在 `name`中包括类型参数。 例如， C#代码 `GetMember("MyMethod<int>")` 搜索文本名称为 "`MyMethod<int>`" 的成员，而不是使用一个名为 `int`类型的泛型参数的名为 `MyMethod` 的方法。  
  
   
  
## Examples  
 下面的示例显示以字母 C 开头的 `myString` 类的所有方法。  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">派生类必须提供一个实现。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的成员（包括属性、方法、字段、事件等）。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MemberInfo[] GetMembers() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回为当前 <see cref="T:System.Type" /> 的所有公共成员。</summary>
        <returns>表示当前 <see cref="T:System.Reflection.MemberInfo" /> 的所有公共成员的 <see cref="T:System.Type" /> 对象数组。  
  
或 
如果当前 <see cref="T:System.Reflection.MemberInfo" /> 没有公共成员，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

成员包括属性、方法、构造函数、字段、事件和嵌套类型。
  
 <xref:System.Type.GetMembers%2A> 方法不按特定顺序（如字母顺序或声明顺序）返回成员。 你的代码不能依赖于成员的返回顺序，因为该顺序会有所不同。  
  
 此方法重载调用 <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> 方法重载，并 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> （<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> Visual Basic）。 它将找不到类初始值设定项（静态构造函数）。 若要查找类初始值设定项，请调用 <xref:System.Type.GetMembers(System.Reflection.BindingFlags)> 重载， &#124;并指定 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> （<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`中的 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>）。 还可以使用 <xref:System.Type.TypeInitializer%2A> 属性获取类初始值设定项。  
  
 下表显示了在类型上反射时，`Get` 方法返回基类的成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法（虚拟和非虚拟）可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|属性|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分，包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射，属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性，但派生类只有 get 访问器，则派生类属性将隐藏基类属性，并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法返回 <xref:System.Reflection.MemberInfo> 对象，这些对象的类型参数被替换为相应的类型参数。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的成员，或者在没有类约束的情况下搜索 <xref:System.Object> 的成员。 
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Type.GetMembers> 方法重载来收集有关指定类的所有公共成员的信息。  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
或 
 若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回空数组。</param>
        <summary>当在派生类中重写时，使用指定绑定约束，搜索为当前 <see cref="T:System.Type" /> 定义的成员。</summary>
        <returns>表示为当前 <see cref="T:System.Reflection.MemberInfo" /> 定义的匹配指定绑定约束的所有成员的 <see cref="T:System.Type" /> 对象数组。  
  
或 
如果没有为当前 <see cref="T:System.Type" /> 定义成员，或者定义的成员均与绑定约束不匹配，则为空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

成员包括属性、方法、构造函数、字段、事件和嵌套类型。

为了使 `GetMethods(BindingFlags)` 重载成功检索方法信息，`bindingAttr` 参数必须包含至少一个 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> 和 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>，同时至少包含 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 和 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>中的一个。 唯一的例外情况是 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>的方法调用，它返回有关嵌套类型的成员信息。

以下 <xref:System.Reflection.BindingFlags> 筛选器标志可用于定义要包括在搜索中的成员： 

- 指定 `BindingFlags.Instance` 以包含实例方法。 

- 指定 `BindingFlags.Static` 以包含静态方法。 
  
- 指定 `BindingFlags.Public` 以在搜索中包含公共方法。  
  
- 指定 `BindingFlags.NonPublic` 以在搜索中包括非公共方法（即私有、内部和受保护的方法）。 仅返回基类的受保护方法和内部方法;不返回基类上的私有方法。  
  
- 指定 `BindingFlags.FlattenHierarchy` 包括层次结构中的 `public` 和 `protected` 静态成员;不包括继承类中 `private` 静态成员。  

- 单独指定 `BindingFlags.Default` 以返回空的 <xref:System.Reflection.MethodInfo> 数组。

以下 <xref:System.Reflection.BindingFlags> 修饰符标志可用于更改搜索的工作方式：  
  
- `BindingFlags.DeclaredOnly` 仅搜索 <xref:System.Type>上声明的成员，而不搜索简单继承的成员。  
  
有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  

<xref:System.Type.GetMembers%2A> 方法不按特定顺序（如字母顺序或声明顺序）返回成员。 你的代码不能依赖于成员的返回顺序，因为该顺序会有所不同。  

 若要使用此方法重载获取类初始值设定项（静态构造函数），必须&#124;指定 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> （<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 中的 Visual Basic）。 还可以使用 <xref:System.Type.TypeInitializer%2A> 属性获取类初始值设定项。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法返回 <xref:System.Reflection.MemberInfo> 对象，这些对象的类型参数被替换为相应的类型参数。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的成员，或者在没有类约束的情况下搜索 <xref:System.Object> 的成员。  

## Examples  
 下面的代码示例演示如何使用 <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> 方法重载来收集有关指定类的所有公共实例成员的信息。  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的特定方法。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod name" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的公共方法的名称的字符串。</param>
        <summary>搜索具有指定名称的公共方法。</summary>
        <returns>表示具有指定名称的公共方法的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜索 `name` 区分大小写。 搜索包括公共静态和公共实例方法。  
  
 如果重载了方法并且有多个公共方法，<xref:System.Type.GetMethod%28System.String%29> 方法将引发 <xref:System.Reflection.AmbiguousMatchException> 异常。 在下面的示例中，引发了异常，因为有多个 <xref:System.Int32.ToString%2A?displayProperty=nameWithType> 方法的公共重载。  另一方面，因为 `Person.ToString` 方法会重写 <xref:System.Object.ToString%2A?displayProperty=nameWithType>，因此不会重载，<xref:System.Type.GetMethod%28System.String%29> 方法可以检索 <xref:System.Reflection.MethodInfo> 对象。  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 可以执行以下操作之一来检索特定方法：  
  
-   调用 <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> 方法，并指定唯一标识该方法的 `bindingAttr` 参数。 例如，如果由于类型具有静态和实例重载而引发异常，则可以指定 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>的 `bindingAttr` 参数。  
  
-   调用 <xref:System.Type.GetMethod%2A> 方法的重载，该重载包含定义该方法的参数类型的 `types` 参数。  
  
-   调用 <xref:System.Type.GetMethods> 方法可以检索包含属于某个类型的所有公共方法的数组。 然后，你可以对其进行循环访问，以确定名为 `name`的重复方法。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法将返回类型参数替换为相应类型参数的 <xref:System.Reflection.MethodInfo>。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的方法，如果没有类约束，则搜索 <xref:System.Object> 的方法。  
  
> [!NOTE]
>  对于泛型方法，请不要在 `name`中包括类型参数。 例如， C#代码 `GetMember("MyMethod<int>")` 搜索文本名称为 "`MyMethod<int>`" 的成员，而不是使用一个名为 `int`类型的泛型参数的名为 `MyMethod` 的方法。  
  
   
  
## Examples  
 下面的示例获取名为 `MethodA`的方法。  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到了多个具有指定名称的方法。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的方法名称的字符串。</param>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
或 
 若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</param>
        <summary>使用指定绑定约束搜索指定方法。</summary>
        <returns>表示符合指定要求的方法的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 以下 <xref:System.Reflection.BindingFlags> 筛选器标志可用于定义要包括在搜索中的方法：  
  
-   若要获取返回，必须指定 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> 或 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>。  
  
-   指定 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> 以在搜索中包含公共方法。  
  
-   指定 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 以在搜索中包括非公共方法（即私有、内部和受保护的方法）。  
  
-   指定 <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> 包括层次结构中的 `public` 和 `protected` 静态成员;不包括继承类中 `private` 静态成员。  
  
 以下 <xref:System.Reflection.BindingFlags> 修饰符标志可用于更改搜索的工作方式：  
  
-   <xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> 忽略 `name`的大小写。  
  
-   <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> 仅搜索 <xref:System.Type>上声明的方法，而不搜索简单继承的方法。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果重载了某个方法，并且有多个重载满足 `bindingAttr` 参数所指定的约束，则该方法将引发 <xref:System.Reflection.AmbiguousMatchException> 异常。 在下面的示例中，引发了异常，因为：  
  
-   `TestClass` 类型具有 `DisplayValue` 方法的两个公共实例重载，`DisplayValue(String)` 和 `DisplayValue(String, Object[])`。  
  
-   `TestClass` 类型具有 `Equals` 方法的两个公共实例重载，其中一个方法是从 <xref:System.Object>： `Equals(TestClass)` 和 `Equals(Object)`继承。  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 可以执行以下操作之一来检索特定方法：  
  
-   更改绑定约束。 在前面的示例中，尝试检索由类型声明的公共实例 `Equals` 方法，而不是成功地检索 `Equals(TestClass)`。  
  
-   调用 <xref:System.Type.GetMethod%2A> 方法的重载，该重载包含定义该方法的参数类型的 `types` 参数。  
  
-   调用 <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> 方法可以检索包含属于具有指定绑定特性的类型的所有方法的数组。 然后，你可以对其进行循环访问，以确定名为 `name`的重复方法。 此方法在上一个示例的 <xref:System.Reflection.AmbiguousMatchException> 异常处理程序中进行了说明。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法将返回类型参数替换为相应类型参数的 <xref:System.Reflection.MethodInfo>。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的方法，如果没有类约束，则搜索 <xref:System.Object> 的方法。  
  
> [!NOTE]
>  对于泛型方法，请不要在 `name`中包括类型参数。 例如， C#代码 `GetMember("MyMethod<int>")` 搜索文本名称为 "`MyMethod<int>`" 的成员，而不是使用一个名为 `int`类型的泛型参数的名为 `MyMethod` 的方法。  
  
   
  
## Examples  
 下面的示例获取与指定的绑定标志匹配的方法。  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到多个具有指定名称且与指定绑定约束匹配的方法。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的公共方法的名称的字符串。</param>
        <param name="types">表示此方法要获取的参数的个数、顺序和类型的 <see cref="T:System.Type" /> 对象数组。  
  
或 
空的 <see cref="T:System.Type" /> 对象数组（由 <see cref="F:System.Type.EmptyTypes" /> 字段提供），用来获取不采用参数的方法。</param>
        <summary>搜索其参数与指定参数类型匹配的指定公共方法。</summary>
        <returns>表示其参数与指定参数类型匹配的公共方法的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜索 `name` 区分大小写。 搜索包括公共静态和公共实例方法。  
  
> [!NOTE]
>  在查找构造函数和方法时，不能忽略参数。 在调用时，只能省略参数。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法将返回类型参数替换为相应类型参数的 <xref:System.Reflection.MethodInfo>。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的方法，如果没有类约束，则搜索 <xref:System.Object> 的方法。  
  
> [!NOTE]
>  `name` 参数不能包括类型参数。 例如， C#代码 `GetMethod("MyGenericMethod<int>")` 搜索文本名称为 "`MyGenericMethod<int>`" 的方法，而不是使用一个名为 `int`类型的泛型参数的名为 `MyGenericMethod` 的方法。 请改用 `types` 数组中具有相应参数的 `GetMethod("MyGenericMethod")`。  
  
   
  
## Examples  
 下面的示例查找 `MethodA`的特定重载，并指定多种参数类型。  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] 示例需要 `/unsafe` 编译器选项。  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 下面的示例检索 <xref:System.Reflection.MethodInfo> 对象，这些对象表示非泛型类型（<xref:System.Collections.ArrayList> 类）的 `Add` 方法、开放式泛型类型（<xref:System.Collections.Generic.List%601> 类）和封闭式泛型类型（`List(Of String)` 类型。  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 该示例定义了一个 `GetAddMethod` 方法，该方法检索相应的 <xref:System.Reflection.MethodInfo> 对象。 若要为开放式泛型类型提供 `types` 参数，它将调用 <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> 方法。 若要为封闭式泛型类型提供 `types` 参数，它将检索 <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> 属性的值。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到了多个具有指定名称和指定参数的方法。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。  
  
或 
 <paramref name="types" /> 为 <see langword="null" />。  
  
或 
<paramref name="types" /> 的其中一个元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> 是多维的。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types, modifiers)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types, modifiers)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的公共方法的名称的字符串。</param>
        <param name="types">表示此方法要获取的参数的个数、顺序和类型的 <see cref="T:System.Type" /> 对象数组。  
  
或 
空的 <see cref="T:System.Type" /> 对象数组（由 <see cref="F:System.Type.EmptyTypes" /> 字段提供），用来获取不采用参数的方法。</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <paramref name="types" /> 数组中的相应元素关联的特性。 仅当通过 COM 互操作进行调用时才使用，而且仅处理通过引用传递的参数。 默认的联编程序不处理此参数。</param>
        <summary>搜索其参数与指定参数类型及修饰符匹配的指定公共方法。</summary>
        <returns>表示符合指定需求的公共方法的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管默认联编程序不处理 <xref:System.Reflection.ParameterModifier> （`modifiers` 参数），但你可以使用 abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> 类编写处理 `modifiers`的自定义联编程序。 仅当通过 COM 互操作进行调用时才使用 `ParameterModifier`，且仅处理通过引用传递的参数。  
  
 搜索 `name` 区分大小写。 搜索包括公共静态和公共实例方法。  
  
> [!NOTE]
>  在查找构造函数和方法时，不能忽略参数。 在调用时，只能省略参数。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法将返回类型参数替换为相应类型参数的 <xref:System.Reflection.MethodInfo>。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的方法，如果没有类约束，则搜索 <xref:System.Object> 的方法。  
  
> [!NOTE]
>  对于泛型方法，请不要在 `name`中包括类型参数。 例如， C#代码 `GetMethod("MyMethod<int>")` 搜索文本名称为 "`MyMethod<int>`" 的成员，而不是使用一个名为 `int`类型的泛型参数的名为 `MyMethod` 的方法。 请改用 `types` 数组中具有相应参数的 `GetMethod("MyMethod")`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到了多个具有指定名称和指定参数的方法。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。  
  
或 
 <paramref name="types" /> 为 <see langword="null" />。  
  
或 
<paramref name="types" /> 的其中一个元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> 是多维的。  
  
或 
 <paramref name="modifiers" /> 是多维的。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的方法名称的字符串。</param>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
或 
 若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。  
  
或 
要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</param>
        <param name="types">表示此方法要获取的参数的个数、顺序和类型的 <see cref="T:System.Type" /> 对象数组。  
  
或 
空的 <see cref="T:System.Type" /> 对象数组（由 <see cref="F:System.Type.EmptyTypes" /> 字段提供），用来获取不采用参数的方法。</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <paramref name="types" /> 数组中的相应元素关联的特性。 仅当通过 COM 互操作进行调用时才使用，而且仅处理通过引用传递的参数。 默认的联编程序不处理此参数。</param>
        <summary>使用指定绑定约束，搜索其参数与指定自变量类型及修饰符匹配的指定方法。</summary>
        <returns>表示符合指定要求的方法的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管默认联编程序不处理 <xref:System.Reflection.ParameterModifier> （`modifiers` 参数），但你可以使用 abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> 类编写处理 `modifiers`的自定义联编程序。 仅当通过 COM 互操作进行调用时才使用 `ParameterModifier`，且仅处理通过引用传递的参数。  
  
 以下 <xref:System.Reflection.BindingFlags> 筛选器标志可用于定义要包括在搜索中的方法：  
  
-   若要获取返回，必须指定 `BindingFlags.Instance` 或 `BindingFlags.Static`。  
  
-   指定 `BindingFlags.Public` 以在搜索中包含公共方法。  
  
-   指定 `BindingFlags.NonPublic` 以在搜索中包括非公共方法（即私有方法、内部方法和受保护的方法）。  
  
-   指定 `BindingFlags.FlattenHierarchy` 包括层次结构中的 `public` 和 `protected` 静态成员;不包括继承类中 `private` 静态成员。  
  
 以下 <xref:System.Reflection.BindingFlags> 修饰符标志可用于更改搜索的工作方式：  
  
-   `BindingFlags.IgnoreCase` 忽略 `name`的大小写。  
  
-   `BindingFlags.DeclaredOnly` 仅搜索 <xref:System.Type>上声明的方法，而不搜索简单继承的方法。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
> [!NOTE]
>  在查找构造函数和方法时，不能忽略参数。 在调用时，只能省略参数。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法将返回类型参数替换为相应类型参数的 <xref:System.Reflection.MethodInfo>。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的方法，如果没有类约束，则搜索 <xref:System.Object> 的方法。  
  
> [!NOTE]
>  对于泛型方法，请不要在 `name`中包括类型参数。 例如， C#代码 `GetMember("MyMethod<int>")` 搜索文本名称为 "`MyMethod<int>`" 的成员，而不是使用一个名为 `int`类型的泛型参数的名为 `MyMethod` 的方法。  
  
   
  
## Examples  
 下面的示例查找 `MethodA`的特定重载，并指定绑定约束和各种参数类型。  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] 示例需要 `/unsafe` 编译器选项。  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到多个具有指定名称且与指定绑定约束匹配的方法。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。  
  
或 
 <paramref name="types" /> 为 <see langword="null" />。  
  
或 
<paramref name="types" /> 的其中一个元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> 是多维的。  
  
或 
 <paramref name="modifiers" /> 是多维的。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的方法名称的字符串。</param>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
或 
 若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。  
  
或 
要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</param>
        <param name="callConvention">该对象用于指定要使用的一套规则，这些规则涉及自变量的顺序和布局、传递返回值的方式、用于自变量的寄存器和清理堆栈的方式。</param>
        <param name="types">表示此方法要获取的参数的个数、顺序和类型的 <see cref="T:System.Type" /> 对象数组。  
  
或 
空的 <see cref="T:System.Type" /> 对象数组（由 <see cref="F:System.Type.EmptyTypes" /> 字段提供），用来获取不采用参数的方法。</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <paramref name="types" /> 数组中的相应元素关联的特性。 仅当通过 COM 互操作进行调用时才使用，而且仅处理通过引用传递的参数。 默认的联编程序不处理此参数。</param>
        <summary>用指定的绑定约束和指定的调用约定，搜索参数与指定的参数类型及修饰符相匹配的指定方法。</summary>
        <returns>表示符合指定要求的方法的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管默认联编程序不处理 <xref:System.Reflection.ParameterModifier> （`modifiers` 参数），但你可以使用 abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> 类编写处理 `modifiers`的自定义联编程序。 仅当通过 COM 互操作进行调用时才使用 `ParameterModifier`，且仅处理通过引用传递的参数。  
  
 下表显示了在类型上反射时，`GetXXX` 方法返回基类的成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法（虚拟和非虚拟）可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|属性|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分，包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射，属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性，但派生类只有 get 访问器，则派生类属性将隐藏基类属性，并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 以下 <xref:System.Reflection.BindingFlags> 筛选器标志可用于定义要包括在搜索中的方法：  
  
-   若要获取返回，必须指定 `BindingFlags.Instance` 或 `BindingFlags.Static`。  
  
-   指定 `BindingFlags.Public` 以在搜索中包含公共方法。  
  
-   指定 `BindingFlags.NonPublic` 以在搜索中包括非公共方法（即私有方法、内部方法和受保护的方法）。  
  
-   指定 `BindingFlags.FlattenHierarchy` 包括层次结构中的 `public` 和 `protected` 静态成员;不包括继承类中 `private` 静态成员。  
  
 以下 <xref:System.Reflection.BindingFlags> 修饰符标志可用于更改搜索的工作方式：  
  
-   `BindingFlags.IgnoreCase` 忽略 `name`的大小写。  
  
-   `BindingFlags.DeclaredOnly` 仅搜索 <xref:System.Type>上声明的方法，而不搜索简单继承的方法。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
> [!NOTE]
>  在查找构造函数和方法时，不能忽略参数。 在调用时，只能省略参数。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法将返回类型参数替换为相应类型参数的 <xref:System.Reflection.MethodInfo>。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的方法，如果没有类约束，则搜索 <xref:System.Object> 的方法。  
  
> [!NOTE]
>  对于泛型方法，请不要在 `name`中包括类型参数。 例如， C#代码 `GetMember("MyMethod<int>")` 搜索文本名称为 "`MyMethod<int>`" 的成员，而不是使用一个名为 `int`类型的泛型参数的名为 `MyMethod` 的方法。  
  
   
  
## Examples  
 下面的示例查找 `MethodA`的特定重载，指定绑定约束、调用约定和各种参数类型。  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] 示例需要 `/unsafe` 编译器选项。  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到多个具有指定名称且与指定绑定约束匹配的方法。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。  
  
或 
 <paramref name="types" /> 为 <see langword="null" />。  
  
或 
<paramref name="types" /> 的其中一个元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> 是多维的。  
  
或 
 <paramref name="modifiers" /> 是多维的。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="6" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的方法名称的字符串。</param>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
或 
 若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。  
  
或 
要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</param>
        <param name="callConvention">该对象，用于指定要使用的一套规则，这些规则涉及自变量的顺序和布局、传递返回值的方式、用于自变量的寄存器以及哪个进程清理堆栈。</param>
        <param name="types">表示此方法要获取的参数的个数、顺序和类型的 <see cref="T:System.Type" /> 对象数组。  
  
或 
一个类型为 <see cref="T:System.Type" /> （即 Type[] types = new Type[0]）的空数组，用于获取一个不带参数的方法。  
  
或 
 <see langword="null" />。 如果 <paramref name="types" /> 为 <see langword="null" />，则自变量不匹配。</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <paramref name="types" /> 数组中的相应元素关联的特性。 默认的联编程序不处理此参数。</param>
        <summary>当在派生类中重写时，使用指定的绑定约束和指定的调用约定搜索其参数与指定的自变量类型和修饰符匹配的指定方法。</summary>
        <returns>表示符合指定要求的方法的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管默认联编程序不处理 <xref:System.Reflection.ParameterModifier> （`modifiers` 参数），但你可以使用 abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> 类编写处理 `modifiers`的自定义联编程序。 仅当通过 COM 互操作进行调用时才使用 `ParameterModifier`，且仅处理通过引用传递的参数。  
  
 如果 `types` 为 `null`，则自变量不匹配。  
  
 以下 <xref:System.Reflection.BindingFlags> 筛选器标志可用于定义要包括在搜索中的方法：  
  
-   若要获取返回，必须指定 `BindingFlags.Instance` 或 `BindingFlags.Static`。  
  
-   指定 `BindingFlags.Public` 以在搜索中包含公共方法。  
  
-   指定 `BindingFlags.NonPublic` 以在搜索中包括非公共方法（即私有、内部和受保护的方法）。  
  
-   指定 `BindingFlags.FlattenHierarchy` 包括层次结构中的 `public` 和 `protected` 静态成员;不包括继承类中 `private` 静态成员。  
  
 以下 <xref:System.Reflection.BindingFlags> 修饰符标志可用于更改搜索的工作方式：  
  
-   `BindingFlags.IgnoreCase` 忽略 `name`的大小写。  
  
-   `BindingFlags.DeclaredOnly` 仅搜索 <xref:System.Type>上声明的方法，而不搜索简单继承的方法。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到多个具有指定名称且与指定绑定约束匹配的方法。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> 是多维的。  
  
或 
 <paramref name="modifiers" /> 是多维的。  
  
或 
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的长度不相同。</exception>
        <exception cref="T:System.NotSupportedException">当前的类型是 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 或 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="6" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的方法。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo[] GetMethods() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : unit -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回为当前 <see cref="T:System.Type" /> 的所有公共方法。</summary>
        <returns>表示为当前 <see cref="T:System.Reflection.MethodInfo" /> 定义的所有公共方法的 <see cref="T:System.Type" /> 对象数组。  
  
或 
如果没有为当前 <see cref="T:System.Reflection.MethodInfo" /> 定义的公共方法，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<xref:System.Type.GetMethods%2A> 方法不按特定顺序（如字母顺序或声明顺序）返回方法。 你的代码不能依赖于方法的返回顺序，因为该顺序会有所不同。  
  
 构造函数不包含在此调用所返回的方法的数组中。 对 `GetConstructors()` 进行单独调用以获取构造函数方法。  
  
 下表显示了在类型上反射时，`Get` 方法返回基类的成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法（虚拟和非虚拟）可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|属性|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分，包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射，属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性，但派生类只有 get 访问器，则派生类属性将隐藏基类属性，并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
> [!NOTE]
>  在查找构造函数和方法时，不能忽略参数。 在调用时，只能省略参数。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法返回 <xref:System.Reflection.MethodInfo> 对象，这些对象的类型参数被替换为相应的类型参数。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的方法，如果没有类约束，则搜索 <xref:System.Object> 的方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。

或

 若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回空数组。</param>
        <summary>当在派生类中重写时，使用指定绑定约束，搜索为当前 <see cref="T:System.Type" /> 定义的方法。</summary>
        <returns>表示为当前 <see cref="T:System.Reflection.MethodInfo" /> 定义的匹配指定绑定约束的所有方法的 <see cref="T:System.Type" /> 对象数组。  
  
或 
如果没有为当前 <see cref="T:System.Reflection.MethodInfo" /> 定义的方法，或者如果没有一个定义的方法匹配绑定约束，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

为了使 `GetMethods(BindingFlags)` 重载成功检索方法信息，`bindingAttr` 参数必须包含至少一个 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> 和 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>，同时至少包含 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 和 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>中的一个。 
  
 以下 <xref:System.Reflection.BindingFlags> 筛选器标志可用于定义要包括在搜索中的方法：  
  
- 指定 `BindingFlags.Instance` 以包含实例方法。 

- 指定 `BindingFlags.Static` 以包含静态方法。 
  
- 指定 `BindingFlags.Public` 以在搜索中包含公共方法。  
  
- 指定 `BindingFlags.NonPublic` 以在搜索中包括非公共方法（即私有、内部和受保护的方法）。 仅返回基类的受保护方法和内部方法;不返回基类上的私有方法。  
  
- 指定 `BindingFlags.FlattenHierarchy` 包括层次结构中的 `public` 和 `protected` 静态成员;不包括继承类中 `private` 静态成员。  

- 单独指定 `BindingFlags.Default` 以返回空的 <xref:System.Reflection.MethodInfo> 数组。
  
 以下 <xref:System.Reflection.BindingFlags> 修饰符标志可用于更改搜索的工作方式：  
  
- `BindingFlags.DeclaredOnly` 仅搜索 <xref:System.Type>上声明的方法，而不搜索简单继承的方法。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  

<xref:System.Type.GetMethods%2A> 方法不按特定顺序（如字母顺序或声明顺序）返回方法。 你的代码不能依赖于方法的返回顺序，因为该顺序会有所不同。  

如果当前 <xref:System.Type> 表示构造泛型类型，则此方法返回 <xref:System.Reflection.MethodInfo> 对象，这些对象的类型参数被替换为相应的类型参数。  
  
如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的方法，如果没有类约束，则搜索 <xref:System.Object> 的方法。 
  
## Examples  
 下面的示例创建一个具有两个公共方法和一个受保护方法的类，创建与 `MyTypeClass`对应的 `Type` 对象，获取所有公共和非公共方法，并显示它们的名称。  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取嵌套在当前 <see cref="T:System.Type" /> 中的特定类型。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetNestedType(string name) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetNestedType(System::String ^ name);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetNestedType : string -&gt; Type" Usage="type.GetNestedType name" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string -&gt; Type&#xA;override this.GetNestedType : string -&gt; Type" Usage="type.GetNestedType name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的嵌套类型的名称的字符串。</param>
        <summary>搜索具有指定名称的公共嵌套类型。</summary>
        <returns>如找到，则为表示具有指定名称的公共嵌套类型的对象；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜索 `name` 区分大小写。  
  
 使用嵌套类的简单名称进行 `name`。 不要将其与外部类的名称限定。 对于泛型嵌套类，请使用错位的名称-即，追加一个重音符和泛型参数的数目。 例如，使用字符串 "Inner\`1" 获取泛型嵌套类 `Inner<T>` （`Inner(Of T)` Visual Basic 中）。 不要包含类型参数的特定于语言的语法。  
  
 下表显示了在类型上反射时，`Get` 方法返回基类的成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法（虚拟和非虚拟）可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|属性|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分，包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射，属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性，但派生类只有 get 访问器，则派生类属性将隐藏基类属性，并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的嵌套类型。  
  
 如果嵌套类型是泛型类型，则此方法返回其泛型类型定义。 即使封闭泛型类型是封闭式构造类型，也是如此。  
  
> [!NOTE]
>  如果当前 <xref:System.Type> 表示在中C#定义的泛型类型、Visual Basic 或C++，则其嵌套类型都是通用的，即使它们没有自己的泛型参数也是如此。 这不一定适用于动态程序集中定义的嵌套类型或用[Ilasm （IL 汇编程序）](~/docs/framework/tools/ilasm-exe-il-assembler.md)编译的。  
  
 有关嵌套泛型类型以及如何从其泛型类型定义构造嵌套的泛型类型的信息，请参阅 <xref:System.Type.MakeGenericType%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="type.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的嵌套类型的名称的字符串。</param>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
或 
 若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</param>
        <summary>当在派生类中重写时，使用指定绑定约束搜索指定嵌套类型。</summary>
        <returns>表示符合指定要求的嵌套类型的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用嵌套类的简单名称进行 `name`。 不要将其与外部类的名称限定。 对于泛型嵌套类，请使用错位的名称-即，追加一个重音符和泛型参数的数目。 例如，使用字符串 "Inner\`1" 获取泛型嵌套类 `Inner<T>` （`Inner(Of T)` Visual Basic 中）。 不要包含类型参数的特定于语言的语法。  
  
 以下 <xref:System.Reflection.BindingFlags> 筛选器标志可用于定义要包括在搜索中的嵌套类型：  
  
-   您必须指定 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> 或 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 才能获取返回。  
  
-   指定 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> 以在搜索中包括公共嵌套类型。  
  
-   指定 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 以在搜索中包括非公共嵌套类型（即私有、内部和受保护的嵌套类型）。  
  
 此方法只返回当前类型的嵌套类型。 它不会搜索当前类型的基类。 若要查找嵌套在基类中的类型，必须遍历继承层次结构，并在每个级别调用 <xref:System.Type.GetNestedType%2A>。  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> 和 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> 将被忽略。  
  
 仅用 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> 标志或仅 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 标志调用此方法将返回指定的嵌套类型，并且不需要任何其他标志。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的嵌套类型。  
  
 如果嵌套类型是泛型类型，则此方法返回其泛型类型定义。 即使封闭泛型类型是封闭式构造类型，也是如此。  
  
> [!NOTE]
>  如果当前 <xref:System.Type> 表示在中C#定义的泛型类型、Visual Basic 或C++，则其嵌套类型都是通用的，即使它们没有自己的泛型参数也是如此。 这不一定适用于动态程序集中定义的嵌套类型或用[Ilasm （IL 汇编程序）](~/docs/framework/tools/ilasm-exe-il-assembler.md)编译的。  
  
 有关嵌套泛型类型以及如何从其泛型类型定义构造嵌套的泛型类型的信息，请参阅 <xref:System.Type.MakeGenericType%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取嵌套在当前 <see cref="T:System.Type" /> 中的类型。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type[] GetNestedTypes() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;Type ^&gt; ^ GetNestedTypes();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetNestedTypes : unit -&gt; Type[]" Usage="type.GetNestedTypes " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : unit -&gt; Type[]&#xA;override this.GetNestedTypes : unit -&gt; Type[]" Usage="type.GetNestedTypes " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回嵌套在当前的 <see cref="T:System.Type" /> 中的公共类型。</summary>
        <returns><see cref="T:System.Type" /> 对象的数组，这些对象表示嵌套在当前 <see cref="T:System.Type" /> 中的公共类型（搜索是非递归的）；如果当前的 <see cref="T:System.Type" /> 中没有嵌套公共类型，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetNestedTypes%2A> 方法不按特定顺序（如字母顺序或声明顺序）返回类型。 你的代码不能依赖于类型的返回顺序，因为该顺序会有所不同。  
  
 仅返回立即嵌套在当前类型中的公共类型;搜索不是递归的。  
  
 下表显示了在类型上反射时，`Get` 方法返回基类的成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法（虚拟和非虚拟）可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|属性|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分，包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射，属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性，但派生类只有 get 访问器，则派生类属性将隐藏基类属性，并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的嵌套类型。  
  
 如果嵌套类型是泛型类型，则此方法返回其泛型类型定义。 即使封闭泛型类型是封闭式构造类型，也是如此。  
  
> [!NOTE]
>  如果当前 <xref:System.Type> 表示在中C#定义的泛型类型、Visual Basic 或C++，则其嵌套类型都是通用的，即使它们没有自己的泛型参数也是如此。 这不一定适用于动态程序集中定义的嵌套类型或用[Ilasm （IL 汇编程序）](~/docs/framework/tools/ilasm-exe-il-assembler.md)编译的。  
  
 有关嵌套泛型类型以及如何从其泛型类型定义构造嵌套的泛型类型的信息，请参阅 <xref:System.Type.MakeGenericType%2A>。  
  
   
  
## Examples  
 下面的示例在 `MyClass`中定义了嵌套类和 `struct`，然后使用 `MyClass`类型获取嵌套类型的对象。  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="type.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
或 
 若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</param>
        <summary>当在派生类中重写时，使用指定绑定约束搜索嵌套在当前 <see cref="T:System.Type" /> 中的类型。</summary>
        <returns><see cref="T:System.Type" /> 对象数组，这些对象表示嵌套在当前 <see cref="T:System.Type" /> 中的所有与指定的绑定约束匹配的类型（搜索是非递归的）；如果没有找到与绑定约束匹配的嵌套类型，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 嵌套类型的搜索不是递归的。  
  
 <xref:System.Type.GetNestedTypes%2A> 方法不按特定顺序（如字母顺序或声明顺序）返回类型。 你的代码不能依赖于类型的返回顺序，因为该顺序会有所不同。  
  
 以下 <xref:System.Reflection.BindingFlags> 筛选器标志可用于定义要包括在搜索中的嵌套类型：  
  
-   您必须指定 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> 或 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 才能获取返回。  
  
-   指定 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> 以在搜索中包括公共嵌套类型。  
  
-   指定 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 以在搜索中包括非公共嵌套类型（即私有、内部和受保护的嵌套类型）。  
  
 此方法只返回当前类型的嵌套类型。 它不会搜索当前类型的基类。 若要查找嵌套在基类中的类型，必须遍历继承层次结构，并在每个级别调用 <xref:System.Type.GetNestedTypes%2A>。  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> 和 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> 将被忽略。  
  
 仅用 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> 标志或仅 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 标志调用此方法将返回指定的嵌套类型，并且不需要任何其他标志。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的嵌套类型。  
  
 如果嵌套类型是泛型类型，则此方法返回其泛型类型定义。 即使封闭泛型类型是封闭式构造类型，也是如此。  
  
> [!NOTE]
>  如果当前 <xref:System.Type> 表示在中C#定义的泛型类型、Visual Basic 或C++，则其嵌套类型都是通用的，即使它们没有自己的泛型参数也是如此。 这不一定适用于动态程序集中定义的嵌套类型或用[Ilasm （IL 汇编程序）](~/docs/framework/tools/ilasm-exe-il-assembler.md)编译的。  
  
 有关嵌套泛型类型以及如何从其泛型类型定义构造嵌套的泛型类型的信息，请参阅 <xref:System.Type.MakeGenericType%2A>。  
  
   
  
## Examples  
 下面的示例创建两个嵌套公共类和两个嵌套的受保护类，并显示与指定绑定约束匹配的类的信息。  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的属性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : unit -&gt; System.Reflection.PropertyInfo[]&#xA;override this.GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回为当前 <see cref="T:System.Type" /> 的所有公共属性。</summary>
        <returns>表示当前 <see cref="T:System.Reflection.PropertyInfo" /> 的所有公共属性的 <see cref="T:System.Type" /> 对象数组。  
  
或 
如果当前 <see cref="T:System.Reflection.PropertyInfo" /> 没有公共属性，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此重载等效于调用 <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> 重载，该重载的 `bindingAttr` 参数等于 `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` C#和 Visual Basic 中的 `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public`。 它将返回所有公共实例和静态属性，这两个属性都由当前 <xref:System.Type> 对象所表示的类型以及从其基类型继承的类型定义。  
  
 如果某个属性至少具有一个公共访问器，则该属性将被视为 "公共"。 否则，该属性将被视为私有属性，必须使用&#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> （在 Visual Basic 中，使用 `Or`组合值）来获取它。  
  
 <xref:System.Type.GetProperties%2A> 方法不按特定顺序（如字母顺序或声明顺序）返回属性。 你的代码不能依赖属性的返回顺序，因为该顺序会有所不同。  
  
 下表显示了在类型上反射时，`Get` 方法返回基类的成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法（虚拟和非虚拟）可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|属性|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分，包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射，属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性，但派生类只有 get 访问器，则派生类属性将隐藏基类属性，并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法返回 <xref:System.Reflection.PropertyInfo> 对象，这些对象的类型参数被替换为相应的类型参数。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的属性。  
  
   
  
## Examples  
 下面的示例演示 `GetProperties` 方法的用法。  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。

或

 若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回空数组。</param>
        <summary>当在派生类中重写时，使用指定绑定约束，搜索当前 <see cref="T:System.Type" /> 的属性。</summary>
        <returns>一个对象数组，它表示当前 <see cref="T:System.Type" /> 中与指定的绑定约束匹配的所有属性。  
  
或 
如果当前 <see cref="T:System.Reflection.PropertyInfo" /> 没有属性，或者如果没有一个属性匹配绑定约束，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

为了使 `GetProperties(BindingFlags)` 重载成功检索属性信息，`bindingAttr` 参数必须包含至少一个 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> 和 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>，同时至少包含 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 和 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>中的一个。 

以下 <xref:System.Reflection.BindingFlags> 筛选器标志可用于定义要包括在搜索中的属性：  
  
- 指定 `BindingFlags.Instance` 以包含实例方法。 

- 指定 `BindingFlags.Static` 以包含静态方法。 
  
- 指定 `BindingFlags.Public` 以在搜索中包括公共属性。 如果某个属性至少具有一个公共访问器，则该属性将被视为 "公共"。 
  
- 指定 `BindingFlags.NonPublic` 以在搜索中包括非公共属性（即私有、内部和受保护的属性）。 仅返回基类的受保护的和内部属性;不返回基类上的私有属性。  
  
- 指定 `BindingFlags.FlattenHierarchy` 包括层次结构中的 `public` 和 `protected` 静态成员;不包括继承类中 `private` 静态成员。  

- 单独指定 `BindingFlags.Default` 以返回空的 <xref:System.Reflection.PropertyInfo> 数组。

 以下 <xref:System.Reflection.BindingFlags> 修饰符标志可用于更改搜索的工作方式：  
  
- `BindingFlags.DeclaredOnly` 仅搜索 <xref:System.Type>上声明的属性，而不搜索仅继承的属性。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
<xref:System.Type.GetProperties%2A> 方法不按特定顺序（如字母顺序或声明顺序）返回属性。 你的代码不能依赖属性的返回顺序，因为该顺序会有所不同。  

 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法返回 <xref:System.Reflection.PropertyInfo> 对象，这些对象的类型参数被替换为相应的类型参数。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的属性。  
  
   
  
## Examples  
 下面的示例定义了一个名为 `PropertyClass` 的类，该类包含六个属性：两个是公共的，一个是专用的，一个是专用的，一个是内部的（`Friend` 在 Visual Basic 中），另一个是受保护的内部（`Protected Friend` Visual Basic）。 然后，它会显示一些基本属性信息（属性名称和类型，无论是读取还是写入，它的 `get` 和 `set` 访问器的可见性）都是与指定绑定约束匹配的属性。  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的特定属性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty name" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的公共属性名的字符串。</param>
        <summary>搜索具有指定名称的公共属性。</summary>
        <returns>表示具有指定名称的公共属性的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜索 `name` 区分大小写。 搜索包括公共静态和公共实例属性。  
  
 如果某个属性至少具有一个公共访问器，则该属性将被视为 "公共"。 否则，该属性将被视为私有属性，必须使用&#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> （在 Visual Basic 中，使用 `Or`组合值）来获取它。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法将返回类型参数替换为相应类型参数的 <xref:System.Reflection.PropertyInfo>。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的属性。  
  
 发生 <xref:System.Reflection.AmbiguousMatchException> 的情况包括：  
  
-   类型包含两个具有相同名称但参数数目不同的索引属性。 若要解决多义性，请使用 <xref:System.Type.GetProperty%2A> 方法的重载，该重载指定参数类型。  
  
-   派生的类型声明一个属性，该属性通过使用 `new` 修饰符（`Shadows` Visual Basic）来隐藏同名的继承属性。 若要解决多义性问题，请使用 <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> 方法重载，并添加 <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> 标志，以将搜索限制为未继承的成员。  
  
## <a name="indexers-and-default-properties"></a>索引器和默认属性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]和 [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] 具有简化的访问索引属性的语法，并允许一个索引属性作为其类型的默认值。 例如，如果变量 `myList` 引用 <xref:System.Collections.ArrayList>，则语法 `myList[3]` （Visual Basic 中的`myList(3)`）检索索引为3的元素。 可以重载属性。  
  
 在C#中，此功能称为索引器，不能按名称引用。 默认情况下， C#索引器在元数据中显示为名为 "Item" 的索引属性。 但是，类库开发人员可以使用 <xref:System.Runtime.CompilerServices.IndexerNameAttribute> 特性来更改元数据中索引器的名称。 例如，<xref:System.String> 类具有一个名为 <xref:System.String.Chars%2A>的索引器。 使用以外的其他语言创建的C#索引属性也可以包含除 Item 以外的其他名称。  
  
 若要确定某一类型是否具有默认属性，请使用 <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> 方法测试 <xref:System.Reflection.DefaultMemberAttribute> 特性。 如果该类型具有 <xref:System.Reflection.DefaultMemberAttribute>，则 <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> 属性将返回默认属性的名称。  
  
   
  
## Examples  
 下面的示例检索用户定义类的 `Type` 对象、检索该类的属性并显示属性名称。  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 在内部，在元数据中，名称为 "Item"。 尝试使用反射获取 `PropertyInfo` 必须指定此内部名称，才能正确返回 `PropertyInfo` 属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到了多个具有指定名称的属性。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的属性名的字符串。</param>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
或 
若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</param>
        <summary>使用指定的绑定约束搜索指定属性。</summary>
        <returns>表示符合指定需求的属性的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果某个属性至少具有一个公共访问器，则该属性将被视为 "公共"。 否则，该属性将被视为私有属性，必须使用&#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> （在 Visual Basic 中，使用 `Or`组合值）来获取它。  
  
 以下 <xref:System.Reflection.BindingFlags> 筛选器标志可用于定义要包括在搜索中的属性：  
  
-   若要获取返回，必须指定 `BindingFlags.Instance` 或 `BindingFlags.Static`。  
  
-   指定 `BindingFlags.Public` 以在搜索中包括公共属性。  
  
-   指定 `BindingFlags.NonPublic` 以在搜索中包括非公共属性（即私有、内部和受保护的属性）。  
  
-   指定 `BindingFlags.FlattenHierarchy` 包括层次结构中的 `public` 和 `protected` 静态成员;不包括继承类中 `private` 静态成员。  
  
 以下 <xref:System.Reflection.BindingFlags> 修饰符标志可用于更改搜索的工作方式：  
  
-   `BindingFlags.IgnoreCase` 忽略 `name`的大小写。  
  
-   `BindingFlags.DeclaredOnly` 仅搜索 <xref:System.Type>上声明的属性，而不搜索仅继承的属性。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法将返回类型参数替换为相应类型参数的 <xref:System.Reflection.PropertyInfo>。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的属性。  
  
 发生 <xref:System.Reflection.AmbiguousMatchException> 的情况包括：  
  
-   类型包含两个具有相同名称但参数数目不同的索引属性。 若要解决多义性，请使用 <xref:System.Type.GetProperty%2A> 方法的重载，该重载指定参数类型。  
  
-   派生的类型声明一个属性，该属性使用 `new` 修饰符（`Shadows` Visual Basic）隐藏同名的继承属性。 若要解决多义性，请包括 <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> 将搜索限制为未继承的成员。  
  
## <a name="indexers-and-default-properties"></a>索引器和默认属性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]和 [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] 具有简化的访问索引属性的语法，并允许一个索引属性作为其类型的默认值。 例如，如果变量 `myList` 引用 <xref:System.Collections.ArrayList>，则语法 `myList[3]` （Visual Basic 中的`myList(3)`）检索索引为3的元素。 可以重载属性。  
  
 在C#中，此功能称为索引器，不能按名称引用。 默认情况下， C#索引器在元数据中显示为名为 "Item" 的索引属性。 但是，类库开发人员可以使用 <xref:System.Runtime.CompilerServices.IndexerNameAttribute> 特性来更改元数据中索引器的名称。 例如，<xref:System.String> 类具有一个名为 <xref:System.String.Chars%2A>的索引器。 使用以外的其他语言创建的C#索引属性也可以包含除 Item 以外的其他名称。  
  
 若要确定某一类型是否具有默认属性，请使用 <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> 方法测试 <xref:System.Reflection.DefaultMemberAttribute> 特性。 如果该类型具有 <xref:System.Reflection.DefaultMemberAttribute>，则 <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> 属性将返回默认属性的名称。  
  
   
  
## Examples  
 下面的示例检索用户定义的类的类型，检索该类的属性，并根据指定的绑定约束显示属性名称。  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到多个具有指定名称的属性且属性与指定绑定约束匹配。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的公共属性名的字符串。</param>
        <param name="returnType">属性的返回类型。</param>
        <summary>搜索具有指定名称和返回类型的公共属性。</summary>
        <returns>表示具有指定名称的公共属性的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果某个属性至少具有一个公共访问器，则该属性将被视为 "公共"。 否则，该属性将被视为私有属性，必须使用&#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> （在 Visual Basic 中，使用 `Or`组合值）来获取它。  
  
 搜索 `name` 区分大小写。 搜索包括公共静态和公共实例属性。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法将返回类型参数替换为相应类型参数的 <xref:System.Reflection.PropertyInfo>。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的属性。  
  
## <a name="indexers-and-default-properties"></a>索引器和默认属性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]和 [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] 具有简化的访问索引属性的语法，并允许一个索引属性作为其类型的默认值。 例如，如果变量 `myList` 引用 <xref:System.Collections.ArrayList>，则语法 `myList[3]` （Visual Basic 中的`myList(3)`）检索索引为3的元素。 可以重载属性。  
  
 在C#中，此功能称为索引器，不能按名称引用。 默认情况下， C#索引器在元数据中显示为名为 "Item" 的索引属性。 但是，类库开发人员可以使用 <xref:System.Runtime.CompilerServices.IndexerNameAttribute> 特性来更改元数据中索引器的名称。 例如，<xref:System.String> 类具有一个名为 <xref:System.String.Chars%2A>的索引器。 使用以外的其他语言创建的C#索引属性也可以包含除 Item 以外的其他名称。  
  
 若要确定某一类型是否具有默认属性，请使用 <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> 方法测试 <xref:System.Reflection.DefaultMemberAttribute> 特性。 如果该类型具有 <xref:System.Reflection.DefaultMemberAttribute>，则 <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> 属性将返回默认属性的名称。  
  
   
  
## Examples  
 下面的示例定义一个具有一个属性的类，并检索属性的名称和类型。  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到了多个具有指定名称的属性。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 是 <see langword="null" />，或 <paramref name="returnType" /> 是 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, types)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, types)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的公共属性名的字符串。</param>
        <param name="types">一个 <see cref="T:System.Type" /> 对象数组，表示要获取的索引属性的参数的数目、顺序和类型。  
  
或 
获取未被索引的属性的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。</param>
        <summary>搜索其参数与指定自变量类型匹配的指定公共属性。</summary>
        <returns>表示其参数与指定参数类型匹配的公共属性的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果某个属性至少具有一个公共访问器，则该属性将被视为 "公共"。 否则，该属性将被视为私有属性，必须使用&#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> （在 Visual Basic 中，使用 `Or`组合值）来获取它。  
  
 搜索 `name` 区分大小写。 搜索包括公共静态和公共实例属性。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法将返回类型参数替换为相应类型参数的 <xref:System.Reflection.PropertyInfo>。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的属性。  
  
## <a name="indexers-and-default-properties"></a>索引器和默认属性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]和 [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] 具有简化的访问索引属性的语法，并允许一个索引属性作为其类型的默认值。 例如，如果变量 `myList` 引用 <xref:System.Collections.ArrayList>，则语法 `myList[3]` （Visual Basic 中的`myList(3)`）检索索引为3的元素。 可以重载属性。  
  
 在C#中，此功能称为索引器，不能按名称引用。 默认情况下， C#索引器在元数据中显示为名为 "Item" 的索引属性。 但是，类库开发人员可以使用 <xref:System.Runtime.CompilerServices.IndexerNameAttribute> 特性来更改元数据中索引器的名称。 例如，<xref:System.String> 类具有一个名为 <xref:System.String.Chars%2A>的索引器。 使用以外的其他语言创建的C#索引属性也可以包含除 Item 以外的其他名称。  
  
 若要确定某一类型是否具有默认属性，请使用 <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> 方法测试 <xref:System.Reflection.DefaultMemberAttribute> 特性。 如果该类型具有 <xref:System.Reflection.DefaultMemberAttribute>，则 <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> 属性将返回默认属性的名称。  
  
   
  
## Examples  
 下面的示例检索用户定义的类的 `Type` 对象、检索该类的属性，并显示由传递给 `GetProperty`的参数指定的属性的属性名称和类型。  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到多个具有指定名称且与指定自变量类型匹配的属性。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。  
  
或 
 <paramref name="types" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> 是多维的。</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="types" /> 的元素为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的公共属性名的字符串。</param>
        <param name="returnType">属性的返回类型。</param>
        <param name="types">一个 <see cref="T:System.Type" /> 对象数组，表示要获取的索引属性的参数的数目、顺序和类型。  
  
或 
获取未被索引的属性的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。</param>
        <summary>搜索其参数与指定自变量类型匹配的指定公共属性。</summary>
        <returns>表示其参数与指定参数类型匹配的公共属性的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果某个属性至少具有一个公共访问器，则该属性将被视为 "公共"。 否则，该属性将被视为私有属性，必须使用&#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> （在 Visual Basic 中，使用 `Or`组合值）来获取它。  
  
 搜索 `name` 区分大小写。 搜索包括公共静态和公共实例属性。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法将返回类型参数替换为相应类型参数的 <xref:System.Reflection.PropertyInfo>。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的属性。  
  
## <a name="indexers-and-default-properties"></a>索引器和默认属性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]和 [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] 具有简化的访问索引属性的语法，并允许一个索引属性作为其类型的默认值。 例如，如果变量 `myList` 引用 <xref:System.Collections.ArrayList>，则语法 `myList[3]` （Visual Basic 中的`myList(3)`）检索索引为3的元素。 可以重载属性。  
  
 在C#中，此功能称为索引器，不能按名称引用。 默认情况下， C#索引器在元数据中显示为名为 "Item" 的索引属性。 但是，类库开发人员可以使用 <xref:System.Runtime.CompilerServices.IndexerNameAttribute> 特性来更改元数据中索引器的名称。 例如，<xref:System.String> 类具有一个名为 <xref:System.String.Chars%2A>的索引器。 使用以外的其他语言创建的C#索引属性也可以包含除 Item 以外的其他名称。  
  
 若要确定某一类型是否具有默认属性，请使用 <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> 方法测试 <xref:System.Reflection.DefaultMemberAttribute> 特性。 如果该类型具有 <xref:System.Reflection.DefaultMemberAttribute>，则 <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> 属性将返回默认属性的名称。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到多个具有指定名称且与指定自变量类型匹配的属性。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。  
  
或 
 <paramref name="types" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> 是多维的。</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="types" /> 的元素为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types, modifiers)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types, modifiers)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的公共属性名的字符串。</param>
        <param name="returnType">属性的返回类型。</param>
        <param name="types">一个 <see cref="T:System.Type" /> 对象数组，表示要获取的索引属性的参数的数目、顺序和类型。  
  
或 
获取未被索引的属性的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <paramref name="types" /> 数组中的相应元素关联的特性。 默认的联编程序不处理此参数。</param>
        <summary>搜索其参数与指定自变量类型及修饰符匹配的指定公共属性。</summary>
        <returns>表示符合指定要求的公共属性的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果某个属性至少具有一个公共访问器，则该属性将被视为 "公共"。 否则，该属性将被视为私有属性，必须使用&#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> （在 Visual Basic 中，使用 `Or`组合值）来获取它。  
  
 尽管默认联编程序不处理 <xref:System.Reflection.ParameterModifier> （`modifiers` 参数），但你可以使用 abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> 类编写处理 `modifiers`的自定义联编程序。 仅当通过 COM 互操作进行调用时才使用 `ParameterModifier`，且仅处理通过引用传递的参数。  
  
 搜索 `name` 区分大小写。 搜索包括公共静态和公共实例属性。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法将返回类型参数替换为相应类型参数的 <xref:System.Reflection.PropertyInfo>。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的属性。  
  
## <a name="indexers-and-default-properties"></a>索引器和默认属性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]和 [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] 具有简化的访问索引属性的语法，并允许一个索引属性作为其类型的默认值。 例如，如果变量 `myList` 引用 <xref:System.Collections.ArrayList>，则语法 `myList[3]` （Visual Basic 中的`myList(3)`）检索索引为3的元素。 可以重载属性。  
  
 在C#中，此功能称为索引器，不能按名称引用。 默认情况下， C#索引器在元数据中显示为名为 "Item" 的索引属性。 但是，类库开发人员可以使用 <xref:System.Runtime.CompilerServices.IndexerNameAttribute> 特性来更改元数据中索引器的名称。 例如，<xref:System.String> 类具有一个名为 <xref:System.String.Chars%2A>的索引器。 使用以外的其他语言创建的C#索引属性也可以包含除 Item 以外的其他名称。  
  
 若要确定某一类型是否具有默认属性，请使用 <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> 方法测试 <xref:System.Reflection.DefaultMemberAttribute> 特性。 如果该类型具有 <xref:System.Reflection.DefaultMemberAttribute>，则 <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> 属性将返回默认属性的名称。  
  
   
  
## Examples  
 下面的示例获取对应于 `MyPropertyClass`的 `Type` 对象，并使用传递给 `GetProperty` 方法的参数检索此类的索引属性。  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到多个具有指定名称且与指定参数类型和修饰符匹配的属性。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。  
  
或 
 <paramref name="types" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> 是多维的。  
  
或 
 <paramref name="modifiers" /> 是多维的。  
  
或 
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的长度不相同。</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="types" /> 的元素为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的属性名的字符串。</param>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
或 
 若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。  
  
或 
要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</param>
        <param name="returnType">属性的返回类型。</param>
        <param name="types">一个 <see cref="T:System.Type" /> 对象数组，表示要获取的索引属性的参数的数目、顺序和类型。  
  
或 
获取未被索引的属性的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <paramref name="types" /> 数组中的相应元素关联的特性。 默认的联编程序不处理此参数。</param>
        <summary>使用指定的绑定约束，搜索参数与指定的自变量类型及修饰符匹配的指定属性。</summary>
        <returns>表示符合指定需求的属性的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果某个属性至少具有一个公共访问器，则该属性将被视为 "公共"。 否则，该属性将被视为私有属性，必须使用&#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> （在 Visual Basic 中，使用 `Or`组合值）来获取它。  
  
 尽管默认联编程序不处理 <xref:System.Reflection.ParameterModifier> （`modifiers` 参数），但你可以使用 abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> 类编写处理 `modifiers`的自定义联编程序。 仅当通过 COM 互操作进行调用时才使用 `ParameterModifier`，且仅处理通过引用传递的参数。  
  
 下表显示了在类型上反射时，`Get` 方法返回基类的成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法（虚拟和非虚拟）可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|属性|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分，包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射，属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性，但派生类只有 get 访问器，则派生类属性将隐藏基类属性，并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 以下 <xref:System.Reflection.BindingFlags> 筛选器标志可用于定义要包括在搜索中的属性：  
  
-   若要获取返回，必须指定 `BindingFlags.Instance` 或 `BindingFlags.Static`。  
  
-   指定 `BindingFlags.Public` 以在搜索中包括公共属性。  
  
-   指定 `BindingFlags.NonPublic` 以在搜索中包括非公共属性（即私有、内部和受保护的属性）。  
  
-   指定 `BindingFlags.FlattenHierarchy` 包括层次结构中的 `public` 和 `protected` 静态成员;不包括继承类中 `private` 静态成员。  
  
 以下 <xref:System.Reflection.BindingFlags> 修饰符标志可用于更改搜索的工作方式：  
  
-   `BindingFlags.IgnoreCase` 忽略 `name`的大小写。  
  
-   `BindingFlags.DeclaredOnly` 仅搜索 <xref:System.Type>上声明的属性，而不搜索仅继承的属性。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此方法将返回类型参数替换为相应类型参数的 <xref:System.Reflection.PropertyInfo>。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法会搜索类约束的属性。  
  
## <a name="indexers-and-default-properties"></a>索引器和默认属性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]和 [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] 具有简化的访问索引属性的语法，并允许一个索引属性作为其类型的默认值。 例如，如果变量 `myList` 引用 <xref:System.Collections.ArrayList>，则语法 `myList[3]` （Visual Basic 中的`myList(3)`）检索索引为3的元素。 可以重载属性。  
  
 在C#中，此功能称为索引器，不能按名称引用。 默认情况下， C#索引器在元数据中显示为名为 "Item" 的索引属性。 但是，类库开发人员可以使用 <xref:System.Runtime.CompilerServices.IndexerNameAttribute> 特性来更改元数据中索引器的名称。 例如，<xref:System.String> 类具有一个名为 <xref:System.String.Chars%2A>的索引器。 使用以外的其他语言创建的C#索引属性也可以包含除 Item 以外的其他名称。  
  
 若要确定某一类型是否具有默认属性，请使用 <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> 方法测试 <xref:System.Reflection.DefaultMemberAttribute> 特性。 如果该类型具有 <xref:System.Reflection.DefaultMemberAttribute>，则 <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> 属性将返回默认属性的名称。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到多个具有指定名称的属性且属性与指定绑定约束匹配。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。  
  
或 
 <paramref name="types" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> 是多维的。  
  
或 
 <paramref name="modifiers" /> 是多维的。  
  
或 
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的长度不相同。</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="types" /> 的元素为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的属性名的字符串。</param>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
或 
 若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载成员、强制自变量类型和通过反射调用成员。  
  
或 
要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</param>
        <param name="returnType">属性的返回类型。</param>
        <param name="types">一个 <see cref="T:System.Type" /> 对象数组，表示要获取的索引属性的参数的数目、顺序和类型。  
  
或 
获取未被索引的属性的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <paramref name="types" /> 数组中的相应元素关联的特性。 默认的联编程序不处理此参数。</param>
        <summary>当在派生类中重写时，使用指定的绑定约束搜索其参数与指定的参数类型和修饰符匹配的指定属性。</summary>
        <returns>表示符合指定需求的属性的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管默认联编程序不处理 <xref:System.Reflection.ParameterModifier> （`modifiers` 参数），但你可以使用 abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> 类编写处理 `modifiers`的自定义联编程序。 仅当通过 COM 互操作进行调用时才使用 `ParameterModifier`，且仅处理通过引用传递的参数。  
  
 以下 <xref:System.Reflection.BindingFlags> 筛选器标志可用于定义要包括在搜索中的属性：  
  
-   若要获取返回，必须指定 `BindingFlags.Instance` 或 `BindingFlags.Static`。  
  
-   指定 `BindingFlags.Public` 以在搜索中包括公共属性。  
  
-   指定 `BindingFlags.NonPublic` 以在搜索中包括非公共属性（即私有、内部和受保护的属性）。  
  
-   指定 `BindingFlags.FlattenHierarchy` 包括层次结构中的 `public` 和 `protected` 静态成员;不包括继承类中 `private` 静态成员。  
  
 以下 <xref:System.Reflection.BindingFlags> 修饰符标志可用于更改搜索的工作方式：  
  
-   `BindingFlags.IgnoreCase` 忽略 `name`的大小写。  
  
-   `BindingFlags.DeclaredOnly` 仅搜索 <xref:System.Type>上声明的属性，而不搜索仅继承的属性。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到多个具有指定名称的属性且属性与指定绑定约束匹配。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。  
  
或 
 <paramref name="types" /> 为 <see langword="null" />。  
  
或 
<paramref name="types" /> 的其中一个元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> 是多维的。  
  
或 
 <paramref name="modifiers" /> 是多维的。  
  
或 
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的长度不相同。</exception>
        <exception cref="T:System.NotSupportedException">当前的类型是 <see cref="T:System.Reflection.Emit.TypeBuilder" />、<see cref="T:System.Reflection.Emit.EnumBuilder" /> 或 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取表示指定类型的 <see cref="T:System.Type" /> 对象。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="type.GetType " />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" />。</summary>
        <returns>当前的 <see cref="T:System.Type" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">调用了类初始值设定项，且该项引发了异常。</exception>
        <altmember cref="T:System.TypeLoadException" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">指定完全限定的类型名称</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member GetType : string -&gt; Type" Usage="System.Type.GetType typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">要获取的类型的程序集限定名称。 请参阅 <see cref="P:System.Type.AssemblyQualifiedName" />。 如果该类型位于当前正在执行的程序集中或者 Mscorlib.dll 中，则提供由命名空间限定的类型名称就足够了。</param>
        <summary>获取具有指定名称的 <see cref="T:System.Type" />，执行区分大小写的搜索。</summary>
        <returns>具有指定名称的类型（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果知道另一个程序集中的某个类型的程序集限定名称（可从 <xref:System.Type.AssemblyQualifiedName>获取），则可以使用 <xref:System.Type.GetType%2A> 方法获取该类型的 <xref:System.Type> 对象。 <xref:System.Type.GetType%2A> 导致加载 `typeName`中指定的程序集。 你还可以使用 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> 方法加载程序集，然后使用 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 或 <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> 方法获取 <xref:System.Type> 对象。 如果类型位于您的程序在编译时已知的程序集中，则使用中C#的 `typeof` 或 Visual Basic 中的 `GetType` 运算符更有效。
  
> [!NOTE]
>  如果找不到 `typeName`，对 <xref:System.Type.GetType%28System.String%29> 方法的调用将返回 `null`。 它不会引发异常。 若要控制是否引发异常，请调用具有 `throwOnError` 参数的 <xref:System.Type.GetType%2A> 方法的重载。  
  
 <xref:System.Type.GetType%2A> 仅适用于从磁盘加载的程序集。 如果调用 <xref:System.Type.GetType%2A> 来查找使用 <xref:System.Reflection.Emit> 服务定义的动态程序集中定义的类型，则可能会出现不一致的行为。 此行为取决于动态程序集是否为持久性的，即使用 `RunAndSave` 或 `Save` <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> 枚举的访问模式创建。 如果动态程序集是永久性的，并且在调用 `GetType` 之前已写入磁盘，则加载程序将在磁盘上找到保存的程序集，加载该程序集，并从该程序集检索类型。 如果在调用 `GetType` 时未将程序集保存到磁盘，则该方法将返回 `null`。 `GetType` 不理解暂时性动态程序集;因此，调用 `GetType` 检索暂时性动态程序集中的类型会返回 `null`。  
  
 若要在动态模块上使用 `GetType`，请在保存前订阅 <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> 事件并调用 `GetType`。 否则，将在内存中获取程序集的两个副本。  
  
 下表显示了在类型上反射时，`Get` 方法返回基类的成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法（虚拟和非虚拟）可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|属性|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分，包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射，属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性，但派生类只有 get 访问器，则派生类属性将隐藏基类属性，并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 不会搜索数组或 COM 类型，除非已将它们加载到可用类的表中。  
  
 `typeName` 可以是由其命名空间限定的类型名称，也可以是包含程序集名称规范的程序集限定名称。 请参阅 <xref:System.Type.AssemblyQualifiedName%2A>。  
  
 如果 `typeName` 包含命名空间而不包含程序集名称，则此方法将按顺序搜索调用对象的程序集和 Mscorlib.dll。 如果 typeName 完全限定了部分或完整的程序集名称，则此方法将在指定的程序集中搜索。 如果程序集具有强名称，则需要完整的程序集名称。  
  
 <xref:System.Type.AssemblyQualifiedName%2A> 属性返回完全限定的类型名称，包括嵌套类型、程序集名称和泛型类型参数。 所有支持公共语言运行时的编译器都将发出嵌套类的简单名称，并且在查询时，反射将按照以下约定构造错位的名称。  
  
> [!NOTE]
>  在 .NET Framework 版本2.0 中，处理器体系结构添加到程序集标识，并可指定为程序集名称字符串的一部分。 例如，"ProcessorArchitecture = msil"。 不过，由于兼容性原因，它不包含在 <xref:System.Type.AssemblyQualifiedName%2A> 属性返回的字符串中。 还可以通过创建 <xref:System.Reflection.AssemblyName> 对象并将其传递到 <xref:System.Reflection.Assembly.Load%2A> 方法的适当重载来加载类型。 然后，可以使用 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 方法从程序集加载类型。 另请参阅 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。  
  
|后面|含义|  
|---------------|-------------|  
|反斜杠 (\\)|转义符。|  
|反撇号（'）|在一个或多个数字之前，表示泛型类型名称末尾的类型参数的数目。|  
|方括号（[]）|为构造的泛型类型包含泛型类型参数列表;在类型参数列表中，将程序集限定的类型括起来。|  
|逗号（，）|在程序集名称之前。|  
|Period （.）|表示命名空间标识符。|  
|加号（+）|在嵌套类之前。|  
  
 例如，类的完全限定名称可能如下所示：  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 如果命名空间为 TopNamespace + 命名空间，则字符串必须在加号（+）前面加上转义符（\\），以防止它被解释为嵌套分隔符。 反射发出此字符串，如下所示：  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 "+ +" 变成 "\\+\\+"，而 "\\" 变成 "\\\\"。  
  
 此限定名称可以保留，以后用于加载 <xref:System.Type>。 若要搜索并加载 <xref:System.Type>，请将 <xref:System.Type.GetType%2A> 只与类型名称一起使用，或者使用程序集限定的类型名称。 仅 <xref:System.Type.GetType%2A> 类型名称将在调用方的程序集中查找 <xref:System.Type>，然后在系统程序集中查找。 具有程序集限定类型名称的 <xref:System.Type.GetType%2A> 将查找任何程序集中的 <xref:System.Type>。  
  
 类型名称可能包含表示类型附加信息的尾随字符，如类型是引用类型、指针类型还是数组类型。 若要检索不包含这些尾随字符的类型名称，请使用 `t.GetElementType().ToString()`，其中 `t` 为类型。  
  
 空格在除程序集名称之外的所有类型名称组件中都是相关的。 在程序集名称中，"，" 分隔符前面的空格是相关的，但 "，" 分隔符后面的空格将被忽略。  
  
 泛型类型的名称以反撇号（\`）开头，后跟表示泛型类型参数数目的数字。 此名称重整的用途是允许编译器支持具有相同名称但具有不同数量的类型参数的泛型类型，这些类型在同一范围内发生。 例如，反射将返回 `Tuple`1` and `元组的有错位名称`2` 从 `Tuple(Of T0, T1)` 中的泛型方法 `Tuple(Of T)` 和 Visual Basic，或在视觉对象C#中 `Tuple<T>``\<T0, T1>` 和元组。  
  
 对于泛型类型，类型参数列表括在括号中，类型参数由逗号分隔。 例如，泛型 <xref:System.Collections.Generic.Dictionary%602> 有两个类型参数。 带有类型 <xref:System.String> 的键的 `MyType` 的 <xref:System.Collections.Generic.Dictionary%602> 可能如下所示：  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 若要在类型参数列表中指定程序集限定类型，请将程序集限定类型括在括号内。 否则，分隔程序集限定名称的各部分的逗号将解释为分隔附加类型参数。 例如，可以按如下所示指定 <xref:System.Collections.Generic.Dictionary%602> `MyType` fromMyAssembly，其中包含类型 <xref:System.String>的键）：  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  仅当程序集限定类型出现在类型参数列表中时，才可以将其括在括号中。 用于在类型参数列表中搜索限定类型和非限定类型的程序集的规则与限定和非限定非泛型类型的规则相同。  
  
 可以为 null 的类型是泛型类型的特例。 例如，可以为 null 的 <xref:System.Int32> 由字符串 "system.string" 1 [System.object] "表示。  
  
> [!NOTE]
>  在C#、 C++和中 Visual Basic 你还可以使用类型运算符获取可以为 null 的类型。 例如，可以为 null 的 <xref:System.Boolean> 类型由 `typeof(Nullable<bool>)` 在中C#，`Nullable<Boolean>::typeid` 在中C++，通过在 Visual Basic 中 `GetType(Nullable(Of Boolean))`。  
  
 下表显示了在各种类型的 `GetType` 中使用的语法。  
  
|获取|使用|  
|------------|---------|  
|可以为 null 的 <xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|要 `MyType` 的非托管指针|`Type.GetType("MyType*")`|  
|指向指向的指针的非托管指针 `MyType`|`Type.GetType("MyType**")`|  
|托管指针或对的引用 `MyType`|`Type.GetType("MyType&")`。 请注意，与指针不同，引用仅限于一个级别。|  
|父类和嵌套类|`Type.GetType("MyParentClass+MyNestedClass")`|  
|下限为0的一维数组|`Type.GetType("MyType[]")`|  
|下限未知的一维数组|`Type.GetType("MyType[*]")`|  
|一维数组|括号中的逗号（，）的总计 n-1 次。 例如，`System.Object[,,]` 表示三维 `Object` 数组。|  
|一维数组的数组|`Type.GetType("MyType[][]")`|  
|下限未知的矩形二维数组|`Type.GetType("MyType[,]")`|  
|具有一个类型参数的泛型类型|``Type.GetType("MyGenericType`1[MyType]")``|  
|具有两个类型参数的泛型类型|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|具有两个程序集限定类型参数的泛型类型|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|具有程序集限定类型参数的程序集限定的泛型类型|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|一个泛型类型，其类型自变量是具有两个类型参数的泛型类型|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 下面的示例检索 `System.Int32` 的类型，并使用该类型对象显示 `System.Int32`的 <xref:System.Type.FullName%2A> 属性。  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">调用了类初始值设定项，且该项引发了异常。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> 表示将指针类型、<see langword="ByRef" /> 类型或 <see cref="T:System.Void" /> 作为其类型参数之一的泛型类型。  
  
或 
 <paramref name="typeName" /> 表示具有错误的类型参数数目的泛型类型。  
  
或 
 <paramref name="typeName" /> 表示泛型类型，并且其类型参数之一不满足相应类型参数的约束。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> 表示 <see cref="T:System.TypedReference" /> 的数组。</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.IO.IOException" />。  
  
</para>
          </block>  
  
 找到了程序集或其依赖项之一，但无法加载它们。</exception>
        <exception cref="T:System.BadImageFormatException">程序集或其依赖项之一无效。  
  
 或  
  
 当前加载的是公共语言运行时 2.0 版或更高版本，而程序集使用更高的版本编译。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">指定完全限定的类型名称</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">要获取的类型的程序集限定名称。 请参阅 <see cref="P:System.Type.AssemblyQualifiedName" />。 如果该类型位于当前正在执行的程序集中或者 Mscorlib.dll 中，则提供由命名空间限定的类型名称就足够了。</param>
        <param name="throwOnError">如果为 <see langword="true" />，则在找不到该类型时引发异常；如果为 <see langword="false" />，则返回 <see langword="null" />。 指定 <see langword="false" /> 还会取消某些其他异常条件，但并不取消所有条件。 请参见“异常”部分。</param>
        <summary>获取具有指定名称的 <see cref="T:System.Type" />，指定是否执行区分大小写的搜索，以及在找不到类型时是否引发异常。</summary>
        <returns>具有指定名称的类型。 如果找不到该类型，则 <paramref name="throwOnError" /> 参数指定是返回 <see langword="null" /> 还是引发异常。 在某些情况下，将引发异常，而不考虑 <paramref name="throwOnError" /> 的值。 请参见“异常”部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果知道另一个程序集中的某个类型的程序集限定名称（可从 <xref:System.Type.AssemblyQualifiedName>获取），则可以使用 <xref:System.Type.GetType%2A> 方法获取该类型的 <xref:System.Type> 对象。 <xref:System.Type.GetType%2A> 导致加载 `typeName`中指定的程序集。 你还可以使用 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> 方法加载程序集，然后使用 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 或 <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> 方法获取 <xref:System.Type> 对象。 如果类型位于您的程序在编译时已知的程序集中，则使用中C#的 `typeof` 或 Visual Basic 中的 `GetType` 运算符更有效。
  
 `GetType` 仅适用于从磁盘加载的程序集。 如果调用 `GetType` 来查找使用 <xref:System.Reflection.Emit> 服务定义的动态程序集中定义的类型，则可能会出现不一致的行为。 此行为取决于动态程序集是否为持久性的，即使用 `RunAndSave` 或 `Save` <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> 枚举的访问模式创建。 如果动态程序集是永久性的，并且在调用 `GetType` 之前已写入磁盘，则加载程序将在磁盘上找到保存的程序集，加载该程序集，并从该程序集检索类型。 如果在调用 `GetType` 时未将程序集保存到磁盘，则该方法将返回 `null`。 `GetType` 不理解暂时性动态程序集;因此，调用 `GetType` 检索暂时性动态程序集中的类型会返回 `null`。  
  
 若要在动态模块上使用 `GetType`，请在保存前订阅 <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> 事件并调用 `GetType`。 否则，将在内存中获取程序集的两个副本。  
  
 `throwOnError` 参数指定当找不到该类型时所发生的情况，还会取消某些其他异常条件，如 "异常" 一节中所述。 如果 `throwOnError`的值，则会引发某些异常。 例如，如果找到类型但无法加载，则即使 `throwOnError` `false`，也会引发 <xref:System.TypeLoadException>。  
  
 下表显示了在类型上反射时，`Get` 方法返回基类的成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法（虚拟和非虚拟）可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|属性|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分，包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射，属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性，但派生类只有 get 访问器，则派生类属性将隐藏基类属性，并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 不会搜索数组或 COM 类型，除非已将它们加载到可用类的表中。  
  
 `typeName` 可以是由其命名空间限定的类型名称，也可以是包含程序集名称规范的程序集限定名称。 请参阅 <xref:System.Type.AssemblyQualifiedName%2A>。  
  
 如果 `typeName` 包含命名空间而不包含程序集名称，则此方法将按顺序搜索调用对象的程序集和 Mscorlib.dll。 如果 typeName 完全限定了部分或完整的程序集名称，则此方法将在指定的程序集中搜索。 如果程序集具有强名称，则需要完整的程序集名称。  
  
 <xref:System.Type.AssemblyQualifiedName%2A> 属性返回完全限定的类型名称，包括嵌套类型、程序集名称和泛型参数。 所有支持公共语言运行时的编译器都将发出嵌套类的简单名称，并且在查询时，反射将按照以下约定构造错位的名称。  
  
> [!NOTE]
>  在 .NET Framework 版本2.0 中，处理器体系结构添加到程序集标识，并可指定为程序集名称字符串的一部分。 例如，"ProcessorArchitecture = msil"。 不过，由于兼容性原因，它不包含在 <xref:System.Type.AssemblyQualifiedName%2A> 属性返回的字符串中。 还可以通过创建 <xref:System.Reflection.AssemblyName> 对象并将其传递到 <xref:System.Reflection.Assembly.Load%2A> 方法的适当重载来加载类型。 然后，可以使用 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 方法从程序集加载类型。 另请参阅 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。  
  
|后面|含义|  
|---------------|-------------|  
|反斜杠 (\\)|转义符。|  
|反撇号（'）|在一个或多个数字之前，表示泛型类型名称末尾的类型参数的数目。|  
|方括号（[]）|为构造的泛型类型包含泛型类型参数列表;在类型参数列表中，将程序集限定的类型括起来。|  
|逗号（，）|在程序集名称之前。|  
|Period （.）|表示命名空间标识符。|  
|加号（+）|在嵌套类之前。|  
  
 例如，类的完全限定名称可能如下所示：  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 如果命名空间为 TopNamespace + 命名空间，则字符串必须在加号（+）前面加上转义符（\\），以防止它被解释为嵌套分隔符。 反射发出此字符串，如下所示：  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 "+ +" 变成 "\\+\\+"，而 "\\" 变成 "\\\\"。  
  
 此限定名称可以保留，以后用于加载 <xref:System.Type>。 若要搜索并加载 <xref:System.Type>，请将 <xref:System.Type.GetType%2A> 只与类型名称一起使用，或者使用程序集限定的类型名称。 仅 <xref:System.Type.GetType%2A> 类型名称将在调用方的程序集中查找 <xref:System.Type>，然后在系统程序集中查找。 具有程序集限定类型名称的 <xref:System.Type.GetType%2A> 将查找任何程序集中的 <xref:System.Type>。  
  
 类型名称可能包含表示类型附加信息的尾随字符，如类型是引用类型、指针类型还是数组类型。 若要检索不包含这些尾随字符的类型名称，请使用 `t.GetElementType().ToString()`，其中 `t` 为类型。  
  
 空格在除程序集名称之外的所有类型名称组件中都是相关的。 在程序集名称中，"，" 分隔符前面的空格是相关的，但 "，" 分隔符后面的空格将被忽略。  
  
 泛型类型的名称以反撇号（\`）开头，后跟表示泛型类型参数数目的数字。 此名称重整的用途是允许编译器支持具有相同名称但具有不同数量的类型参数的泛型类型，这些类型在同一范围内发生。 例如，反射将返回 `Tuple`1` and `元组的有错位名称`2` 从 `Tuple(Of T0, T1)` 中的泛型方法 `Tuple(Of T)` 和 Visual Basic，或在视觉对象C#中 `Tuple<T>``\<T0, T1>` 和元组。  
  
 对于泛型类型，类型参数列表括在括号中，类型参数由逗号分隔。 例如，泛型 <xref:System.Collections.Generic.Dictionary%602> 有两个类型参数。 带有类型 <xref:System.String> 的键的 `MyType` 的 <xref:System.Collections.Generic.Dictionary%602> 可能如下所示：  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 若要在类型参数列表中指定程序集限定类型，请将程序集限定类型括在括号内。 否则，分隔程序集限定名称的各部分的逗号将解释为分隔附加类型参数。 例如，可以按如下所示指定 <xref:System.Collections.Generic.Dictionary%602> `MyType` MyAssembly，其中包含类型 <xref:System.String>的键）：  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  仅当程序集限定类型出现在类型参数列表中时，才可以将其括在括号中。 用于在类型参数列表中搜索限定类型和非限定类型的程序集的规则与限定和非限定非泛型类型的规则相同。  
  
 可以为 null 的类型是泛型类型的特例。 例如，可以为 null 的 <xref:System.Int32> 由字符串 "system.string" 1 [System.object] "表示。  
  
> [!NOTE]
>  在C#、 C++和中 Visual Basic 你还可以使用类型运算符获取可以为 null 的类型。 例如，可以为 null 的 <xref:System.Boolean> 类型由 `typeof(Nullable<bool>)` 在中C#，`Nullable<Boolean>::typeid` 在中C++，通过在 Visual Basic 中 `GetType(Nullable(Of Boolean))`。  
  
 下表显示了在各种类型的 `GetType` 中使用的语法。  
  
|获取|使用|  
|------------|---------|  
|可以为 null 的 <xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|要 `MyType` 的非托管指针|`Type.GetType("MyType*")`|  
|指向指向的指针的非托管指针 `MyType`|`Type.GetType("MyType**")`|  
|托管指针或对的引用 `MyType`|`Type.GetType("MyType&")`。 请注意，与指针不同，引用仅限于一个级别。|  
|父类和嵌套类|`Type.GetType("MyParentClass+MyNestedClass")`|  
|下限为0的一维数组|`Type.GetType("MyArray[]")`|  
|下限未知的一维数组|`Type.GetType("MyArray[*]")`|  
|一维数组|括号中的逗号（，）的总计 n-1 次。 例如，`System.Object[,,]` 表示三维 `Object` 数组。|  
|二维数组的数组|`Type.GetType("MyArray[][]")`|  
|下限未知的矩形二维数组|`Type.GetType("MyArray[,]")`|  
|具有一个类型参数的泛型类型|``Type.GetType("MyGenericType`1[MyType]")``|  
|具有两个类型参数的泛型类型|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|具有两个程序集限定类型参数的泛型类型|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|具有程序集限定类型参数的程序集限定的泛型类型|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|一个泛型类型，其类型自变量是具有两个类型参数的泛型类型|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 下面的示例检索 `System.Int32` 的类型，并使用该类型对象显示 `System.Int32`的 <xref:System.Type.FullName%2A> 属性。 如果类型对象引用不存在的程序集，则此示例将引发异常。  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">调用了类初始值设定项，且该项引发了异常。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> 是 <see langword="true" />，且找不到该类型。  
  
或 
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 包含无效字符，例如嵌入的制表符。 
或 
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 为空字符串。  
  
或 
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 表示大小无效的数组类型。  
  
或 
 <paramref name="typeName" /> 表示 <see cref="T:System.TypedReference" /> 的数组。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="throwOnError" /> 是 <see langword="true" />，且 <paramref name="typeName" /> 包含无效的语法。 例如："MyType[,*,]"。  
  
或 
 <paramref name="typeName" /> 表示将指针类型、<see langword="ByRef" /> 类型或 <see cref="T:System.Void" /> 作为其类型参数之一的泛型类型。  
  
或 
 <paramref name="typeName" /> 表示具有错误的类型参数数目的泛型类型。  
  
或 
 <paramref name="typeName" /> 表示泛型类型，并且其类型参数之一不满足相应类型参数的约束。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> 是 <see langword="true" /> 并且未找到程序集或其依赖项之一。</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.IO.IOException" />。  
  
</para>
          </block>  
  
 找到了程序集或其依赖项之一，但无法加载它们。</exception>
        <exception cref="T:System.BadImageFormatException">程序集或其依赖项之一无效。  
  
 或  
  
 当前加载的是公共语言运行时 2.0 版或更高版本，而程序集使用更高的版本编译。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">指定完全限定的类型名称</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="typeName">要获取的类型的程序集限定名称。 请参阅 <see cref="P:System.Type.AssemblyQualifiedName" />。 如果该类型位于当前正在执行的程序集中或者 Mscorlib.dll 中，则提供由命名空间限定的类型名称就足够了。</param>
        <param name="throwOnError">如果为 <see langword="true" />，则在找不到该类型时引发异常；如果为 <see langword="false" />，则返回 <see langword="null" />。 指定 <see langword="false" /> 还会取消某些其他异常条件，但并不取消所有条件。 请参见“异常”部分。</param>
        <param name="ignoreCase">对 <see langword="true" /> 执行的搜索不区分大小写，则为 <paramref name="typeName" />；对 <see langword="false" /> 执行的搜索区分大小写，则为 <paramref name="typeName" />。</param>
        <summary>获取具有指定名称的 <see cref="T:System.Type" />，指定是否执行区分大小写的搜索，以及在找不到类型时是否引发异常。</summary>
        <returns>具有指定名称的类型。 如果找不到该类型，则 <paramref name="throwOnError" /> 参数指定是返回 <see langword="null" /> 还是引发异常。 在某些情况下，将引发异常，而不考虑 <paramref name="throwOnError" /> 的值。 请参见“异常”部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果知道另一个程序集中的某个类型的程序集限定名称（可从 <xref:System.Type.AssemblyQualifiedName>获取），则可以使用 <xref:System.Type.GetType%2A> 方法获取该类型的 <xref:System.Type> 对象。 <xref:System.Type.GetType%2A> 导致加载 `typeName`中指定的程序集。 你还可以使用 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> 方法加载程序集，然后使用 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 或 <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> 方法获取 <xref:System.Type> 对象。 如果类型位于您的程序在编译时已知的程序集中，则使用中C#的 `typeof` 或 Visual Basic 中的 `GetType` 运算符更有效。
  
 `GetType` 仅适用于从磁盘加载的程序集。 如果调用 `GetType` 来查找使用 <xref:System.Reflection.Emit> 服务定义的动态程序集中定义的类型，则可能会出现不一致的行为。 此行为取决于动态程序集是否为持久性的，即使用 `RunAndSave` 或 `Save` <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> 枚举的访问模式创建。 如果动态程序集是永久性的，并且在调用 `GetType` 之前已写入磁盘，则加载程序将在磁盘上找到保存的程序集，加载该程序集，并从该程序集检索类型。 如果在调用 `GetType` 时未将程序集保存到磁盘，则该方法将返回 `null`。 `GetType` 不理解暂时性动态程序集;因此，调用 `GetType` 检索暂时性动态程序集中的类型会返回 `null`。  
  
 若要在动态模块上使用 `GetType`，请在保存前订阅 <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> 事件并调用 `GetType`。 否则，将在内存中获取程序集的两个副本。  
  
 `throwOnError` 参数指定当找不到该类型时所发生的情况，还会取消某些其他异常条件，如 "异常" 一节中所述。 如果 `throwOnError`的值，则会引发某些异常。 例如，如果找到类型但无法加载，则即使 `throwOnError` `false`，也会引发 <xref:System.TypeLoadException>。  
  
 下表显示了在类型上反射时，`Get` 方法返回基类的成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法（虚拟和非虚拟）可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|属性|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分，包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射，属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性，但派生类只有 get 访问器，则派生类属性将隐藏基类属性，并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 不会搜索数组或 COM 类型，除非已将它们加载到可用类的表中。  
  
 `typeName` 可以是由其命名空间限定的类型名称，也可以是包含程序集名称规范的程序集限定名称。 请参阅 <xref:System.Type.AssemblyQualifiedName%2A>。  
  
 如果 `typeName` 包含命名空间而不包含程序集名称，则此方法将按顺序搜索调用对象的程序集和 Mscorlib.dll。 如果 typeName 完全限定了部分或完整的程序集名称，则此方法将在指定的程序集中搜索。 如果程序集具有强名称，则需要完整的程序集名称。  
  
 <xref:System.Type.AssemblyQualifiedName%2A> 属性返回完全限定的类型名称，包括嵌套类型、程序集名称和类型参数。 所有支持公共语言运行时的编译器都将发出嵌套类的简单名称，并且在查询时，反射将按照以下约定构造错位的名称。  
  
> [!NOTE]
>  在 .NET Framework 版本2.0 中，处理器体系结构添加到程序集标识，并可指定为程序集名称字符串的一部分。 例如，"ProcessorArchitecture = msil"。 不过，由于兼容性原因，它不包含在 <xref:System.Type.AssemblyQualifiedName%2A> 属性返回的字符串中。 还可以通过创建 <xref:System.Reflection.AssemblyName> 对象并将其传递到 <xref:System.Reflection.Assembly.Load%2A> 方法的适当重载来加载类型。 然后，可以使用 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 方法从程序集加载类型。 另请参阅 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。  
  
|后面|含义|  
|---------------|-------------|  
|反斜杠 (\\)|转义符。|  
|反撇号（'）|在一个或多个数字之前，表示泛型类型名称末尾的类型参数的数目。|  
|方括号（[]）|为构造的泛型类型包含泛型类型参数列表;在类型参数列表中，将程序集限定的类型括起来。|  
|逗号（，）|在程序集名称之前。|  
|Period （.）|表示命名空间标识符。|  
|加号（+）|在嵌套类之前。|  
  
 例如，类的完全限定名称可能如下所示：  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 如果命名空间为 TopNamespace + 命名空间，则字符串必须在加号（+）前面加上转义符（\\），以防止它被解释为嵌套分隔符。 反射发出此字符串，如下所示：  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 "+ +" 变成 "\\+\\+"，而 "\\" 变成 "\\\\"。  
  
 此限定名称可以保留，以后用于加载 <xref:System.Type>。 若要搜索并加载 <xref:System.Type>，请将 <xref:System.Type.GetType%2A> 只与类型名称一起使用，或者使用程序集限定的类型名称。 仅 <xref:System.Type.GetType%2A> 类型名称将在调用方的程序集中查找 <xref:System.Type>，然后在系统程序集中查找。 具有程序集限定类型名称的 <xref:System.Type.GetType%2A> 将查找任何程序集中的 <xref:System.Type>。  
  
 类型名称可能包含表示类型附加信息的尾随字符，如类型是引用类型、指针类型还是数组类型。 若要检索不包含这些尾随字符的类型名称，请使用 `t.GetElementType().ToString()`，其中 `t` 为类型。  
  
 空格在除程序集名称之外的所有类型名称组件中都是相关的。 在程序集名称中，"，" 分隔符前面的空格是相关的，但 "，" 分隔符后面的空格将被忽略。  
  
 泛型类型的名称以反撇号（\`）开头，后跟表示泛型类型参数数目的数字。 此名称重整的用途是允许编译器支持具有相同名称但具有不同数量的类型参数的泛型类型，这些类型在同一范围内发生。 例如，反射将返回 `Tuple`1` and `元组的有错位名称`2` 从 `Tuple(Of T0, T1)` 中的泛型方法 `Tuple(Of T)` 和 Visual Basic，或在视觉对象C#中 `Tuple<T>``\<T0, T1>` 和元组。  
  
 对于泛型类型，类型参数列表括在括号中，类型参数由逗号分隔。 例如，泛型 <xref:System.Collections.Generic.Dictionary%602> 有两个类型参数。 带有类型 <xref:System.String> 的键的 `MyType` 的 <xref:System.Collections.Generic.Dictionary%602> 可能如下所示：  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 若要在类型参数列表中指定程序集限定类型，请将程序集限定类型括在括号内。 否则，分隔程序集限定名称的各部分的逗号将解释为分隔附加类型参数。 例如，可以按如下所示指定 <xref:System.Collections.Generic.Dictionary%602> `MyType` MyAssembly，其中包含类型 <xref:System.String>的键）：  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  仅当程序集限定类型出现在类型参数列表中时，才可以将其括在括号中。 用于在类型参数列表中搜索限定类型和非限定类型的程序集的规则与限定和非限定非泛型类型的规则相同。  
  
 可以为 null 的类型是泛型类型的特例。 例如，可以为 null 的 <xref:System.Int32> 由字符串 "system.string" 1 [System.object] "表示。  
  
> [!NOTE]
>  在C#、 C++和中 Visual Basic 你还可以使用类型运算符获取可以为 null 的类型。 例如，可以为 null 的 <xref:System.Boolean> 类型由 `typeof(Nullable<bool>)` 在中C#，`Nullable<Boolean>::typeid` 在中C++，通过在 Visual Basic 中 `GetType(Nullable(Of Boolean))`。  
  
 下表显示了在各种类型的 `GetType` 中使用的语法。  
  
|获取|使用|  
|------------|---------|  
|可以为 null 的 <xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|要 `MyType` 的非托管指针|`Type.GetType("MyType*")`|  
|指向指向的指针的非托管指针 `MyType`|`Type.GetType("MyType**")`|  
|托管指针或对的引用 `MyType`|`Type.GetType("MyType&")`。 请注意，与指针不同，引用仅限于一个级别。|  
|父类和嵌套类|`Type.GetType("MyParentClass+MyNestedClass")`|  
|下限为0的一维数组|`Type.GetType("MyArray[]")`|  
|下限未知的一维数组|`Type.GetType("MyArray[*]")`|  
|一维数组|括号中的逗号（，）的总计 n-1 次。 例如，`System.Object[,,]` 表示三维 `Object` 数组。|  
|二维数组的数组|`Type.GetType("MyArray[][]")`|  
|下限未知的矩形二维数组|`Type.GetType("MyArray[,]")`|  
|具有一个类型参数的泛型类型|``Type.GetType("MyGenericType`1[MyType]")``|  
|具有两个类型参数的泛型类型|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|具有两个程序集限定类型参数的泛型类型|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|具有程序集限定类型参数的程序集限定的泛型类型|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|一个泛型类型，其类型自变量是具有两个类型参数的泛型类型|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">调用了类初始值设定项，且该项引发了异常。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> 是 <see langword="true" />，且找不到该类型。  
  
或 
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 包含无效字符，例如嵌入的制表符。 
或 
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 为空字符串。  
  
或 
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 表示大小无效的数组类型。  
  
或 
 <paramref name="typeName" /> 表示 <see cref="T:System.TypedReference" /> 的数组。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="throwOnError" /> 是 <see langword="true" />，且 <paramref name="typeName" /> 包含无效的语法。 例如："MyType[,*,]"。  
  
或 
 <paramref name="typeName" /> 表示将指针类型、<see langword="ByRef" /> 类型或 <see cref="T:System.Void" /> 作为其类型参数之一的泛型类型。  
  
或 
 <paramref name="typeName" /> 表示具有错误的类型参数数目的泛型类型。  
  
或 
 <paramref name="typeName" /> 表示泛型类型，并且其类型参数之一不满足相应类型参数的约束。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> 的值为 <see langword="true" />，且未找到程序集或程序集的某个依赖项。</exception>
        <exception cref="T:System.IO.FileLoadException">找到了程序集或其依赖项之一，但无法加载它们。</exception>
        <exception cref="T:System.BadImageFormatException">程序集或其依赖项之一无效。  
  
 或  
  
 当前加载的是公共语言运行时 2.0 版或更高版本，而程序集使用更高的版本编译。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">指定完全限定的类型名称</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName">要获取的类型的名称。 如果提供了 <paramref name="typeResolver" /> 参数，则类型名称可以为 <paramref name="typeResolver" /> 能够解析的任何字符串。 如果提供了 <paramref name="assemblyResolver" /> 参数，或者使用了标准类型解析，则除非该类型位于当前正在执行的程序集或 Mscorlib.dll 中（在这种情况下足以提供其命名空间所限定的类型名称），否则 <paramref name="typeName" /> 必须为程序集限定的名称（请参见 <see cref="P:System.Type.AssemblyQualifiedName" />）。</param>
        <param name="assemblyResolver">一个方法，它定位并返回 <paramref name="typeName" /> 中指定的程序集。 以 <paramref name="assemblyResolver" /> 对象形式传递给 <see cref="T:System.Reflection.AssemblyName" /> 的程序集名称。 如果 <paramref name="typeName" /> 不包含程序集的名称，则不调用 <paramref name="assemblyResolver" />。 如果未提供 <paramref name="assemblyResolver" />，则执行标准程序集解析。  
  
警告   不要通过未知的或不受信任的调用方传递方法。 此操作可能会导致恶意代码特权提升。 仅使用你提供或者熟悉的方法。</param>
        <param name="typeResolver">一个方法，它在由 <paramref name="typeName" /> 或标准程序集解析返回的程序集中定位并返回 <paramref name="assemblyResolver" /> 所指定的类型。 如果未提供任何程序集，则 <paramref name="typeResolver" /> 方法可以提供一个程序集。 该方法还采用一个参数以指定是否执行不区分大小写的搜索；<see langword="false" /> 传递给该参数。  
  
警告   不要通过未知的或不受信任的调用方传递方法。</param>
        <summary>获取具有指定名称的类型，（可选）提供自定义方法以解析程序集和该类型。</summary>
        <returns>具有指定名称的类型，如果未找到该类型，则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的使用方案以及有关 `assemblyResolver` 和 `typeResolver` 参数的详细信息可在 <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> 方法重载中找到。  
  
> [!NOTE]
>  如果找不到 `typeName`，对 <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> 方法的调用将返回 `null`。 它不会引发异常。 若要控制是否引发异常，请调用具有 `throwOnError` 参数的 <xref:System.Type.GetType%2A> 方法的重载。  
  
 调用此方法重载与调用 <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> 方法重载和指定 `throwOnError` 和 `ignoreCase` 参数 `false` 相同。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">调用了类初始值设定项，且该项引发了异常。</exception>
        <exception cref="T:System.ArgumentException">当 <paramref name="typeName" /> 解析为类型名称和程序集名称时（例如，当简单类型名称包含未转义的特殊字符时），发生错误。  
  
或 
 <paramref name="typeName" /> 表示将指针类型、<see langword="ByRef" /> 类型或 <see cref="T:System.Void" /> 作为其类型参数之一的泛型类型。  
  
或 
 <paramref name="typeName" /> 表示具有错误的类型参数数目的泛型类型。  
  
或 
 <paramref name="typeName" /> 表示泛型类型，并且其类型参数之一不满足相应类型参数的约束。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> 表示 <see cref="T:System.TypedReference" /> 的数组。</exception>
        <exception cref="T:System.IO.FileLoadException">找到了程序集或其依赖项之一，但无法加载它们。  
  
或 
 <paramref name="typeName" /> 包含无效的程序集名称。  
  
或 
 <paramref name="typeName" /> 是一个不含类型名称的有效程序集名称。</exception>
        <exception cref="T:System.BadImageFormatException">程序集或其依赖项之一无效。  
  
 或  
  
 此程序集使用高于当前所加载版本的公共语言运行时版本编译而成。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName">要获取的类型的名称。 如果提供了 <paramref name="typeResolver" /> 参数，则类型名称可以为 <paramref name="typeResolver" /> 能够解析的任何字符串。 如果提供了 <paramref name="assemblyResolver" /> 参数，或者使用了标准类型解析，则除非该类型位于当前正在执行的程序集或 Mscorlib.dll 中（在这种情况下足以提供其命名空间所限定的类型名称），否则 <paramref name="typeName" /> 必须为程序集限定的名称（请参见 <see cref="P:System.Type.AssemblyQualifiedName" />）。</param>
        <param name="assemblyResolver">一个方法，它定位并返回 <paramref name="typeName" /> 中指定的程序集。 以 <paramref name="assemblyResolver" /> 对象形式传递给 <see cref="T:System.Reflection.AssemblyName" /> 的程序集名称。 如果 <paramref name="typeName" /> 不包含程序集的名称，则不调用 <paramref name="assemblyResolver" />。 如果未提供 <paramref name="assemblyResolver" />，则执行标准程序集解析。  
  
警告   不要通过未知的或不受信任的调用方传递方法。 此操作可能会导致恶意代码特权提升。 仅使用你提供或者熟悉的方法。</param>
        <param name="typeResolver">一个方法，它在由 <paramref name="typeName" /> 或标准程序集解析返回的程序集中定位并返回 <paramref name="assemblyResolver" /> 所指定的类型。 如果未提供任何程序集，则该方法可以提供一个程序集。 该方法还采用一个参数以指定是否执行不区分大小写的搜索；<see langword="false" /> 传递给该参数。  
  
警告   不要通过未知的或不受信任的调用方传递方法。</param>
        <param name="throwOnError">如果为 <see langword="true" />，则在找不到该类型时引发异常；如果为 <see langword="false" />，则返回 <see langword="null" />。 指定 <see langword="false" /> 还会取消某些其他异常条件，但并不取消所有条件。 请参见“异常”部分。</param>
        <summary>获取具有指定名称的类型，指定在找不到该类型时是否引发异常，（可选）提供自定义方法以解析程序集和该类型。</summary>
        <returns>具有指定名称的类型。 如果找不到该类型，则 <paramref name="throwOnError" /> 参数指定是返回 <see langword="null" /> 还是引发异常。 在某些情况下，将引发异常，而不考虑 <paramref name="throwOnError" /> 的值。 请参见“异常”部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的使用方案以及有关 `assemblyResolver` 和 `typeResolver` 参数的详细信息可在 <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> 方法重载中找到。  
  
 调用此方法重载与调用 <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> 方法重载和指定 `ignoreCase` 参数 `false` 的情况相同。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">调用了类初始值设定项，且该项引发了异常。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> 是 <see langword="true" />，且找不到该类型。  
  
或 
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 包含无效字符，例如嵌入的制表符。 
或 
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 为空字符串。  
  
或 
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 表示大小无效的数组类型。  
  
或 
 <paramref name="typeName" /> 表示 <see cref="T:System.TypedReference" /> 的数组。</exception>
        <exception cref="T:System.ArgumentException">当 <paramref name="typeName" /> 解析为类型名称和程序集名称时（例如，当简单类型名称包含未转义的特殊字符时），发生错误。  
  
或 
 <paramref name="throwOnError" /> 是 <see langword="true" />，且 <paramref name="typeName" /> 包含无效的语法（例如 "MyType[,*,]"）。  
  
或 
 <paramref name="typeName" /> 表示将指针类型、<see langword="ByRef" /> 类型或 <see cref="T:System.Void" /> 作为其类型参数之一的泛型类型。  
  
或 
 <paramref name="typeName" /> 表示具有错误的类型参数数目的泛型类型。  
  
或 
 <paramref name="typeName" /> 表示泛型类型，并且其类型参数之一不满足相应类型参数的约束。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> 的值为 <see langword="true" />，且未找到程序集或程序集的某个依赖项。  
  
或 
 <paramref name="typeName" /> 包含无效的程序集名称。  
  
或 
 <paramref name="typeName" /> 是一个不含类型名称的有效程序集名称。</exception>
        <exception cref="T:System.IO.FileLoadException">找到了程序集或其依赖项之一，但无法加载它们。</exception>
        <exception cref="T:System.BadImageFormatException">程序集或其依赖项之一无效。  
  
 或  
  
 此程序集使用高于当前所加载版本的公共语言运行时版本编译而成。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName">要获取的类型的名称。 如果提供了 <paramref name="typeResolver" /> 参数，则类型名称可以为 <paramref name="typeResolver" /> 能够解析的任何字符串。 如果提供了 <paramref name="assemblyResolver" /> 参数，或者使用了标准类型解析，则除非该类型位于当前正在执行的程序集或 Mscorlib.dll 中（在这种情况下足以提供其命名空间所限定的类型名称），否则 <paramref name="typeName" /> 必须为程序集限定的名称（请参见 <see cref="P:System.Type.AssemblyQualifiedName" />）。</param>
        <param name="assemblyResolver">一个方法，它定位并返回 <paramref name="typeName" /> 中指定的程序集。 以 <paramref name="assemblyResolver" /> 对象形式传递给 <see cref="T:System.Reflection.AssemblyName" /> 的程序集名称。 如果 <paramref name="typeName" /> 不包含程序集的名称，则不调用 <paramref name="assemblyResolver" />。 如果未提供 <paramref name="assemblyResolver" />，则执行标准程序集解析。  
  
警告   不要通过未知的或不受信任的调用方传递方法。 此操作可能会导致恶意代码特权提升。 仅使用你提供或者熟悉的方法。</param>
        <param name="typeResolver">一个方法，它在由 <paramref name="typeName" /> 或标准程序集解析返回的程序集中定位并返回 <paramref name="assemblyResolver" /> 所指定的类型。 如果未提供任何程序集，则该方法可以提供一个程序集。 该方法还采用一个参数以指定是否执行不区分大小写的搜索；<paramref name="ignoreCase" /> 的值传递给该参数。  
  
警告   不要通过未知的或不受信任的调用方传递方法。</param>
        <param name="throwOnError">如果为 <see langword="true" />，则在找不到该类型时引发异常；如果为 <see langword="false" />，则返回 <see langword="null" />。 指定 <see langword="false" /> 还会取消某些其他异常条件，但并不取消所有条件。 请参见“异常”部分。</param>
        <param name="ignoreCase">对 <see langword="true" /> 执行的搜索不区分大小写，则为 <paramref name="typeName" />；对 <see langword="false" /> 执行的搜索区分大小写，则为 <paramref name="typeName" />。</param>
        <summary>获取具有指定名称的类型，指定是否执行区分大小写的搜索，在找不到类型时是否引发异常，（可选）提供自定义方法以解析程序集和该类型。</summary>
        <returns>具有指定名称的类型。 如果找不到该类型，则 <paramref name="throwOnError" /> 参数指定是返回 <see langword="null" /> 还是引发异常。 在某些情况下，将引发异常，而不考虑 <paramref name="throwOnError" /> 的值。 请参见“异常”部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法重载及其关联重载（<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> 和 <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>）将 <xref:System.Type.GetType%2A> 方法的默认实现替换为更灵活的实现。 通过提供自己的方法来解析类型名称以及包含它们的程序集的名称，您可以执行以下操作：  
  
-   控制从其加载类型的程序集的版本。  
  
-   提供另一个查找不包括程序集名称的类型名称的位置。  
  
-   使用部分程序集名称加载程序集。  
  
-   返回不是由公共语言运行时（CLR）创建的 <xref:System.Type?displayProperty=nameWithType> 的子类。  
  
 例如，在版本容错序列化中，此方法使你能够使用部分名称搜索 "最适合" 程序集。 <xref:System.Type.GetType%2A> 方法的其他重载需要程序集限定的类型名称，包括版本号。  
  
 类型系统的其他实现可能需要返回不是由 CLR 创建的 <xref:System.Type?displayProperty=nameWithType> 的子类;<xref:System.Type.GetType%2A> 方法的其他重载返回的所有类型都是运行时类型。  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a>使用说明  
 此方法重载及其关联的重载会将 `typeName` 分析为类型名称和程序集名称，然后解析名称。 程序集名称的解析出现在类型名称解析之前，因为类型名称必须在程序集的上下文中解析。  
  
> [!NOTE]
>  如果不熟悉程序集限定类型名称的概念，请参阅 <xref:System.Type.AssemblyQualifiedName%2A> 属性。  
  
 如果 `typeName` 不是程序集限定名称，则跳过程序集解析。 可在 Mscorlib.dll 或当前正在执行的程序集的上下文中解析不合格的类型名称，也可以选择在 `typeResolver` 参数中提供程序集。 包括或省略不同类型名称解析的程序集名称的效果在[混合名称解析](#mixed_name_resolution)部分中显示为一个表。  
  
 一般使用说明：  
  
-   如果方法来自未知或不受信任的调用方，请不要将方法传递给 `assemblyResolver` 或 `typeResolver`。 仅使用你提供或者熟悉的方法。  
  
    > [!CAUTION]
    >  使用来自未知或不受信任调用方的方法可能会导致恶意代码特权提升。  
  
-   如果省略 `assemblyResolver` 和/或 `typeResolver` 参数，`throwOnError` 参数的值将传递给执行默认解析的方法。  
  
-   如果 `true``throwOnError`，则当 `typeResolver` 返回 `null`时，此方法将引发 <xref:System.TypeLoadException>，<xref:System.IO.FileNotFoundException> 返回 `assemblyResolver` 时，此方法将引发。`null`  
  
-   此方法不会捕获 `assemblyResolver` 和 `typeResolver`引发的异常。 你负责解析程序方法引发的任何异常。  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a>解析程序集  
 `assemblyResolver` 方法接收一个 <xref:System.Reflection.AssemblyName> 对象，该对象是通过分析 `typeName`中包含的字符串程序集名称生成的。 如果 `typeName` 不包含程序集名称，则不会调用 `assemblyResolver` 并且 `null` 传递到 `typeResolver`。  
  
 如果未提供 `assemblyResolver`，则使用标准程序集探测来定位程序集。 如果提供了 `assemblyResolver`，<xref:System.Type.GetType%2A> 方法不执行标准探测;在这种情况下，您必须确保您的 `assemblyResolver` 可以处理您传递给它的所有程序集。  
  
 如果无法解析程序集，`assemblyResolver` 方法应返回 `null`。 如果 `assemblyResolver` 返回 `null`，则不会调用 `typeResolver`，也不会进行进一步的处理;此外，如果 `true``throwOnError`，则会引发 <xref:System.IO.FileNotFoundException>。  
  
 如果传递到 `assemblyResolver` 的 <xref:System.Reflection.AssemblyName> 是部分名称，则 `null`一个或多个部分。 例如，如果它没有版本，则 `null`<xref:System.Reflection.AssemblyName.Version%2A> 属性。 如果 <xref:System.Reflection.AssemblyName.Version%2A> 属性、<xref:System.Reflection.AssemblyName.CultureInfo%2A> 属性和 <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> 方法全部返回 `null`，则仅提供程序集的简单名称。 `assemblyResolver` 方法可以使用或忽略程序集名称的所有部分。  
  
 对于简单的和程序集限定的类型名称，不同的程序集解析选项的作用在[混合名称解析](#mixed_name_resolution)部分中显示为一个表。  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a>解析类型  
 如果 `typeName` 未指定程序集名称，则始终调用 `typeResolver`。 如果 `typeName` 指定程序集名称，则只有在成功解析程序集名称时才会调用 `typeResolver`。 如果 `assemblyResolver` 或标准程序集探测返回 `null`，则不会调用 `typeResolver`。  
  
 `typeResolver` 方法收到三个参数：  
  
-   要搜索或 `null` 的程序集（如果 `typeName` 不包含程序集名称）。  
  
-   类型的简单名称。 对于嵌套类型，这是最外层的包含类型。 对于泛型类型，这是泛型类型的简单名称。  
  
-   如果要忽略类型名称的大小写，则为 `true` 的布尔值。  
  
 实现确定使用这些参数的方式。 如果 `typeResolver` 方法无法解析该类型，则应返回 `null`。 如果 `typeResolver` 返回 `null` 并且 `throwOnError` `true`，则 <xref:System.Type.GetType%2A> 的此重载将引发 <xref:System.TypeLoadException>。  
  
 对于简单的和程序集限定的类型名称，不同类型解析选项的效果在[混合名称解析](#mixed_name_resolution)部分中显示为一个表。  
  
#### <a name="resolving-nested-types"></a>解析嵌套类型  
 如果 `typeName` 是嵌套类型，则仅将包含类型的最外面的名称传递给 `typeResolver`。 当 `typeResolver` 返回此类型时，<xref:System.Type.GetNestedType%2A> 方法将以递归方式调用，直到最内层的嵌套类型得以解决。  
  
#### <a name="resolving-generic-types"></a>解析泛型类型  
 <xref:System.Type.GetType%2A> 以递归方式调用以解析泛型类型：首先解析泛型类型本身，然后解析其类型参数。 如果类型参数是泛型，则递归调用 <xref:System.Type.GetType%2A> 以解析其类型参数，依此类推。  
  
 提供的 `assemblyResolver` 和 `typeResolver` 的组合必须能够解析此递归的所有级别。 例如，假设提供控制 `MyAssembly`加载的 `assemblyResolver`。 假设要解析泛型类型 `Dictionary<string, MyType>` （`Dictionary(Of String, MyType)` Visual Basic）。 你可能会传递以下泛型类型名称：  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 请注意，`MyType` 是唯一的程序集限定类型参数。 <xref:System.Collections.Generic.Dictionary%602> 和 <xref:System.String> 类的名称不是程序集限定的。 `typeResolver` 必须能够处理程序集或 `null`，因为它将接收 <xref:System.Collections.Generic.Dictionary%602> 和 <xref:System.String>的 `null`。 它可以通过调用采用字符串的 <xref:System.Type.GetType%2A> 方法的重载来处理这种情况，因为两个非限定类型名称都在 Mscorlib.dll 中：  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 不会为字典类型和字符串类型调用 `assemblyResolver` 方法，因为这些类型名称不是程序集限定的。  
  
 现在，假设从 `YourAssembly`中 `YourType`第一个泛型参数类型，而不是 `System.String`：  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 由于此程序集既不是 Mscorlib.dll，也不是当前正在执行的程序集，因此无法解析没有程序集限定名称的 `YourType`。 由于你的 `assemblyResolve` 将以递归方式调用，因此它必须能够处理这种情况。 它不会为除 `MyAssembly`以外的程序集返回 `null`，它现在使用提供的 <xref:System.Reflection.AssemblyName> 对象执行程序集加载。  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 返回到[使用说明](#usage_notes)。  
  
#### <a name="resolving-type-names-with-special-characters"></a>解析包含特殊字符的类型名称  
 某些字符在程序集限定名称中具有特殊含义。 如果简单的类型名称包含这些字符，则当简单名称是程序集限定名称的一部分时，这些字符将导致分析错误。 若要避免分析错误，必须使用反斜杠对特殊字符进行转义，然后才能将程序集限定名称传递给 <xref:System.Type.GetType%2A> 方法。 例如，如果某一类型命名为 `Strange]Type`，则必须将转义字符添加到方括号之前，如下所示： `Strange\]Type`。  
  
> [!NOTE]
>  不能在 Visual Basic 或C#中创建具有此类特殊字符的名称，但可以使用 Microsoft 中间语言（MSIL）或发出动态程序集来创建它们。  
  
 下表显示了类型名称的特殊字符。  
  
|字符|含义|  
|---------------|-------------|  
|`,` （逗号）|程序集限定名称的分隔符。|  
|`[]` （方括号）|作为后缀对，指示数组类型;作为分隔符对，包含泛型参数列表和程序集限定名称。|  
|`&` （与号）|作为后缀，指示类型是引用类型。|  
|`*` （星号）|作为后缀，指示类型是指针类型。|  
|`+` （加号）|嵌套类型的分隔符。|  
|`\` （反斜杠）|转义符。|  
  
 属性（如 <xref:System.Type.AssemblyQualifiedName%2A>）返回正确的转义字符串。 必须将正确转义的字符串传递给 <xref:System.Type.GetType%2A> 方法。 接下来，<xref:System.Type.GetType%2A> 方法将正确的转义名称传递到 `typeResolver` 和默认类型解析方法。 如果需要在 `typeResolver`中将名称与未转义的名称进行比较，则必须删除转义符。  
  
 返回到[使用说明](#usage_notes)。  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a>混合名称解析  
 下表汇总了 `typeName`中类型名称和程序集名称的所有组合 `assemblyResolver`、`typeResolver`和默认名称解析之间的交互：  
  
|类型名称的内容|程序集解析程序方法|类型解析程序方法|结果|  
|---------------------------|------------------------------|--------------------------|------------|  
|类型、程序集|null|null|等效于调用 <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 方法重载。|  
|类型、程序集|规定|null|如果程序集无法解析程序集，则 `assemblyResolver` 返回程序集或返回 `null`。 如果程序集已解析，则 <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 方法重载用于从程序集加载类型;否则，将不会尝试解析该类型。|  
|类型、程序集|null|规定|等效于将程序集名称转换为 <xref:System.Reflection.AssemblyName> 对象，并调用 <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> 方法重载以获取程序集。 如果对程序集进行解析，则将其传递到 `typeResolver`;否则，将不会调用 `typeResolver`，也不会再尝试解析该类型。|  
|类型、程序集|规定|规定|如果程序集无法解析程序集，则 `assemblyResolver` 返回程序集或返回 `null`。 如果对程序集进行解析，则将其传递到 `typeResolver`;否则，将不会调用 `typeResolver`，也不会再尝试解析该类型。|  
|type|提供空值|null|等效于调用 <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 方法重载。 由于未提供程序集名称，因此只会搜索 Mscorlib.dll 和当前正在执行的程序集。 如果提供 `assemblyResolver`，则将其忽略。|  
|type|提供空值|规定|调用 `typeResolver`，并为程序集传递 `null`。 `typeResolver` 可以提供任何程序集中的类型，包括为此目的而加载的程序集。 如果提供 `assemblyResolver`，则将其忽略。|  
|程序集 (assembly)|提供空值|提供空值|引发 <xref:System.IO.FileLoadException>，因为程序集名称被分析为程序集限定的类型名称。 这会导致无效的程序集名称。|  
  
 返回到：[使用说明](#usage_notes)，[解析程序集](#resolving_assemblies)，[解析类型](#resolving_types)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">调用了类初始值设定项，且该项引发了异常。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> 是 <see langword="true" />，且找不到该类型。  
  
或 
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 包含无效字符，例如嵌入的制表符。 
或 
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 为空字符串。  
  
或 
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 表示大小无效的数组类型。  
  
或 
 <paramref name="typeName" /> 表示 <see cref="T:System.TypedReference" /> 的数组。</exception>
        <exception cref="T:System.ArgumentException">当 <paramref name="typeName" /> 解析为类型名称和程序集名称时（例如，当简单类型名称包含未转义的特殊字符时），发生错误。  
  
或 
 <paramref name="throwOnError" /> 是 <see langword="true" />，且 <paramref name="typeName" /> 包含无效的语法（例如 "MyType[,*,]"）。  
  
或 
 <paramref name="typeName" /> 表示将指针类型、<see langword="ByRef" /> 类型或 <see cref="T:System.Void" /> 作为其类型参数之一的泛型类型。  
  
或 
 <paramref name="typeName" /> 表示具有错误的类型参数数目的泛型类型。  
  
或 
 <paramref name="typeName" /> 表示泛型类型，并且其类型参数之一不满足相应类型参数的约束。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> 的值为 <see langword="true" />，且未找到程序集或程序集的某个依赖项。</exception>
        <exception cref="T:System.IO.FileLoadException">找到了程序集或其依赖项之一，但无法加载它们。  
  
或 
 <paramref name="typeName" /> 包含无效的程序集名称。  
  
或 
 <paramref name="typeName" /> 是一个不含类型名称的有效程序集名称。</exception>
        <exception cref="T:System.BadImageFormatException">程序集或其依赖项之一无效。  
  
 或  
  
 此程序集使用高于当前所加载版本的公共语言运行时版本编译而成。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member GetTypeArray : obj[] -&gt; Type[]" Usage="System.Type.GetTypeArray args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="args">要确定其类型的对象数组。</param>
        <summary>获取指定数组中对象的类型。</summary>
        <returns>表示 <see cref="T:System.Type" /> 中相应元素的类型的 <paramref name="args" /> 对象数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Type.GetTypeArray%2A> 方法列出数组元素的类型。  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="args" /> 为 <see langword="null" />。  
  
或 
<paramref name="args" /> 的其中一个或多个元素为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">调用类初始值设定项，并且至少一个引发异常。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetTypeCode : Type -&gt; TypeCode" Usage="System.Type.GetTypeCode type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">要获取其基础代码的类型。</param>
        <summary>获取指定 <see cref="T:System.Type" /> 的基础类型代码。</summary>
        <returns>如果 <see cref="F:System.TypeCode.Empty" /> 为 <paramref name="type" />，则为基础类型代码或 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当从 <xref:System.Type>继承时，可以通过重写 <xref:System.Type.GetTypeCodeImpl%2A> 方法来更改此方法的行为。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.TypeCode> 枚举。 在 `WriteObjectInfo` 方法中的决策块中，将检查 <xref:System.Object> 参数的 <xref:System.TypeCode>，并将相应的消息写入控制台。  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCodeImpl : unit -&gt; TypeCode&#xA;override this.GetTypeCodeImpl : unit -&gt; TypeCode" Usage="type.GetTypeCodeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此 <see cref="T:System.Type" /> 实例的基础类型代码。</summary>
        <returns>基础类型的类型代码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法提供 `static` （在中C#）或 `Shared` （Visual Basic） <xref:System.Type.GetTypeCode%28System.Type%29> 方法的实现。 当从 <xref:System.Type>继承时，可以重写此方法以提供您自己的 <xref:System.Type.GetTypeCode%2A>实现。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取与指定类标识符 (CLSID) 关联的类型。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid -&gt; Type" Usage="System.Type.GetTypeFromCLSID clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid">要获取的类型的 CLSID。</param>
        <summary>获取与指定类标识符 (CLSID) 关联的类型。</summary>
        <returns><see langword="System.__ComObject" />，无论 CLSID 是否有效。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你知道 COM 对象的类标识符（CLSID）时，<xref:System.Type.GetTypeFromCLSID%2A> 方法支持对 .NET Framework 应用程序的非托管 COM 对象进行后期绑定访问。  COM 类的类标识符是在注册表的 HKEY_CLASSES_ROOT\CLSID 项中定义的。 可以检索 <xref:System.Type.IsCOMObject%2A> 属性的值，以确定此方法返回的类型是否为 COM 对象。  
  
> [!TIP]
>  可以调用 <xref:System.Type.GetTypeFromProgID%2A> 方法，以便对你知道其编程标识符（ProgID）的 COM 对象进行后期绑定访问。  
  
 从其 CLSID 实例化非托管 COM 对象的过程分为两个步骤：  
  
1.  通过调用 <xref:System.Type.GetTypeFromCLSID%2A> 方法获取表示与 CLSID 对应的`__ComObject` 的 <xref:System.Type> 对象。  
  
2.  调用 <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> 方法来实例化 COM 对象。  
  
 有关说明，请参阅示例。  
  
 <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> 重载会忽略根据 `clsid` 参数实例化 <xref:System.Type> 对象时可能发生的任何异常。 请注意，如果在注册表中找不到 `clsid`，则不会引发异常。  
  
   
  
## Examples  
 下面的示例使用 Microsoft Word[应用程序对象](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word)的 CLSID 来检索表示 Microsoft word 应用程序的 COM 类型。 然后，它通过调用 <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 方法来实例化该类型，并通过调用[应用程序 Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word)方法关闭该类型。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>此方法用于处理 COM 对象，而不是与 .NET Framework 对象一起使用。 所有托管对象（包括对 COM 可见的对象（即 <see langword="true" />其 <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> 属性）都具有 <see cref="P:System.Type.GUID" /> 属性返回的 GUID。 尽管方法返回与 .NET Framework 对象的 GUID 相对应的 <see cref="T:System.Type" /> 对象，但你不能通过调用 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 方法来使用该 <see cref="T:System.Type" /> 对象创建类型实例，如下面的示例所示。  
  
[！ code-csharp[GetTypeFromCLSID # 11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)][！ code-vb[GetTypeFromCLSID # 11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
相反，<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> 应仅用于检索非托管 COM 对象的 GUID，并且传递到 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 方法的生成的 <see cref="T:System.Type" /> 对象必须表示非托管 COM 对象。</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid">要获取的类型的 CLSID。</param>
        <param name="throwOnError"><see langword="true" /> 将引发所发生的任何异常。  
  
或 
 <see langword="false" /> 将忽略所发生的任何异常。</param>
        <summary>获取与指定类标识符 (CLSID) 关联的类型，指定在加载该类型时如果发生错误是否引发异常。</summary>
        <returns><see langword="System.__ComObject" />，无论 CLSID 是否有效。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你知道 COM 对象的类标识符（CLSID）时，<xref:System.Type.GetTypeFromCLSID%2A> 方法支持对 .NET Framework 应用程序的非托管 COM 对象进行后期绑定访问。  COM 类的类标识符是在注册表的 HKEY_CLASSES_ROOT\CLSID 项中定义的。 可以检索 <xref:System.Type.IsCOMObject%2A> 属性的值，以确定此方法返回的类型是否为 COM 对象。  
  
> [!TIP]
>  可以调用 <xref:System.Type.GetTypeFromProgID%2A> 方法，以便对你知道其编程标识符（ProgID）的 COM 对象进行后期绑定访问。  
  
 从其 CLSID 实例化非托管 COM 对象的过程分为两个步骤：  
  
1.  通过调用 <xref:System.Type.GetTypeFromCLSID%2A> 方法获取表示与 CLSID 对应的 `__ComObject` 的 <xref:System.Type> 对象。  
  
2.  调用 <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> 方法来实例化 COM 对象。  
  
 有关说明，请参阅示例。  
  
 指定 `throwOnError`的 `true` 时，将会引发 <xref:System.OutOfMemoryException> 异常，但未注册的 Clsid 将不会失败。  
  
   
  
## Examples  
 下面的示例使用 Microsoft Word[应用程序对象](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word)的 CLSID 来检索表示 Microsoft word 应用程序的 COM 类型。 然后，它通过调用 <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 方法来实例化该类型，并通过调用[应用程序 Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word)方法关闭该类型。 如果在加载该类型时发生错误，则会引发异常。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>此方法用于处理 COM 对象，而不是与 .NET Framework 对象一起使用。 所有托管对象（包括对 COM 可见的对象（即 <see langword="true" />其 <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> 属性）都具有 <see cref="P:System.Type.GUID" /> 属性返回的 GUID。 尽管方法返回与 .NET Framework 对象的 GUID 相对应的 <see cref="T:System.Type" /> 对象，但你不能通过调用 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 方法来使用该 <see cref="T:System.Type" /> 对象创建类型实例，如下面的示例所示。  
  
[！ code-csharp[GetTypeFromCLSID # 11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)][！ code-vb[GetTypeFromCLSID # 11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
相反，<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> 应仅用于检索非托管 COM 对象的 GUID，并且传递到 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 方法的生成的 <see cref="T:System.Type" /> 对象必须表示非托管 COM 对象。</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid">要获取的类型的 CLSID。</param>
        <param name="server">用于从中加载该类型的服务器。 如果服务器名称为 <see langword="null" />，则此方法会自动恢复到本地计算机上。</param>
        <summary>从指定服务器获取与指定类标识符 (CLSID) 关联的类型。</summary>
        <returns><see langword="System.__ComObject" />，无论 CLSID 是否有效。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你知道 COM 对象的类标识符（CLSID）时，<xref:System.Type.GetTypeFromCLSID%2A> 方法支持对 .NET Framework 应用程序的非托管 COM 对象进行后期绑定访问。  COM 类的类标识符是在注册表的 HKEY_CLASSES_ROOT\CLSID 项中定义的。 可以检索 <xref:System.Type.IsCOMObject%2A> 属性的值，以确定此方法返回的类型是否为 COM 对象。  
  
> [!TIP]
>  可以调用 <xref:System.Type.GetTypeFromProgID%2A> 方法，以便对你知道其编程标识符（ProgID）的 COM 对象进行后期绑定访问。  
  
 从其 CLSID 实例化非托管 COM 对象的过程分为两个步骤：  
  
1.  通过调用 <xref:System.Type.GetTypeFromCLSID%2A> 方法获取表示与 CLSID 对应的 `__ComObject` 的 <xref:System.Type> 对象。  
  
2.  调用 <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> 方法来实例化 COM 对象。  
  
   
  
## Examples  
 下面的示例使用 Microsoft Word[应用程序对象](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word)的 CLSID 从名为 computer17.central.contoso.com 的服务器中检索代表 Microsoft Word 应用程序的 COM 类型。 然后，它通过调用 <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 方法来实例化该类型，并通过调用[应用程序 Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word)方法关闭该类型。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>此方法用于处理 COM 对象，而不是与 .NET Framework 对象一起使用。 所有托管对象（包括对 COM 可见的对象（即 <see langword="true" />其 <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> 属性）都具有 <see cref="P:System.Type.GUID" /> 属性返回的 GUID。 尽管方法返回与 .NET Framework 对象的 GUID 相对应的 <see cref="T:System.Type" /> 对象，但你不能通过调用 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 方法来使用该 <see cref="T:System.Type" /> 对象创建类型实例，如下面的示例所示。  
  
[！ code-csharp[GetTypeFromCLSID # 11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)][！ code-vb[GetTypeFromCLSID # 11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
相反，<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> 应仅用于检索非托管 COM 对象的 GUID，并且传递到 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 方法的生成的 <see cref="T:System.Type" /> 对象必须表示非托管 COM 对象。</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid">要获取的类型的 CLSID。</param>
        <param name="server">用于从中加载该类型的服务器。 如果服务器名称为 <see langword="null" />，则此方法会自动恢复到本地计算机上。</param>
        <param name="throwOnError"><see langword="true" /> 将引发所发生的任何异常。  
  
或 
 <see langword="false" /> 将忽略所发生的任何异常。</param>
        <summary>从指定服务器获取与指定类标识符 (CLSID) 关联的类型，指定在加载该类型时如果发生错误是否引发异常。</summary>
        <returns><see langword="System.__ComObject" />，无论 CLSID 是否有效。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你知道 COM 对象的类标识符（CLSID）时，<xref:System.Type.GetTypeFromCLSID%2A> 方法支持对 .NET Framework 应用程序的非托管 COM 对象进行后期绑定访问。  COM 类的类标识符是在注册表的 HKEY_CLASSES_ROOT\CLSID 项中定义的。 可以检索 <xref:System.Type.IsCOMObject%2A> 属性的值，以确定此方法返回的类型是否为 COM 对象。  
  
> [!TIP]
>  可以调用 <xref:System.Type.GetTypeFromProgID%2A> 方法，以便对你知道其编程标识符（ProgID）的 COM 对象进行后期绑定访问。  
  
 从其 CLSID 实例化非托管 COM 对象的过程分为两个步骤：  
  
1.  通过调用 <xref:System.Type.GetTypeFromCLSID%2A> 方法获取表示与 CLSID 对应的 `__ComObject` 的 <xref:System.Type> 对象。  
  
2.  调用 <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> 方法来实例化 COM 对象。  
  
 指定 `throwOnError`的 `true` 时，将会引发 <xref:System.OutOfMemoryException> 异常，但未注册的 Clsid 将不会失败。  
  
   
  
## Examples  
 下面的示例使用 Microsoft Word[应用程序对象](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word)的 CLSID 从名为 computer17.central.contoso.com 的服务器中检索代表 Microsoft Word 应用程序的 COM 类型。 然后，它通过调用 <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 方法来实例化该类型，并通过调用[应用程序 Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word)方法关闭该类型。 如果在加载该类型时发生错误，则会引发异常。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>此方法用于处理 COM 对象，而不是与 .NET Framework 对象一起使用。 所有托管对象（包括对 COM 可见的对象（即 <see langword="true" />其 <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> 属性）都具有 <see cref="P:System.Type.GUID" /> 属性返回的 GUID。 尽管 <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> 方法返回对应于特定托管对象的 GUID 的 <see cref="T:System.Type" /> 对象，但你不能通过调用 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 方法来使用该 <see cref="T:System.Type" /> 对象创建类型实例，如下面的示例所示。  
  
[！ code-csharp[GetTypeFromCLSID # 11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)][！ code-vb[GetTypeFromCLSID # 11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
相反，<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> 应仅用于检索非托管 COM 对象的 GUID，并且传递到 <see cref="M:System.Activator.CreateInstance(System.Type)" /> 方法的生成的 <see cref="T:System.Type" /> 对象必须表示非托管 COM 对象。</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromHandle : RuntimeTypeHandle -&gt; Type" Usage="System.Type.GetTypeFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">引用类型的对象。</param>
        <summary>获取由指定类型句柄引用的类型。</summary>
        <returns>如果 <see cref="T:System.RuntimeTypeHandle" /> 的 <see langword="null" /> 属性为 <see cref="P:System.RuntimeTypeHandle.Value" />，则为由指定的 <paramref name="handle" /> 引用的类型，或者为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 句柄仅在获取它们的应用程序域中有效。  
  
   
  
## Examples  
 下面的示例使用 <xref:System.Type.GetTypeFromHandle%2A> 方法从 <xref:System.Type.GetTypeHandle%2A> 方法提供的 <xref:System.RuntimeTypeHandle> 获取 <xref:System.Type> 对象。  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">调用了类初始值设定项，且该项引发了异常。</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取与指定程序标识符 (ProgID) 关联的类型。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string -&gt; Type" Usage="System.Type.GetTypeFromProgID progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID">要获取的类型的 ProgID。</param>
        <summary>获取与指定程序标识符 (ProgID) 关联的类型，如果在加载 <see cref="T:System.Type" /> 时遇到错误，则返回空值。</summary>
        <returns>如果 <paramref name="progID" /> 是注册表中的有效项，并且有与之关联的类型，则为与指定 ProgID 关联的类型；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此方法是为了支持 COM。 Progid 不在 Microsoft .NET 框架中使用，因为它们已被命名空间的概念取代。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要对直接调用方的完全信任。 部分受信任的或透明的代码不能使用此成员。</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID">要获取的类型的 ProgID。</param>
        <param name="throwOnError"><see langword="true" /> 将引发所发生的任何异常。  
  
或 
 <see langword="false" /> 将忽略所发生的任何异常。</param>
        <summary>获取与指定程序标识符 (ProgID) 关联的类型，指定如果在加载该类型时发生错误是否引发异常。</summary>
        <returns>如果 <paramref name="progID" /> 是注册表中的有效项且有与之关联的类型，则为与指定程序标识符 (ProgID) 关联的类型；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此方法是为了支持 COM。 程序 Id 未在 Microsoft .NET 框架中使用，因为它们已被命名空间的概念取代。  
  
   
  
## Examples  
 下面的示例通过传递 ProgID 来检索一个类型，并指定当 ProgID 无效时是否引发异常。 然后，该示例显示与 ProgID 相关的 ClassID 以及任何适用的异常消息。  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">未注册指定的 ProgID。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要对直接调用方的完全信任。 部分受信任的或透明的代码不能使用此成员。</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID">要获取的类型的 ProgID。</param>
        <param name="server">用于从中加载该类型的服务器。 如果服务器名称为 <see langword="null" />，则此方法会自动恢复到本地计算机上。</param>
        <summary>从指定服务器获取与指定程序标识符 (progID) 关联的类型，如果在加载该类型时遇到错误则返回空值。</summary>
        <returns>如果 <paramref name="progID" /> 是注册表中的有效项且有与之关联的类型，则为与指定程序标识符 (ProgID) 关联的类型；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此方法是为了支持 COM。 程序 Id 未在 Microsoft .NET 框架中使用，因为它们已被命名空间的概念取代。  
  
   
  
## Examples  
 下面的示例通过传递 ProgID 和服务器名称来检索类型。 然后，该示例显示与 ProgID 相关的 ClassID，或如果 ProgID 或服务器名称无效，则会引发异常。  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="prodID" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要对直接调用方的完全信任。 部分受信任的或透明的代码不能使用此成员。</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID">要获取的 <see cref="T:System.Type" /> 的 progID。</param>
        <param name="server">用于从中加载该类型的服务器。 如果服务器名称为 <see langword="null" />，则此方法会自动恢复到本地计算机上。</param>
        <param name="throwOnError"><see langword="true" /> 将引发所发生的任何异常。  
  
或 
 <see langword="false" /> 将忽略所发生的任何异常。</param>
        <summary>从指定服务器获取与指定程序标识符 (progID) 关联的类型，指定如果在加载该类型时发生错误是否引发异常。</summary>
        <returns>如果 <paramref name="progID" /> 是注册表中的有效项且有与之关联的类型，则为与指定程序标识符 (ProgID) 关联的类型；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此方法是为了支持 COM。 程序 Id 未在 Microsoft .NET 框架中使用，因为它们已被命名空间的概念取代。  
  
   
  
## Examples  
 下面的示例通过传递 ProgID 和服务器名称来检索类型。 然后，该示例显示与 ProgID 相关的 ClassID，并指定当 ProgID 或服务器名称无效时是否引发异常。  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">未注册指定的 progID。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要对直接调用方的完全信任。 部分受信任的或透明的代码不能使用此成员。</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetTypeHandle : obj -&gt; RuntimeTypeHandle" Usage="System.Type.GetTypeHandle o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="o">要获取类型句柄的对象。</param>
        <summary>获取指定对象的 <see cref="T:System.Type" /> 的句柄。</summary>
        <returns>指定 <see cref="T:System.Type" /> 的 <see cref="T:System.Object" /> 的句柄。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 句柄仅在获取它们的应用程序域中有效。  
  
   
  
## Examples  
 下面的示例定义类 `MyClass1`、获取其实例，并检索对象的运行时句柄。  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="o" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Type.GUID" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与 <see cref="T:System.Type" />关联的 GUID。</summary>
        <value>获取与 <see cref="T:System.Type" /> 关联的 GUID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GUID 与使用 <xref:System.Runtime.InteropServices.GuidAttribute> 特性的类型相关联。  
  
   
  
## Examples  
 下面的示例使用公共方法创建类 `MyClass1`，创建与 `MyClass1`对应的 `Type` 对象，并使用 `GUID` 类的 `Type` 属性获取 <xref:System.Guid> 结构。  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasElementType : bool" Usage="System.Type.HasElementType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示当前 <see cref="T:System.Type" /> 是包含还是引用另一类型，即当前 <see cref="T:System.Type" /> 是数组、指针还是通过引用传递。</summary>
        <value>如果 <see langword="true" /> 为数组、指针或按引用传递，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例如，键入 GetType （"Int32 []"）。HasElementType 返回 `true`，但类型为 GetType （"Int32"）。HasElementType 返回 `false`。 HasElementType 还返回 "Int32 *" 和 "Int32 &" `true`。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型类型或泛型方法的定义中的类型参数，则此属性始终返回 `false`。  
  
   
  
## Examples  
 下面的示例根据对象是数组、引用类型还是指针返回 `true` 或 `false`。  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member HasElementTypeImpl : unit -&gt; bool" Usage="type.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中重写时，实现 <see cref="P:System.Type.HasElementType" /> 属性，确定当前 <see cref="T:System.Type" /> 是否包含另一类型或对其引用；即，当前 <see cref="T:System.Type" /> 是否是数组、指针或由引用传递。</summary>
        <returns>如果 <see langword="true" /> 为数组、指针或按引用传递，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例如，键入 GetType （"Int32 []"）。HasElementTypeImpl 返回 `true`，但类型为 GetType （"Int32"）。HasElementTypeImpl 返回 `false`。 HasElementTypeImpl 还返回 "Int32 *" 和 "Int32 &" `true`。  
  
   
  
## Examples  
 下面的示例定义了类 `MyTypeDelegator`，该类将重写 `HasElementTypeImpl` 方法。 主类检查 `HasElementType` 属性，并显示元素类型。  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>调用当前 <see cref="T:System.Type" /> 的特定成员。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">字符串，它包含要调用的构造函数、方法、属性或字段成员的名称。  
  
或 
空字符串 ("")，表示调用默认成员。  
  
或 
对于 <see langword="IDispatch" /> 成员，则为一个表示 DispID 的字符串，例如"[DispID=3]"。</param>
        <param name="invokeAttr">枚举值的按位组合，这些值指定如何进行搜索。 访问可以是 <see langword="BindingFlags" /> 之一，如 <see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" /> 和 <see langword="GetField" /> 等。 查找类型无需指定。 如果省略查找的类型，则将使用 <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。  
  
或 
要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。 请注意，为了成功地使用变量参数来调用方法重载，可能必须显式定义 <see cref="T:System.Reflection.Binder" /> 对象。</param>
        <param name="target">对其调用指定成员的对象。</param>
        <param name="args">包含传递给要调用的成员的参数的数组。</param>
        <summary>使用指定的绑定约束并匹配指定的参数列表，调用指定成员。</summary>
        <returns>一个对象，表示被调用成员的返回值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  不能使用 <xref:System.Type.InvokeMember%2A> 调用泛型方法。  
  
 以下 <xref:System.Reflection.BindingFlags> 筛选器标志可用于定义要包括在搜索中的成员：  
  
-   指定 `BindingFlags.Public` 以在搜索中包括公共成员。  
  
-   指定 `BindingFlags.NonPublic` 以包含搜索中的非公共成员（即，私有和受保护成员）。  
  
-   指定 `BindingFlags.FlattenHierarchy` 以在层次结构中包含静态成员。  
  
 以下 <xref:System.Reflection.BindingFlags> 修饰符标志可用于更改搜索的工作方式：  
  
-   `BindingFlags.IgnoreCase` 忽略 `name`的大小写。  
  
-   `BindingFlags.DeclaredOnly` 仅搜索 <xref:System.Type>上声明的成员，而不搜索简单继承的成员。  
  
 以下 <xref:System.Reflection.BindingFlags> 调用标志可用于表示要对成员执行的操作：  
  
-   `CreateInstance` 调用构造函数。 `name` 将被忽略。 与其他调用标志无效。  
  
-   `InvokeMethod` 调用方法，而不是构造函数或类型初始值设定项。 与 `SetField` 或 `SetProperty`无效。 如果 `InvokeMethod` 单独指定，`BindingFlags.Public`、`BindingFlags.Instance`和 `BindingFlags.Static` 将自动包括在内。  
  
-   `GetField` 获取字段的值。 与 `SetField`无效。  
  
-   `SetField` 设置字段的值。 与 `GetField`无效。  
  
-   `GetProperty` 获取属性。 与 `SetProperty`无效。  
  
-   `SetProperty` 设置属性。 与 `GetProperty`无效。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果以下两个条件均为 true，则将调用方法：  
  
-   方法声明中的参数数目等于 `args` 数组中的参数个数（除非在成员上定义了默认参数，并且指定了 `BindingFlags.OptionalParamBinding`）。  
  
-   联编程序可以将每个参数的类型转换为参数的类型。  
  
 此联编程序将查找所有匹配的方法。 这些方法基于所请求的绑定类型（<xref:System.Reflection.BindingFlags> 值 `InvokeMethod`、`GetProperty`，等等）。 方法集按名称、参数数目和在联编程序中定义的一组搜索修饰符进行筛选。  
  
 选择方法后，将调用该方法。 此时将检查可访问性。 搜索可根据与方法关联的可访问性属性控制要搜索的方法集。 <xref:System.Reflection.Binder> 类的 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> 方法负责选择要调用的方法。 默认联编程序将选择最特定的匹配项。  
  
 完全受信任的代码将忽略访问限制;也就是说，只要代码完全受信任，就可以通过 <xref:System.Reflection> 访问和调用私有构造函数、方法、字段和属性。  
  
 通过指定 <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>，可以使用 `Type.InvokeMember` 将字段设置为特定值。 例如，如果想要在类 C 上设置名为 F 的公共实例字段，并且 F 是 `String`，则可以使用以下代码：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 如果 F 是 `String[]`，则可以使用以下代码：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 这会将 F 字段初始化为这个新的数组。 你还可以使用 `Type.InvokeMember` 通过使用如下所示的代码提供值的索引，然后再设置下一个值，来设置数组中的位置：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 这会将 F 包含的数组中的字符串 "z" 更改为字符串 "b"。  
  
 调用 `IDispatch` 成员时，可以使用字符串格式 "[DispID = # #]" 来指定 DispID 而不是成员名称。 例如，如果 MyComMethod 为3，则可以指定字符串 "[DispID = 3]" 而不是 "MyComMethod"。 DispID 调用成员比按名称查找成员的速度更快。 在复杂的聚合方案中，DispID 有时是调用所需成员的唯一方法。  
  
> [!NOTE]
>  从 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]开始，此方法可用于访问非公共成员（如果已向调用方授予了 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 标志的 <xref:System.Security.Permissions.ReflectionPermission>）以及非公共成员的授予集是否限制为调用方的授予集或其中的一个子集。 （请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。）  
>   
>  若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
   
  
## Examples  
 下面的示例使用 `InvokeMember` 访问类型的成员。  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" /> 不包含 <see langword="CreateInstance" />，并且 <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="invokeAttr" /> 不是有效的 <see cref="T:System.Reflection.BindingFlags" /> 属性。  
  
或 
 <paramref name="invokeAttr" /> 不包含以下某个绑定标志：<see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" />。  
  
或 
 <paramref name="invokeAttr" /> 包含 <see langword="CreateInstance" /> 与 <see langword="InvokeMethod" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" /> 的组合。  
  
或 
 <paramref name="invokeAttr" /> 同时包含 <see langword="GetField" /> 和 <see langword="SetField" />。  
  
或 
 <paramref name="invokeAttr" /> 同时包含 <see langword="GetProperty" /> 和 <see langword="SetProperty" />。  
  
或 
 <paramref name="invokeAttr" /> 包含 <see langword="InvokeMethod" /> 与 <see langword="SetField" /> 或 <see langword="SetProperty" /> 的组合。  
  
或 
 <paramref name="invokeAttr" /> 包含 <see langword="SetField" />，并且 <paramref name="args" /> 具有多个元素。  
  
或 
对 COM 对象调用了此方法，但以下绑定标志中有一个未传入：<see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" /> 或 <see langword="BindingFlags.PutRefDispProperty" />。  
  
或 
其中一个命名参数数组包含一个值为 <see langword="null" /> 的字符串。</exception>
        <exception cref="T:System.MethodAccessException">指定的成员是类初始值设定项。</exception>
        <exception cref="T:System.MissingFieldException">找不到此字段或属性。</exception>
        <exception cref="T:System.MissingMethodException">找不到与 <paramref name="args" /> 中的参数匹配的方法。  
  
或 
当前 <see cref="T:System.Type" /> 对象表示包含开放类型参数的类型，也就是说，<see cref="P:System.Type.ContainsGenericParameters" /> 将返回 <see langword="true" />。</exception>
        <exception cref="T:System.Reflection.TargetException">不能在 <paramref name="target" /> 上调用指定的成员。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">多个方法与绑定条件匹配。</exception>
        <exception cref="T:System.NotSupportedException">.NET Compact Framework 当前不支持此方法。</exception>
        <exception cref="T:System.InvalidOperationException">由 <paramref name="name" /> 表示的方法具有一个或多个未指定的泛型类型参数。 也就是说，此方法的 <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> 属性将返回 <see langword="true" />。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用于访问非公共成员，而不考虑其授予集。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">调用非托管代码。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, culture)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, culture)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">字符串，它包含要调用的构造函数、方法、属性或字段成员的名称。  
  
或 
空字符串 ("")，表示调用默认成员。  
  
或 
对于 <see langword="IDispatch" /> 成员，则为一个表示 DispID 的字符串，例如"[DispID=3]"。</param>
        <param name="invokeAttr">枚举值的按位组合，这些值指定如何进行搜索。 访问可以是 <see langword="BindingFlags" /> 之一，如 <see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" /> 和 <see langword="GetField" /> 等。 查找类型无需指定。 如果省略查找的类型，则将使用 <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。  
  
或 
要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。 请注意，为了成功地使用变量参数来调用方法重载，可能必须显式定义 <see cref="T:System.Reflection.Binder" /> 对象。</param>
        <param name="target">对其调用指定成员的对象。</param>
        <param name="args">包含传递给要调用的成员的参数的数组。</param>
        <param name="culture">表示要使用的全局化区域设置的对象，它对区域设置特定的转换可能是必需的，比如将数字 <see cref="T:System.String" /> 转换为 <see cref="T:System.Double" />。  
  
或 
要使用当前线程的 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="T:System.Globalization.CultureInfo" />）。</param>
        <summary>使用指定的绑定约束和匹配的指定参数列表及区域性来调用指定成员。</summary>
        <returns>一个对象，表示被调用成员的返回值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管默认联编程序不处理 <xref:System.Globalization.CultureInfo> （`culture` 参数），但你可以使用 abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> 类编写处理 `culture`的自定义联编程序。  
  
> [!NOTE]
>  不能使用 <xref:System.Type.InvokeMember%2A> 调用泛型方法。  
  
 以下 <xref:System.Reflection.BindingFlags> 筛选器标志可用于定义要包括在搜索中的成员：  
  
-   指定 `BindingFlags.Public` 以在搜索中包括公共成员。  
  
-   指定 `BindingFlags.NonPublic` 以在搜索中包括非公共成员（即，私有成员、内部成员和受保护成员）。  
  
-   指定 `BindingFlags.FlattenHierarchy` 以在层次结构中包含静态成员。  
  
 以下 <xref:System.Reflection.BindingFlags> 修饰符标志可用于更改搜索的工作方式：  
  
-   `BindingFlags.IgnoreCase` 忽略 `name`的大小写。  
  
-   `BindingFlags.DeclaredOnly` 仅搜索 <xref:System.Type>上声明的成员，而不搜索简单继承的成员。  
  
 以下 <xref:System.Reflection.BindingFlags> 调用标志可用于表示要对成员执行的操作：  
  
-   `CreateInstance` 调用构造函数。 `name` 将被忽略。 与其他调用标志无效。  
  
-   `InvokeMethod` 调用方法，而不是构造函数或类型初始值设定项。 与 `SetField` 或 `SetProperty`无效。 如果 `InvokeMethod` 单独指定，`BindingFlags.Public`、`BindingFlags.Instance`和 `BindingFlags.Static` 将自动包括在内。  
  
-   `GetField` 获取字段的值。 与 `SetField`无效。  
  
-   `SetField` 设置字段的值。 与 `GetField`无效。  
  
-   `GetProperty` 获取属性。 与 `SetProperty`无效。  
  
-   `SetProperty` 设置属性。 与 `GetProperty`无效。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果以下两个条件均为 true，则将调用方法：  
  
-   方法声明中的参数数目等于 `args` 数组中的参数个数（除非在成员上定义了默认参数，并且指定了 `BindingFlags.OptionalParamBinding`）。  
  
-   联编程序可以将每个参数的类型转换为参数的类型。  
  
 此联编程序将查找所有匹配的方法。 这些方法基于所请求的绑定类型（<xref:System.Reflection.BindingFlags> 值 `InvokeMethod`、`GetProperty`，等等）。 方法集按名称、参数数目和在联编程序中定义的一组搜索修饰符进行筛选。  
  
 选择方法后，将调用该方法。 此时将检查可访问性。 搜索可根据与方法关联的可访问性属性控制要搜索的方法集。 <xref:System.Reflection.Binder> 类的 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> 方法负责选择要调用的方法。 默认联编程序将选择最特定的匹配项。  
  
 完全受信任的代码将忽略访问限制;也就是说，只要代码完全受信任，就可以通过反射访问和调用私有构造函数、方法、字段和属性。  
  
 通过指定 <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>，可以使用 `Type.InvokeMember` 将字段设置为特定值。 例如，如果想要在类 C 上设置名为 F 的公共实例字段，并且 F 是 `String` 可以使用如下代码：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 如果 F 是 `String[]`，则可以使用以下代码：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 这会将 F 字段初始化为这个新的数组。 你还可以使用 `Type.InvokeMember` 通过使用如下所示的代码提供值的索引，然后再设置下一个值，来设置数组中的位置：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 这会将 F 包含的数组中的字符串 "z" 更改为字符串 "b"。  
  
 调用 `IDispatch` 成员时，可以使用字符串格式 "[DispID = # #]" 来指定 DispID 而不是成员名称。 例如，如果 MyComMethod 为3，则可以指定字符串 "[DispID = 3]" 而不是 "MyComMethod"。 DispID 调用成员比按名称查找成员的速度更快。 在复杂的聚合方案中，DispID 有时是调用所需成员的唯一方法。  
  
> [!NOTE]
>  从 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]开始，此方法可用于访问非公共成员（如果已向调用方授予了 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 标志的 <xref:System.Security.Permissions.ReflectionPermission>）以及非公共成员的授予集是否限制为调用方的授予集或其中的一个子集。 （请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。）  
>   
>  若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" /> 不包含 <see langword="CreateInstance" />，并且 <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="invokeAttr" /> 不是有效的 <see cref="T:System.Reflection.BindingFlags" /> 属性。  
  
或 
 <paramref name="invokeAttr" /> 不包含以下某个绑定标志：<see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" />。  
  
或 
 <paramref name="invokeAttr" /> 包含 <see langword="CreateInstance" /> 与 <see langword="InvokeMethod" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" /> 的组合。  
  
或 
 <paramref name="invokeAttr" /> 同时包含 <see langword="GetField" /> 和 <see langword="SetField" />。  
  
或 
 <paramref name="invokeAttr" /> 同时包含 <see langword="GetProperty" /> 和 <see langword="SetProperty" />。  
  
或 
 <paramref name="invokeAttr" /> 包含 <see langword="InvokeMethod" /> 与 <see langword="SetField" /> 或 <see langword="SetProperty" /> 的组合。  
  
或 
 <paramref name="invokeAttr" /> 包含 <see langword="SetField" />，并且 <paramref name="args" /> 具有多个元素。  
  
或 
对 COM 对象调用了此方法，但以下绑定标志中有一个未传入：<see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" /> 或 <see langword="BindingFlags.PutRefDispProperty" />。  
  
或 
其中一个命名参数数组包含一个值为 <see langword="null" /> 的字符串。</exception>
        <exception cref="T:System.MethodAccessException">指定的成员是类初始值设定项。</exception>
        <exception cref="T:System.MissingFieldException">找不到此字段或属性。</exception>
        <exception cref="T:System.MissingMethodException">找不到与 <paramref name="args" /> 中的参数匹配的方法。  
  
或 
当前 <see cref="T:System.Type" /> 对象表示包含开放类型参数的类型，也就是说，<see cref="P:System.Type.ContainsGenericParameters" /> 将返回 <see langword="true" />。</exception>
        <exception cref="T:System.Reflection.TargetException">不能在 <paramref name="target" /> 上调用指定的成员。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">多个方法与绑定条件匹配。</exception>
        <exception cref="T:System.InvalidOperationException">由 <paramref name="name" /> 表示的方法具有一个或多个未指定的泛型类型参数。 也就是说，此方法的 <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> 属性将返回 <see langword="true" />。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用于访问非公共成员，而不考虑其授予集。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">调用非托管代码。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="namedParameters" Type="System.String[]" Index="7" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">字符串，它包含要调用的构造函数、方法、属性或字段成员的名称。  
  
或 
空字符串 ("")，表示调用默认成员。  
  
或 
对于 <see langword="IDispatch" /> 成员，则为一个表示 DispID 的字符串，例如"[DispID=3]"。</param>
        <param name="invokeAttr">枚举值的按位组合，这些值指定如何进行搜索。 访问可以是 <see langword="BindingFlags" /> 之一，如 <see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" /> 和 <see langword="GetField" /> 等。 查找类型无需指定。 如果省略查找的类型，则将使用 <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。  
  
或 
要使用 <see cref="P:System.Type.DefaultBinder" /> 的空引用（在 Visual Basic 中为 Nothing）。 请注意，为了成功地使用变量参数来调用方法重载，可能必须显式定义 <see cref="T:System.Reflection.Binder" /> 对象。</param>
        <param name="target">对其调用指定成员的对象。</param>
        <param name="args">包含传递给要调用的成员的参数的数组。</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <paramref name="args" /> 数组中的相应元素关联的特性。 参数的关联的属性存储在成员的签名中。  
  
只有在调用 COM 组件时，默认联编程序才处理此参数。</param>
        <param name="culture">表示要使用的全局化区域设置的 <see cref="T:System.Globalization.CultureInfo" /> 对象，它对区域设置特定的转换可能是必需的，比如将数字 String 转换为 Double。  
  
或 
要使用当前线程的 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="T:System.Globalization.CultureInfo" />）。</param>
        <param name="namedParameters">包含参数名称的数组，<paramref name="args" /> 数组中的值将传递给这些参数。</param>
        <summary>当在派生类中重写时，使用指定的绑定约束并匹配指定的参数列表、修饰符和区域性，调用指定成员。</summary>
        <returns>一个对象，表示被调用成员的返回值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InvokeMember` 调用构造函数成员或方法成员，获取或设置属性成员，获取或设置数据字段成员，或者获取或设置数组成员的元素。  
  
> [!NOTE]
>  不能使用 <xref:System.Type.InvokeMember%2A> 调用泛型方法。  
  
 调用 `IDispatch` 成员时，可以使用字符串格式 "[DispID = # #]" 来指定 DispID 而不是成员名称。 例如，如果 MyComMethod 为3，则可以指定字符串 "[DispID = 3]" 而不是 "MyComMethod"。 DispID 调用成员比按名称查找成员的速度更快。 在复杂的聚合方案中，DispID 有时是调用所需成员的唯一方法。  
  
 尽管默认联编程序不处理 <xref:System.Reflection.ParameterModifier> 或 <xref:System.Globalization.CultureInfo> （`modifiers` 和 `culture` 的参数），但你可以使用抽象 <xref:System.Reflection.Binder?displayProperty=nameWithType> 类编写处理 `modifiers` 和 `culture`的自定义联编程序。 仅当通过 COM 互操作进行调用时才使用 `ParameterModifier`，且仅处理通过引用传递的参数。  
  
 `namedParameters` 数组中的每个参数对应 `args` 数组中的元素来获取值。 如果 `args` 的长度大于 `namedParameters` 的长度，则剩余的自变量值将按顺序传递。  
  
 `namedParameters` 数组可用于更改输入数组中参数的顺序。 例如，如果给定方法 `M(string a, int b)` （`M(ByVal a As String, ByVal b As Integer)` 在 Visual Basic 中）和输入数组 `{ 42, "x" }`，则在为 `args` 提供数组 `{ "b", "a" }` 时，输入数组可以保持不变。`namedParameters`  
  
 以下 <xref:System.Reflection.BindingFlags> 筛选器标志可用于定义要包括在搜索中的成员：  
  
-   指定 `BindingFlags.Public` 以在搜索中包括公共成员。  
  
-   指定 `BindingFlags.NonPublic` 以在搜索中包括非公共成员（即，私有成员、内部成员和受保护成员）。  
  
-   指定 `BindingFlags.FlattenHierarchy` 以在层次结构中包含静态成员。  
  
 以下 <xref:System.Reflection.BindingFlags> 修饰符标志可用于更改搜索的工作方式：  
  
-   `BindingFlags.IgnoreCase` 忽略 `name`的大小写。  
  
-   `BindingFlags.DeclaredOnly` 仅搜索 <xref:System.Type>上声明的成员，而不搜索简单继承的成员。  
  
 以下 <xref:System.Reflection.BindingFlags> 调用标志可用于表示要对成员执行的操作：  
  
-   `CreateInstance` 调用构造函数。 `name` 将被忽略。 与其他调用标志无效。  
  
-   `InvokeMethod` 调用方法，而不是构造函数或类型初始值设定项。 与 `SetField` 或 `SetProperty`无效。 如果 `InvokeMethod` 单独指定，`BindingFlags.Public`、`BindingFlags.Instance`和 `BindingFlags.Static` 将自动包括在内。  
  
-   `GetField` 获取字段的值。 与 `SetField`无效。  
  
-   `SetField` 设置字段的值。 与 `GetField`无效。  
  
-   `GetProperty` 获取属性。 与 `SetProperty`无效。  
  
-   `SetProperty` 设置属性。 与 `GetProperty`无效。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果以下两个条件均为 true，则将调用方法：  
  
-   方法声明中的参数数目等于 `args` 数组中的参数个数（除非在成员上定义了默认参数，并且指定了 `BindingFlags.OptionalParamBinding`）。  
  
-   联编程序可以将每个参数的类型转换为参数的类型。  
  
 此联编程序将查找所有匹配的方法。 这些方法基于所请求的绑定类型（<xref:System.Reflection.BindingFlags> 值 `InvokeMethod`、`GetProperty`，等等）。 方法集按名称、参数数目和在联编程序中定义的一组搜索修饰符进行筛选。  
  
 选择方法后，将调用该方法。 此时将检查可访问性。 搜索可根据与方法关联的可访问性属性控制要搜索的方法集。 <xref:System.Reflection.Binder> 类的 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> 方法负责选择要调用的方法。 默认联编程序将选择最特定的匹配项。  
  
 `InvokeMember` 可用于调用带有具有默认值的参数的方法。 若要绑定到这些方法，反射需要指定 <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType>。 对于具有默认值的参数，可以提供不同的值，或者提供 <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> 来使用默认值。  
  
 例如，假设有一个方法，如 MyMethod （int x，float y = 2.0）。 若要调用此方法并只将第一个参数作为 MyMethod （4），请传递上述绑定标志之一，并传递两个参数，即第一个参数的4个参数，为第二个参数 `Missing.Value`。 除非使用 `Missing.Value`，否则不能省略 `Invoke` 方法的可选参数。 如果必须这样做，请改用 `InvokeMember`。  
  
 完全受信任的代码将忽略访问限制;也就是说，只要代码完全受信任，就可以通过 <xref:System.Reflection> 访问和调用私有构造函数、方法、字段和属性。  
  
 通过指定 <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>，可以使用 `Type.InvokeMember` 将字段设置为特定值。 例如，如果想要在类 C 上设置名为 F 的公共实例字段，并且 F 是 `String`，则可以使用以下代码：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 如果 F 是 `String[]`，则可以使用以下代码：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 这会将 F 字段初始化为这个新的数组。 你还可以使用 `Type.InvokeMember` 通过使用如下所示的代码提供值的索引，然后再设置下一个值，来设置数组中的位置：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 这会将 F 包含的数组中的字符串 "z" 更改为字符串 "b"。  
  
> [!NOTE]
>  从 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]开始，此方法可用于访问非公共成员（如果已向调用方授予了 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 标志的 <xref:System.Security.Permissions.ReflectionPermission>）以及非公共成员的授予集是否限制为调用方的授予集或其中的一个子集。 （请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。）  
>   
>  若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" /> 不包含 <see langword="CreateInstance" />，并且 <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="args" /> 和 <paramref name="modifiers" /> 的长度不相同。  
  
或 
 <paramref name="invokeAttr" /> 不是有效的 <see cref="T:System.Reflection.BindingFlags" /> 属性。  
  
或 
 <paramref name="invokeAttr" /> 不包含以下某个绑定标志：<see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" />。  
  
或 
 <paramref name="invokeAttr" /> 包含 <see langword="CreateInstance" /> 与 <see langword="InvokeMethod" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" /> 的组合。  
  
或 
 <paramref name="invokeAttr" /> 同时包含 <see langword="GetField" /> 和 <see langword="SetField" />。  
  
或 
 <paramref name="invokeAttr" /> 同时包含 <see langword="GetProperty" /> 和 <see langword="SetProperty" />。  
  
或 
 <paramref name="invokeAttr" /> 包含 <see langword="InvokeMethod" /> 与 <see langword="SetField" /> 或 <see langword="SetProperty" /> 的组合。  
  
或 
 <paramref name="invokeAttr" /> 包含 <see langword="SetField" />，并且 <paramref name="args" /> 具有多个元素。  
  
或 
命名的参数数组大于参数数组。  
  
或 
对 COM 对象调用了此方法，但以下绑定标志中有一个未传入：<see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" /> 或 <see langword="BindingFlags.PutRefDispProperty" />。  
  
或 
其中一个命名参数数组包含一个值为 <see langword="null" /> 的字符串。</exception>
        <exception cref="T:System.MethodAccessException">指定的成员是类初始值设定项。</exception>
        <exception cref="T:System.MissingFieldException">找不到此字段或属性。</exception>
        <exception cref="T:System.MissingMethodException">找不到与 <paramref name="args" /> 中的参数匹配的方法。  
  
或 
找不到具有 <paramref name="namedParameters" /> 中提供的参数名称的成员。  
  
或 
当前 <see cref="T:System.Type" /> 对象表示包含开放类型参数的类型，也就是说，<see cref="P:System.Type.ContainsGenericParameters" /> 将返回 <see langword="true" />。</exception>
        <exception cref="T:System.Reflection.TargetException">不能在 <paramref name="target" /> 上调用指定的成员。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">多个方法与绑定条件匹配。</exception>
        <exception cref="T:System.InvalidOperationException">由 <paramref name="name" /> 表示的方法具有一个或多个未指定的泛型类型参数。 也就是说，此方法的 <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> 属性将返回 <see langword="true" />。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用于访问非公共成员，而不考虑其授予集。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">调用非托管代码。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Type.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否为抽象的并且必须被重写。</summary>
        <value>如果 <see cref="T:System.Type" /> 是抽象的，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在以下情况下，<xref:System.Type.IsAbstract%2A> 属性将返回 `true`：  
  
-   当前类型是抽象的;也就是说，它不能进行实例化，但只能充当派生类的基类。 在C#中，抽象类标有[abstract](~/docs/csharp/language-reference/keywords/abstract.md)关键字;在 Visual Basic 中，它们用[MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md)关键字进行标记。  
  
-   当前类型是接口。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此属性始终返回 `false`。  
  
   
  
## Examples  
 下面的示例创建一个 <xref:System.Type> 对象的数组，这些对象表示以下类型：如果指定的对象 `abstract`，则包含类型返回 `true`;否则，它将返回 `false`。  
  
-   `AbstractClass`，抽象类（在C# Visual Basic 中标记为 `abstract` 的类 `MustInherit`）。  
  
-   `DerivedClass`，从 `AbstractClass`继承的类。  
  
-   `SingleClass`，不能继承的类。 它在 Visual Basic 中C#定义为和 `NotInheritable` `sealed`。  
  
-   `ITypeInfo`，接口。  
  
-   `ImplementingClass`，用于实现 `ITypeInfo` 接口的类。  
  
 此方法仅为 `AbstractClass`、抽象类和 `ITypeInfo`的接口返回 `true`。  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnsiClass : bool" Usage="System.Type.IsAnsiClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否为 <see langword="AnsiClass" /> 选择了字符串格式属性 <see cref="T:System.Type" />。</summary>
        <value>如果为 <see langword="true" /> 选择了字符串格式属性 <see langword="AnsiClass" />，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask> 选择字符串格式特性。 字符串格式特性通过定义应如何解释字符串来增强互操作性。  
  
 如果当前 <xref:System.Type> 表示泛型类型，则此属性适用于构造该类型的泛型类型定义。 例如，如果当前 <xref:System.Type> 表示 `MyGenericType<int>` （`MyGenericType(Of Integer)` Visual Basic），则此属性的值由 `MyGenericType<T>`确定。  
  
 如果当前 <xref:System.Type> 表示泛型类型的类型参数，则此属性始终返回 `false`。  
  
   
  
## Examples  
 下面的示例获取字段信息并检查 `AnsiClass` 特性。  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public virtual bool IsArray { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsArray As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsArray { bool get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Type.IsArray" />
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示类型是否为数组。</summary>
        <value>如果当前类型是数组，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsArray%2A> 属性返回 <xref:System.Array> 类的 `false`。 如果当前实例是表示集合类型的 <xref:System.Type> 对象或旨在使用集合的接口（如 <xref:System.Collections.IEnumerable> 或 <xref:System.Collections.Generic.IEnumerable%601>），则它也会返回 `false`。  
  
 若要检查数组，请使用如下所示的代码：  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 如果当前类型表示泛型类型或泛型类型或泛型方法的定义中的类型参数，则此属性始终返回 `false`。  
  
 此属性是只读的。  
  
   
  
## Examples  
 下面的示例演示如何使用 <xref:System.Type.IsArray%2A> 属性。  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsArrayImpl : unit -&gt; bool" Usage="type.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，实现 <see cref="P:System.Type.IsArray" /> 属性并确定 <see cref="T:System.Type" /> 是否为数组。</summary>
        <returns>如果 <see langword="true" /> 是数组，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> 类的实例必须返回 `false`，因为它是一个对象，而不是一个数组。  
  
   
  
## Examples  
 下面的示例重写 `MyTypeDelegator` 类中的 `IsArrayImpl` 方法，检查变量是否为数组，并显示结果。  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsAssignableFrom : Type -&gt; bool&#xA;override this.IsAssignableFrom : Type -&gt; bool" Usage="type.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="c">要与当前类型进行比较的类型。</param>
        <summary>确定指定类型的实例是否能分配给当前类型的变量。</summary>
        <returns>如果满足下列任一条件，则为 <see langword="true" />： 
-   <paramref name="c" /> 和当前实例表示相同类型。  
  
-   <paramref name="c" /> 是从当前实例直接或间接派生的。 如果继承于当前实例，则 <paramref name="c" /> 是从当前实例直接派生的；如果继承于从当前实例继承的接连一个或多个类，则 <paramref name="c" /> 是从当前实例间接派生的。  
  
-   当前实例是 <paramref name="c" /> 实现的一个接口。  
  
-   <paramref name="c" /> 是一个泛型类型参数，并且当前实例表示 <paramref name="c" /> 的约束之一。  
  
在以下示例中，当前实例是表示 <see cref="T:System.IO.Stream" /> 类的 <see cref="T:System.Type" /> 对象。 <c>GenericWithConstraint</c> 是一种泛型类型，其泛型类型参数必须为 <see cref="T:System.IO.Stream" /> 类型。 将其泛型类型参数传递到 <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> 表示可以将泛型类型参数的实例分配给 <see cref="T:System.IO.Stream" /> 对象。  
  
[!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)] 
-   <paramref name="c" /> 表示一个值类型，并且当前实例表示 <c>Nullable&lt;c&gt;</c>（在 Visual Basic 中为 <c>Nullable(Of c)</c>）。  
  
 如果不满足上述任何一个条件或者 <paramref name="c" /> 为 <see langword="false" />，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsAssignableFrom%2A> 方法可用于确定是否可将 `c` 的实例分配给当前类型的实例，当你在设计时处理其类型未知并允许条件赋值的对象时，该方法最为有用。，如下例所示。  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 因此，此方法可确保在运行时执行如下代码行，而不会引发 <xref:System.InvalidCastException> 异常或类似的异常：  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 此方法可由派生类重写。  
  
> [!NOTE]
>  泛型类型定义不可从封闭式构造类型赋值。 也就是说，不能将封闭式构造类型 `MyGenericList<int>` （`MyGenericList(Of Integer)` 在 Visual Basic 中）分配给 `MyGenericList<T>`类型的变量。  
  
 如果 `c` 参数的类型为 <xref:System.Reflection.Emit.TypeBuilder>，则结果将基于要生成的类型。 下面的代码示例使用名为 `B`的生成类型对此进行演示。  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 下面的示例演示了使用定义的类、整数数组和泛型的 `IsAssignableFrom` 方法。  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoClass : bool" Usage="System.Type.IsAutoClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否为 <see langword="AutoClass" /> 选择了字符串格式属性 <see cref="T:System.Type" />。</summary>
        <value>如果为 <see langword="true" /> 选择了字符串格式属性 <see langword="AutoClass" />，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask> 选择字符串格式特性。 字符串格式特性通过定义应如何解释字符串来增强互操作性。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此属性应用于构造该类型的泛型类型定义。 例如，如果当前 <xref:System.Type> 表示 `MyGenericType<int>` （`MyGenericType(Of Integer)` Visual Basic），则此属性的值由 `MyGenericType<T>`确定。  
  
 如果当前 <xref:System.Type> 表示泛型类型的类型参数，则此属性始终返回 `false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoLayout : bool" Usage="System.Type.IsAutoLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示当前类型的字段是否由公共语言运行时自动放置的值。</summary>
        <value>如果当前类型的 <see langword="true" /> 属性包括 <see cref="P:System.Type.Attributes" />，则为 <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此属性是为了方便。 或者，您可以使用 <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> 的枚举值选择类型布局特性，然后测试是否设置了 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>。 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>、<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>和 <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> 枚举值指示类型的字段在内存中的布局方式。  
  
 对于动态类型，可以在创建类型时指定 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>。 在代码中，将具有 <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> 枚举值的 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 特性应用到类型，以使运行时确定对类进行布局的适当方式。  
  
> [!NOTE]
>  不能使用 <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> 方法来确定 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 是否已应用于类型。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此属性应用于构造该类型的泛型类型定义。 例如，如果当前 <xref:System.Type> 表示 `MyGenericType<int>` （`MyGenericType(Of Integer)` Visual Basic），则此属性的值由 `MyGenericType<T>.`  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此属性始终返回 `false`。  
  
   
  
## Examples  
 下面的示例创建类型的实例并显示 <xref:System.Type.IsAutoLayout%2A> 属性。  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">元数据和自描述组件</related>
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public virtual bool IsByRef { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRef As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRef { bool get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.IsByRef : bool" Usage="System.Type.IsByRef" />
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Type" /> 是否由引用传递。</summary>
        <value>如果 <see cref="T:System.Type" /> 按引用传递，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要获取实际类型，请取消引用通过引用传递的类型，然后对该类型调用 <xref:System.Type.GetElementType%2A>。  
  
   
  
## Examples  
 下面的示例演示如何使用 `IsByRef` 属性检查是否按引用传递了指定的类型。 该示例定义了类 `MyTypeDelegator`，该类将重写 `HasElementTypeImpl` 方法。 主类检查 `HasElementType` 属性，并显示元素类型。  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsByRefImpl : unit -&gt; bool" Usage="type.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，实现 <see cref="P:System.Type.IsByRef" /> 属性并确定<see cref="T:System.Type" /> 是否通过引用传递。</summary>
        <returns>如果 <see cref="T:System.Type" /> 按引用传递，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Type.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClass : bool" Usage="System.Type.IsClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否是一个类或委托；即，不是值类型或接口。</summary>
        <value>如果 <see cref="T:System.Type" /> 是类，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回类和委托 `true`。 它会返回值类型的 `false` （对于结构和枚举），即使它们已装箱也是如此。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此属性始终返回 `true`。如果当前 <xref:System.Type> 表示构造泛型类型，则此属性将在泛型类型定义为类定义时返回 `true`;也就是说，它不定义接口或值类型。  
  
> [!NOTE]
>  此属性为表示 <xref:System.Enum> 和 <xref:System.ValueType> 类 `Type` 实例返回 `true`。 这两个类分别是枚举和值类型的基类型，但它们不是枚举或值类型本身。 有关详细信息，请参阅 "<xref:System.Type.IsValueType%2A>" 和 "<xref:System.Type.IsEnum%2A>" 属性。  
  
 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> 的枚举值将类型声明分为类或接口。但是，类和值类型均标记有 <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> 特性。 如果检索类型属性的值，并使用 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> 值来确定类型是否是类而不是值类型，则还必须调用 <xref:System.Type.IsValueType%2A> 属性。 <xref:System.Reflection.TypeAttributes> 枚举的示例包含附加信息以及 anexample。  
  
 此属性是只读的。  
  
   
  
## Examples  
 下面的示例创建一个类型的实例，并指示该类型是否为类。  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCOMObject : bool" Usage="System.Type.IsCOMObject" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否为 COM 对象。</summary>
        <value>如果 <see langword="true" /> 为 COM 对象，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回 COM 接口 `false`，因为它们不是对象。 COM 接口可由 Microsoft .NET Framework 对象实现。  
  
 还可以通过使用[tlbimp.exe （类型库导入程序）](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)工具加载 com 类并获取该 com 类的 `Type` 对象。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此属性应用于构造该类型的泛型类型定义。 例如，如果当前 <xref:System.Type> 表示 `MyGenericType<int`> （`MyGenericType(Of Integer)` Visual Basic），则此属性的值由 `MyGenericType<T>`确定。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此属性始终返回 `false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsCOMObjectImpl : unit -&gt; bool" Usage="type.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中重写时，实现 <see cref="P:System.Type.IsCOMObject" /> 属性并确定 <see cref="T:System.Type" /> 是否为 COM 对象。</summary>
        <returns>如果 <see langword="true" /> 为 COM 对象，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回 COM 接口 `false`，因为它们不是对象。 COM 接口可由 Microsoft .NET Framework 对象实现。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public abstract bool IsConstructedGenericType { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsConstructedGenericType As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsConstructedGenericType { bool get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Type.IsConstructedGenericType" />
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示此对象是否表示构造的泛型类型的值。 你可以创建构造型泛型类型的实例。</summary>
        <value>如果此对象表示构造泛型类型，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 构造的泛型类型已为其所有泛型类型参数提供显式类型。 它也称为封闭式泛型类型。  
  
 `true`此属性时，可以创建当前类型的实例;如果 `false`，则不能。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsContextful : bool" Usage="System.Type.IsContextful" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 在上下文中是否可以被承载。</summary>
        <value>如果 <see cref="T:System.Type" /> 能够在某个上下文中承载，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 上下文会截获对类成员的调用，并强制实施应用于类的策略，如同步。 有关远程处理上下文的详细信息，请参阅 <xref:System.Runtime.Remoting.Contexts.Context>。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此属性始终返回 `false`。  
  
   
  
## Examples  
 下面的示例演示了 <xref:System.Type> 类的 `IsContextful`、<xref:System.Type.IsMarshalByRef%2A>和 <xref:System.Type.IsPrimitive%2A> 属性。 它会检查给定的类型是否可在上下文中承载，是否可以按引用进行封送处理，以及该类型是否为基元数据类型。  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsContextfulImpl : unit -&gt; bool&#xA;override this.IsContextfulImpl : unit -&gt; bool" Usage="type.IsContextfulImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>实现 <see cref="P:System.Type.IsContextful" /> 属性并确定 <see cref="T:System.Type" /> 在上下文中是否可以被承载。</summary>
        <returns>如果 <see cref="T:System.Type" /> 能够在某个上下文中承载，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可由派生类重写。  
  
 上下文会截获对类成员的调用，并强制实施应用于类的策略，如同步。  
  
   
  
## Examples  
 下面的示例演示如何使用 `IsContextfulImpl` 方法。  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Type.IsEnum" />
      <MemberSignature Language="C#" Value="public bool IsEnum { get; }" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEnum As Boolean" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEnum { bool get(); };" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前的 <see cref="T:System.Type" /> 是否表示枚举。</summary>
        <value>如果当前 <see langword="true" /> 表示枚举，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回枚举的 `true`，但不返回 <xref:System.Enum> 类型本身的。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此属性应用于构造该类型的泛型类型定义。 例如，如果当前 <xref:System.Type> 表示 `MyGenericType<int>` （`MyGenericType(Of Integer)` Visual Basic），则此属性的值由 `MyGenericType<T>`确定。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此属性始终返回 `false`。  
  
 此属性是只读的。  
  
   
  
## Examples  
 下面的示例演示如何使用 `IsEnum` 属性。  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsEnumDefined : obj -&gt; bool&#xA;override this.IsEnumDefined : obj -&gt; bool" Usage="type.IsEnumDefined value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">要测试的值。</param>
        <summary>返回一个值，该值指示当前的枚举类型中是否存在指定的值。</summary>
        <returns>如果指定的值是当前枚举类型的成员，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">当前类型不是一个枚举。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> 类型不能为枚举的基础类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsEquivalentTo : Type -&gt; bool&#xA;override this.IsEquivalentTo : Type -&gt; bool" Usage="type.IsEquivalentTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="other">要测试是否与当前类型等效的 COM 类型。</param>
        <summary>确定两个 COM 类型是否具有相同的标识，以及是否符合类型等效的条件。</summary>
        <returns>如果 COM 类型等效，则为 <see langword="true" />；否则为 <see langword="false" />。 如果一个类型位于为执行加载的程序集中，而另一个类型位于已加载到仅限反射上下文的程序集中，则此方法也返回 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]开始，公共语言运行时支持直接将 COM 类型的类型信息嵌入到托管程序集中，而不需要托管程序集从互操作程序集获取 COM 类型的类型信息。 由于嵌入式类型信息仅包含托管程序集实际使用的类型和成员，因此两个托管程序集可能具有相同 COM 类型的不同视图。 每个托管程序集都有不同的 <xref:System.Type> 对象来表示其 COM 类型视图。 公共语言运行时支持接口、结构、枚举和委托等不同视图之间的类型等效性。  
  
 类型等效性意味着从一个托管程序集传递到另一个托管程序集的 COM 对象可以转换为接收程序集中适当的托管类型。 <xref:System.Type.IsEquivalentTo%2A> 方法使程序集能够确定从另一个程序集获取的 com 对象与第一个程序集自己的嵌入互操作类型之一具有相同的 COM 标识，因此可将其强制转换为该类型。  
  
 有关详细信息，请参阅[类型等效性和嵌入的互操作类型](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExplicitLayout : bool" Usage="System.Type.IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示当前类型的字段是否放置在显式指定的偏移量处的值。</summary>
        <value>如果当前类型的 <see langword="true" /> 属性包括 <see cref="P:System.Type.Attributes" />，则为 <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此属性是为了方便。 或者，您可以使用 <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> 的枚举值选择类型布局特性，然后测试是否设置了 <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>。 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>、<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>和 <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> 枚举值指示类型的字段在内存中的布局方式。  
  
 对于动态类型，可以在创建类型时指定 <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>。 在代码中，将具有 <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> 枚举值的 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 特性应用到类型，以指定显式指定字段开始的偏移量。  
  
> [!NOTE]
>  不能使用 <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> 方法来确定 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 是否已应用于类型。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此属性应用于构造该类型的泛型类型定义。 例如，如果当前 <xref:System.Type> 表示 `MyGenericType<int>` （`MyGenericType(Of Integer)` Visual Basic），则此属性的值由 `MyGenericType<T>`确定。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此属性始终返回 `false`。  
  
   
  
## Examples  
 下面的示例创建一个类型的实例，并显示其 <xref:System.Type.IsExplicitLayout%2A> 属性的值。 它使用 `MySystemTime` 类，该类也在 <xref:System.Runtime.InteropServices.StructLayoutAttribute>的代码示例中。  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">元数据和自描述组件</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodParameter : bool" Usage="System.Type.IsGenericMethodParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public abstract bool IsGenericParameter { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsGenericParameter As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsGenericParameter { bool get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Type.IsGenericParameter" />
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前 <see cref="T:System.Type" /> 是否表示泛型类型或方法的定义中的类型参数。</summary>
        <value>如果 <see cref="T:System.Type" /> 对象表示泛型类型定义或泛型方法定义的类型参数，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以通过调用表示泛型类型定义的 <xref:System.Type> 对象的 <xref:System.Type.GetGenericArguments%2A> 方法或表示泛型方法定义的 <xref:System.Reflection.MethodInfo> 对象的 <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> 方法来获取表示泛型类型参数的 <xref:System.Type> 对象。  
  
-   对于泛型类型或方法定义，<xref:System.Type.IsGenericParameter%2A> 属性返回生成的数组的每个元素的 `true`。  
  
-   对于封闭式构造类型或方法，<xref:System.Type.IsGenericParameter%2A> 属性返回 <xref:System.Type.GetGenericArguments%2A> 方法返回的数组的每个元素的 `false`。  
  
-   对于开放构造的类型或方法，数组的某些元素可能是特定类型，而其他元素可能为类型参数。 <xref:System.Type.IsGenericParameter%2A> 返回类型参数的类型和 `true` `false`。 <xref:System.Type.ContainsGenericParameters%2A> 属性的代码示例演示了混合类型和类型参数的泛型类。  
  
 有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。  
  
   
  
## Examples  
 下面的示例使用 <xref:System.Type.IsGenericParameter%2A> 属性测试泛型类型中的泛型类型参数。  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反射类型和泛型类型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反射检查和实例化泛型类型</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Type.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前类型是否是泛型类型。</summary>
        <value><see langword="true" /> 如果当前类型是泛型类型，则为; 否则为。否则，<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Type.IsGenericType%2A> 属性可确定 <xref:System.Type> 对象是否表示泛型类型。 使用 <xref:System.Type.ContainsGenericParameters%2A> 属性可确定 <xref:System.Type> 对象表示开放构造类型还是封闭式构造类型。  
  
> [!NOTE]
>  如果直接类型不是泛型，则 <xref:System.Type.IsGenericType%2A> 属性返回 `false`。 例如，其元素属于类型 `A<int>` （`A(Of Integer)` Visual Basic）本身不是泛型类型的数组。  
  
 下表总结了泛型反射中使用的常用术语的固定条件。  
  
|术语|固定条件|  
|----------|---------------|  
|Generic Type Definition — 泛型类型定义|<xref:System.Type.IsGenericTypeDefinition%2A> 属性为 `true`。<br /><br /> 定义泛型类型。 构造类型是通过对表示泛型类型定义并指定类型参数数组的 <xref:System.Type> 对象调用 <xref:System.Type.MakeGenericType%2A> 方法创建的。<br /><br /> 只能对泛型类型定义调用 <xref:System.Type.MakeGenericType%2A>。<br /><br /> 任何泛型类型定义都是泛型类型（<xref:System.Type.IsGenericType%2A> 属性是 `true`的），但反之不成立。|  
|Generic Type — 泛型类型|<xref:System.Type.IsGenericType%2A> 属性为 `true`。<br /><br /> 可以是泛型类型定义、开放式构造类型或封闭式构造类型。<br /><br /> 请注意，其元素类型为泛型的数组类型本身不是泛型类型。 这同样适用于表示指向泛型类型的指针的 <xref:System.Type> 对象。|  
|开放式构造类型|<xref:System.Type.ContainsGenericParameters%2A> 属性为 `true`。<br /><br /> 例如，具有未分配的类型参数的泛型类型、嵌套在泛型类型定义中的类型或开放构造类型中的泛型类型，或者具有 `true`<xref:System.Type.ContainsGenericParameters%2A> 属性的类型参数的泛型类型。<br /><br /> 不能创建开放式构造类型的实例。<br /><br /> 请注意，并非所有开放式构造类型都是泛型的。 例如，其元素类型为泛型类型定义的数组不是泛型类型，而指向开放式构造类型的指针不是泛型类型。|  
|封闭式构造类型|<xref:System.Type.ContainsGenericParameters%2A> 属性为 `false`。<br /><br /> 递归检查时，类型没有未分配的泛型参数。|  
|Generic Type Parameter — 泛型类型参数|<xref:System.Type.IsGenericParameter%2A> 属性为 `true`。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 属性为 `true`。<br /><br /> 在泛型类型定义中，将在稍后赋值的类型的占位符。|  
|Generic Type Argument — 泛型类型变量|可以是任何类型，包括泛型类型参数。<br /><br /> 类型参数指定为在创建构造泛型类型时传递给 <xref:System.Type.MakeGenericType%2A> 方法的 <xref:System.Type> 对象的数组。 如果要创建结果类型的实例，则必须为所有类型参数 `false` <xref:System.Type.ContainsGenericParameters%2A> 属性。|  
  
 下面的代码示例和表说明了其中一些术语和固定条件。 `Derived` 类特别有用，因为其基类型是一个构造类型，该类型在其类型参数列表中混合了类型和类型参数。  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 下表显示了在类 `Base`、`Derived`和 `G`上使用和生成的示例。 当C++和C#代码相同时，只显示一个条目。  
  
|示例|固定协定|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|对于此类型：<br /><br /> <xref:System.Type.IsGenericType%2A> 为 `true`。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> 为 `true`。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 为 `true`。|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|对于此类型：<br /><br /> <xref:System.Type.IsGenericType%2A> 为 `true`。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> 为 `false`。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 为 `true`。|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|对于变量的类型 `d`：<br /><br /> <xref:System.Type.IsGenericType%2A> 是 `false` 的，因为 `d` 是一个数组。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> 为 `false`。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 为 `false`。|  
|`T`、`U`和 `V` （它们显示的位置）|<xref:System.Type.IsGenericParameter%2A> 为 `true`。<br /><br /> <xref:System.Type.IsGenericType%2A> 是 `false` 的，因为没有办法将类型形参约束为泛型类型。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> 为 `false`。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 是 `true` 的，因为 `T`、`U`和 `V` 本身是泛型类型参数。 这并不意味着有关稍后分配给它们的类型参数的任何信息。|  
|字段的类型 `F`|<xref:System.Type.IsGenericType%2A> 为 `true`。<br /><br /> 由于已将类型分配给 `G`的类型参数，因此 `false` <xref:System.Type.IsGenericTypeDefinition%2A>。 请注意，这等效于调用 <xref:System.Type.MakeGenericType%2A> 方法。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 是 `true` 的，因为 `F` 字段的类型具有一个为开放式构造类型的类型参数。 构造类型是开放式的，因为其类型参数（即 `Base`）是一个泛型类型定义。 这说明了 <xref:System.Type.IsGenericType%2A> 属性的递归特性。|  
|嵌套类 `Nested`|即使 `Nested` 类没有自己的泛型类型参数，<xref:System.Type.IsGenericType%2A> 仍 `true`，因为它嵌套在泛型类型中。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> 为 `true`。 也就是说，可以调用 <xref:System.Type.MakeGenericType%2A> 方法，并提供封闭类型的类型参数，`Derived`。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 是 `true` 的，因为封闭类型 `Derived`具有泛型类型参数。 这说明了 <xref:System.Type.ContainsGenericParameters%2A> 属性的递归特性。|  
  
   
  
## Examples  
 下面的代码示例显示了 "备注" 部分中描述的类型的 <xref:System.Type.IsGenericType%2A>、<xref:System.Type.IsGenericTypeDefinition%2A>、<xref:System.Type.IsGenericParameter%2A>和 <xref:System.Type.ContainsGenericParameters%2A> 属性的值。 有关属性值的说明，请参阅 "备注" 中附带的表。  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反射类型和泛型类型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反射检查和实例化泛型类型</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Type.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前 <see cref="T:System.Type" /> 是否表示可以用来构造其他泛型类型的泛型类型定义。</summary>
        <value>如果此 <see langword="true" /> 对象表示泛型类型定义，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 泛型类型定义是可以从中构造其他类型的模板。 例如，从泛型类型定义 `G<T>` （用C#语法表示; `G(Of T)` 在 Visual Basic 或 `generic <typename T> ref class G` 中C++），可以通过调用 `G<int>` 方法并将该类型`G(Of Integer)`包含 <xref:System.Int32> 类型的泛型参数列表。<xref:System.Type.MakeGenericType%2A> 给定表示此构造类型的 <xref:System.Type> 对象，<xref:System.Type.GetGenericTypeDefinition%2A> 方法将再次获取泛型类型定义。  
  
 使用 <xref:System.Type.IsGenericTypeDefinition%2A> 属性来确定是否可以从当前类型创建新类型。 如果 <xref:System.Type.IsGenericTypeDefinition%2A> 属性返回 `true`，则可以调用 <xref:System.Type.MakeGenericType%2A> 方法来创建新的泛型类型。  
  
 有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。  
  
   
  
## Examples  
 下面的示例显示有关类型的信息，包括该类型是否为泛型类型定义。 为构造类型、泛型类型定义和普通类型显示信息。  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反射类型和泛型类型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反射检查和实例化泛型类型</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeParameter : bool" Usage="System.Type.IsGenericTypeParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsImport : bool" Usage="System.Type.IsImport" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Type" /> 是否应用了 <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> 属性，如果应用了该属性，则表示它是从 COM 类型库导入的。</summary>
        <value>如果 <see langword="true" /> 具有 <see cref="T:System.Type" />，则为 <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此属性应用于构造该类型的泛型类型定义。 例如，如果当前 <xref:System.Type> 表示 `MyGenericType<int>` （`MyGenericType(Of Integer)` Visual Basic），则此属性的值由 `MyGenericType<T>.`  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此属性始终返回 `false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="abstract member IsInstanceOfType : obj -&gt; bool&#xA;override this.IsInstanceOfType : obj -&gt; bool" Usage="type.IsInstanceOfType o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="o">要与当前类型进行比较的对象。</param>
        <summary>确定指定的对象是否是当前 <see cref="T:System.Type" /> 的实例。</summary>
        <returns>如果满足下列任一条件，则为 <see langword="true" />：当前 <see langword="Type" /> 位于由 <paramref name="o" /> 表示的对象的继承层次结构中；当前 <see langword="Type" /> 是 <paramref name="o" /> 实现的接口。 如果不属于其中任一种情况，<paramref name="o" /> 为 <see langword="null" />，或者当前 <see langword="Type" /> 为开放式泛型类型（即 <see cref="P:System.Type.ContainsGenericParameters" /> 返回 <see langword="true" />），则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可由派生类重写。  
  
> [!NOTE]
>  构造类型不是其泛型类型定义的实例。 也就是说，`MyGenericList<int>` （Visual Basic 中的`MyGenericList(Of Integer)`）不是 `MyGenericList<T>` 的实例（`MyGenericList(Of T)` 中的 Visual Basic）。  
  
   
  
## Examples  
 下面的示例演示 `IsInstanceOfType` 方法的用法。  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInterface : bool" Usage="System.Type.IsInterface" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否是一个接口；即，不是类或值类型。</summary>
        <value>如果 <see langword="true" /> 是接口，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> 将类型声明和类、接口或值类型区分开来。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此属性始终返回 `false`。  
  
 此属性是只读的。  
  
   
  
## Examples  
 下面的示例创建一个接口，检查接口类型，并指示类是否具有 `IsInterface` 属性集。  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLayoutSequential : bool" Usage="System.Type.IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示当前类型的字段是否按顺序（定义顺序或发送到元数据的顺序）放置的值。</summary>
        <value>如果当前类型的 <see langword="true" /> 属性包括 <see cref="P:System.Type.Attributes" />，则为 <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此属性是为了方便。 或者，您可以使用 <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> 的枚举值选择类型布局特性，然后测试是否设置了 <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>。 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>、<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>和 <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> 枚举值指示类型的字段在内存中的布局方式。  
  
 对于动态类型，可以在创建类型时指定 <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>。 在代码中，将具有 <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> 枚举值的 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 特性应用到类型，以指定布局是按顺序进行的。  
  
> [!NOTE]
>  不能使用 <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> 方法来确定 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 是否已应用于类型。  
  
 有关详细信息，请参阅公共语言基础结构（CLI）文档的规范的9.1.2 部分： "第 II 部分：元数据定义和语义"。 可联机获取该文档；请参阅 MSDN 上的 [ECMA C# 和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)和 Ecma International 网站上的[标准 ECMA-335 - 公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此属性应用于构造该类型的泛型类型定义。 例如，如果当前 <xref:System.Type> 表示 `MyGenericType<int>` （`MyGenericType(Of Integer)` Visual Basic），则此属性的值由 `MyGenericType<T>`确定。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此属性始终返回 `false`。  
  
   
  
## Examples  
 下面的示例创建一个类的实例，该类在 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 类中已设置 <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> 枚举值，检查 <xref:System.Type.IsLayoutSequential%2A> 属性，并显示结果。  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">元数据和自描述组件</related>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarshalByRef : bool" Usage="System.Type.IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Type" /> 是否按引用进行封送。</summary>
        <value>如果 <see langword="true" /> 是由引用封送的，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示了 <xref:System.Type> 类的 `IsContextful`、<xref:System.Type.IsMarshalByRef%2A>和 <xref:System.Type.IsPrimitive%2A> 属性。 它会检查给定的类型是否可在上下文中承载，是否可以按引用进行封送处理，以及该类型是否为基元数据类型。  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsMarshalByRefImpl : unit -&gt; bool&#xA;override this.IsMarshalByRefImpl : unit -&gt; bool" Usage="type.IsMarshalByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>实现 <see cref="P:System.Type.IsMarshalByRef" /> 属性并确定 <see cref="T:System.Type" /> 是否按引用来进行封送。</summary>
        <returns>如果 <see langword="true" /> 是由引用封送的，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可由派生类重写。  
  
   
  
## Examples  
 下面的示例确定给定类型是否按引用进行封送并显示结果。  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNested : bool" Usage="System.Type.IsNested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个指示当前 <see cref="T:System.Type" /> 对象是否表示其定义嵌套在另一个类型的定义之内的类型的值。</summary>
        <value>如果 <see langword="true" /> 嵌套在另一个类型内，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsNested%2A> 属性返回所有嵌套类型的 `true`，而不考虑可见性。 若要同时测试嵌套和可见性，请使用相关属性 <xref:System.Type.IsNestedAssembly%2A>、<xref:System.Type.IsNestedFamily%2A>、<xref:System.Type.IsNestedFamANDAssem%2A>、<xref:System.Type.IsNestedFamORAssem%2A>、<xref:System.Type.IsNestedPrivate%2A>或 <xref:System.Type.IsNestedPublic%2A>。  
  
> [!NOTE]
>  <xref:System.Reflection.TypeAttributes.VisibilityMask> 枚举成员选择类型的可见性特性。  
  
   
  
## Examples  
 下面的示例创建一个外部类，其中包含多个具有不同类型的可见性的嵌套类。 然后，它检索父类型及其每个嵌套类型的多个与可见性相关的 <xref:System.Type> 属性的值。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedAssembly : bool" Usage="System.Type.IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否是嵌套的并且只能在它自己的程序集内可见。</summary>
        <value>如果 <see langword="true" /> 是嵌套的并且仅在它自己的程序集中可见，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前 <xref:System.Type> 表示泛型类型的类型参数，则此属性始终返回 `false`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 选择可见性特性。  
  
   
  
## Examples  
 下面的示例创建一个外部类，其中包含多个具有不同类型的可见性的嵌套类。 然后，它检索父类型及其每个嵌套类型的多个与可见性相关的 <xref:System.Type> 属性的值。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamANDAssem : bool" Usage="System.Type.IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否是嵌套的并且只对同时属于自己家族和自己程序集的类可见。</summary>
        <value>如果 <see cref="T:System.Type" /> 是嵌套的并且只对同时属于它自己的家族和它自己的程序集的类可见，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前 <xref:System.Type> 表示泛型类型的类型参数，则此属性始终返回 `false`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 选择可见性特性。  
  
> [!NOTE]
>  C#和 Visual Basic 语言不包括允许您定义嵌套类型的语义，此嵌套类型仅在其自己的程序集中受保护的类型可见。 `protected internal` 中的C#可见性和 `Protected Friend` 中的可见性 Visual Basic 定义一个对受保护类型和同一程序集中的类型可见的嵌套类型。  
  
 <xref:System.Type> 对象的系列定义为同一 <xref:System.Type> 及其子类型的所有对象。  
  
   
  
## Examples  
 下面的示例创建一个外部类，其中包含多个具有不同类型的可见性的嵌套类。 然后，它检索父类型及其每个嵌套类型的多个与可见性相关的 <xref:System.Type> 属性的值。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamily : bool" Usage="System.Type.IsNestedFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否是嵌套的并且只能在它自己的家族内可见。</summary>
        <value>如果 <see langword="true" /> 是嵌套的并且仅在它自己的家族中可见，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前 <xref:System.Type> 表示泛型类型的类型参数，则此属性始终返回 `false`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 选择可见性特性。  
  
 <xref:System.Type> 对象的系列定义为完全相同的所有对象 <xref:System.Type> 及其子类型的对象。  
  
   
  
## Examples  
 下面的示例创建一个外部类，其中包含多个具有不同类型的可见性的嵌套类。 然后，它检索父类型及其每个嵌套类型的多个与可见性相关的 <xref:System.Type> 属性的值。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamORAssem : bool" Usage="System.Type.IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否是嵌套的并且只对属于它自己的家族或属于它自己的程序集的类可见。</summary>
        <value>如果 <see langword="true" /> 是嵌套的并且只对属于它自己的家族或属于它自己的程序集的类可见，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果类型的可见性在 Visual Basic 中 `protected internal` C#或 `Protected Friend`，则 <xref:System.Type.IsNestedFamORAssem%2A> 属性将返回 `true`。  
  
 如果当前 <xref:System.Type> 表示泛型类型的类型参数，则此属性始终返回 `false`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 选择可见性特性。  
  
 <xref:System.Type> 对象的系列定义为完全相同的所有对象 <xref:System.Type> 及其子类型的对象。  
  
   
  
## Examples  
 下面的示例创建一个外部类，其中包含多个具有不同类型的可见性的嵌套类。 然后，它检索父类型及其每个嵌套类型的多个与可见性相关的 <xref:System.Type> 属性的值。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPrivate : bool" Usage="System.Type.IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否是嵌套的并声明为私有。</summary>
        <value>如果 <see langword="true" /> 是嵌套的并声明为私有，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前 <xref:System.Type> 表示泛型类型的类型参数，则此属性始终返回 `false`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 选择可见性特性。  
  
   
  
## Examples  
 下面的示例创建一个外部类，其中包含多个具有不同类型的可见性的嵌套类。 然后，它检索父类型及其每个嵌套类型的多个与可见性相关的 <xref:System.Type> 属性的值。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPublic : bool" Usage="System.Type.IsNestedPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示类是否是嵌套的并且声明为公共的。</summary>
        <value>如果类是嵌套的并且声明为公共的，则为<see langword="true" /> ；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前 <xref:System.Type> 表示泛型类型的类型参数，则此属性始终返回 `false`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 选择可见性特性。  
  
   
  
## Examples  
 下面的示例创建一个外部类，其中包含多个具有不同类型的可见性的嵌套类。 然后，它检索父类型及其每个嵌套类型的多个与可见性相关的 <xref:System.Type> 属性的值。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNotPublic : bool" Usage="System.Type.IsNotPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Type" /> 是否声明为公共类型。</summary>
        <value>如果 <see langword="true" /> 未声明为公共类型且不是嵌套类型，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不要将此属性与嵌套类型一起使用;请改用 <xref:System.Type.IsNestedPublic%2A> 属性。  
  
 如果当前 <xref:System.Type> 表示泛型类型的类型参数，则此属性将返回 `false`。  
  
   
  
## Examples  
 此示例使用 `IsNotPublic` 属性获取类型的可见性。  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 下面的代码示例演示无法使用嵌套类 `IsPublic` 和 `IsNotPublic` 的原因。  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 对于嵌套类，忽略 `IsPublic` 和 `IsNotPublic` 的结果，并只关注 `IsNestedPublic` 和 `IsNestedPrivate`的结果。 此代码片段的反射输出如下所示：  
  
|类|IsNotPublic|IsPublic|IsNestedPublic|IsNestedPrivate|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|包含当前请求的 URL 的|false|true|false|false|  
|B|false|false|true|false|  
|C|false|false|false|true|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public virtual bool IsPointer { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsPointer As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsPointer { bool get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.IsPointer : bool" Usage="System.Type.IsPointer" />
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否为指针。</summary>
        <value>如果 <see cref="T:System.Type" /> 是指针，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前 <xref:System.Type> 表示泛型类型或泛型类型或泛型方法的定义中的类型参数，则此属性始终返回 `false`。  
  
 此属性是只读的。  
  
   
  
## Examples  
 下面的示例演示了 `IsPointer` 属性的用法。  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPointerImpl : unit -&gt; bool" Usage="type.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，实现 <see cref="P:System.Type.IsPointer" /> 属性并确定 <see cref="T:System.Type" /> 是否为指针。</summary>
        <returns>如果 <see cref="T:System.Type" /> 是指针，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrimitive : bool" Usage="System.Type.IsPrimitive" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否为基元类型之一。</summary>
        <value>如果 <see langword="true" /> 为基元类型之一，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基元类型为 <xref:System.Boolean>、<xref:System.Byte>、<xref:System.SByte>、<xref:System.Int16>、<xref:System.UInt16>、<xref:System.Int32>、<xref:System.UInt32>、<xref:System.Int64>、<xref:System.UInt64>、<xref:System.IntPtr>、<xref:System.UIntPtr>、<xref:System.Char>、<xref:System.Double>和 <xref:System.Single>。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型类型或泛型方法的定义中的类型参数，则此属性始终返回 `false`。  
  
   
  
## Examples  
 下面的示例演示了 <xref:System.Type> 类的 `IsContextful`、<xref:System.Type.IsMarshalByRef%2A>和 <xref:System.Type.IsPrimitive%2A> 属性。 它会检查给定的类型是否可在上下文中承载，是否可以按引用进行封送处理，以及该类型是否为基元数据类型。  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPrimitiveImpl : unit -&gt; bool" Usage="type.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，实现 <see cref="P:System.Type.IsPrimitive" /> 属性并确定 <see cref="T:System.Type" /> 是否为基元类型之一。</summary>
        <returns>如果 <see langword="true" /> 为基元类型之一，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基元类型为 <xref:System.Boolean>、<xref:System.Byte>、<xref:System.SByte>、<xref:System.Int16>、<xref:System.UInt16>、<xref:System.Int32>、<xref:System.UInt32>、<xref:System.Int64>、<xref:System.UInt64>、<xref:System.Char>、<xref:System.Double>和 <xref:System.Single>。  
  
   
  
## Examples  
 下面的示例确定给定的类型是否为基元类型并显示结果。  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Type.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Type" /> 是否声明为公共类型。</summary>
        <value>如果 <see langword="true" /> 声明为公共类型且不是嵌套类型，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不要将与嵌套类型一起使用;改用 <xref:System.Type.IsNestedPublic%2A>。  
  
 如果当前 <xref:System.Type> 表示泛型类型的类型参数，则此属性将返回 `true`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 选择可见性特性。  
  
   
  
## Examples  
 下面的示例创建 `MyTestClass`的实例，检查 `IsPublic` 属性并显示结果。  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 对于嵌套类，忽略 `IsPublic` 和 `IsNotPublic` 的结果，并只关注 <xref:System.Type.IsNestedPublic%2A> 和 <xref:System.Type.IsNestedPrivate%2A>的结果。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Type.IsSealed" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Type" /> 是否声明为密封的。</summary>
        <value>如果 <see langword="true" /> 被声明为密封的，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前 <xref:System.Type> 表示泛型类型的类型参数，则此属性始终返回 `true`。  
  
   
  
## Examples  
 下面的示例创建一个 `sealed` 类的实例，检查 `IsSealed` 属性并显示结果。  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Type.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前的类型在当前信任级别上是安全关键的还是安全可靠关键的，并因此可以执行关键操作。</summary>
        <value>如果当前类型在当前信任级别上是安全关键的或安全可靠关键的，则为 <see langword="true" />；如果它是透明的，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsSecurityCritical%2A>、<xref:System.Type.IsSecuritySafeCritical%2A>和 <xref:System.Type.IsSecurityTransparent%2A> 属性根据公共语言运行时（CLR）的确定，在其当前信任级别报告类型的透明度级别。 下表显示了这些属性的组合：  
  
|安全级别|IsSecurityCritical|IsSecurityCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|严重|`true`|`false`|`false`|  
|安全关键|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 使用这些属性比检查程序集及其类型的安全批注、检查当前的信任级别，以及尝试复制运行时的规则要简单得多。  
  
> [!IMPORTANT]
>  对于部分信任的程序集，此属性的值取决于程序集的当前信任级别。 如果将程序集加载到部分受信任的应用程序域中（例如，在沙盒应用程序域中），则运行时将忽略程序集的安全注释。 程序集及其所有类型都被视为透明。 仅当程序集加载到完全受信任的应用程序域中时（例如，在桌面应用程序的默认应用程序域中），运行时才会注意到部分信任程序集的安全注释。 相反，受信任的程序集（即安装在全局程序集缓存中的强名称程序集）始终以完全信任方式加载，而不考虑应用程序域的信任级别，因此，其当前信任级别始终是完全受信任的。 您可以使用 "<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>" 和 "<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>" 属性来确定程序集和应用程序域的当前信任级别。  
  
 有关反射和透明度的详细信息，请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。 有关透明度的信息，请参阅[安全更改](~/docs/framework/security/security-changes.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">反射的安全注意事项</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework 中的安全性更改</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Type.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前类型在当前信任级别上是否是安全可靠关键的；即它是否可以执行关键操作并可以由透明代码访问。</summary>
        <value>如果当前类型在当前信任级别上是安全可靠关键的，则为 <see langword="true" />；如果它是安全关键的或透明的，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsSecurityCritical%2A>、<xref:System.Type.IsSecuritySafeCritical%2A>和 <xref:System.Type.IsSecurityTransparent%2A> 属性根据公共语言运行时（CLR）的确定，在其当前信任级别报告类型的透明度级别。 下表显示了这些属性的组合：  
  
|安全级别|IsSecurityCritical|IsSecurityCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|严重|`true`|`false`|`false`|  
|安全关键|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 使用这些属性比检查程序集及其类型的安全批注、检查当前的信任级别，以及尝试复制运行时的规则要简单得多。  
  
> [!IMPORTANT]
>  对于部分信任的程序集，此属性的值取决于程序集的当前信任级别。 如果将程序集加载到部分受信任的应用程序域中（例如，在沙盒应用程序域中），则运行时将忽略程序集的安全注释。 程序集及其所有类型都被视为透明。 仅当程序集加载到完全受信任的应用程序域中时（例如，在桌面应用程序的默认应用程序域中），运行时才会注意到部分信任程序集的安全注释。 相反，受信任的程序集（即安装在全局程序集缓存中的强名称程序集）始终以完全信任方式加载，而不考虑应用程序域的信任级别，因此，其当前信任级别始终是完全受信任的。 您可以使用 "<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>" 和 "<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>" 属性来确定程序集和应用程序域的当前信任级别。  
  
 有关反射和透明度的详细信息，请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。 有关透明度的信息，请参阅[安全更改](~/docs/framework/security/security-changes.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">反射的安全注意事项</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework 中的安全性更改</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Type.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前类型在当前信任级别上是否是透明的而无法执行关键操作。</summary>
        <value>如果该类型在当前信任级别上是安全透明的，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此属性返回 `true`，则 <xref:System.Type.IsSecurityCritical%2A> 和 <xref:System.Type.IsSecuritySafeCritical%2A> 属性返回 `false`。  
  
 <xref:System.Type.IsSecurityCritical%2A>、<xref:System.Type.IsSecuritySafeCritical%2A>和 <xref:System.Type.IsSecurityTransparent%2A> 属性根据公共语言运行时（CLR）的确定，在其当前信任级别报告类型的透明度级别。 使用这些属性比检查程序集及其类型的安全批注、检查当前的信任级别，以及尝试复制运行时的规则要简单得多。  
  
> [!IMPORTANT]
>  对于部分信任的程序集，此属性的值取决于程序集的当前信任级别。 如果将程序集加载到部分受信任的应用程序域中（例如，在沙盒应用程序域中），则运行时将忽略程序集的安全注释。 程序集及其所有类型都被视为透明。 仅当程序集加载到完全受信任的应用程序域中时（例如，在桌面应用程序的默认应用程序域中），运行时才会注意到部分信任程序集的安全注释。 相反，受信任的程序集（即安装在全局程序集缓存中的强名称程序集）始终以完全信任方式加载，而不考虑应用程序域的信任级别，因此，其当前信任级别始终是完全受信任的。 您可以使用 "<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>" 和 "<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>" 属性来确定程序集和应用程序域的当前信任级别。  
  
 有关反射和透明度的详细信息，请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。 有关透明度的信息，请参阅[安全更改](~/docs/framework/security/security-changes.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">反射的安全注意事项</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework 中的安全性更改</related>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Type.IsSerializable" />
      <MemberSignature Language="C#" Value="public bool IsSerializable { get; }" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSerializable As Boolean" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSerializable { bool get(); };" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否为可序列化的。</summary>
        <value>如果 <see cref="T:System.Type" /> 是可序列化的，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
.NET Standard 中定义的类型未标记为 <xref:System.SerializableAttribute>。 相反，每个 .NET 实现确定类型是否可序列化。 在运行时，可以使用 <xref:System.Type.IsSerializable%2A> 属性来确定该实现是否支持对该类型的实例进行序列化。 有关详细信息和示例，请参阅[如何确定 .NET Standard 对象是否可以序列化](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md)。
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此属性应用于构造该类型的泛型类型定义。 例如，如果当前 <xref:System.Type> 表示 `MyGenericType<int>` （`MyGenericType(Of Integer)` Visual Basic），则此属性的值由 `MyGenericType<T>`确定。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此属性始终返回 `false`。  
  
   
  
## Examples  
 下面的示例创建 `MyTestClass` 类的实例，设置 [Serializable] 特性，并检查 `true` 或 `false`的 `IsSerializable` 属性。  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSignatureType : bool" Usage="System.Type.IsSignatureType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Type.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示该类型是否具有需要特殊处理的名称。</summary>
        <value>如果该类型具有需要特殊处理的名称，则为<see langword="true" /> ；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 以或开头的名称包含下划线字符（_）、属性访问器和运算符重载方法是可能需要某些编译器特殊处理的类型的示例。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此属性应用于构造该类型的泛型类型定义。 例如，如果当前 <xref:System.Type> 表示 `MyGenericType<int>` （`MyGenericType(Of Integer)` Visual Basic），则此属性的值由 `MyGenericType<T>`确定。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此属性始终返回 `false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsSubclassOf : Type -&gt; bool&#xA;override this.IsSubclassOf : Type -&gt; bool" Usage="type.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="c">要与当前类型进行比较的类型。</param>
        <summary>确定当前 <see cref="T:System.Type" /> 是否派生自指定的 <see cref="T:System.Type" />。</summary>
        <returns>如果当前 <see langword="true" /> 派生于 <see langword="Type" />，则为 <paramref name="c" />；否则为 <see langword="false" />。 如果 <see langword="false" /> 和当前 <paramref name="c" /> 相等，此方法也返回 <see langword="Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以调用 <xref:System.Type.IsSubclassOf%2A> 方法来确定以下任何内容：  
  
-   一个类是否派生自另一个类。  
  
-   类型是否派生自 <xref:System.ValueType>。 不过，<xref:System.Type.IsValueType%2A> 是一种更有效的方法来确定类型是否为值类型。  
  
-   类型是否派生自 <xref:System.Enum>。 不过，<xref:System.Type.IsEnum%2A> 方法是确定类型是否为枚举的更有效的方法。  
  
-   类型是否为委托，即是否从 <xref:System.Delegate> 或 <xref:System.MulticastDelegate>派生。  
  
 不能使用 <xref:System.Type.IsSubclassOf%2A> 方法来确定某个接口是派生自另一个接口，还是类实现接口。 出于此目的使用 <xref:System.Type.IsAssignableFrom%2A> 方法，如以下示例所示。  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则它从其类约束派生或从 <xref:System.Object?displayProperty=nameWithType> 派生（如果它没有类约束）。  
  
> [!NOTE]
>  除了与接口一起使用时，<xref:System.Type.IsSubclassOf%2A> <xref:System.Type.IsAssignableFrom%2A>。 也就是说，如果 `true``t1.IsSubclassOf(t2)`，则还 `true``t2.IsAssignableFrom(t1)`。  
  
 此方法可由派生类重写。  
  
   
  
## Examples  
 下面的示例创建一个名为 `Class1` 的类和一个名为 `DerivedC1`的派生类。 它调用 <xref:System.Type.IsSubclassOf%2A> 方法，以显示 `DerivedC1` 是 `Class1`的子类。  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="c" /> 为 <see langword="null" />。</exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Type.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Type.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnicodeClass : bool" Usage="System.Type.IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否为 <see langword="UnicodeClass" /> 选择了字符串格式属性 <see cref="T:System.Type" />。</summary>
        <value>如果为 <see langword="true" /> 选择了字符串格式属性 <see langword="UnicodeClass" />，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask> 用于选择字符串格式特性。 字符串格式特性通过定义应如何解释字符串来增强互操作性。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此属性应用于构造该类型的泛型类型定义。 例如，如果当前 <xref:System.Type> 表示 `MyGenericType<int>` （`MyGenericType(Of Integer)` Visual Basic），则此属性的值由 `MyGenericType<T>`确定。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此属性始终返回 `false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueType : bool" Usage="System.Type.IsValueType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否为值类型。</summary>
        <value>如果 <see langword="true" /> 是值类型，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值类型是表示为位序列的类型;值类型不是类或接口。 在某些编程语言中，值类型称为 "结构"。 枚举是值类型的一种特殊情况。  
  
 此属性将返回 <xref:System.ValueType> 类 `false`，因为 <xref:System.ValueType> 不是值类型本身。 它是所有值类型的基类，因此可以为其分配任何值类型。 如果 <xref:System.ValueType> 本身是值类型，则无法进行此操作。 如果将值类型分配给类型 <xref:System.ValueType>的字段，则会将这些值类型装箱。  
  
 此属性返回枚举的 `true`，但不返回 <xref:System.Enum> 类型本身的。 有关演示此行为的示例，请参阅 <xref:System.Type.IsEnum%2A>。  
  
 此属性是只读的。  
  
   
  
## Examples  
 下面的示例创建一个 `MyEnum`类型的变量，检查 `IsValueType` 属性并显示结果。  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsValueTypeImpl : unit -&gt; bool&#xA;override this.IsValueTypeImpl : unit -&gt; bool" Usage="type.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>实现 <see cref="P:System.Type.IsValueType" /> 属性并确定 <see cref="T:System.Type" /> 是否是值类型；即，它不是值类或接口。</summary>
        <returns>如果 <see langword="true" /> 是值类型，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此方法是为了实现备用类型系统。 它通常不在应用程序代码中使用。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Type.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisible : bool" Usage="System.Type.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个指示 <see cref="T:System.Type" /> 是否可由程序集之外的代码访问的值。</summary>
        <value>如果当前 <see langword="true" /> 是公共类型或公共嵌套类型从而使所有封闭类型都是公共类型，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此属性确定类型是否为组件程序集的公共接口的一部分。  
  
   
  
## Examples  
 下面的代码示例测试两个类，其中只有一个类在程序集外可见。  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回表示当前类型的数组的 <see cref="T:System.Type" /> 对象。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public abstract Type MakeArrayType ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MakeArrayType () As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ MakeArrayType();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : unit -&gt; Type" Usage="type.MakeArrayType " FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : unit -&gt; Type&#xA;override this.MakeArrayType : unit -&gt; Type" Usage="type.MakeArrayType " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回 <see cref="T:System.Type" /> 对象，该对象表示当前类型的一维数组（下限为零）。</summary>
        <returns>返回一个表示当前类型的一维数组（下限为零）的 <see cref="T:System.Type" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Type.MakeArrayType%2A> 方法可以生成元素类型在运行时计算的数组类型。  
  
 **注意**公共语言运行时区分向量（即，始终从零开始的一维数组）和多维数组。 向量（始终只有一个维度）不同于只具有一个维度的多维数组。 此方法重载仅可用于创建矢量类型，并且是创建矢量类型的唯一方法。 使用 <xref:System.Type.MakeArrayType%28System.Int32%29> 方法重载创建多维数组类型。  
  
   
  
## Examples  
 下面的代码示例创建数组、`ref` （`ByRef` Visual Basic）和 `Test` 类的指针类型。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。 派生类必须提供一个实现。</exception>
        <exception cref="T:System.TypeLoadException">当前的类型是 <see cref="T:System.TypedReference" />。  
  
或 
当前的类型是 <see langword="ByRef" /> 类型。 也就是说，<see cref="P:System.Type.IsByRef" /> 返回 <see langword="true" />。</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public abstract Type MakeArrayType (int rank);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MakeArrayType (rank As Integer) As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ MakeArrayType(int rank);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : int -&gt; Type" Usage="type.MakeArrayType rank" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : int -&gt; Type&#xA;override this.MakeArrayType : int -&gt; Type" Usage="type.MakeArrayType rank" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rank">数组的维数。 此数字必须小于或等于 32。</param>
        <summary>返回 <see cref="T:System.Type" /> 对象，该对象表示一个具有指定维数的当前类型的数组。</summary>
        <returns>表示当前类型的指定维数的数组的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Type.MakeArrayType%2A> 方法可以生成元素类型在运行时计算的数组类型。  
  
> [!NOTE]
>  公共语言运行时区分向量（即，始终从零开始的一维数组）和多维数组。 向量（始终只有一个维度）不同于只具有一个维度的多维数组。 不能使用此方法重载来创建矢量类型;如果 `rank` 为1，则此方法重载将返回一个恰好具有一个维度的多维数组类型。 使用 <xref:System.Type.MakeArrayType> 方法重载来创建矢量类型。  
  
   
  
## Examples  
 下面的代码示例创建数组、`ref` （`ByRef` Visual Basic）和 `Test` 类的指针类型。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="rank" /> 无效。 例如，0 或负数。</exception>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。</exception>
        <exception cref="T:System.TypeLoadException">当前的类型是 <see cref="T:System.TypedReference" />。  
  
或 
当前的类型是 <see langword="ByRef" /> 类型。 也就是说，<see cref="P:System.Type.IsByRef" /> 返回 <see langword="true" />。  
  
或 
 <paramref name="rank" /> 大于 32。</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public abstract Type MakeByRefType ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MakeByRefType () As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ MakeByRefType();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member MakeByRefType : unit -&gt; Type" Usage="type.MakeByRefType " FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member MakeByRefType : unit -&gt; Type&#xA;override this.MakeByRefType : unit -&gt; Type" Usage="type.MakeByRefType " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示作为 <see cref="T:System.Type" /> 参数（在 Visual Basic 中为 <see langword="ref" /> 参数）传递时的当前类型的 <see langword="ByRef" /> 对象。</summary>
        <returns>表示作为 <see cref="T:System.Type" /> 参数（在 Visual Basic 中为 <see langword="ref" /> 参数）传递时的当前类型的 <see langword="ByRef" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeByRefType%2A> 方法提供了一种为参数列表生成 `ref` 类型（Visual Basic 中的`ByRef`）的方法。  
  
 如果当前 <xref:System.Type> 对象表示 <xref:System.Int32>，则使用 Microsoft 中间语言（MSIL）的语法，此方法返回表示 `Int32&`的 <xref:System.Type> 对象。  
  
   
  
## Examples  
 下面的代码示例创建数组、`ref` （`ByRef` Visual Basic）和 `Test` 类的指针类型。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。</exception>
        <exception cref="T:System.TypeLoadException">当前的类型是 <see cref="T:System.TypedReference" />。  
  
或 
当前的类型是 <see langword="ByRef" /> 类型。 也就是说，<see cref="P:System.Type.IsByRef" /> 返回 <see langword="true" />。</exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberSignature Language="F#" Value="static member MakeGenericMethodParameter : int -&gt; Type" Usage="System.Type.MakeGenericMethodParameter position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericSignatureType">
      <MemberSignature Language="C#" Value="public static Type MakeGenericSignatureType (Type genericTypeDefinition, params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericSignatureType(class System.Type genericTypeDefinition, class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericSignatureType(System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericSignatureType (genericTypeDefinition As Type, ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericSignatureType(Type ^ genericTypeDefinition, ... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="static member MakeGenericSignatureType : Type * Type[] -&gt; Type" Usage="System.Type.MakeGenericSignatureType (genericTypeDefinition, typeArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericTypeDefinition" Type="System.Type" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="typeArguments" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="genericTypeDefinition">泛型类型定义。</param>
        <param name="typeArguments">类型参数数组。</param>
        <summary>创建一个泛型签名类型，该类型允许第三方重新实现反射，从而完全支持在查询类型成员时使用签名类型。</summary>
        <returns>泛型签名类型。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public abstract Type MakeGenericType (params Type[] typeArguments);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MakeGenericType (ParamArray typeArguments As Type()) As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericType : Type[] -&gt; Type" Usage="type.MakeGenericType typeArguments" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericType : Type[] -&gt; Type&#xA;override this.MakeGenericType : Type[] -&gt; Type" Usage="type.MakeGenericType typeArguments" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">将代替当前泛型类型的类型参数的类型数组。</param>
        <summary>替代由当前泛型类型定义的类型参数组成的类型数组的元素，并返回表示结果构造类型的 <see cref="T:System.Type" /> 对象。</summary>
        <returns><see cref="T:System.Type" /> 表示的构造类型通过以下方式形成：用 <paramref name="typeArguments" /> 的元素取代当前泛型类型的类型参数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 利用 <xref:System.Type.MakeGenericType%2A> 方法，你可以编写将特定类型分配给泛型类型定义的类型参数的代码，从而创建表示特定构造类型的 <xref:System.Type> 对象。 您可以使用此 <xref:System.Type> 对象创建构造类型的运行时实例。  
  
 用 <xref:System.Type.MakeGenericType%2A> 构造的类型可以是开放的，也就是说，它们的某些类型参数可以是封闭泛型方法或类型的类型参数。 发出动态程序集时，可以使用此类开放式构造类型。 例如，请考虑以下代码中 `Base` 和 `Derived` 的类。  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 若要在动态程序集中生成 `Derived`，需要构造其基类型。 为此，请对表示类 `Base`的 <xref:System.Type> 对象调用 <xref:System.Type.MakeGenericType%2A> 方法，同时使用泛型类型参数 <xref:System.Int32> 和 `V` 中的类型参数 `Derived`。 因为类型和泛型类型参数都由 <xref:System.Type> 对象表示，所以，同时包含这两个参数的数组可传递给 <xref:System.Type.MakeGenericType%2A> 方法。  
  
> [!NOTE]
>  发出代码时，构造类型（如 `Base<int, V>`）非常有用，但无法对该类型调用 <xref:System.Type.MakeGenericType%2A> 方法，因为该类型不是泛型类型定义。 若要创建一个可以实例化的封闭式构造类型，请首先调用 <xref:System.Type.GetGenericTypeDefinition%2A> 方法来获取表示泛型类型定义的 <xref:System.Type> 对象，然后使用所需的类型参数调用 <xref:System.Type.MakeGenericType%2A>。  
  
 <xref:System.Type.MakeGenericType%2A> 返回的 <xref:System.Type> 对象与通过调用生成的构造类型的 <xref:System.Object.GetType%2A> 方法获取的 <xref:System.Type> 或使用相同的泛型类型定义创建的任何构造类型的 <xref:System.Object.GetType%2A> 方法相同类型实参。  
  
> [!NOTE]
>  泛型类型的数组本身不是泛型类型。 不能对 `C<T>[]` （`Dim ac() As C(Of T)` Visual Basic）中的数组类型调用 <xref:System.Type.MakeGenericType%2A>。 若要从 `C<T>[]`构造关闭的泛型类型，请调用 <xref:System.Type.GetElementType%2A> 以获取泛型类型定义 `C<T>`;对泛型类型定义调用 <xref:System.Type.MakeGenericType%2A>，以创建构造类型;最后，对构造类型调用 <xref:System.Type.MakeArrayType%2A> 方法来创建数组类型。 这同样适用于指针类型和 `ref` 类型（`ByRef` Visual Basic）。  
  
 有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。  
  
## <a name="nested-types"></a>嵌套类型  
 如果使用C#、 C++或 Visual Basic 定义泛型类型，则其嵌套类型都是泛型类型。 即使嵌套类型没有自己的类型参数，也是如此，因为所有这三种语言都包括嵌套类型的类型参数列表中的封闭类型的类型参数。 请考虑以下类：  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 嵌套类 `Inner` 的类型参数列表具有两个类型参数，`T` 和 `U`，其中第一个参数是其封闭类的类型参数。 同样，嵌套类 `Innermost1` 的类型参数列表具有三个类型参数： `T`、`U`和 `V`，其中 `T` 和 `U` 来自其封闭类。 嵌套类 `Innermost2` 有两个类型参数，`T` 和 `U`，它们来自其封闭类。  
  
 如果封闭类型的参数列表具有多个类型参数，则按顺序列出的所有类型参数都包含在嵌套类型的类型参数列表中。  
  
 若要从嵌套类型的泛型类型定义构造泛型类型，请使用通过 <xref:System.Type.MakeGenericType%2A> 连接所有封闭类型的类型参数数组（从最外面的泛型类型开始，以嵌套类型本身的参数数组（如果它具有其自己的类型参数）。 若要创建 `Innermost1`的实例，请调用具有包含三种类型的数组的 <xref:System.Type.MakeGenericType%2A> 方法，以便将其分配给 T、U 和 V。若要创建 `Innermost2`的实例，请使用包含两个类型的数组调用 <xref:System.Type.MakeGenericType%2A> 方法，以便将其分配给 T 和 U。  
  
 语言以这种方式传播封闭类型的类型参数，因此可以使用封闭类型的类型参数来定义嵌套类型的字段。 否则，类型参数将不会位于嵌套类型体内的范围内。 通过在动态程序集中发出代码或使用[Ilasm （IL 汇编程序）](~/docs/framework/tools/ilasm-exe-il-assembler.md)，可以定义嵌套类型而无需传播封闭类型的类型参数。 对于 MSIL 组装器，请考虑以下代码：  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 在此示例中，无法在类 `Innermost`中定义类型 `T` 或 `U` 的字段，因为这些类型参数不在范围内。 以下汇编程序代码定义了嵌套类，它们的行为方式与它们在、 C++Visual Basic 和C#中定义的方式相同：  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 可以使用[Ildasm （IL 拆装器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)检查在高级语言中定义的嵌套类，并观察此命名方案。  
  
   
  
## Examples  
 下面的示例使用 <xref:System.Type.MakeGenericType%2A> 方法从 <xref:System.Collections.Generic.Dictionary%602> 类型的泛型类型定义中创建构造类型。 构造类型表示具有字符串键的 `Test` 对象的 <xref:System.Collections.Generic.Dictionary%602>。  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前的类型不表示泛型类型定义。 也就是说，<see cref="P:System.Type.IsGenericTypeDefinition" /> 返回 <see langword="false" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeArguments" /> 为 <see langword="null" />。  
  
或 
<paramref name="typeArguments" /> 的任意元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeArguments" /> 中的元素数与当前泛型类型定义中的类型参数数不同。  
  
或 
<paramref name="typeArguments" /> 的所有元素都不满足为当前泛型类型的相应类型参数指定的约束。  
  
或 
 <paramref name="typeArguments" /> 包含一个元素，该元素是一个指针类型（<see cref="P:System.Type.IsPointer" /> 返回 <see langword="true" />）、by-ref 类型（<see cref="P:System.Type.IsByRef" /> 返回 <see langword="true" />）或 <see cref="T:System.Void" />。</exception>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。 派生类必须提供一个实现。</exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反射类型和泛型类型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反射检查和实例化泛型类型</related>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public abstract Type MakePointerType ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MakePointerType () As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ MakePointerType();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member MakePointerType : unit -&gt; Type" Usage="type.MakePointerType " FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member MakePointerType : unit -&gt; Type&#xA;override this.MakePointerType : unit -&gt; Type" Usage="type.MakePointerType " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示指向当前类型的指针的 <see cref="T:System.Type" /> 对象。</summary>
        <returns>表示指向当前类型的指针的 <see cref="T:System.Type" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakePointerType%2A> 方法提供了一种方法来生成参数列表的指针类型。  
  
 如果当前 <xref:System.Type> 对象表示 <xref:System.Int32>，则使用 Microsoft 中间语言（MSIL）的语法，此方法返回表示 `Int32*`的 <xref:System.Type> 对象。  
  
   
  
## Examples  
 下面的代码示例创建数组、`ref` （`ByRef` Visual Basic）和 `Test` 类的指针类型。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。</exception>
        <exception cref="T:System.TypeLoadException">当前的类型是 <see cref="T:System.TypedReference" />。  
  
或 
当前的类型是 <see langword="ByRef" /> 类型。 也就是说，<see cref="P:System.Type.IsByRef" /> 返回 <see langword="true" />。</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Type.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个指示此成员是类型还是嵌套类型的 <see cref="T:System.Reflection.MemberTypes" /> 值。</summary>
        <value>一个 <see cref="T:System.Reflection.MemberTypes" /> 值，指示此成员是类型还是嵌套类型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性将重写 <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>。 因此，当您检查一组 <xref:System.Reflection.MemberInfo> 对象（例如，由 <xref:System.Type.GetMembers%2A> 返回的数组）时，当给定成员是嵌套类型时，<xref:System.Reflection.MemberInfo.MemberType%2A> 属性返回 <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType>。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此属性应用于构造该类型的泛型类型定义。 例如，如果当前 <xref:System.Type> 表示 `MyGenericType<int>` （`MyGenericType(Of Integer)` Visual Basic），则此属性的值由 `MyGenericType<T>`确定。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此属性始终返回 <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的代码示例演示 `MemberType` 字段作为 `GetMember` 方法的参数：  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberSignature Language="F#" Value=" staticval mutable Missing : obj" Usage="System.Type.Missing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="T:System.Type" /> 信息中的缺少值。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 `Missing` 字段通过反射调用以获取参数的默认值。 如果为参数值传入了 `Missing` 字段，并且该参数没有默认值，则将引发 <xref:System.ArgumentException>。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 `Missing` 字段，以使用其默认参数调用方法。  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 此代码生成以下输出：  
  
 a = 10 b = 55.3 c = 12  
  
 a = 10 b = 1.3 c = 1  
  
 a = 10 b = 1.2 c = 1  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Type.Module" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在其中定义当前 <see cref="T:System.Type" /> 的模块 (DLL)。</summary>
        <value>在其中定义当前 <see cref="T:System.Type" /> 的模块。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前 <xref:System.Type> 表示构造的泛型类型，则此属性返回定义了泛型类型定义的模块。 例如，如果创建 `MyGenericStack<int>`的实例，则构造类型的 <xref:System.Type.Module%2A> 属性将返回定义 `MyGenericStack<T>` 的模块。  
  
 同样，如果当前 <xref:System.Type> 表示泛型参数 `T`，则此属性将返回包含定义 `T`的泛型类型的程序集。  
  
   
  
## Examples  
 下面的示例演示如何使用 <xref:System.Type.Namespace%2A> 和 `Module` 属性以及 <xref:System.Type>的 <xref:System.Type.ToString%2A> 方法。  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Type.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中覆盖时，获取当前类型的名称。</summary>
        <value>当前类型的名称。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Type.Namespace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Type" /> 的命名空间。</summary>
        <value><see cref="T:System.Type" /> 的命名空间；如果当前实例没有命名空间或表示泛型参数，则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 命名空间是逻辑设计时命名方便，主要用于在应用程序中定义作用域，并在单个层次结构中组织类和其他类型。 从运行时的角度来看，没有任何命名空间。  
  
 如果当前 <xref:System.Type> 表示构造泛型类型，则此属性返回包含泛型类型定义的命名空间。 同样，如果当前 <xref:System.Type> 表示泛型参数 `T`，则此属性返回包含定义 `T`的泛型类型定义的命名空间。  
  
 如果当前 <xref:System.Type> 对象表示泛型参数，则此属性将返回 `null`。  
  
   
  
## Examples  
 下面的示例演示如何使用 `Namespace` 和 <xref:System.Type.Module%2A> 属性以及 <xref:System.Type>的 <xref:System.Type.ToString%2A> 方法。  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">指定完全限定的类型名称</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Type * Type -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个对象。</param>
        <param name="right">要比较的第二个对象。</param>
        <summary>指示两个 <see cref="T:System.Type" /> 对象是否相等。</summary>
        <returns>如果 <see langword="true" /> 等于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Type * Type -&gt; bool" Usage="System.Type.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个对象。</param>
        <param name="right">要比较的第二个对象。</param>
        <summary>指示两个 <see cref="T:System.Type" /> 对象是否不相等。</summary>
        <returns>如果 <see langword="true" /> 不等于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Type.ReflectedType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于获取该成员的类对象。</summary>
        <value><see langword="Type" /> 对象，通过它获取了此 <see cref="T:System.Type" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于 <xref:System.Type> 对象，此属性的值始终与 <xref:System.Type.DeclaringType%2A> 属性的值相同。  
  
   
  
## Examples  
 此示例显示嵌套类的反射类型。  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyGetType : string * bool * bool -&gt; Type" Usage="System.Type.ReflectionOnlyGetType (typeName, throwIfNotFound, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName">要获取的 <see cref="T:System.Type" /> 的程序集限定名称。</param>
        <param name="throwIfNotFound">如果为 <see langword="true" />，则会在找不到该类型时引发 <see cref="T:System.TypeLoadException" />；如果为 <see langword="false" />，则在找不到该类型时返回 <see langword="null" />。 指定 <see langword="false" /> 还会取消某些其他异常条件，但并不取消所有条件。 请参见“异常”部分。</param>
        <param name="ignoreCase">如果为 <see langword="true" />，则执行不区分大小写的 <paramref name="typeName" /> 搜索；如果为 <see langword="false" />，则执行区分大小写的 <paramref name="typeName" /> 搜索。</param>
        <summary>获取具有指定名称的 <see cref="T:System.Type" />，指定是否执行区分大小写的搜索，以及在找不到类型时是否引发异常。 该类型只为反射加载，而不为执行加载。</summary>
        <returns>具有指定名称的类型（如果找到的话）；否则为 <see langword="null" />。 如果找不到该类型，则 <paramref name="throwIfNotFound" /> 参数指定是返回 <see langword="null" /> 还是引发异常。 在某些情况下，将引发异常，而不考虑 <paramref name="throwIfNotFound" /> 的值。 请参见“异常”部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果包含该类型的程序集尚未加载到仅反射上下文中，则使用 <xref:System.Type.ReflectionOnlyGetType%2A> 方法等效于首先使用 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 方法加载该程序集，然后通过调用程序集的来加载该类型的<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 方法。 有关程序集限定名称的信息，请参见 <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> 属性。 有关指定类型名称的更多详细信息，请参阅 <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> 方法重载。  
  
 如果程序集已加载以便执行，则将另一个副本加载到仅反射上下文中。  
  
 `throwIfNotFound` 参数指定当找不到该类型时所发生的情况，还会取消某些其他异常条件，如 "异常" 一节中所述。 如果 `throwIfNotFound`的值，则会引发某些异常。 例如，如果程序集无效，则即使 `throwIfNotFound` `false`，也会引发 <xref:System.BadImageFormatException>。  
  
 有关使用仅反射上下文的详细信息，请参阅[如何：将程序集加载到仅反射上下文](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)中。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">调用了类初始值设定项，且该项引发了异常。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwIfNotFound" /> 是 <see langword="true" />，且找不到该类型。  
  
或 
 <paramref name="throwIfNotFound" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 包含无效字符，例如嵌入的制表符。 
或 
 <paramref name="throwIfNotFound" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 为空字符串。  
  
或 
 <paramref name="throwIfNotFound" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 表示大小无效的数组类型。  
  
或 
 <paramref name="typeName" /> 表示 <see cref="T:System.TypedReference" /> 对象数组。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> 不包括程序集名称。  
  
或 
 <paramref name="throwIfNotFound" /> 为 <see langword="true" />，且 <paramref name="typeName" /> 包含无效的语法（例如 "MyType[,*,]"）。  
  
或 
 <paramref name="typeName" /> 表示将指针类型、<see langword="ByRef" /> 类型或 <see cref="T:System.Void" /> 作为其类型参数之一的泛型类型。  
  
或 
 <paramref name="typeName" /> 表示具有错误的类型参数数目的泛型类型。  
  
或 
 <paramref name="typeName" /> 表示泛型类型，并且其类型参数之一不满足相应类型参数的约束。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwIfNotFound" /> 的值为 <see langword="true" />，且未找到程序集或程序集的某个依赖项。</exception>
        <exception cref="T:System.IO.FileLoadException">找到了程序集或其依赖项之一，但无法加载它们。</exception>
        <exception cref="T:System.BadImageFormatException">程序集或其依赖项之一无效。  
  
 或  
  
 此程序集使用高于当前所加载版本的公共语言运行时版本编译而成。</exception>
        <exception cref="T:System.PlatformNotSupportedException">仅限 .NET Core：不支持此成员。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">指定完全限定的类型名称</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md">如何：将程序集加载到仅反射上下文中</related>
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StructLayoutAttribute : System.Runtime.InteropServices.StructLayoutAttribute" Usage="System.Type.StructLayoutAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个描述当前类型的布局的 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />。</summary>
        <value>获取一个描述当前类型的大致布局特性的 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> 方法未返回 <xref:System.Runtime.InteropServices.StructLayoutAttribute>。 而是使用此属性获取它。  
  
   
  
## Examples  
 下面的代码示例首先使用特殊的布局特性（结构嵌套在类中）来定义类、结构和结构。 然后，该示例使用 <xref:System.Type.StructLayoutAttribute%2A> 属性获取每个类型的 <xref:System.Runtime.InteropServices.StructLayoutAttribute>，并显示特性的属性。  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。</exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid">留待将来使用。 必须为 IID_NULL。</param>
        <param name="rgszNames">要映射的名称的传入数组。</param>
        <param name="cNames">要映射的名称的计数。</param>
        <param name="lcid">要在其中解释名称的区域设置上下文。</param>
        <param name="rgDispId">调用方分配的数组，用于接收与名称对应的 ID。</param>
        <summary>将一组名称映射为对应的一组调度标识符。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于从非托管代码访问托管类，不应从托管代码调用。 有关 `IDispatch::GetIDsOfNames` 的详细信息，请参阅 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo">要返回的类型信息。</param>
        <param name="lcid">类型信息的区域设置标识符。</param>
        <param name="ppTInfo">指向请求的类型信息对象的指针。</param>
        <summary>检索对象的类型信息，然后可以使用该信息获取接口的类型信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于从非托管代码访问托管类，不应从托管代码调用。 有关 `IDispatch::GetTypeInfo` 的详细信息，请参阅 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">指向一个位置，该位置接收对象提供的类型信息接口的数量。</param>
        <summary>检索对象提供的类型信息接口的数量（0 或 1）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于从非托管代码访问托管类，不应从托管代码调用。 有关 `IDispatch::GetTypeInfoCount` 的详细信息，请参阅 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">标识成员。</param>
        <param name="riid">留待将来使用。 必须为 IID_NULL。</param>
        <param name="lcid">要在其中解释自变量的区域设置上下文。</param>
        <param name="wFlags">描述调用的上下文的标志。</param>
        <param name="pDispParams">指向一个结构的指针，该结构包含一个参数数组、一个命名参数的 DISPID 参数数组和数组中元素数的计数。</param>
        <param name="pVarResult">指向要存储结果的位置的指针。</param>
        <param name="pExcepInfo">指向一个包含异常信息的结构的指针。</param>
        <param name="puArgErr">第一个出错参数的索引。</param>
        <summary>提供对某一对象公开的属性和方法的访问。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于从非托管代码访问托管类，不应从托管代码调用。 有关 `IDispatch::Invoke` 的详细信息，请参阅 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="type.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示当前 <see langword="String" /> 的名称的 <see langword="Type" />。</summary>
        <returns>表示当前 <see cref="T:System.String" /> 的名称的 <see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法为所有基元类型返回完全限定的公共语言运行时命名空间和名称。 例如， C#指令 `(long)0.Type().ToString()` 返回 "system.string" 而不只是 "Int64"。  
  
 如果当前 <xref:System.Type> 表示泛型类型，则类型及其类型参数由命名空间和嵌套类型限定，而不是由程序集限定。 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此方法返回类型参数的非限定名称。  
  
   
  
## Examples  
 下面的示例演示如何使用 <xref:System.Type.Namespace%2A> 和 <xref:System.Type.Module%2A> 属性以及 <xref:System.Type>的 `ToString` 方法。  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 下面的示例将 <xref:System.Type.ToString%2A> 方法返回的字符串与 `Name`、<xref:System.Type.FullName%2A>和 <xref:System.Type.AssemblyQualifiedName%2A> 属性进行比较。  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Type.TypeHandle" />
      <MemberSignature Language="C#" Value="public abstract RuntimeTypeHandle TypeHandle { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property TypeHandle As RuntimeTypeHandle" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的句柄。</summary>
        <value>当前 <see cref="T:System.Type" /> 的句柄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `TypeHandle` 封装指向表示类型的内部数据结构的指针。 此句柄在进程生存期内是唯一的。 该句柄仅在获取该句柄的应用程序域中有效。  
  
   
  
## Examples  
 下面的示例返回相应类型的句柄，并将该句柄传递给一个方法，该方法从句柄获取类型并显示该类型。  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">.NET Compact Framework 当前不支持此属性。</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeInitializer : System.Reflection.ConstructorInfo" Usage="System.Type.TypeInitializer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取该类型的初始值设定项。</summary>
        <value>包含 <see cref="T:System.Type" /> 的类构造函数的名称的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 类初始值设定项还可通过 <xref:System.Type.FindMembers%2A> 方法或 <xref:System.Type.GetMember%2A>、<xref:System.Type.GetMembers%2A>、<xref:System.Type.GetConstructor%2A>和 <xref:System.Type.GetConstructors%2A> 方法（采用 <xref:System.Reflection.BindingFlags> 作为参数）的重载来使用。  
  
 如果当前 <xref:System.Type> 表示泛型类型或泛型方法的定义中的类型参数，则此属性将返回 `null`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Type.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示表示该类型的公共语言运行时提供的类型。</summary>
        <value><see cref="T:System.Type" /> 的基础系统类型。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>
