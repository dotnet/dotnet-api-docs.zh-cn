<Type Name="Object" FullName="System.Object">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9d0be2dcd729ec97618275f30d0e7f7c163160f1" /><Meta Name="ms.sourcegitcommit" Value="a8ca33e500a87229bed50d12e09b1347df519648" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="10/09/2020" /><Meta Name="ms.locfileid" Value="91904509" /></Metadata><TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit object" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>支持 .NET 类层次结构中的所有类，并为派生类提供低级别服务。 这是所有 .NET 类的最终基类；它是类型层次结构的根。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 语言通常不需要类来声明继承 <xref:System.Object> ，因为继承是隐式的。  
  
 因为 .NET 中的所有类都是从派生的 <xref:System.Object> ，所以类中定义的每个方法 <xref:System.Object> 都可用于系统中的所有对象。 派生类可以和重写其中一些方法，其中包括：  
  
-   <xref:System.Object.Equals%2A> -支持对象之间的比较。  
  
-   <xref:System.Object.Finalize%2A> -在自动回收对象之前执行清理操作。  
  
-   <xref:System.Object.GetHashCode%2A> -生成与对象的值相对应的数字以支持使用哈希表。  
  
-   <xref:System.Object.ToString%2A> -制造描述类的实例的用户可读文本字符串。  
  
## <a name="performance-considerations"></a>性能注意事项  
 如果正在设计的类（如集合）必须处理任何类型的对象，则可以创建接受类的实例的类成员 <xref:System.Object> 。 但是，对类型进行装箱和取消装箱的过程会产生性能开销。 如果你知道新类将经常处理某些值类型，则可以使用以下两种策略之一来最大程度地减少装箱成本。  
  
-   创建接受类型的常规方法 <xref:System.Object> ，并创建一组特定于类型的方法重载，这些重载接受你希望类经常处理的每个值类型。 如果存在接受调用参数类型的特定于类型的方法，则不会发生任何装箱并调用类型特定的方法。 如果没有与调用参数类型匹配的方法参数，则将参数装箱，并调用常规方法。  
  
-   将类型及其成员设计为使用泛型。 当你创建类的实例并指定泛型类型参数时，公共语言运行时将创建一个封闭式泛型类型。 泛型方法是类型特定的，可以在不装箱调用参数的情况下调用。  
  
 尽管有时需要开发接受和返回类型的通用类 <xref:System.Object> ，但你可以通过提供类型特定的类来处理常用类型，从而提高性能。 例如，提供特定于设置和获取布尔值的类可消除装箱和取消装箱布尔值的成本。  
  
   
  
## Examples  
 下面的示例定义了从类派生的点类型 <xref:System.Object> ，并重写了类的许多虚方法 <xref:System.Object> 。 此外，该示例还演示了如何调用类的多个静态和实例方法 <xref:System.Object> 。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs" interactive="try-dotnet" id="snippet1":::
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp" id="snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb" id="snippet1":::
  
 ]]></format>
    </remarks>
    <threadsafe><see langword="Shared" />此类型) 成员 Visual Basic 的公共静态 (是线程安全的。 实例成员不一定是线程安全的。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Object" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数由派生类中的构造函数调用，但也可用于直接创建类的实例 <xref:System.Object> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定两个对象实例是否相等。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要与当前对象进行比较的对象。</param>
        <summary>确定指定对象是否等于当前对象。</summary>
        <returns>如果指定的对象等于当前对象，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前实例和参数之间的比较类型 `obj` 取决于当前实例是引用类型还是值类型。  

-   如果当前实例是引用类型，则 <xref:System.Object.Equals%28System.Object%29> 方法会测试引用相等性，并调用 <xref:System.Object.Equals%28System.Object%29> 方法等效于调用 <xref:System.Object.ReferenceEquals%2A> 方法。 引用相等性意味着比较的对象变量引用相同的对象。 下面的示例说明了此类比较的结果。 它定义了一个 `Person` 类，该类是一个引用类型，它调用 `Person` 类构造函数来实例化两个新的 `Person` 对象， `person1a` 这些对象 `person2` 具有相同的值。 它还分配 `person1a` 给另一个对象变量 `person1b` 。 如示例的输出所示， `person1a` 和 `person1b` 相等，因为它们引用相同的对象。 但是， `person1a` 和 `person2` 不相等，但它们具有相同的值。  
  
     :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs" interactive="try-dotnet" id="Snippet2":::
     :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb" id="Snippet2":::
  
-   如果当前实例是值类型，则方法会 <xref:System.Object.Equals%28System.Object%29> 测试值是否相等。 值相等性意味着：  
  
    -   这两个对象属于同一类型。 如下面的示例所示， <xref:System.Byte> 值为12的对象不等于 <xref:System.Int32> 值为12的对象，因为这两个对象具有不同的运行时类型。  
  
         :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs" interactive="try-dotnet-method" id="Snippet3":::
         :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb" id="Snippet3":::
  
    -   这两个对象的公共字段和私有字段的值相等。 下面的示例测试值是否相等。 它定义 `Person` 结构（值类型），并调用 `Person` 类构造函数来实例化两个 `Person` `person1` 具有相同值的新对象和 `person2` 。 如示例中的输出所示，尽管这两个对象变量引用不同的对象，但 `person1` `person2` 它们相等，因为它们对于私有字段具有相同的值 `personName` 。  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)] 
  
 因为 <xref:System.Object> 该类是 .NET Framework 中所有类型的基类，所以 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 方法为所有其他类型提供默认的相等比较。 但类型通常会重写 <xref:System.Object.Equals%2A> 方法以实现值相等性。 有关详细信息，请参阅调用方的说明和对继承者的说明部分。  
  
## <a name="notes-for-the-wrt"></a>说明 [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 当对中的 <xref:System.Object.Equals%28System.Object%29> 类调用方法重载时 [!INCLUDE[wrt](~/includes/wrt-md.md)] ，它将为不重写的类提供默认行为 <xref:System.Object.Equals%28System.Object%29> 。 这是 .NET Framework 为 (提供的支持的一部分 [!INCLUDE[wrt](~/includes/wrt-md.md)] ，请参阅 [Windows 应用商店应用的 .NET Framework 支持和) Windows 运行时](/dotnet/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime) 。 中的类 [!INCLUDE[wrt](~/includes/wrt-md.md)] 不会继承 <xref:System.Object> ，当前无法实现 <xref:System.Object.Equals%28System.Object%29> 方法。 但是， <xref:System.Object.ToString%2A> <xref:System.Object.Equals%28System.Object%29> <xref:System.Object.GetHashCode%2A> 当你在 c # 或 Visual Basic 代码中使用它们时，它们看起来具有、和方法，而 .NET Framework 提供这些方法的默认行为。  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] 用 c # 或 Visual Basic 编写的类可以重写 <xref:System.Object.Equals%28System.Object%29> 方法重载。  
  
## <a name="notes-for-callers"></a>调用方说明  
 派生类经常重写 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 方法以实现值相等性。 此外，类型通常还向方法提供附加的强类型重载 `Equals` ，这通常是通过实现接口来实现的 <xref:System.IEquatable%601> 。 当调用 `Equals` 方法来测试相等性时，应知道当前实例是否会重写， <xref:System.Object.Equals%2A?displayProperty=nameWithType> 并了解对方法的特定调用的 `Equals` 解析方式。 否则，你可能会执行与预期不同的相等性测试，方法可能会返回意外值。  
  
 下面的示例进行了这方面的演示。 它 <xref:System.Text.StringBuilder> 用相同的字符串实例化三个对象，然后对方法进行四次调用 `Equals` 。 第一个方法调用返回 `true` ，其余三个返回 `false` 。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs" interactive="try-dotnet" id="Snippet5":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb" id="Snippet5":::
  
 在第一种情况下，将调用强类型化 <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> 方法重载，该重载用于测试值相等性。 由于分配给这两个对象的字符串 <xref:System.Text.StringBuilder> 相等，因此该方法返回 `true` 。 但是，不 <xref:System.Text.StringBuilder> 会重写 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 。 因此，当将 <xref:System.Text.StringBuilder> 对象强制转换为 <xref:System.Object> 类型的变量，并将 <xref:System.Text.StringBuilder> <xref:System.Object> 该 <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> 方法传递给两个对象时，将 <xref:System.Text.StringBuilder> <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 调用默认方法。 由于 <xref:System.Text.StringBuilder> 是引用类型，因此这等效于将两个 <xref:System.Text.StringBuilder> 对象传递给 <xref:System.Object.ReferenceEquals%2A> 方法。 尽管所有三个 <xref:System.Text.StringBuilder> 对象都包含相同的字符串，但是它们引用三个不同的对象。 因此，这三个方法调用返回 `false` 。  
  
 通过调用方法，可以将当前的对象与另一个对象进行比较以便引用相等性 <xref:System.Object.ReferenceEquals%2A> 。 在 Visual Basic 中，还可以使用 `is` 关键字 (例如， `If Me Is otherObject Then ...`) 。  
  
## <a name="notes-for-inheritors"></a>对继承者的说明  
 定义自己的类型时，该类型将继承其基类型的方法所定义的功能 `Equals` 。 下表列出了方法的默认实现，该 `Equals` 方法适用于 .NET Framework 中的类型的主要类别。  
  
|类型类别|定义的相等|注释|  
|-------------------|-------------------------|--------------|  
|直接从派生的类 <xref:System.Object>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|引用相等性;等效于调用 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 。|  
|结构|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|值相等性;使用反射直接进行逐字节比较或逐字段比较。|  
|枚举|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|值必须具有相同的枚举类型和基础值。|  
|委托|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|委托必须具有相同的调用列表类型。|  
|接口|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|引用相等性。|  
  
 对于值类型，应始终重写 <xref:System.Object.Equals%2A> ，因为依赖于反射的相等性测试会降低性能。 您还可以重写引用类型的的默认实现 <xref:System.Object.Equals%2A> ，以测试值相等性而不是引用相等性，并定义值相等性的精确含义。 <xref:System.Object.Equals%2A> `true` 如果两个对象具有相同的值，则此类实现将返回，即使它们不是相同的实例。 类型的实施器决定对象的值是什么，但它通常是存储在对象的实例变量中的部分或全部数据。 例如，对象的值 <xref:System.String> 基于字符串的字符; <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> 方法会重写 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 方法，以便 `true` 为任意两个包含相同字符的字符串实例返回相同的顺序。  
  
 下面的示例演示如何重写 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 方法，以测试值是否相等。 它重写 <xref:System.Object.Equals%2A> 类的方法 `Person` 。 如果 `Person` 接受其相等的基类实现，则 `Person` 只有当两个对象引用单个对象时，它们才相等。 但在这种情况下，如果两个对象具有相同的属性值，则这两个 `Person` 对象相等 `Person.Id` 。  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
   
 除了重写外 <xref:System.Object.Equals%2A> ，还可以实现 <xref:System.IEquatable%601> 接口，以提供相等的强类型测试。  
  
 对于方法的所有实现，以下语句必须为 true <xref:System.Object.Equals%28System.Object%29> 。 在列表中， `x` 、 `y` 和 `z` 表示不 **为 null**的对象引用。  
  
-   `x.Equals(x)` 返回 `true` ，但涉及浮点类型的情况除外。 请参阅 [ISO/IEC/IEEE 60559:2011，信息技术--微处理器系统--Floating-Point 算术](https://www.iso.org/standard/57469.html)。  
  
-   `x.Equals(y)` 返回与 `y.Equals(x)` 相同的值。  
  
-   `x.Equals(y)``true`如果 `x` 和均为，则返回 `y` `NaN` 。  
  
-   如果 `(x.Equals(y) && y.Equals(z))` 返回 `true` ，则 `x.Equals(z)` 返回 `true` 。  
  
-   如果 `x.Equals(y)` 不修改和引用的对象，则连续调用将返回相同的值 `x` `y` 。  
  
-   `x.Equals(null)` 返回 `false`。  
  
 的实现 <xref:System.Object.Equals%2A> 不得引发异常; 它们应始终返回值。 例如，如果 `obj` 为 `null` ，则该 <xref:System.Object.Equals%2A> 方法应返回， `false` 而不是引发 <xref:System.ArgumentNullException> 。  
  
 重写时，请遵循以下准则 <xref:System.Object.Equals%28System.Object%29> ：  
  
-   实现的类型 <xref:System.IComparable> 必须重写 <xref:System.Object.Equals%28System.Object%29> 。  
  
-   重写的类型 <xref:System.Object.Equals%28System.Object%29> 还必须重写 <xref:System.Object.GetHashCode%2A> ; 否则，哈希表可能无法正常工作。  
  
-   应考虑实现 <xref:System.IEquatable%601> 接口，以支持强类型化测试是否相等。 你的 <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> 实现应返回与一致的结果 <xref:System.Object.Equals%2A> 。  
  
-   如果您的编程语言支持运算符重载，而您为给定类型重载了相等运算符，则您还必须重写 <xref:System.Object.Equals%28System.Object%29> 方法以返回与相等运算符相同的结果。 这有助于确保使用 <xref:System.Object.Equals%2A> (（如和) ）的类库代码的 <xref:System.Collections.ArrayList> <xref:System.Collections.Hashtable> 行为方式与应用程序代码使用相等运算符的方式一致。  
  
### <a name="guidelines-for-reference-types"></a>引用类型的准则  
 以下准则适用于替代 <xref:System.Object.Equals%28System.Object%29> 引用类型：  
  
-   <xref:System.Object.Equals%2A>如果类型的语义基于该类型表示)  (某个值这一事实，请考虑重写。  
  
-   大多数引用类型不得重载相等运算符（即使它们重写） <xref:System.Object.Equals%2A> 。 但是，如果要实现的引用类型应具有值语义（如复数类型），则必须重写相等运算符。  
  
-   不应覆盖 <xref:System.Object.Equals%2A> 可变引用类型。 这是因为，重写 <xref:System.Object.Equals%2A> 要求你还重写 <xref:System.Object.GetHashCode%2A> 方法，如前一部分中所述。 这意味着可变引用类型的实例的哈希代码在其生存期内可能会更改，这可能会导致对象在哈希表中丢失。  
  
### <a name="guidelines-for-value-types"></a>值类型的准则  
 以下准则适用于重写 <xref:System.Object.Equals%28System.Object%29> 值类型：  
  
-   如果要定义的值类型包括一个或多个字段的值为引用类型，则应重写 <xref:System.Object.Equals%28System.Object%29> 。 <xref:System.Object.Equals%28System.Object%29>提供的实现 <xref:System.ValueType> 对其字段为所有值类型的值类型执行逐字节的比较，但它使用反射来执行字段中包含引用类型的值类型的逐字段比较。  
  
-   如果重写 <xref:System.Object.Equals%2A> ，并且你的开发语言支持运算符重载，则必须重载相等运算符。  
  
-   应该实现 <xref:System.IEquatable%601> 接口。 调用强类型 <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> 方法可避免对参数进行装箱 `obj` 。  
  
   
  
## Examples  
 下面的示例演示一个 `Point` 重写 <xref:System.Object.Equals%2A> 方法以提供值相等性的类，以及一个 `Point3D` 派生自的类 `Point` 。 因为 `Point` 重写 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 可测试值相等性，所以 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 不会调用方法。 但是， `Point3D.Equals` 调用 `Point.Equals` `Point` 是因为实现 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 方式可提供值相等性。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb" id="Snippet1":::
  
 方法将进行 `Point.Equals` 检查以确保 `obj` 参数不为 **null** ，并且它引用与此对象相同的类型的实例。 如果任一检查失败，则该方法将返回 `false` 。  
  
 `Point.Equals`方法调用 <xref:System.Object.GetType%2A> 方法来确定两个对象的运行时类型是否相同。 如果该方法在 c # 或 Visual Basic 中使用了窗体的检查，则当 `obj is Point` `TryCast(obj, Point)` 是的 `true` `obj` 派生类的实例时，检查将返回 `Point` ，即使 `obj` 当前实例的运行时类型不相同也是如此。 验证两个对象的类型是否相同，方法强制转换 `obj` 为类型 `Point` 并返回比较两个对象的实例字段的结果。  
  
 在中，将在 `Point3D.Equals` `Point.Equals` 执行其他操作之前调用继承的方法（重写 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> ）。 因为`Point3D`是一个密封的类 (在 Visual Basic 中为 `NotInheritable`)，签入窗体`obj is Point`C# 中或`TryCast(obj, Point)`在 Visual Basic 中是足以确保`obj`是`Point3D`对象。 如果它是一个 `Point3D` 对象，则会将其强制转换为 `Point` 对象，并传递给的基类实现 <xref:System.Object.Equals%2A> 。 仅当继承的 `Point.Equals` 方法返回时 `true` ，方法才会比较 `z` 派生类中引入的实例字段。  
  
 下面的示例定义了一个 `Rectangle` 类，该类在内部实现一个矩形作为两个 `Point` 对象。 `Rectangle`类还将重写 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 以提供值相等性。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb" id="Snippet1":::

 某些语言（如 c # 和 Visual Basic 支持运算符重载。 当类型重载相等运算符时，它还必须重写 <xref:System.Object.Equals%28System.Object%29> 方法以提供相同的功能。 这通常通过使用 <xref:System.Object.Equals%28System.Object%29> 重载的相等运算符编写方法来完成，如以下示例中所示。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb" id="Snippet1":::
  
 由于 `Complex` 是值类型，因此不能从派生。  因此，对方法的重写 <xref:System.Object.Equals%28System.Object%29> 不需要调用 <xref:System.Object.GetType%2A> 来确定每个对象的确切运行时类型，但可以使用 `is` c # 中的运算符或 `TypeOf` Visual Basic 中的运算符来检查参数的类型 `obj` 。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">要比较的第一个对象。</param>
        <param name="objB">要比较的第二个对象。</param>
        <summary>确定指定的对象实例是否被视为相等。</summary>
        <returns>如果对象被视为相等，则为 <see langword="true" />，否则为 <see langword="false" />。 如果 <paramref name="objA" /> 和 <paramref name="objB" /> 均为 null，此方法返回 <see langword="true" />****。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 静态 <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> 方法指示两个对象是否 `objA`  `objB` 相等。 它还使你能够测试值为 **null** 的对象是否相等。 它比较 `objA` 和 `objB` 以确定是否相等，如下所示：  
  
-   它确定两个对象是否表示相同的对象引用。 如果是这样，则该方法返回 `true` 。 此测试等效于调用 <xref:System.Object.ReferenceEquals%2A> 方法。 此外，如果 `objA` 和均为 `objB` **null**，则该方法返回 `true` 。  
  
-   它确定或是否 `objA` `objB` 为 **null**。 如果是，则返回 `false` 。  
  
-   如果两个对象不表示同一对象引用，并且两者都不为 **null**，则将调用 `objA` `Equals` (`objB`) 并返回结果。 这意味着，如果 `objA` 重写 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 方法，则将调用此重写。  
  
   
  
## Examples  
 下面的示例演示 <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> 方法，并将其与方法进行比较 <xref:System.Object.ReferenceEquals%2A> 。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb" id="Snippet1"::: 
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Finalize() cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在垃圾回收将某一对象回收前允许该对象尝试释放资源并执行其他清理操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.Finalize%2A>方法用于在销毁对象之前对当前对象占用的非托管资源执行清理操作。 方法是受保护的，因此只能通过此类或派生类访问。  
  
 本部分内容：  
  
-   [终止的工作方式](#How)  
  
-   [实施者注意事项](#Notes)  
  
-   [SafeHandle 备用方法](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a>终止的工作方式  
 <xref:System.Object>类不提供方法的实现 <xref:System.Object.Finalize%2A> ，垃圾回收器不会将派生自的类型标记 <xref:System.Object> 为终止，除非它们重写 <xref:System.Object.Finalize%2A> 方法。  
  
 如果类型确实重写 <xref:System.Object.Finalize%2A> 方法，则垃圾回收器会将类型的每个实例的条目添加到称为终止队列的内部结构。 终止队列包含托管堆中的所有对象的条目，在垃圾回收器可以回收内存之前，必须先运行终止代码。 然后，垃圾回收器 <xref:System.Object.Finalize%2A> 会在以下条件下自动调用方法：  
  
-   在垃圾回收器发现对象不可访问后，除非已通过调用方法免除了该对象的终止 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> 。  
  
-   **仅在 .NET Framework**的情况下，在应用程序域的关闭过程中，除非该对象免于终止。 在关闭期间，即使仍可访问的对象也会完成。  
  
 <xref:System.Object.Finalize%2A> 仅在给定的实例上自动调用一次，除非该对象是使用之类的机制重新注册的， <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> 并且 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> 随后未调用方法。  
  
 <xref:System.Object.Finalize%2A> 操作具有以下限制：  
  
-   不确定终结器执行时的准确时间。 若要确保类的实例的资源的确定性版本，请实现 `Close` 方法或提供 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 实现。  
  
-   不能保证两个对象的终结器以任何特定顺序运行，即使一个对象引用另一个对象也是如此。 也就是说，如果对象 A 具有对对象 B 的引用，并且都具有终结器，	在对象 A 的终结器启动时，对象 B 可能已被终结。  
  
-   不指定终结器在其上运行的线程。  
  
 在 <xref:System.Object.Finalize%2A> 以下异常情况下，该方法可能无法运行到完成或根本不会运行：  
  
-   如果另一个终结器无限期地阻止 (进入无限循环，则尝试获取它永远无法获取的锁，依此类推) 。 因为运行时尝试运行终结器来完成，所以如果终结器无限期阻塞，则可能不会调用其他终结器。  
  
-   如果进程终止，无需给运行时提供清理的机会。 在这种情况下，运行时的进程终止通知是 DLL_PROCESS_DETACH 通知。  
  
 仅在关闭过程中，运行时继续完成对象，但可继续减少可终结对象的数量。  
  
 如果 <xref:System.Object.Finalize%2A> 或的替代 <xref:System.Object.Finalize%2A> 引发了异常，并且运行时不是由覆盖默认策略的应用程序承载，则运行时将终止进程，并且不会执行任何活动的 `try` / `finally` 块或终结器。 如果终结器无法释放或销毁资源，则此行为可确保进程完整性。  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a>重写 Finalize 方法 
 应 <xref:System.Object.Finalize%2A> 为使用非托管资源的类（例如，在垃圾回收过程中丢弃使用非托管资源的文件句柄或数据库连接）进行重写。 不应实现 <xref:System.Object.Finalize%2A> 托管对象的方法，因为垃圾回收器会自动释放托管资源。  
  
> [!IMPORTANT]
>  如果 <xref:System.Runtime.InteropServices.SafeHandle> 对象可用于包装非托管资源，则建议的替代方法是使用安全句柄实现 dispose 模式，而不是重写 <xref:System.Object.Finalize%2A> 。 有关详细信息，请参阅 [SafeHandle 替代](#SafeHandle) 部分。  
  
 <xref:System.Object.Finalize%2A?displayProperty=nameWithType>默认情况下，此方法不执行任何操作，但你应 <xref:System.Object.Finalize%2A> 仅在必要时重写，并且仅释放非托管资源。 如果某个终止操作运行，则回收内存要花费更长时间，因为它需要至少两个垃圾回收。 此外，还应 <xref:System.Object.Finalize%2A> 为仅引用类型重写方法。 公共语言运行时仅终结引用类型。 它忽略值类型上的终结器。  

该方法的范围 <xref:System.Object.Finalize%2A?displayProperty=nameWithType> 为 `protected` 。 重写类中的方法时，应保持此有限范围。 通过使 <xref:System.Object.Finalize%2A> 方法受到保护，可以防止应用程序的用户直接调用对象的 <xref:System.Object.Finalize%2A> 方法。
  
 派生类型中的每个实现都 <xref:System.Object.Finalize%2A> 必须调用其基类型的实现 <xref:System.Object.Finalize%2A> 。 这是允许应用程序代码调用的唯一情况 <xref:System.Object.Finalize%2A> 。 对象的 <xref:System.Object.Finalize%2A> 方法不应在其基类以外的任何对象上调用方法。 这是因为调用的其他对象可以与调用对象同时收集，如公共语言运行时关闭的情况。 
  
> [!NOTE]
>  C # 编译器不允许重写 <xref:System.Object.Finalize%2A> 方法。 而是通过实现类的 [析构函数](/dotnet/csharp/programming-guide/classes-and-structs/destructors) 来提供终结器。 C # 析构函数自动调用其基类的析构函数。  
>   
>  Visual C++ 还提供其自己的语法来实现 <xref:System.Object.Finalize%2A> 方法。 有关详细信息，请参阅 [如何：定义和使用类和结构 (c + +/cli) ](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)中的 "析构函数和终结器" 一节。  
  
 由于垃圾回收是不确定的，因此，在垃圾回收器执行终止时，您不会精确地知道。 若要立即释放资源，还可以选择实现 [dispose 模式](/dotnet/standard/garbage-collection/implementing-dispose) 和 <xref:System.IDisposable> 接口。 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>实现可由类的使用者调用以释放非托管资源，并且可以 <xref:System.Object.Finalize%2A> 在未调用方法的情况下使用方法来释放非托管资源 <xref:System.IDisposable.Dispose%2A> 。  
  
 <xref:System.Object.Finalize%2A> 几乎可以执行任何操作，包括 resurrecting 对象 (即，使该对象在垃圾回收过程中被清理后再次) 可供访问。 但是，对象只能复活一次;在 <xref:System.Object.Finalize%2A> 垃圾回收期间，不能对复活对象调用。
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a>SafeHandle 备用方法  
 创建可靠的终结器通常很难，因为你无法对应用程序的状态进行假设，并且因为未处理的系统异常（如 <xref:System.OutOfMemoryException> 和） <xref:System.StackOverflowException> 终止终结器。 您可以使用从类派生的对象 <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> 来包装非托管资源，并在不使用终结器的情况下实现 dispose 模式，而不是实现类的终结器以释放非托管资源。 .NET Framework 提供命名空间中的以下类 <xref:Microsoft.Win32?displayProperty=nameWithType> ，这些类派生自 <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> ：  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 是文件句柄的包装类。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> 是内存映射的文件句柄的包装类。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> 指向非托管内存块的指针的包装类。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>、 <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle> 和 <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> 是加密句柄的包装类。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> 是管道句柄的包装类。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> 是注册表项的句柄的包装类。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> 是等待句柄的包装类。  
  
 下面的示例将 [dispose 模式](/dotnet/standard/garbage-collection/implementing-dispose) 与安全句柄一起使用，而不是重写 <xref:System.Object.Finalize%2A> 方法。 它定义一个 `FileAssociation` 类，该类包装有关处理具有特定文件扩展名的文件的应用程序的注册表信息。 Windows RegOpenKeyEx 函数调用将两个作为参数返回的注册表句柄 `out` 传递[RegOpenKeyEx](/windows/win32/api/winreg/nf-winreg-regopenkeyexa)到 <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> 构造函数。 然后，该类型的受保护 `Dispose` 方法会调用 `SafeRegistryHandle.Dispose` 方法来释放这两个句柄。  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 下面的示例验证 <xref:System.Object.Finalize%2A> 当重写的对象被销毁时调用的方法 <xref:System.Object.Finalize%2A> 。 请注意，在生产应用程序中，将 <xref:System.Object.Finalize%2A> 重写方法以释放由该对象占用的非托管资源。 另请注意，c # 示例提供析构函数，而不是重写 <xref:System.Object.Finalize%2A> 方法。  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 有关替代方法的其他示例 <xref:System.Object.Finalize%2A> ，请参见 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> 方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>作为默认哈希函数。</summary>
        <returns>当前对象的哈希代码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 哈希代码是一个数字值，用于在基于哈希的集合（如 <xref:System.Collections.Generic.Dictionary%602> 类、 <xref:System.Collections.Hashtable> 类或从类派生的类型）中插入和标识对象 <xref:System.Collections.DictionaryBase> 。 <xref:System.Object.GetHashCode%2A>方法为需要快速检查对象相等性的算法提供此哈希代码。  
  
> [!NOTE]
>  有关哈希表中的哈希代码和其他哈希代码算法如何使用哈希代码的信息，请参阅维基百科中的 [哈希函数](https://en.wikipedia.org/wiki/Hash_function) 条目。  
  
 相等的两个对象返回的哈希代码相等。 但是，反之亦然：相等的哈希代码不意味着对象相等，因为不同的 (不相等) 对象可以具有相同的哈希代码。 此外，.NET 不保证方法的默认实现 <xref:System.Object.GetHashCode%2A> ，并且此方法返回的值可能在 .net 实现之间有所不同，例如 .NET Framework 和 .Net Core 的不同版本以及平台（如32位和64位平台）。 出于这些原因，请不要将此方法的默认实现用作唯一对象标识符以进行哈希处理。 下面是两个结果：  
  
-   不应假定相等哈希代码意味着对象相等。  
  
-   永远不应在创建它的应用程序域之外保留或使用哈希代码，因为相同的对象可能会在应用程序域、进程和平台之间进行哈希运算。  
  
> [!WARNING]
>  哈希代码适用于基于哈希表的集合中的高效插入和查找。 哈希代码不是永久值。 出于此原因：  
>   
> -   不要序列化哈希代码值或将其存储在数据库中。  
> -   不要使用哈希代码作为密钥来检索键控集合中的对象。  
> -   不要跨应用程序域或进程发送哈希代码。 在某些情况下，可以基于每个进程或每个应用程序域来计算哈希代码。  
> -   如果需要加密型强哈希，请不要使用哈希代码（而不是加密哈希函数返回的值）。 对于加密哈希，请使用派生自 <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> 或类的类 <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> 。  
> -   不要测试哈希代码是否相等，以确定两个对象是否相等。  (不相等对象可以具有相同的哈希代码。 ) 要测试是否相等，请调用 <xref:System.Object.ReferenceEquals%2A> 或 <xref:System.Object.Equals%2A> 方法。  
  
 <xref:System.Object.GetHashCode%2A>方法可由派生类型重写。 如果 <xref:System.Object.GetHashCode%2A> 未重写，则通过调用基类的方法计算引用类型的哈希代码 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> ，该方法根据对象的引用计算哈希代码; 有关详细信息，请参阅 <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> 。 换言之，该方法返回的两个对象 <xref:System.Object.ReferenceEquals%2A> `true` 具有相同的哈希代码。 如果值类型不重写 <xref:System.Object.GetHashCode%2A> ，则 <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> 基类的方法使用反射根据类型字段的值来计算哈希代码。 换句话说，其字段具有相等值的值类型具有相同的哈希代码。 有关替代的详细信息 <xref:System.Object.GetHashCode%2A> ，请参阅 "对继承者的说明" 部分。  
  
> [!WARNING]
>  如果重写 <xref:System.Object.GetHashCode%2A> 方法，则还应重写 <xref:System.Object.Equals%2A> ，反之亦然。 如果在 <xref:System.Object.Equals%2A> `true` 测试两个对象是否相等时重写的方法返回，则重写的 <xref:System.Object.GetHashCode%2A> 方法必须为这两个对象返回相同的值。  
  
 如果用作哈希表中的键的对象不提供有用的实现 <xref:System.Object.GetHashCode%2A> ，则可以通过 <xref:System.Collections.IEqualityComparer> 向 <xref:System.Collections.Hashtable> 类构造函数的重载之一提供实现来指定哈希代码提供程序。  
  
## <a name="notes-for-the-wrt"></a>说明 [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 当你在 <xref:System.Object.GetHashCode%2A> 中的类上调用方法时 [!INCLUDE[wrt](~/includes/wrt-md.md)] ，它将为不重写的类提供默认行为 <xref:System.Object.GetHashCode%2A> 。 这是 .NET Framework 为 (提供的支持的一部分 [!INCLUDE[wrt](~/includes/wrt-md.md)] ，请参阅 [Windows 应用商店应用的 .NET Framework 支持和) Windows 运行时](/dotnet/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime) 。 中的类 [!INCLUDE[wrt](~/includes/wrt-md.md)] 不继承 <xref:System.Object> ，当前未实现 <xref:System.Object.GetHashCode%2A> 。 但是， <xref:System.Object.ToString%2A> <xref:System.Object.Equals%28System.Object%29> <xref:System.Object.GetHashCode%2A> 当你在 c # 或 Visual Basic 代码中使用它们时，它们看起来具有、和方法，而 .NET Framework 提供这些方法的默认行为。  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] 用 c # 或 Visual Basic 编写的类可以重写 <xref:System.Object.GetHashCode%2A> 方法。  
  
   
  
## Examples  
 为具有相同或更小范围的数字值计算哈希代码的最简单方法之一 <xref:System.Int32> 是只返回该值。 下面的示例演示了一个结构的实现 `Number` 。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb" id="Snippet1"::: 
  
 通常，类型具有多个数据字段，这些字段可参与生成哈希代码。 生成哈希代码的一种方法是使用操作来合并这些字段 `XOR (eXclusive OR)` ，如以下示例中所示。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb" id="Snippet2":::  
  
 前面的示例为 (n1、n2) 和 (n2，n1) 返回相同的哈希代码，因此可能会产生比预期更多的冲突。 提供了许多解决方案，以便这些情况下的哈希代码不完全相同。 一种是返回对象的哈希代码 `Tuple` ，该对象反映每个字段的顺序。 下面的示例演示使用类的可能的实现 <xref:System.Tuple%602> 。 但请注意，实例化对象的性能开销 `Tuple` 可能会显著影响在哈希表中存储大量对象的应用程序的整体性能。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb" id="Snippet3":::
  
 第二种替代解决方案涉及通过将连续字段的哈希代码左移两位或更多位，来加权单个哈希代码。 最佳情况下，超出位31的位应换行，而不是丢弃。 由于 bits 是由 c # 和 Visual Basic 中的左移运算符丢弃的，因此需要创建左移和换行方法，如下所示：  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 然后，下面的示例使用此 shift 和 wrap 方法计算 `Point` 前面的示例中使用的结构的哈希代码。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs" interactive="try-dotnet" id="Snippet5":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb" id="Snippet5":::
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>使用哈希函数可以快速生成与对象的值相对应的数字 (哈希代码) 。 哈希函数通常是特定于每个类型的，因此，为实现唯一性，必须使用至少一个实例字段作为输入。 不应使用静态字段的值来计算哈希代码。  
  
对于派生自的类 <see cref="T:System.Object" /> ， <see langword="GetHashCode" /> <see cref="M:System.Object.GetHashCode" /> 只有当派生类将相等定义为引用相等性时，该方法才能委托给基类实现。 对于引用类型，的默认实现 <see cref="M:System.Object.GetHashCode" /> 返回的哈希代码等效于方法返回的哈希代码 <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> 。 可 <see cref="M:System.Object.GetHashCode" /> 对不可变引用类型重写。 通常，对于可变引用类型，应 <see cref="M:System.Object.GetHashCode" /> 仅在以下情况下重写： 
-可以计算不可变的字段中的哈希代码;或 
-可以确保可变对象的哈希代码在依赖于其哈希代码的集合中时不会更改。  
  
否则，你可能会认为可变对象会在哈希表中丢失。 如果选择替代 <see cref="M:System.Object.GetHashCode" /> 可变引用类型，您的文档应清楚地说明，当对象存储在哈希表中时，您的类型的用户不应修改对象值。  
  
对于值类型， <see cref="M:System.ValueType.GetHashCode" /> 提供使用反射的默认哈希代码实现。 你应考虑重写它以获得更好的性能。  
  
 <block subset="none" type="note"><para>  
 有关以各种方式计算哈希代码的详细信息和示例，请参阅 "示例" 部分。  
  
</para></block>  
  
 哈希函数必须具有以下属性： 
-如果两个对象的比较结果相等，则 <see cref="M:System.Object.GetHashCode" /> 每个对象的方法必须返回相同的值。 但是，如果两个对象的比较结果不相等，则 <see cref="M:System.Object.GetHashCode" /> 这两个对象的方法不必返回不同的值。  
  
- <see cref="M:System.Object.GetHashCode" /> 对于对象状态不会修改确定对象的 [system.object](xref:System.Object.Equals*) 方法返回值的对象状态，对象的方法必须始终返回相同的哈希代码。 请注意，这仅适用于当前执行的应用程序，并且如果重新运行应用程序，则可以返回不同的哈希代码。  
  
-为了获得最佳性能，哈希函数应为所有输入生成偶数分布，其中包括大量聚集输入。 这意味着，对对象状态的小修改应该会导致对生成的哈希代码进行较大的修改，以获得最佳的哈希表性能。  
  
-哈希函数的计算成本应较低。  
  
- <see cref="M:System.Object.GetHashCode" /> 方法不应引发异常。  
  
例如， <see cref="M:System.String.GetHashCode" /> 类提供的方法的实现 <see cref="T:System.String" /> 返回相同字符串值的相同哈希代码。 因此，如果两个 <see cref="T:System.String" /> 对象表示相同的字符串值，则它将返回相同的哈希代码。 此外，该方法使用字符串中的所有字符生成合理的随机分发输出，即使输入在某些范围内处于聚集 (例如，许多用户的字符串可能只包含较低的 128 ASCII 字符，即使字符串可包含任何 65535 Unicode 字符) 。  
  
在类上提供良好的哈希函数可能会显著影响将这些对象添加到哈希表的性能。 在具有提供哈希函数的良好实现的键的哈希表中，搜索元素所用的时间 (例如，O (1) 操作) 。 在包含哈希函数实现的哈希表中，搜索的性能取决于哈希表中的项数 (例如，O (`n`) 运算，其中 `n` 是哈希表) 中的项数。 恶意用户可以输入增加冲突数量的数据，这可能会显著降低依赖于哈希表的应用程序的性能，但在以下情况下： 
-哈希函数产生频繁冲突。  
  
-当哈希表中的大量对象产生相等或近似相等的哈希代码时。  
  
-当用户输入从中计算哈希代码的数据时。  
  
重写的派生类 <see cref="M:System.Object.GetHashCode" /> 还必须重写 <see cref="M:System.Object.Equals(System.Object)" /> 以确保两个被视为相等的对象具有相同的哈希代码; 否则，该 <see cref="T:System.Collections.Hashtable" /> 类型可能无法正常工作。</para></block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取当前实例的 <see cref="T:System.Type" />。</summary>
        <returns>当前实例的准确运行时类型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 因为 <xref:System.Object?displayProperty=nameWithType> 是 .net 类型系统中所有类型的基类，所以 <xref:System.Object.GetType%2A> 方法可用于返回 <xref:System.Type> 表示所有 .net 类型的对象。 .NET 可识别以下五类类型：  
  
-   派生 <xref:System.Object?displayProperty=nameWithType> 自的类  
  
-   值类型，派生自 <xref:System.ValueType?displayProperty=nameWithType> 。  
  
-   接口，从 <xref:System.Object?displayProperty=nameWithType> .NET Framework 2.0 开始派生。  
  
-   派生自的枚举 <xref:System.Enum?displayProperty=nameWithType> 。  
  
-   委托，派生自 <xref:System.MulticastDelegate?displayProperty=nameWithType> 。  
  
 如果两个 `x` 对象 `y` 具有相同的运行时类型，则 `Object.ReferenceEquals(x.GetType(),y.GetType())` 返回 `true` 。 下面的示例将 <xref:System.Object.GetType%2A> 方法与方法一起使用， <xref:System.Object.ReferenceEquals%2A> 以确定一个数值是否为与另外两个数值相同的类型。  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb" id="Snippet1"::: 

> [!NOTE]
>  若要确定某个对象是否为特定类型，可以使用您的语言的类型比较关键字或构造。 例如，可以在 Visual Basic 中使用 `TypeOf…Is` 构造，或在 `is` c # 中使用关键字。  
  
 此 <xref:System.Object.GetType%2A> 方法由派生自的所有类型继承 <xref:System.Object> 。 这意味着，除了使用自己的语言的比较关键字外，还可以使用 <xref:System.Object.GetType%2A> 方法来确定特定对象的类型，如下面的示例所示。  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb" id="Snippet2":::
  
 <xref:System.Type>对象公开与当前的类关联的元数据 <xref:System.Object> 。  
  
   
  
## Examples  

 下面的代码示例演示 <xref:System.Object.GetType%2A> 返回当前实例的运行时类型。  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp" id="Snippet1"::: 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建当前 <see cref="T:System.Object" /> 的浅表副本。</summary>
        <returns>当前 <see cref="T:System.Object" /> 的浅表副本。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法创建一个 <xref:System.Object.MemberwiseClone%2A> 浅表副本，方法是创建一个新的对象，然后将当前对象的非静态字段复制到新的对象。 如果字段是值类型，则执行字段的逐位副本。 如果字段是引用类型，则会复制引用，但不会复制引用的对象;因此，原始对象及其复本引用相同的对象。  
  
 例如，假设有一个名为 X 的对象引用对象 A 和 B。对象 B 反过来引用对象 C。X 的浅表副本创建新的对象 X2，后者同时引用对象 A 和 B。与之相比，X 的深层副本会创建一个新的对象 X2，该对象引用作为 A 和 B 的副本的新对象 A2 和 B2，进而引用新的对象 C2，这是 C 的副本。该示例说明了浅层和深层复制操作之间的差异。  
  
 如果方法执行的浅层复制操作 <xref:System.Object.MemberwiseClone%2A> 不能满足您的需要，可以通过多种方式实现深层复制操作。 这些功能包括以下这些：  
  
-   调用要复制的对象的类构造函数，以创建具有从第一个对象获取的属性值的第二个对象。 这假设对象的值由其类构造函数完全定义。  
  
-   调用 <xref:System.Object.MemberwiseClone%2A> 方法以创建对象的浅表副本，然后将新对象的值与原始对象的值相同，分配给任何属性或其值为引用类型的字段。 该 `DeepCopy` 示例中的方法演示了这种方法。  
  
-   序列化要深层复制的对象，然后将序列化的数据还原到其他对象变量。  
  
-   使用带有递归的反射来执行深层复制操作。  
  
   
  
## Examples  
 下面的示例演示 <xref:System.Object.MemberwiseClone%2A> 方法。 它定义了一 `ShallowCopy` 种方法，该方法调用 <xref:System.Object.MemberwiseClone%2A> 方法以对对象执行浅表复制操作 `Person` 。 它还定义了对 `DeepCopy` 对象执行深层复制操作的方法 `Person` 。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb" id="Snippet1":::
  
 在此示例中， `Person.IdInfo` 属性返回 `IdInfo` 对象。 如示例的输出所示，当 `Person` 通过调用方法克隆对象时， <xref:System.Object.MemberwiseClone%2A> 克隆的 `Person` 对象是原始对象的独立副本，只不过它们共享相同的 `Person.IdInfo` 对象引用。 因此，修改克隆的 `Person.IdInfo` 属性会更改原始对象的 `Person.IdInfo` 属性。 另一方面，执行深层复制操作时， `Person` 可以修改克隆的对象（包括其 `Person.IdInfo` 属性），而不会影响原始对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">要比较的第一个对象。</param>
        <param name="objB">要比较的第二个对象。</param>
        <summary>确定指定的 <see cref="T:System.Object" /> 实例是否是相同的实例。</summary>
        <returns>如果 <paramref name="objA" /> 是与 <paramref name="objB" /> 相同的实例，或如果两者均为 **null**，则为 <see langword="true" />，否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与 <xref:System.Object.Equals%2A> 方法和相等运算符不同， <xref:System.Object.ReferenceEquals%2A> 方法不能被重写。 因此，如果要测试两个对象引用是否相等，并且不确定方法的实现 `Equals` ，则可以调用 <xref:System.Object.ReferenceEquals%2A> 方法。  
  
 但是， <xref:System.Object.ReferenceEquals%2A> 在这两种情况下，方法的返回值可能看起来是异常的：  
  
-   比较值类型时。 如果 `objA` 和 `objB` 是值类型，则在将其传递给方法之前将它们装箱 <xref:System.Object.ReferenceEquals%2A> 。 这意味着，如果 `objA` 和均 `objB` 表示值类型的同一个实例，则 <xref:System.Object.ReferenceEquals%2A> 方法仍返回 `false` ，如下面的示例所示。  
  
     [!code-csharp-interactive[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     有关装箱值类型的信息，请参阅 [装箱和取消装箱](/dotnet/csharp/programming-guide/types/boxing-and-unboxing)。  
  
-   比较字符串时。 如果 `objA` 和 `objB` 是字符串，则在 <xref:System.Object.ReferenceEquals%2A> 暂存字符串时，方法将返回 `true` 。 它不会执行值相等性测试。  在下面的示例中， `s1` 和 `s2` 相等，因为它们是单个暂存字符串的两个实例。 但是， `s3` 和 `s4` 不相等，因为虽然它们具有相同的字符串值，但不会暂存该字符串。  
  
     [!code-csharp-interactive[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     有关字符串暂留的详细信息，请参阅 <xref:System.String.IsInterned%2A?displayProperty=nameWithType> 。  
  
   
  
## Examples  

 下面的示例使用 <xref:System.Object.ReferenceEquals%2A> 确定两个对象是否为同一个实例。  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp-interactive[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示当前对象的字符串。</summary>
        <returns>表示当前对象的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 是 .NET Framework 中的主要格式设置方法。 它将对象转换为其字符串表示形式，以便它适合于显示。  (有关 .NET Framework 中格式设置支持的信息，请参阅 [格式设置类型](/dotnet/standard/base-types/formatting-types)。方法的 ) 默认实现 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 返回对象类型的完全限定名称。  
  
> [!IMPORTANT]
>  您可能已通过从另一类型成员列表中的链接来访问此页。 这是因为该类型不会重写 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 。 相反，它将继承方法的功能 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 。  
  
 类型经常重写 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法，以提供更适合特定类型的字符串表示形式。 类型还经常重载 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法，以提供对格式字符串或区分区域性的格式设置的支持。  

 本部分内容：  
  
 [默认的对象 ToString ( # A1 方法](#Default)   
 [重写对象 ToString ( # A1 方法](#Overriding)   
 [重载 ToString 方法](#Overloading)   
 [扩展对象 ToString 方法](#Extending)   
 [Windows 运行时的说明](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a>默认的对象 ToString ( # A1 方法  
 方法的默认实现 <xref:System.Object.ToString%2A> 返回的类型的完全限定名称 <xref:System.Object> ，如下面的示例所示。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb" id="Snippet1":::
  
 由于 <xref:System.Object> 是 .NET Framework 中所有引用类型的基类，因此此行为是由不重写方法的引用类型继承的 <xref:System.Object.ToString%2A> 。 下面的示例对此进行了演示。 它定义一个名为 `Object1` 的类，该类接受所有成员的默认实现 <xref:System.Object> 。 其 <xref:System.Object.ToString%2A> 方法返回对象的完全限定类型名称。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp" id="Snippet2":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb" id="Snippet2":::  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a>重写对象 ToString ( # A1 方法  
 类型通常会重写 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法以返回表示对象实例的字符串。 例如，基类型（如 <xref:System.Char> 、和） <xref:System.Int32> <xref:System.String> 提供 <xref:System.Object.ToString%2A> 的实现返回对象所表示的值的字符串形式。 下面的示例定义了一个类， `Object2` 用于重写 <xref:System.Object.ToString%2A> 方法以返回类型名称及其值。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp" id="Snippet3":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb" id="Snippet3":::
  
 下表列出了 .NET 中的类型类别，并指示它们是否重写 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法。  
  
|类型类别|重写对象 ToString ( # A1|行为|  
|-------------------|-----------------------------------|--------------|  
|类|不适用|不适用|  
|结构|是 (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>) |与 `Object.ToString()` 相同|  
|枚举|是 (<xref:System.Enum.ToString?displayProperty=nameWithType>) |成员名称|  
|接口|否|不适用|  
|委托|否|不适用|  
  
 有关替代的其他信息，请参阅对继承者的说明部分 <xref:System.Object.ToString%2A> 。  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a>重载 ToString 方法  
 除了重写无参数的 <xref:System.Object.ToString?displayProperty=nameWithType> 方法之外，许多类型还重载 `ToString` 方法以提供接受参数的方法的版本。 最常见的是，这样做是为了提供对可变格式设置和区分区域性的格式设置的支持。  
  
 下面的示例重载 `ToString` 方法以返回一个结果字符串，其中包含类的各个字段的值 `Automobile` 。 它定义了四个格式字符串： G，它返回模型名称和年份;D：返回模型名称、年份和门的数量;C，返回柱面的名称、年份和数量;和，返回包含所有四个字段值的字符串。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs" interactive="try-dotnet" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb" id="Snippet4"::: 
  
 下面的示例调用重载 <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 的方法，以显示货币值的区分区域性的格式设置。  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 有关格式字符串和区分区域性的格式设置的详细信息，请参阅 [格式设置类型](/dotnet/standard/base-types/formatting-types)。 有关数字值支持的格式字符串，请参阅 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 和 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。 有关日期和时间值支持的格式字符串，请参阅 [标准日期和时间格式字符串](/dotnet/standard/base-types/standard-date-and-time-format-strings) 和 [自定义日期和时间格式字符串](/dotnet/standard/base-types/custom-date-and-time-format-strings)。  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a>扩展对象 ToString 方法  
 因为类型继承了默认 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法，所以你可能会发现它不需要的行为，并需要对其进行更改。 这对于数组和集合类尤其如此。 尽管可能需要 `ToString` 数组或集合类的方法来显示其成员的值，但它将显示类型完全限定的类型名称，如下面的示例所示。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs" interactive="try-dotnet-method" id="Snippet6":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb" id="Snippet6":::
  
 您可以使用多个选项来生成所需的结果字符串。  
  
-   如果类型是数组、集合对象或实现 <xref:System.Collections.IEnumerable> 或接口的对象 <xref:System.Collections.Generic.IEnumerable%601> ，则可以使用 `foreach` c # 中的语句或 Visual Basic 中的构造来枚举其元素 `For Each...Next` 。  
  
-   如果类不 `sealed` 在 c # 中 () 或 `NotInheritable` (Visual Basic) 中，则可以开发从要自定义其方法的基类继承的包装类 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 。 至少需要执行以下操作：  
  
    1.  实现任何所需的构造函数。 派生类不继承它们的基类构造函数。  
  
    2.  重写 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法以返回所需的结果字符串。  
  
     下面的示例定义了类的包装类 <xref:System.Collections.Generic.List%601> 。 它重写 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法，以显示集合的每个方法的值，而不是完全限定的类型名称。  
  
     :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs" interactive="try-dotnet" id="Snippet7":::
     :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb" id="Snippet7"::: 
  
-   开发可返回所需结果字符串的 [扩展方法](/dotnet/standard/design-guidelines/extension-methods) 。 请注意，不能 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 以这种方式重写默认方法 (即，c ) # 中的扩展类 (，Visual Basic 中的模块 (不能有一个名为的无参数方法 `ToString` ，可以调用该方法来代替原始类型的 `ToString` 方法。 必须为无参数替换提供其他名称 `ToString` 。  
  
     下面的示例定义扩展类的两个方法 <xref:System.Collections.Generic.List%601> ：一个无参数的 `ToString2` 方法，以及一个 `ToString` 具有 <xref:System.String> 表示格式字符串的参数的方法。  
  
     :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs" interactive="try-dotnet" id="Snippet8":::
     :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb" id="Snippet8"::: 
  
<a name="WinRT"></a>   
## <a name="notes-for-the-wrt"></a>说明 [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 当你在 <xref:System.Object.ToString%2A> 中的类上调用方法时 [!INCLUDE[wrt](~/includes/wrt-md.md)] ，它将为不重写的类提供默认行为 <xref:System.Object.ToString%2A> 。 这是 .NET Framework 为 (提供的支持的一部分 [!INCLUDE[wrt](~/includes/wrt-md.md)] ，请参阅 [Windows 应用商店应用的 .NET Framework 支持和) Windows 运行时](/dotnet/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime) 。 中的类 [!INCLUDE[wrt](~/includes/wrt-md.md)] 不会继承 <xref:System.Object> ，也不总是实现 <xref:System.Object.ToString%2A> 。 但是， <xref:System.Object.ToString%2A> <xref:System.Object.Equals%28System.Object%29> <xref:System.Object.GetHashCode%2A> 当你在 c # 或 Visual Basic 代码中使用它们时，它们始终具有、和方法，而 .NET Framework 提供这些方法的默认行为。  
  
 从开始 [!INCLUDE[net_v451](~/includes/net-v451-md.md)] ，公共语言运行时将对对象使用 [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) ， [!INCLUDE[wrt](~/includes/wrt-md.md)] 然后再回退到的默认实现 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 。  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] 用 c # 或 Visual Basic 编写的类可以重写 <xref:System.Object.ToString%2A> 方法。  
  
### <a name="the-wrt-and-the-istringable-interface"></a>[!INCLUDE[wrt](~/includes/wrt-md.md)]和 IStringable 接口  
 从开始 [!INCLUDE[win81](~/includes/win81-md.md)] ， [!INCLUDE[wrt](~/includes/wrt-md.md)] 包含一个 [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 接口，该接口的单一方法 [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)提供与提供的基本格式设置支持 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 。 若要防止歧义，不应在托管类型上实现 [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 。  
  
 当本机代码或使用 JavaScript 或 c + +/CX 等语言编写的代码调用托管对象时，它们似乎实现了 [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)。 公共语言运行时将从 [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) 到的调用自动将调用路由到， <xref:System.Object.ToString%2A?displayProperty=nameWithType> 事件 [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 未在托管对象上实现。  
  
> [!WARNING]
>  由于公共语言运行时自动实现应用中所有托管类型的 [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) ，因此， [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] 我们建议你不要提供自己的 [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 实现。 在[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) `ToString` 从 [!INCLUDE[wrt](~/includes/wrt-md.md)] 、c + +/cx 或 JavaScript 调用时，实现 IStringable 可能会导致意外的行为。  
  
 如果选择在组件中导出的公共托管类型中实现 [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) [!INCLUDE[wrt](~/includes/wrt-md.md)] ，则以下限制适用：  
  
- 你只能在 "类实现" 关系中定义 [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 接口，如下所示：

    ```csharp
    public class NewClass : IStringable
    ```

    ```vb
    Public Class NewClass : Implements IStringable
    ```

-   无法在接口上实现 [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 。  
  
-   不能将参数声明为 [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)类型。  
  
-   [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 不能是方法、属性或字段的返回类型。  
  
-   你无法通过使用如下所示的方法定义，从基类中隐藏 [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 实现：  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     相反， [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) 实现必须始终重写基类实现。 只能通过对强类型类实例调用 `ToString` 实现来隐藏该实现。  
  
 请注意，在各种条件下，从本机代码到实现 [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 或隐藏其 [ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) 实现的托管类型的调用可能会产生意外行为。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>实现自己的类型时，应重写 <see cref="M:System.Object.ToString" /> 方法以返回对这些类型有意义的值。 需要更好地控制格式设置的派生类 <see cref="M:System.Object.ToString" /> 可以实现 <see cref="T:System.IFormattable" /> 接口。 它的 <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> 方法使你能够定义用于控制格式设置的格式字符串，并使用 <see cref="T:System.IFormatProvider" /> 可为区域性特定的格式设置提供的对象。  
  
方法的重写 <see cref="M:System.Object.ToString" /> 应遵循以下准则： 
-返回的字符串应该是友好的，可供人们阅读。  
  
-返回的字符串应唯一标识对象实例的值。  
  
-返回的字符串应尽可能短，以便调试器能够显示它。  
  
- <see cref="M:System.Object.ToString" /> 重写不应返回 <see cref="F:System.String.Empty" /> 或为空字符串。  
  
- <see cref="M:System.Object.ToString" /> 重写不应引发异常。  
  
-如果实例的字符串表示形式区分区域性或可通过多种方式进行格式化，则实现 <see cref="T:System.IFormattable" /> 接口。  
  
-如果返回的字符串包含敏感信息，则应首先请求适当的权限。 如果请求成功，则可以返回敏感信息;否则，应返回排除敏感信息的字符串。  
  
- <see cref="M:System.Object.ToString" /> 重写应没有可观察到的副作用，以避免调试中的复杂。 例如，对方法的调用 <see cref="M:System.Object.ToString" /> 不应更改实例字段的值。  
  
-如果你的类型 (或 <see langword="Parse" /> 或 <see langword="TryParse" /> 方法、构造函数或从字符串) 实例化类型实例的其他静态方法实现分析方法，则应确保该方法返回的字符串 <see cref="M:System.Object.ToString" /> 可转换为对象实例。</para></block>
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">设置 .NET 中类型的格式</related>
      </Docs>
    </Member>
  </Members>
</Type>
