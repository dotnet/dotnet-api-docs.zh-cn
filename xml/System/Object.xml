<Type Name="Object" FullName="System.Object">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bb7e4f2ce5b003cab655e3d4e9cae3be04676b41" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83899244" /></Metadata><TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit object" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>支持 .NET 类层次结构中的所有类，并为派生类提供低级别服务。 这是所有 .NET 类的最终基类；它是类型层次结构的根。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 语言通常不需要类声明从 <xref:System.Object> 继承，因为继承是隐式的。  
  
 由于 .NET 中的所有类均派生自 <xref:System.Object>，因此在 <xref:System.Object> 类中定义的每个方法都可用于系统中的所有对象。 派生类可以和重写其中一些方法，其中包括：  
  
-   <xref:System.Object.Equals%2A>-支持对象之间的比较。  
  
-   <xref:System.Object.Finalize%2A>-在自动回收对象之前执行清理操作。  
  
-   <xref:System.Object.GetHashCode%2A>-生成与对象的值相对应的数字以支持使用哈希表。  
  
-   <xref:System.Object.ToString%2A> 制造描述类的实例的用户可读文本字符串。  
  
## <a name="performance-considerations"></a>性能注意事项  
 如果要设计的类（如集合）必须处理任何类型的对象，则可以创建接受 <xref:System.Object> 类的实例的类成员。 但是，对类型进行装箱和取消装箱的过程会产生性能开销。 如果你知道新类将经常处理某些值类型，则可以使用以下两种策略之一来最大程度地减少装箱成本。  
  
-   创建接受 <xref:System.Object> 类型的常规方法，并创建一组特定于类型的方法重载，这些重载接受你希望类经常处理的每个值类型。 如果存在接受调用参数类型的特定于类型的方法，则不会发生任何装箱并调用类型特定的方法。 如果没有与调用参数类型匹配的方法参数，则将参数装箱，并调用常规方法。  
  
-   将类型及其成员设计为使用泛型。 当你创建类的实例并指定泛型类型参数时，公共语言运行时将创建一个封闭式泛型类型。 泛型方法是类型特定的，可以在不装箱调用参数的情况下调用。  
  
 尽管有时需要开发接受和返回 <xref:System.Object> 类型的通用类，但你可以通过提供特定于类型的类来处理常用类型，从而提高性能。 例如，提供特定于设置和获取布尔值的类可消除装箱和取消装箱布尔值的成本。  
  
   
  
## Examples  
 下面的示例定义派生自 <xref:System.Object> 类的点类型，并重写 <xref:System.Object> 类的许多虚方法。 此外，该示例还演示了如何调用 <xref:System.Object> 类的许多静态和实例方法。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs" interactive="try-dotnet" id="snippet1":::
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp" id="snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb" id="snippet1":::
  
 ]]></format>
    </remarks>
    <threadsafe>此类型的公共静态（<see langword="Shared" /> Visual Basic）成员是线程安全的。 实例成员不一定是线程安全的。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Object" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数由派生类中的构造函数调用，但也可用于直接创建 <xref:System.Object> 类的实例。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定两个对象实例是否相等。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要与当前对象进行比较的对象。</param>
        <summary>确定指定的对象是否等于当前对象。</summary>
        <returns>如果指定的对象等于当前对象，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前实例与 `obj` 参数之间的比较类型取决于当前实例是引用类型还是值类型。  

-   如果当前实例是引用类型，则 <xref:System.Object.Equals%28System.Object%29> 方法会测试引用相等性，调用 <xref:System.Object.Equals%28System.Object%29> 方法等效于对 <xref:System.Object.ReferenceEquals%2A> 方法的调用。 引用相等性意味着比较的对象变量引用相同的对象。 下面的示例说明了此类比较的结果。 它定义了一个 `Person` 类，该类是一个引用类型，它调用 `Person` 类构造函数来实例化两个新的 `Person` 对象 `person2``person1a`，这些对象具有相同的值。 它还将 `person1a` 分配给另一个对象变量，`person1b`。 如示例的输出所示，`person1a` 和 `person1b` 相等，因为它们引用相同的对象。 但 `person1a` 和 `person2` 不相等，尽管它们具有相同的值。  
  
     :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs" interactive="try-dotnet" id="Snippet2":::
     :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb" id="Snippet2":::
  
-   如果当前实例是值类型，则 <xref:System.Object.Equals%28System.Object%29> 方法会测试值是否相等。 值相等性意味着：  
  
    -   这两个对象属于同一类型。 如下面的示例所示，值为12的 <xref:System.Byte> 对象不等于值为12的 <xref:System.Int32> 对象，因为这两个对象具有不同的运行时类型。  
  
         :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs" interactive="try-dotnet-method" id="Snippet3":::
         :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb" id="Snippet3":::
  
    -   这两个对象的公共字段和私有字段的值相等。 下面的示例测试值是否相等。 它定义了一个 `Person` 结构，它是一个值类型，并调用 `Person` 类构造函数来实例化两个新的 `Person` 对象 `person2``person1`，它们具有相同的值。 如示例中的输出所示，尽管这两个对象变量引用不同对象，但 `person1` 和 `person2` 相等，因为它们与专用 `personName` 字段具有相同的值。  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)] 
  
 由于 <xref:System.Object> 类是 .NET Framework 中所有类型的基类，因此 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 方法提供所有其他类型的默认相等比较。 但类型经常会重写 <xref:System.Object.Equals%2A> 方法以实现值相等性。 有关详细信息，请参阅调用方的说明和对继承者的说明部分。  
  
## <a name="notes-for-the-wrt"></a>[!INCLUDE[wrt](~/includes/wrt-md.md)] 的说明  
 当对 [!INCLUDE[wrt](~/includes/wrt-md.md)]中的类调用 <xref:System.Object.Equals%28System.Object%29> 方法重载时，它将为不重写 <xref:System.Object.Equals%28System.Object%29>的类提供默认行为。 这是 .NET Framework 为 [!INCLUDE[wrt](~/includes/wrt-md.md)] 提供的支持的一部分（请参阅[Windows 应用商店应用和 Windows 运行时 .NET Framework 支持](/dotnet/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime)）。 [!INCLUDE[wrt](~/includes/wrt-md.md)] 中的类不会继承 <xref:System.Object>，当前未实现 <xref:System.Object.Equals%28System.Object%29> 方法。 但是，当你在C#或 Visual Basic 代码中使用它们时，它们看起来有 <xref:System.Object.ToString%2A>、<xref:System.Object.Equals%28System.Object%29>和 <xref:System.Object.GetHashCode%2A> 方法，而 .NET Framework 提供这些方法的默认行为。  
  
> [!NOTE]
>  用 Visual Basic C#或编写的 [!INCLUDE[wrt](~/includes/wrt-md.md)] 类可以重写 <xref:System.Object.Equals%28System.Object%29> 方法重载。  
  
## <a name="notes-for-callers"></a>调用方说明  
 派生类经常重写 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 方法以实现值相等性。 此外，类型通常还向 `Equals` 方法提供附加的强类型重载，通常通过实现 <xref:System.IEquatable%601> 接口。 当调用 `Equals` 方法来测试相等性时，应了解当前实例是否重写 <xref:System.Object.Equals%2A?displayProperty=nameWithType> 并了解如何解析对 `Equals` 方法的特定调用。 否则，你可能会执行与预期不同的相等性测试，方法可能会返回意外值。  
  
 下面的示例进行了这方面的演示。 它实例化三个具有相同字符串的 <xref:System.Text.StringBuilder> 对象，然后对 `Equals` 方法进行四次调用。 第一个方法调用返回 `true`，其余三个返回 `false`。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs" interactive="try-dotnet" id="Snippet5":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb" id="Snippet5":::
  
 在第一种情况下，将调用强类型化 <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> 方法重载来测试值相等性。 由于分配给这两个 <xref:System.Text.StringBuilder> 对象的字符串相等，因此该方法返回 `true`。 但 <xref:System.Text.StringBuilder> 不会覆盖 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>。 因此，将 <xref:System.Text.StringBuilder> 对象强制转换为 <xref:System.Object>时，如果将 <xref:System.Text.StringBuilder> 实例分配给类型 <xref:System.Object>的变量，并且 <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> 方法传递两个 <xref:System.Text.StringBuilder> 对象，则将调用默认的 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 方法。 由于 <xref:System.Text.StringBuilder> 是引用类型，因此这等效于将两个 <xref:System.Text.StringBuilder> 对象传递到 <xref:System.Object.ReferenceEquals%2A> 方法。 尽管所有三个 <xref:System.Text.StringBuilder> 对象都包含相同的字符串，但是它们引用三个不同的对象。 因此，这三个方法调用返回 `false`。  
  
 可以通过调用 <xref:System.Object.ReferenceEquals%2A> 方法，将当前的对象与另一个对象进行比较以便引用相等性。 在 Visual Basic 中，还可以使用 `is` 关键字（例如 `If Me Is otherObject Then ...`）。  
  
## <a name="notes-for-inheritors"></a>对继承者的说明  
 定义自己的类型时，该类型将继承其基类型的 `Equals` 方法所定义的功能。 下表列出了 .NET Framework 中类型的主要类别的 `Equals` 方法的默认实现。  
  
|类型类别|定义的相等|注释|  
|-------------------|-------------------------|--------------|  
|直接从中派生的类 <xref:System.Object>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|引用相等性;等效于调用 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>。|  
|结构|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|值相等性;使用反射直接进行逐字节比较或逐字段比较。|  
|枚举|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|值必须具有相同的枚举类型和基础值。|  
|委托|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|委托必须具有相同的调用列表类型。|  
|接口|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|引用相等性。|  
  
 对于值类型，应始终重写 <xref:System.Object.Equals%2A>，因为依赖于反射的相等性测试会降低性能。 您还可以重写引用类型 <xref:System.Object.Equals%2A> 的默认实现，以测试值相等性而不是引用相等性，并定义值相等性的精确含义。 如果两个对象具有相同的值，则此类实现 <xref:System.Object.Equals%2A> 返回 `true`，即使它们不是相同的实例。 类型的实施器决定对象的值是什么，但它通常是存储在对象的实例变量中的部分或全部数据。 例如，<xref:System.String> 对象的值基于字符串的字符;<xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> 方法将重写 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 方法，以便为任意两个具有相同顺序的相同字符的字符串实例返回 `true`。  
  
 下面的示例演示如何重写 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 方法来测试值相等性。 它重写 `Person` 类的 <xref:System.Object.Equals%2A> 方法。 如果 `Person` 接受其相等的基类实现，则只有当两个 `Person` 对象引用单个对象时，它们才相等。 但是，在这种情况下，如果两个 `Person` 对象的 `Person.Id` 属性值相同，则两个对象相等。  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
   
 除了重写 <xref:System.Object.Equals%2A>之外，还可以实现 <xref:System.IEquatable%601> 接口，以提供强类型化的相等性测试。  
  
 对于 <xref:System.Object.Equals%28System.Object%29> 方法的所有实现，以下语句必须为 true。 在列表中，`x`、`y`和 `z` 表示不**为 null**的对象引用。  
  
-   `x.Equals(x)` 返回 `true`，但涉及浮点类型的情况除外。 请参阅[ISO/IEC/IEEE 60559:2011，信息技术--微处理器系统-浮点运算](https://www.iso.org/standard/57469.html)。  
  
-   `x.Equals(y)` 返回与 `y.Equals(x)` 相同的值。  
  
-   如果 `x` 和 `y` 均 `NaN`，则 `x.Equals(y)` 返回 `true`。  
  
-   如果 `(x.Equals(y) && y.Equals(z))` 返回 `true`，则 `x.Equals(z)` 返回 `true`。  
  
-   如果不修改 `x` 和 `y` 引用的对象，则对 `x.Equals(y)` 的后续调用将返回相同的值。  
  
-   `x.Equals(null)` 返回 `false`。  
  
 <xref:System.Object.Equals%2A> 的实现不得引发异常;它们应始终返回值。 例如，如果 `null``obj`，则 <xref:System.Object.Equals%2A> 方法应返回 `false`，而不是引发 <xref:System.ArgumentNullException>。  
  
 覆盖 <xref:System.Object.Equals%28System.Object%29>时，请遵循以下准则：  
  
-   实现 <xref:System.IComparable> 的类型必须重写 <xref:System.Object.Equals%28System.Object%29>。  
  
-   重写 <xref:System.Object.Equals%28System.Object%29> 的类型还必须重写 <xref:System.Object.GetHashCode%2A>;否则，哈希表可能无法正常工作。  
  
-   应考虑实现 <xref:System.IEquatable%601> 接口，以支持强类型化测试是否相等。 <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> 实现应返回与 <xref:System.Object.Equals%2A>一致的结果。  
  
-   如果你的编程语言支持运算符重载，并且你重载给定类型的相等运算符，则还必须重写 <xref:System.Object.Equals%28System.Object%29> 方法才能返回与相等运算符相同的结果。 这有助于确保使用 <xref:System.Object.Equals%2A> （如 <xref:System.Collections.ArrayList> 和 <xref:System.Collections.Hashtable>）的类库代码的行为与应用程序代码使用相等运算符的方式一致。  
  
### <a name="guidelines-for-reference-types"></a>引用类型的准则  
 以下准则适用于替代引用类型的 <xref:System.Object.Equals%28System.Object%29>：  
  
-   如果类型的语义基于该类型表示某个值的情况，请考虑重写 <xref:System.Object.Equals%2A>。  
  
-   大多数引用类型不得重载相等运算符，即使它们重写 <xref:System.Object.Equals%2A>也是如此。 但是，如果要实现的引用类型应具有值语义（如复数类型），则必须重写相等运算符。  
  
-   不应覆盖可变引用类型上的 <xref:System.Object.Equals%2A>。 这是因为，重写 <xref:System.Object.Equals%2A> 要求你还重写 <xref:System.Object.GetHashCode%2A> 方法，如前一部分中所述。 这意味着可变引用类型的实例的哈希代码在其生存期内可能会更改，这可能会导致对象在哈希表中丢失。  
  
### <a name="guidelines-for-value-types"></a>值类型的准则  
 以下准则适用于重写值类型的 <xref:System.Object.Equals%28System.Object%29>：  
  
-   如果要定义包含一个或多个值为引用类型的字段的值类型，则应重写 <xref:System.Object.Equals%28System.Object%29>。 <xref:System.ValueType> 提供的 <xref:System.Object.Equals%28System.Object%29> 实现为其字段为所有值类型的值类型执行逐字节的比较，但它使用反射来执行字段包含引用类型的值类型的逐字段比较。  
  
-   如果重写 <xref:System.Object.Equals%2A> 并且开发语言支持运算符重载，则必须重载相等运算符。  
  
-   应该实现 <xref:System.IEquatable%601> 接口。 调用强类型 <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> 方法可避免对 `obj` 参数进行装箱。  
  
   
  
## Examples  
 下面的示例演示一个 `Point` 类，该类重写 <xref:System.Object.Equals%2A> 方法以提供值相等性，以及一个派生自 `Point`的 `Point3D` 类。 由于 `Point` 重写 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 来测试值相等性，因此不会调用 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 方法。 但 `Point3D.Equals` 调用 `Point.Equals`，因为 `Point` 以提供值相等性的方式实现 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb" id="Snippet1":::
  
 `Point.Equals` 方法将进行检查以确保 `obj` 参数不为**null** ，并且它引用与此对象相同的类型的实例。 如果任一检查失败，则该方法将返回 `false`。  
  
 `Point.Equals` 方法调用 <xref:System.Object.GetType%2A> 方法来确定两个对象的运行时类型是否相同。 如果该方法使用了窗体 `obj is Point` in C#或 `TryCast(obj, Point)` Visual Basic 的检查，则该检查将在 `obj` 为 `Point`派生类的实例的情况下返回 `true`，即使 `obj` 和当前实例的运行时类型不相同也是如此。 验证两个对象的类型是否相同，方法将 `obj` 转换为类型 `Point`，并返回比较两个对象的实例字段的结果。  
  
 在 `Point3D.Equals`中，将在执行任何其他操作之前调用继承 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>的继承 `Point.Equals` 方法。 因为`Point3D`是一个密封的类 (在 Visual Basic 中为 `NotInheritable`)，签入窗体`obj is Point`C# 中或`TryCast(obj, Point)`在 Visual Basic 中是足以确保`obj`是`Point3D`对象。 如果它是 `Point3D` 对象，则会将其强制转换为 `Point` 对象，并传递给 <xref:System.Object.Equals%2A>的基类实现。 仅当继承的 `Point.Equals` 方法返回时 `true` 方法会比较派生类中引入的 `z` 实例字段。  
  
 下面的示例定义了一个 `Rectangle` 类，该类在内部实现一个矩形作为两个 `Point` 对象。 `Rectangle` 类还将重写 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 以提供值相等性。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb" id="Snippet1":::

 某些语言（如C#和） Visual Basic 支持运算符重载。 当类型重载相等运算符时，它还必须重写 <xref:System.Object.Equals%28System.Object%29> 方法才能提供相同的功能。 这通常通过使用重载的相等运算符编写 <xref:System.Object.Equals%28System.Object%29> 方法来完成，如下面的示例中所示。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb" id="Snippet1":::
  
 由于 `Complex` 是值类型，因此不能从派生。  因此，<xref:System.Object.Equals%28System.Object%29> 方法的重写不需要调用 <xref:System.Object.GetType%2A> 来确定每个对象的确切运行时类型，但可以改为使用中C#的 `is` 运算符或 Visual Basic 中的 `TypeOf` 运算符来检查 `obj` 参数的类型。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">要比较的第一个对象。</param>
        <param name="objB">要比较的第二个对象。</param>
        <summary>确定指定的对象实例是否被视为相等。</summary>
        <returns>如果对象被视为相等，则为 <see langword="true" />，否则为 <see langword="false" />。 如果 <paramref name="objA" /> 和 <paramref name="objB" /> 均为 null，此方法返回 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 静态 <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> 方法指示两个对象 `objA` 和 `objB`是否相等。 它还使你能够测试值为**null**的对象是否相等。 它比较 `objA` 和 `objB` 的相等性，如下所示：  
  
-   它确定两个对象是否表示相同的对象引用。 如果是这样，该方法将返回 `true`。 此测试等效于调用 <xref:System.Object.ReferenceEquals%2A> 方法。 此外，如果 `objA` 和 `objB` 均为**null**，则该方法返回 `true`。  
  
-   它确定 `objA` 或 `objB` 是否为**null**。 如果是，它将返回 `false`。  
  
-   如果两个对象不表示相同的对象引用，并且两者都不为**null**，则将调用 `objA`。`Equals`（`objB`）并返回结果。 这意味着，如果 `objA` 重写 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 方法，则调用此重写。  
  
   
  
## Examples  
 下面的示例演示 <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> 方法，并将其与 <xref:System.Object.ReferenceEquals%2A> 方法进行比较。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb" id="Snippet1"::: 
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Finalize() cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在垃圾回收将某一对象回收前允许该对象尝试释放资源并执行其他清理操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.Finalize%2A> 方法用于在销毁对象之前对当前对象占用的非托管资源执行清理操作。 方法是受保护的，因此只能通过此类或派生类访问。  
  
 本节内容：  
  
-   [终止的工作方式](#How)  
  
-   [实施者注意事项](#Notes)  
  
-   [SafeHandle 替代项](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a>终止的工作方式  
 <xref:System.Object> 类不提供 <xref:System.Object.Finalize%2A> 方法的实现，垃圾回收器不会将从 <xref:System.Object> 派生的类型标记为完成，除非它们重写 <xref:System.Object.Finalize%2A> 方法。  
  
 如果某个类型确实重写 <xref:System.Object.Finalize%2A> 方法，则垃圾回收器会将该类型的每个实例的条目添加到称为终止队列的内部结构。 终止队列包含托管堆中的所有对象的条目，在垃圾回收器可以回收内存之前，必须先运行终止代码。 然后，垃圾回收器会在以下条件下自动调用 <xref:System.Object.Finalize%2A> 方法：  
  
-   在垃圾回收器发现对象不可访问后，除非已通过调用 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> 方法免除了该对象的终止。  
  
-   **仅在 .NET Framework**的情况下，在应用程序域的关闭过程中，除非该对象免于终止。 在关闭期间，即使仍可访问的对象也会完成。  
  
 仅在给定的实例上自动调用 <xref:System.Object.Finalize%2A> 一次，除非该对象是使用 <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> 的机制重新注册的，并且尚未随后调用 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> 方法。  
  
 <xref:System.Object.Finalize%2A> 操作具有以下限制：  
  
-   不确定终结器执行时的准确时间。 若要确保类的实例的资源的确定性版本，请实现 `Close` 方法或提供 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 实现。  
  
-   不能保证两个对象的终结器以任何特定顺序运行，即使一个对象引用另一个对象也是如此。 也就是说，如果对象 A 具有对对象 B 的引用，并且都具有终结器，	在对象 A 的终结器启动时，对象 B 可能已被终结。  
  
-   不指定终结器在其上运行的线程。  
  
 在以下异常情况下，<xref:System.Object.Finalize%2A> 方法可能不会运行完成，也可能根本不会运行：  
  
-   如果另一个终结器无限期阻止（进入无限循环，则会尝试获取它永远无法获取的锁定，等等）。 因为运行时尝试运行终结器来完成，所以如果终结器无限期阻塞，则可能不会调用其他终结器。  
  
-   如果进程终止，无需给运行时提供清理的机会。 在这种情况下，运行时的进程终止通知是 DLL_PROCESS_DETACH 通知。  
  
 仅在关闭过程中，运行时继续完成对象，但可继续减少可终结对象的数量。  
  
 如果 <xref:System.Object.Finalize%2A> 的 <xref:System.Object.Finalize%2A> 或重写引发异常，并且运行时不是由覆盖默认策略的应用程序承载，则运行时将终止进程，并且不会执行任何活动的 `try`/`finally` 块或终结器。 如果终结器无法释放或销毁资源，则此行为可确保进程完整性。  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a>重写 Finalize 方法 
 应为使用非托管资源的类（如文件句柄或数据库连接）重写 <xref:System.Object.Finalize%2A>，在垃圾回收过程中，当使用这些资源的托管对象被丢弃时必须释放这些资源。 不应为托管对象实现 <xref:System.Object.Finalize%2A> 方法，因为垃圾回收器会自动释放托管资源。  
  
> [!IMPORTANT]
>  如果 <xref:System.Runtime.InteropServices.SafeHandle> 对象可用来包装非托管资源，则建议的替代方法是使用安全句柄实现 dispose 模式，而不是重写 <xref:System.Object.Finalize%2A>。 有关详细信息，请参阅[SafeHandle 替代](#SafeHandle)部分。  
  
 默认情况下，<xref:System.Object.Finalize%2A?displayProperty=nameWithType> 方法不执行任何操作，但你应仅在必要时重写 <xref:System.Object.Finalize%2A>，并且仅释放非托管资源。 如果某个终止操作运行，则回收内存要花费更长时间，因为它需要至少两个垃圾回收。 此外，还应覆盖仅用于引用类型的 <xref:System.Object.Finalize%2A> 方法。 公共语言运行时仅终结引用类型。 它忽略值类型上的终结器。  

`protected`<xref:System.Object.Finalize%2A?displayProperty=nameWithType> 方法的作用域。 重写类中的方法时，应保持此有限范围。 通过保护 <xref:System.Object.Finalize%2A> 方法，你可以防止应用程序的用户直接调用对象的 <xref:System.Object.Finalize%2A> 方法。
  
 派生类型中 <xref:System.Object.Finalize%2A> 的每个实现都必须调用其基类型的 <xref:System.Object.Finalize%2A>实现。 这是允许应用程序代码调用 <xref:System.Object.Finalize%2A>的唯一情况。 对象的 <xref:System.Object.Finalize%2A> 方法不应在其基类以外的任何对象上调用方法。 这是因为调用的其他对象可以与调用对象同时收集，如公共语言运行时关闭的情况。 
  
> [!NOTE]
>  C#编译器不允许重写 <xref:System.Object.Finalize%2A> 方法。 而是通过实现类的[析构函数](/dotnet/csharp/programming-guide/classes-and-structs/destructors)来提供终结器。 C#析构函数自动调用其基类的析构函数。  
>   
>  视觉C++对象还提供其自己的语法来实现 <xref:System.Object.Finalize%2A> 方法。 有关详细信息，请参阅[如何：定义和使用类和结构C++（/cli）](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)中的 "析构函数和终结器" 一节。  
  
 由于垃圾回收是不确定的，因此，在垃圾回收器执行终止时，您不会精确地知道。 若要立即释放资源，还可以选择实现[dispose 模式](/dotnet/standard/garbage-collection/implementing-dispose)和 <xref:System.IDisposable> 接口。 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 实现可由类的使用者调用以释放非托管资源，并且可以在未调用 <xref:System.IDisposable.Dispose%2A> 方法的情况下，使用 <xref:System.Object.Finalize%2A> 方法释放非托管资源。  
  
 <xref:System.Object.Finalize%2A> 几乎可以执行任何操作，包括 resurrecting 一个对象（即，在垃圾回收过程中清除对象后使对象再次可访问）。 但是，对象只能复活一次;在垃圾回收过程中，不能在复活对象上调用 <xref:System.Object.Finalize%2A>。
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a>SafeHandle 备用方法  
 创建可靠终结器通常很难，因为你无法对应用程序的状态进行假设，并且因为未处理的系统异常（如 <xref:System.OutOfMemoryException> 和 <xref:System.StackOverflowException> 终止终结器）。 您可以使用从 <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> 类派生的对象来包装非托管资源，并在不使用终结器的情况下实现 dispose 模式，而不是为类实现终结器以释放非托管资源。 .NET Framework 提供从 <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>派生的 <xref:Microsoft.Win32?displayProperty=nameWithType> 命名空间中的以下类：  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 是文件句柄的包装类。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> 是内存映射的文件句柄的包装类。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> 是指向非托管内存块的指针的包装类。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>、<xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>和 <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> 是加密句柄的包装类。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> 是管道句柄的包装类。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> 是注册表项的句柄的包装类。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> 是等待句柄的包装类。  
  
 下面的示例将[dispose 模式](/dotnet/standard/garbage-collection/implementing-dispose)与安全句柄一起使用，而不是重写 <xref:System.Object.Finalize%2A> 方法。 它定义了一个 `FileAssociation` 类，该类包装有关处理具有特定文件扩展名的文件的应用程序的注册表信息。 由于 Windows [RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx)函数调用将 `out` 参数传递到 <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> 构造函数，因此返回了两个注册表句柄。 然后，该类型的受保护 `Dispose` 方法调用 `SafeRegistryHandle.Dispose` 方法来释放这两个句柄。  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 下面的示例验证当重写 <xref:System.Object.Finalize%2A> 的对象被销毁时调用 <xref:System.Object.Finalize%2A> 方法。 请注意，在生产应用程序中，将重写 <xref:System.Object.Finalize%2A> 方法，以释放由该对象占用的非托管资源。 另请注意， C#该示例提供析构函数，而不是重写 <xref:System.Object.Finalize%2A> 方法。  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 有关替代 <xref:System.Object.Finalize%2A> 方法的其他示例，请参阅 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> 方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>作为默认哈希函数。</summary>
        <returns>当前对象的哈希代码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 哈希代码是一个数字值，用于在基于哈希的集合（如 <xref:System.Collections.Generic.Dictionary%602> 类、<xref:System.Collections.Hashtable> 类或派生自 <xref:System.Collections.DictionaryBase> 类的类型）中插入和标识对象。 <xref:System.Object.GetHashCode%2A> 方法为需要快速检查对象相等性的算法提供此哈希代码。  
  
> [!NOTE]
>  有关哈希表中的哈希代码和其他哈希代码算法如何使用哈希代码的信息，请参阅维基百科中的[哈希函数](https://en.wikipedia.org/wiki/Hash_function)条目。  
  
 相等的两个对象返回的哈希代码相等。 但是，反之亦然：相等的哈希代码不意味着对象相等，因为不同（不相等）对象可以具有相同的哈希代码。 此外，.NET 不保证 <xref:System.Object.GetHashCode%2A> 方法的默认实现，并且此方法返回的值可能在 .NET 实现（例如不同版本的 .NET Framework 和 .NET Core）和平台（例如32位和64位平台）之间有所不同。 出于这些原因，请不要将此方法的默认实现用作唯一对象标识符以进行哈希处理。 下面是两个结果：  
  
-   不应假定相等哈希代码意味着对象相等。  
  
-   永远不应在创建它的应用程序域之外保留或使用哈希代码，因为相同的对象可能会在应用程序域、进程和平台之间进行哈希运算。  
  
> [!WARNING]
>  哈希代码适用于基于哈希表的集合中的高效插入和查找。 哈希代码不是永久值。 出于此原因：  
>   
> -   不要序列化哈希代码值或将其存储在数据库中。  
> -   不要使用哈希代码作为密钥来检索键控集合中的对象。  
> -   不要跨应用程序域或进程发送哈希代码。 在某些情况下，可以基于每个进程或每个应用程序域来计算哈希代码。  
> -   如果需要加密型强哈希，请不要使用哈希代码（而不是加密哈希函数返回的值）。 对于加密哈希，请使用派生自 <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> 或 <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> 类的类。  
> -   不要测试哈希代码是否相等，以确定两个对象是否相等。 （不相等的对象可以具有相同的哈希代码。）若要测试是否相等，请调用 <xref:System.Object.ReferenceEquals%2A> 或 <xref:System.Object.Equals%2A> 方法。  
  
 <xref:System.Object.GetHashCode%2A> 方法可由派生类型重写。 如果 <xref:System.Object.GetHashCode%2A> 未重写，则通过调用基类的 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 方法来计算引用类型的哈希代码，该方法根据对象的引用计算哈希代码;有关详细信息，请参阅 <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>。 换句话说，<xref:System.Object.ReferenceEquals%2A> 方法返回的两个对象 `true` 具有相同的哈希代码。 如果值类型不重写 <xref:System.Object.GetHashCode%2A>，则基类的 <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> 方法使用反射基于该类型字段的值来计算哈希代码。 换句话说，其字段具有相等值的值类型具有相同的哈希代码。 有关重写 <xref:System.Object.GetHashCode%2A>的详细信息，请参阅 "对继承者的说明" 部分。  
  
> [!WARNING]
>  如果重写 <xref:System.Object.GetHashCode%2A> 方法，则还应重写 <xref:System.Object.Equals%2A>，反之亦然。 如果重写的 <xref:System.Object.Equals%2A> 方法在测试两个对象是否相等时返回 `true`，则重写的 <xref:System.Object.GetHashCode%2A> 方法必须为这两个对象返回相同的值。  
  
 如果用作哈希表中的键的对象不提供 <xref:System.Object.GetHashCode%2A>的有用实现，则可以通过向 <xref:System.Collections.Hashtable> 类构造函数的重载之一提供 <xref:System.Collections.IEqualityComparer> 实现来指定哈希代码提供程序。  
  
## <a name="notes-for-the-wrt"></a>[!INCLUDE[wrt](~/includes/wrt-md.md)] 的说明  
 对 [!INCLUDE[wrt](~/includes/wrt-md.md)]中的类调用 <xref:System.Object.GetHashCode%2A> 方法时，它将为不重写 <xref:System.Object.GetHashCode%2A>的类提供默认行为。 这是 .NET Framework 为 [!INCLUDE[wrt](~/includes/wrt-md.md)] 提供的支持的一部分（请参阅[Windows 应用商店应用和 Windows 运行时 .NET Framework 支持](/dotnet/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime)）。 [!INCLUDE[wrt](~/includes/wrt-md.md)] 中的类不会继承 <xref:System.Object>，当前未实现 <xref:System.Object.GetHashCode%2A>。 但是，当你在C#或 Visual Basic 代码中使用它们时，它们看起来有 <xref:System.Object.ToString%2A>、<xref:System.Object.Equals%28System.Object%29>和 <xref:System.Object.GetHashCode%2A> 方法，而 .NET Framework 提供这些方法的默认行为。  
  
> [!NOTE]
>  用 Visual Basic C#或编写的 [!INCLUDE[wrt](~/includes/wrt-md.md)] 类可以重写 <xref:System.Object.GetHashCode%2A> 方法。  
  
   
  
## Examples  
 对于与 <xref:System.Int32> 类型具有相同或更小范围的数值，计算哈希代码的最简单方法之一是只返回该值。 下面的示例演示 `Number` 结构的实现。  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 通常，类型具有多个数据字段，这些字段可参与生成哈希代码。 生成哈希代码的一种方法是使用 `XOR (eXclusive OR)` 操作来合并这些字段，如以下示例中所示。  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 前面的示例返回相同的哈希代码（n1、n2）和（n2，n1），因此可能会产生比预期更多的冲突。 提供了许多解决方案，以便这些情况下的哈希代码不完全相同。 一种是返回 `Tuple` 对象的哈希代码，该对象反映每个字段的顺序。 下面的示例演示使用 <xref:System.Tuple%602> 类的可能的实现。 但请注意，实例化 `Tuple` 对象的性能开销可能会显著影响在哈希表中存储大量对象的应用程序的整体性能。  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 第二种替代解决方案涉及通过将连续字段的哈希代码左移两位或更多位，来加权单个哈希代码。 最佳情况下，超出位31的位应换行，而不是丢弃。 由于C#和 Visual Basic 中的左移运算符会丢弃 bits，这需要创建左移和换行方法，如下所示：  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 然后，下面的示例使用此 shift 和 wrap 方法计算前面的示例中使用的 `Point` 结构的哈希代码。  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>使用哈希函数可以快速生成与对象的值相对应的数字（哈希代码）。 哈希函数通常是特定于每个类型的，因此，为实现唯一性，必须使用至少一个实例字段作为输入。 不应使用静态字段的值来计算哈希代码。  
  
对于从 <see cref="T:System.Object" />派生的类，只有当派生类将相等性定义为引用相等性时，<see langword="GetHashCode" /> 方法才能将基类委托给基类 <see cref="M:System.Object.GetHashCode" /> 实现。 引用类型 <see cref="M:System.Object.GetHashCode" /> 的默认实现返回的哈希代码等效于 <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> 方法返回的哈希代码。 可以重写不可变引用类型的 <see cref="M:System.Object.GetHashCode" />。 通常，对于可变引用类型，应仅在以下情况下重写 <see cref="M:System.Object.GetHashCode" />： 
-可以计算不可变的字段中的哈希代码;或 
-可以确保可变对象的哈希代码在依赖于其哈希代码的集合中时不会更改。  
  
否则，你可能会认为可变对象会在哈希表中丢失。 如果选择替代可变引用类型的 <see cref="M:System.Object.GetHashCode" />，您的文档应清楚地说明，当对象存储在哈希表中时，您的类型的用户不应修改对象值。  
  
对于值类型，<see cref="M:System.ValueType.GetHashCode" /> 提供使用反射的默认哈希代码实现。 你应考虑重写它以获得更好的性能。  
  
 <block subset="none" type="note"><para>  
 有关以各种方式计算哈希代码的详细信息和示例，请参阅 "示例" 部分。  
  
</para></block>  
  
 哈希函数必须具有以下属性： 
-如果两个对象的比较结果相等，则每个对象的 <see cref="M:System.Object.GetHashCode" /> 方法必须返回相同的值。 但是，如果两个对象的比较结果不相等，则这两个对象的 <see cref="M:System.Object.GetHashCode" /> 方法不必返回不同的值。  
  
-对于对象状态不会修改确定对象的[system.object](xref:System.Object.Equals*)方法返回值的对象状态，对象的 <see cref="M:System.Object.GetHashCode" /> 方法必须始终返回相同的哈希代码。 请注意，这仅适用于当前执行的应用程序，并且如果重新运行应用程序，则可以返回不同的哈希代码。  
  
-为了获得最佳性能，哈希函数应为所有输入生成偶数分布，其中包括大量聚集输入。 这意味着，对对象状态的小修改应该会导致对生成的哈希代码进行较大的修改，以获得最佳的哈希表性能。  
  
-哈希函数的计算成本应较低。  
  
-<see cref="M:System.Object.GetHashCode" /> 方法不应引发异常。  
  
例如，<see cref="T:System.String" /> 类提供的 <see cref="M:System.String.GetHashCode" /> 方法的实现返回相同字符串值的相同哈希代码。 因此，如果两个 <see cref="T:System.String" /> 对象表示相同的字符串值，则它们将返回相同的哈希代码。 此外，该方法使用字符串中的所有字符生成合理的随机分发输出，即使在特定范围内对输入进行群集（例如，许多用户可能包含仅包含较低 128 ASCII 字符的字符串，即使字符串可以包含任何 65535 Unicode 字符）。  
  
在类上提供良好的哈希函数可能会显著影响将这些对象添加到哈希表的性能。 在具有提供哈希函数的良好实现的键的哈希表中，搜索元素会采用固定时间（例如，O （1）操作）。 如果哈希表中的哈希函数实现不佳，则搜索的性能取决于哈希表中的项数（例如，O （`n`）运算，其中 `n` 是哈希表中的项的数目）。 恶意用户可以输入增加冲突数量的数据，这可能会显著降低依赖于哈希表的应用程序的性能，但在以下情况下： 
-哈希函数产生频繁冲突。  
  
-当哈希表中的大量对象产生相等或近似相等的哈希代码时。  
  
-当用户输入从中计算哈希代码的数据时。  
  
重写 <see cref="M:System.Object.GetHashCode" /> 的派生类还必须重写 <see cref="M:System.Object.Equals(System.Object)" />，以保证视为相等的两个对象具有相同的哈希代码;否则，<see cref="T:System.Collections.Hashtable" /> 类型可能无法正常工作。</para></block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取当前实例的 <see cref="T:System.Type" />。</summary>
        <returns>当前实例的准确运行时类型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由于 <xref:System.Object?displayProperty=nameWithType> 是 .NET 类型系统中所有类型的基类，因此 <xref:System.Object.GetType%2A> 方法可用于返回表示所有 .NET 类型 <xref:System.Type> 对象。 .NET 可识别以下五类类型：  
  
-   派生自 <xref:System.Object?displayProperty=nameWithType>的类  
  
-   值类型，派生自 <xref:System.ValueType?displayProperty=nameWithType>。  
  
-   从 .NET Framework 2.0 开始 <xref:System.Object?displayProperty=nameWithType> 派生的接口。  
  
-   派生自 <xref:System.Enum?displayProperty=nameWithType>的枚举。  
  
-   委托，派生自 <xref:System.MulticastDelegate?displayProperty=nameWithType>。  
  
 对于具有相同运行时类型 `x` 和 `y` 的两个对象，`Object.ReferenceEquals(x.GetType(),y.GetType())` 返回 `true`。 下面的示例将 <xref:System.Object.GetType%2A> 方法与 <xref:System.Object.ReferenceEquals%2A> 方法一起使用，以确定一个数值是否为与另外两个数值相同的类型。  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb" id="Snippet1"::: 

> [!NOTE]
>  若要确定某个对象是否为特定类型，可以使用您的语言的类型比较关键字或构造。 例如，你可以在中C#使用 Visual Basic 或 `is` 关键字中的 `TypeOf…Is` 构造。  
  
 派生自 <xref:System.Object>的所有类型都继承 <xref:System.Object.GetType%2A> 方法。 这意味着，除了使用自己的语言的比较关键字外，还可以使用 <xref:System.Object.GetType%2A> 方法来确定特定对象的类型，如下面的示例所示。  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb" id="Snippet2":::
  
 <xref:System.Type> 对象公开与当前 <xref:System.Object>的类关联的元数据。  
  
   
  
## Examples  

 下面的代码示例演示 <xref:System.Object.GetType%2A> 返回当前实例的运行时类型。  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp" id="Snippet1"::: 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建当前 <see cref="T:System.Object" /> 的浅表副本。</summary>
        <returns>当前 <see cref="T:System.Object" /> 的浅表副本。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.MemberwiseClone%2A> 方法创建一个浅表副本，方法是创建一个新的对象，然后将当前对象的非静态字段复制到新的对象。 如果字段是值类型，则执行字段的逐位副本。 如果字段是引用类型，则会复制引用，但不会复制引用的对象;因此，原始对象及其复本引用相同的对象。  
  
 例如，假设有一个名为 X 的对象引用对象 A 和 B。对象 B 反过来引用对象 C。X 的浅表副本创建新的对象 X2，后者同时引用对象 A 和 B。与之相比，X 的深层副本会创建一个新的对象 X2，该对象引用作为 A 和 B 的副本的新对象 A2 和 B2，进而引用新的对象 C2，这是 C 的副本。该示例说明了浅层和深层复制操作之间的差异。  
  
 如果 <xref:System.Object.MemberwiseClone%2A> 方法执行的浅层复制操作无法满足您的需要，则可以通过多种方式实现深层复制操作。 其中包括：  
  
-   调用要复制的对象的类构造函数，以创建具有从第一个对象获取的属性值的第二个对象。 这假设对象的值由其类构造函数完全定义。  
  
-   调用 <xref:System.Object.MemberwiseClone%2A> 方法来创建对象的浅表副本，然后将新对象的值与原始对象的值与原始对象的值相同，以将其值作为引用类型的任何属性或字段。 该示例中的 `DeepCopy` 方法说明了这种方法。  
  
-   序列化要深层复制的对象，然后将序列化的数据还原到其他对象变量。  
  
-   使用带有递归的反射来执行深层复制操作。  
  
   
  
## Examples  
 下面的示例演示 <xref:System.Object.MemberwiseClone%2A> 方法。 它定义了一个 `ShallowCopy` 方法，该方法调用 <xref:System.Object.MemberwiseClone%2A> 方法对 `Person` 对象执行浅表复制操作。 它还定义了一个 `DeepCopy` 方法，该方法对 `Person` 对象执行深层复制操作。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb" id="Snippet1":::
  
 在此示例中，`Person.IdInfo` 属性返回一个 `IdInfo` 对象。 如示例中的输出所示，当通过调用 <xref:System.Object.MemberwiseClone%2A> 方法克隆 `Person` 对象时，克隆的 `Person` 对象是原始对象的独立副本，只不过它们共享相同的 `Person.IdInfo` 对象引用。 因此，修改克隆的 `Person.IdInfo` 属性会更改原始对象的 `Person.IdInfo` 属性。 另一方面，执行深层复制操作时，可以修改克隆的 `Person` 对象（包括其 `Person.IdInfo` 属性），而不会影响原始对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">要比较的第一个对象。</param>
        <param name="objB">要比较的第二个对象。</param>
        <summary>确定指定的 <see cref="T:System.Object" /> 实例是否是相同的实例。</summary>
        <returns>如果 <paramref name="objA" /> 是与 <paramref name="objB" /> 相同的实例，或两者均为 null，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与 <xref:System.Object.Equals%2A> 方法和相等运算符不同，<xref:System.Object.ReferenceEquals%2A> 方法不能被重写。 因此，如果要测试两个对象引用是否相等，并且不确定 `Equals` 方法的实现，则可以调用 <xref:System.Object.ReferenceEquals%2A> 方法。  
  
 但是，在这两种情况下，<xref:System.Object.ReferenceEquals%2A> 方法的返回值可能看起来是异常的：  
  
-   比较值类型时。 如果 `objA` 和 `objB` 是值类型，则在将其传递到 <xref:System.Object.ReferenceEquals%2A> 方法之前，会将这些值装箱。 这意味着，如果 `objA` 和 `objB` 表示值类型的同一个实例，则 <xref:System.Object.ReferenceEquals%2A> 方法仍返回 `false`，如以下示例所示。  
  
     [!code-csharp-interactive[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     有关装箱值类型的信息，请参阅[装箱和取消装箱](/dotnet/csharp/programming-guide/types/boxing-and-unboxing)。  
  
-   比较字符串时。 如果 `objA` 和 `objB` 为字符串，<xref:System.Object.ReferenceEquals%2A> 方法将在暂存字符串时返回 `true`。 它不会执行值相等性测试。  在下面的示例中，`s1` 和 `s2` 相等，因为它们是单个暂存字符串的两个实例。 但 `s3` 和 `s4` 不相等，因为虽然它们具有相同的字符串值，但不会暂存该字符串。  
  
     [!code-csharp-interactive[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     有关字符串暂留的详细信息，请参阅 <xref:System.String.IsInterned%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  

 下面的示例使用 <xref:System.Object.ReferenceEquals%2A> 来确定两个对象是否为同一个实例。  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp-interactive[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示当前对象的字符串。</summary>
        <returns>表示当前对象的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 是 .NET Framework 中的主要格式设置方法。 它将对象转换为其字符串表示形式，以便它适合于显示。 （有关 .NET Framework 中格式设置支持的信息，请参阅[格式设置类型](/dotnet/standard/base-types/formatting-types)。）<xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法的默认实现将返回对象类型的完全限定名称。  
  
> [!IMPORTANT]
>  您可能已通过从另一类型成员列表中的链接来访问此页。 这是因为该类型不会重写 <xref:System.Object.ToString%2A?displayProperty=nameWithType>。 相反，它会继承 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法的功能。  
  
 类型经常重写 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法，以提供更适合特定类型的字符串表示形式。 类型还经常重载 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法，以提供对格式字符串或区分区域性的格式设置的支持。  

 本节内容：  
  
 [默认的对象 ToString （）方法](#Default)   
 [重写对象 ToString （）方法](#Overriding)   
 [重载 ToString 方法](#Overloading)   
 [扩展对象 ToString 方法](#Extending)   
 [Windows 运行时的说明](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a>默认的对象 ToString （）方法  
 <xref:System.Object.ToString%2A> 方法的默认实现返回 <xref:System.Object>类型的完全限定名称，如下面的示例所示。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb" id="Snippet1":::
  
 由于 <xref:System.Object> 是 .NET Framework 中所有引用类型的基类，因此此行为是由不重写 <xref:System.Object.ToString%2A> 方法的引用类型继承的。 下面的示例阐释了这一点。 它定义了一个名为 `Object1` 的类，该类接受所有 <xref:System.Object> 成员的默认实现。 它的 <xref:System.Object.ToString%2A> 方法返回对象的完全限定类型名称。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp" id="Snippet2":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb" id="Snippet2":::  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a>重写对象 ToString （）方法  
 类型通常会重写 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法，以返回表示对象实例的字符串。 例如，基类型（如 <xref:System.Char>、<xref:System.Int32>和 <xref:System.String>）提供返回对象所表示的值的字符串形式的 <xref:System.Object.ToString%2A> 实现。 下面的示例定义了一个类，`Object2`，它重写 <xref:System.Object.ToString%2A> 方法以返回类型名称及其值。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp" id="Snippet3":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb" id="Snippet3":::
  
 下表列出了 .NET 中的类型类别，并指示它们是否覆盖 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法。  
  
|类型类别|重写对象 ToString （）|行为|  
|-------------------|-----------------------------------|--------------|  
|类|n/a|n/a|  
|结构|是 (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)|与 `Object.ToString()` 相同|  
|枚举|是 (<xref:System.Enum.ToString?displayProperty=nameWithType>)|成员名称|  
|接口|否|n/a|  
|委托|No|n/a|  
  
 有关替代 <xref:System.Object.ToString%2A>的其他信息，请参阅对继承者的说明部分。  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a>重载 ToString 方法  
 除了重写无参数 <xref:System.Object.ToString?displayProperty=nameWithType> 方法以外，许多类型还重载了 `ToString` 方法来提供接受参数的方法的版本。 最常见的是，这样做是为了提供对可变格式设置和区分区域性的格式设置的支持。  
  
 下面的示例重载 `ToString` 方法，以返回包含 `Automobile` 类的各种字段值的结果字符串。 它定义了四个格式字符串： G，它返回模型名称和年份;D：返回模型名称、年份和门的数量;C，返回柱面的名称、年份和数量;和，返回包含所有四个字段值的字符串。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs" interactive="try-dotnet" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb" id="Snippet4"::: 
  
 下面的示例调用重载的 <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 方法来显示货币值的区分区域性的格式设置。  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 有关格式字符串和区分区域性的格式设置的详细信息，请参阅[格式设置类型](/dotnet/standard/base-types/formatting-types)。 有关数字值支持的格式字符串，请参阅[标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings)和[自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。 有关日期和时间值支持的格式字符串，请参阅[标准日期和时间格式字符串](/dotnet/standard/base-types/standard-date-and-time-format-strings)和[自定义日期和时间格式字符串](/dotnet/standard/base-types/custom-date-and-time-format-strings)。  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a>扩展对象 ToString 方法  
 因为某一类型继承了默认 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法，所以你可能会发现它不需要的行为，并需要对其进行更改。 这对于数组和集合类尤其如此。 尽管可能需要数组或集合类的 `ToString` 方法来显示其成员的值，但它将显示类型完全限定的类型名称，如下面的示例所示。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs" interactive="try-dotnet-method" id="Snippet6":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb" id="Snippet6":::
  
 您可以使用多个选项来生成所需的结果字符串。  
  
-   如果类型是数组、集合对象或实现 <xref:System.Collections.IEnumerable> 或 <xref:System.Collections.Generic.IEnumerable%601> 接口的对象，则可以使用中C#的 `foreach` 语句或 Visual Basic 中的 `For Each...Next` 构造来枚举其元素。  
  
-   如果类不 `sealed` （在中C#）或 `NotInheritable` （在 Visual Basic 中），则可以开发从要自定义其 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法的基类继承的包装类。 至少需要执行以下操作：  
  
    1.  实现任何所需的构造函数。 派生类不继承它们的基类构造函数。  
  
    2.  重写 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法，以返回所需的结果字符串。  
  
     下面的示例定义了 <xref:System.Collections.Generic.List%601> 类的包装类。 它重写 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法，以显示集合的每个方法的值，而不是完全限定的类型名称。  
  
     :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs" interactive="try-dotnet" id="Snippet7":::
     :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb" id="Snippet7"::: 
  
-   开发可返回所需结果字符串的[扩展方法](/dotnet/standard/design-guidelines/extension-methods)。 请注意，不能以这种方式重写默认 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法（即，扩展类（in C#）或模块（在 Visual Basic 中）不能具有名为 `ToString` 的无参数方法，而调用该方法来代替原始类型的 `ToString` 方法。 必须为无参数 `ToString` 替换提供其他名称。  
  
     下面的示例定义了两个扩展 <xref:System.Collections.Generic.List%601> 类的方法：一个无参数 `ToString2` 方法，以及一个具有表示格式字符串的 <xref:System.String> 参数的 `ToString` 方法。  
  
     :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs" interactive="try-dotnet" id="Snippet8":::
     :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb" id="Snippet8"::: 
  
<a name="WinRT"></a>   
## <a name="notes-for-the-wrt"></a>[!INCLUDE[wrt](~/includes/wrt-md.md)] 的说明  
 对 [!INCLUDE[wrt](~/includes/wrt-md.md)]中的类调用 <xref:System.Object.ToString%2A> 方法时，它将为不重写 <xref:System.Object.ToString%2A>的类提供默认行为。 这是 .NET Framework 为 [!INCLUDE[wrt](~/includes/wrt-md.md)] 提供的支持的一部分（请参阅[Windows 应用商店应用和 Windows 运行时 .NET Framework 支持](/dotnet/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime)）。 [!INCLUDE[wrt](~/includes/wrt-md.md)] 中的类不会继承 <xref:System.Object>，并不总是实现 <xref:System.Object.ToString%2A>。 但是，当你在C#或 Visual Basic 代码中使用它们时，它们始终具有 <xref:System.Object.ToString%2A>、<xref:System.Object.Equals%28System.Object%29>和 <xref:System.Object.GetHashCode%2A> 方法，而 .NET Framework 提供这些方法的默认行为。  
  
 从 [!INCLUDE[net_v451](~/includes/net-v451-md.md)]开始，公共语言运行时将对 [!INCLUDE[wrt](~/includes/wrt-md.md)] 对象使用[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) ，然后再回退到 <xref:System.Object.ToString%2A?displayProperty=nameWithType>的默认实现。  
  
> [!NOTE]
>  用 Visual Basic C#或编写的 [!INCLUDE[wrt](~/includes/wrt-md.md)] 类可以重写 <xref:System.Object.ToString%2A> 方法。  
  
### <a name="the-wrt-and-the-istringable-interface"></a>[!INCLUDE[wrt](~/includes/wrt-md.md)] 和 IStringable 接口  
 从 [!INCLUDE[win81](~/includes/win81-md.md)]开始，[!INCLUDE[wrt](~/includes/wrt-md.md)] 包括[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)接口，该接口的单一方法[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)提供的基本格式设置支持与 <xref:System.Object.ToString%2A?displayProperty=nameWithType>提供的基本格式设置支持相媲美。 若要防止歧义，不应在托管类型上实现[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 。  
  
 当本机代码或使用 JavaScript 或C++/cx 等语言编写的代码调用托管对象时，它们看起来实现了[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)。 公共语言运行时将从[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)自动将调用路由到事件[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)中的 <xref:System.Object.ToString%2A?displayProperty=nameWithType>。  
  
> [!WARNING]
>  由于公共语言运行时自动实现 [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] 应用中所有托管类型的[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) ，因此，我们建议你不要提供自己的[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)实现。 在[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)从 [!INCLUDE[wrt](~/includes/wrt-md.md)]、/Cx 或 JavaScript 调用 `ToString` 时， C++实现 IStringable 可能会导致意外的行为。  
  
 如果选择在 [!INCLUDE[wrt](~/includes/wrt-md.md)] 组件中导出的公共托管类型中实现[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) ，则以下限制适用：  
  
- 你只能在 "类实现" 关系中定义[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)接口，如下所示：

    ```csharp
    public class NewClass : IStringable
    ```

    ```vb
    Public Class NewClass : Implements IStringable
    ```

-   无法在接口上实现[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 。  
  
-   不能将参数声明为[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)类型。  
  
-   [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)不能是方法、属性或字段的返回类型。  
  
-   你无法通过使用如下所示的方法定义，从基类中隐藏[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)实现：  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     相反， [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)实现必须始终重写基类实现。 只能通过对强类型类实例调用 `ToString` 实现来隐藏该实现。  
  
 请注意，在各种条件下，从本机代码到实现[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)或隐藏其[ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)实现的托管类型的调用可能会产生意外行为。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>实现自己的类型时，应重写 <see cref="M:System.Object.ToString" /> 方法，以返回对这些类型有意义的值。 需要更好地控制格式 <see cref="M:System.Object.ToString" /> 设置的派生类可以实现 <see cref="T:System.IFormattable" /> 接口。 通过其 <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> 方法，您可以定义用于控制格式设置的格式字符串，并使用可提供特定于区域性的格式设置 <see cref="T:System.IFormatProvider" /> 对象。  
  
<see cref="M:System.Object.ToString" /> 方法的覆盖应遵循以下准则： 
-返回的字符串应该是友好的，可供人们阅读。  
  
-返回的字符串应唯一标识对象实例的值。  
  
-返回的字符串应尽可能短，以便调试器能够显示它。  
  
-<see cref="M:System.Object.ToString" /> 重写不应返回 <see cref="F:System.String.Empty" /> 或空字符串。  
  
-<see cref="M:System.Object.ToString" /> 重写不应引发异常。  
  
-如果实例的字符串表示形式区分区域性或可通过多种方式进行格式化，则实现 <see cref="T:System.IFormattable" /> 接口。  
  
-如果返回的字符串包含敏感信息，则应首先请求适当的权限。 如果请求成功，则可以返回敏感信息;否则，应返回排除敏感信息的字符串。  
  
-<see cref="M:System.Object.ToString" /> 重写应没有可观察到的副作用，以避免调试中的复杂。 例如，对 <see cref="M:System.Object.ToString" /> 方法的调用不应更改实例字段的值。  
  
-如果你的类型实现了分析方法（或 <see langword="Parse" /> 或 <see langword="TryParse" /> 方法、构造函数或从字符串实例化类型实例的其他静态方法），则应确保 <see cref="M:System.Object.ToString" /> 方法返回的字符串可以转换为对象实例。</para></block>
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">设置 .NET 中类型的格式</related>
      </Docs>
    </Member>
  </Members>
</Type>
