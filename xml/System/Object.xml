<Type Name="Object" FullName="System.Object">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bb7e4f2ce5b003cab655e3d4e9cae3be04676b41" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83899244" /></Metadata><TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit object" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="e1583-101">支持 .NET 类层次结构中的所有类，并为派生类提供低级别服务。</span><span class="sxs-lookup"><span data-stu-id="e1583-101">Supports all classes in the .NET class hierarchy and provides low-level services to derived classes.</span></span> <span data-ttu-id="e1583-102">这是所有 .NET 类的最终基类；它是类型层次结构的根。</span><span class="sxs-lookup"><span data-stu-id="e1583-102">This is the ultimate base class of all .NET classes; it is the root of the type hierarchy.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e1583-103">语言通常不需要类声明从 <xref:System.Object> 继承，因为继承是隐式的。</span><span class="sxs-lookup"><span data-stu-id="e1583-103">Languages typically do not require a class to declare inheritance from <xref:System.Object> because the inheritance is implicit.</span></span>  
  
 <span data-ttu-id="e1583-104">由于 .NET 中的所有类均派生自 <xref:System.Object>，因此在 <xref:System.Object> 类中定义的每个方法都可用于系统中的所有对象。</span><span class="sxs-lookup"><span data-stu-id="e1583-104">Because all classes in .NET are derived from <xref:System.Object>, every method defined in the <xref:System.Object> class is available in all objects in the system.</span></span> <span data-ttu-id="e1583-105">派生类可以和重写其中一些方法，其中包括：</span><span class="sxs-lookup"><span data-stu-id="e1583-105">Derived classes can and do override some of these methods, including:</span></span>  
  
-   <span data-ttu-id="e1583-106"><xref:System.Object.Equals%2A>-支持对象之间的比较。</span><span class="sxs-lookup"><span data-stu-id="e1583-106"><xref:System.Object.Equals%2A> - Supports comparisons between objects.</span></span>  
  
-   <span data-ttu-id="e1583-107"><xref:System.Object.Finalize%2A>-在自动回收对象之前执行清理操作。</span><span class="sxs-lookup"><span data-stu-id="e1583-107"><xref:System.Object.Finalize%2A> - Performs cleanup operations before an object is automatically reclaimed.</span></span>  
  
-   <span data-ttu-id="e1583-108"><xref:System.Object.GetHashCode%2A>-生成与对象的值相对应的数字以支持使用哈希表。</span><span class="sxs-lookup"><span data-stu-id="e1583-108"><xref:System.Object.GetHashCode%2A> - Generates a number corresponding to the value of the object to support the use of a hash table.</span></span>  
  
-   <span data-ttu-id="e1583-109"><xref:System.Object.ToString%2A> 制造描述类的实例的用户可读文本字符串。</span><span class="sxs-lookup"><span data-stu-id="e1583-109"><xref:System.Object.ToString%2A> - Manufactures a human-readable text string that describes an instance of the class.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="e1583-110">性能注意事项</span><span class="sxs-lookup"><span data-stu-id="e1583-110">Performance Considerations</span></span>  
 <span data-ttu-id="e1583-111">如果要设计的类（如集合）必须处理任何类型的对象，则可以创建接受 <xref:System.Object> 类的实例的类成员。</span><span class="sxs-lookup"><span data-stu-id="e1583-111">If you are designing a class, such as a collection, that must handle any type of object, you can create class members that accept instances of the <xref:System.Object> class.</span></span> <span data-ttu-id="e1583-112">但是，对类型进行装箱和取消装箱的过程会产生性能开销。</span><span class="sxs-lookup"><span data-stu-id="e1583-112">However, the process of boxing and unboxing a type carries a performance cost.</span></span> <span data-ttu-id="e1583-113">如果你知道新类将经常处理某些值类型，则可以使用以下两种策略之一来最大程度地减少装箱成本。</span><span class="sxs-lookup"><span data-stu-id="e1583-113">If you know your new class will frequently handle certain value types you can use one of two tactics to minimize the cost of boxing.</span></span>  
  
-   <span data-ttu-id="e1583-114">创建接受 <xref:System.Object> 类型的常规方法，并创建一组特定于类型的方法重载，这些重载接受你希望类经常处理的每个值类型。</span><span class="sxs-lookup"><span data-stu-id="e1583-114">Create a general method that accepts an <xref:System.Object> type, and a set of type-specific method overloads that accept each value type you expect your class to frequently handle.</span></span> <span data-ttu-id="e1583-115">如果存在接受调用参数类型的特定于类型的方法，则不会发生任何装箱并调用类型特定的方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-115">If a type-specific method exists that accepts the calling parameter type, no boxing occurs and the type-specific method is invoked.</span></span> <span data-ttu-id="e1583-116">如果没有与调用参数类型匹配的方法参数，则将参数装箱，并调用常规方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-116">If there is no method argument that matches the calling parameter type, the parameter is boxed and the general method is invoked.</span></span>  
  
-   <span data-ttu-id="e1583-117">将类型及其成员设计为使用泛型。</span><span class="sxs-lookup"><span data-stu-id="e1583-117">Design your type and its members to use generics.</span></span> <span data-ttu-id="e1583-118">当你创建类的实例并指定泛型类型参数时，公共语言运行时将创建一个封闭式泛型类型。</span><span class="sxs-lookup"><span data-stu-id="e1583-118">The common language runtime creates a closed generic type when you create an instance of your class and specify a generic type argument.</span></span> <span data-ttu-id="e1583-119">泛型方法是类型特定的，可以在不装箱调用参数的情况下调用。</span><span class="sxs-lookup"><span data-stu-id="e1583-119">The generic method is type-specific and can be invoked without boxing the calling parameter.</span></span>  
  
 <span data-ttu-id="e1583-120">尽管有时需要开发接受和返回 <xref:System.Object> 类型的通用类，但你可以通过提供特定于类型的类来处理常用类型，从而提高性能。</span><span class="sxs-lookup"><span data-stu-id="e1583-120">Although it is sometimes necessary to develop general purpose classes that accept and return <xref:System.Object> types, you can improve performance by also providing a type-specific class to handle a frequently used type.</span></span> <span data-ttu-id="e1583-121">例如，提供特定于设置和获取布尔值的类可消除装箱和取消装箱布尔值的成本。</span><span class="sxs-lookup"><span data-stu-id="e1583-121">For example, providing a class that is specific to setting and getting Boolean values eliminates the cost of boxing and unboxing Boolean values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e1583-122">下面的示例定义派生自 <xref:System.Object> 类的点类型，并重写 <xref:System.Object> 类的许多虚方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-122">The following example defines a Point type derived from the <xref:System.Object> class and overrides many of the virtual methods of the <xref:System.Object> class.</span></span> <span data-ttu-id="e1583-123">此外，该示例还演示了如何调用 <xref:System.Object> 类的许多静态和实例方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-123">In addition, the example shows how to call many of the static and instance methods of the <xref:System.Object> class.</span></span>  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs" interactive="try-dotnet" id="snippet1":::
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp" id="snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb" id="snippet1":::
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="e1583-124">此类型的公共静态（<see langword="Shared" /> Visual Basic）成员是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="e1583-124">Public static (<see langword="Shared" /> in Visual Basic) members of this type are thread safe.</span></span> <span data-ttu-id="e1583-125">实例成员不一定是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="e1583-125">Instance members are not guaranteed to be thread-safe.</span></span></threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e1583-126">初始化 <see cref="T:System.Object" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="e1583-126">Initializes a new instance of the <see cref="T:System.Object" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e1583-127">此构造函数由派生类中的构造函数调用，但也可用于直接创建 <xref:System.Object> 类的实例。</span><span class="sxs-lookup"><span data-stu-id="e1583-127">This constructor is called by constructors in derived classes, but it can also be used to directly create an instance of the <xref:System.Object> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e1583-128">确定两个对象实例是否相等。</span><span class="sxs-lookup"><span data-stu-id="e1583-128">Determines whether two object instances are equal.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="e1583-129">要与当前对象进行比较的对象。</span><span class="sxs-lookup"><span data-stu-id="e1583-129">The object to compare with the current object.</span></span></param>
        <summary><span data-ttu-id="e1583-130">确定指定的对象是否等于当前对象。</span><span class="sxs-lookup"><span data-stu-id="e1583-130">Determines whether the specified object is equal to the current object.</span></span></summary>
        <returns><span data-ttu-id="e1583-131">如果指定的对象等于当前对象，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="e1583-131"><see langword="true" /> if the specified object  is equal to the current object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e1583-132">当前实例与 `obj` 参数之间的比较类型取决于当前实例是引用类型还是值类型。</span><span class="sxs-lookup"><span data-stu-id="e1583-132">The type of comparison between the current instance and the `obj` parameter depends on whether the current instance is a reference type or a value type.</span></span>  

-   <span data-ttu-id="e1583-133">如果当前实例是引用类型，则 <xref:System.Object.Equals%28System.Object%29> 方法会测试引用相等性，调用 <xref:System.Object.Equals%28System.Object%29> 方法等效于对 <xref:System.Object.ReferenceEquals%2A> 方法的调用。</span><span class="sxs-lookup"><span data-stu-id="e1583-133">If the current instance is a reference type, the <xref:System.Object.Equals%28System.Object%29> method tests for reference equality, and a call to the <xref:System.Object.Equals%28System.Object%29> method is equivalent to a call to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="e1583-134">引用相等性意味着比较的对象变量引用相同的对象。</span><span class="sxs-lookup"><span data-stu-id="e1583-134">Reference equality means that the object variables that are compared refer to the same object.</span></span> <span data-ttu-id="e1583-135">下面的示例说明了此类比较的结果。</span><span class="sxs-lookup"><span data-stu-id="e1583-135">The following example illustrates the result of such a comparison.</span></span> <span data-ttu-id="e1583-136">它定义了一个 `Person` 类，该类是一个引用类型，它调用 `Person` 类构造函数来实例化两个新的 `Person` 对象 `person2``person1a`，这些对象具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="e1583-136">It defines a `Person` class, which is a reference type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1a` and `person2`, which have the same value.</span></span> <span data-ttu-id="e1583-137">它还将 `person1a` 分配给另一个对象变量，`person1b`。</span><span class="sxs-lookup"><span data-stu-id="e1583-137">It also assigns `person1a` to another object variable, `person1b`.</span></span> <span data-ttu-id="e1583-138">如示例的输出所示，`person1a` 和 `person1b` 相等，因为它们引用相同的对象。</span><span class="sxs-lookup"><span data-stu-id="e1583-138">As the output from the example shows, `person1a` and `person1b` are equal because they reference the same object.</span></span> <span data-ttu-id="e1583-139">但 `person1a` 和 `person2` 不相等，尽管它们具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="e1583-139">However, `person1a` and `person2` are not equal, although they have the same value.</span></span>  
  
     :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs" interactive="try-dotnet" id="Snippet2":::
     :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb" id="Snippet2":::
  
-   <span data-ttu-id="e1583-140">如果当前实例是值类型，则 <xref:System.Object.Equals%28System.Object%29> 方法会测试值是否相等。</span><span class="sxs-lookup"><span data-stu-id="e1583-140">If the current instance is a value type, the <xref:System.Object.Equals%28System.Object%29> method tests for value equality.</span></span> <span data-ttu-id="e1583-141">值相等性意味着：</span><span class="sxs-lookup"><span data-stu-id="e1583-141">Value equality means the following:</span></span>  
  
    -   <span data-ttu-id="e1583-142">这两个对象属于同一类型。</span><span class="sxs-lookup"><span data-stu-id="e1583-142">The two objects are of the same type.</span></span> <span data-ttu-id="e1583-143">如下面的示例所示，值为12的 <xref:System.Byte> 对象不等于值为12的 <xref:System.Int32> 对象，因为这两个对象具有不同的运行时类型。</span><span class="sxs-lookup"><span data-stu-id="e1583-143">As the following example shows, a <xref:System.Byte> object that has a value of 12 does not equal an <xref:System.Int32> object that has a value of 12, because the two objects have different run-time types.</span></span>  
  
         :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs" interactive="try-dotnet-method" id="Snippet3":::
         :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb" id="Snippet3":::
  
    -   <span data-ttu-id="e1583-144">这两个对象的公共字段和私有字段的值相等。</span><span class="sxs-lookup"><span data-stu-id="e1583-144">The values of the public and private fields of the two objects are equal.</span></span> <span data-ttu-id="e1583-145">下面的示例测试值是否相等。</span><span class="sxs-lookup"><span data-stu-id="e1583-145">The following example tests for value equality.</span></span> <span data-ttu-id="e1583-146">它定义了一个 `Person` 结构，它是一个值类型，并调用 `Person` 类构造函数来实例化两个新的 `Person` 对象 `person2``person1`，它们具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="e1583-146">It defines a `Person` structure, which is a value type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1` and `person2`, which have the same value.</span></span> <span data-ttu-id="e1583-147">如示例中的输出所示，尽管这两个对象变量引用不同对象，但 `person1` 和 `person2` 相等，因为它们与专用 `personName` 字段具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="e1583-147">As the output from the example shows, although the two object variables refer to different objects, `person1` and `person2` are equal because they have the same value for the private `personName` field.</span></span>  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)] 
  
 <span data-ttu-id="e1583-148">由于 <xref:System.Object> 类是 .NET Framework 中所有类型的基类，因此 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 方法提供所有其他类型的默认相等比较。</span><span class="sxs-lookup"><span data-stu-id="e1583-148">Because the <xref:System.Object> class is the base class for all types in the .NET Framework, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method provides the default equality comparison for all other types.</span></span> <span data-ttu-id="e1583-149">但类型经常会重写 <xref:System.Object.Equals%2A> 方法以实现值相等性。</span><span class="sxs-lookup"><span data-stu-id="e1583-149">However, types often override the <xref:System.Object.Equals%2A> method to implement value equality.</span></span> <span data-ttu-id="e1583-150">有关详细信息，请参阅调用方的说明和对继承者的说明部分。</span><span class="sxs-lookup"><span data-stu-id="e1583-150">For more information, see the Notes for Callers and Notes for Inheritors sections.</span></span>  
  
## <a name="notes-for-the-wrt"></a><span data-ttu-id="e1583-151">[!INCLUDE[wrt](~/includes/wrt-md.md)] 的说明</span><span class="sxs-lookup"><span data-stu-id="e1583-151">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="e1583-152">当对 [!INCLUDE[wrt](~/includes/wrt-md.md)]中的类调用 <xref:System.Object.Equals%28System.Object%29> 方法重载时，它将为不重写 <xref:System.Object.Equals%28System.Object%29>的类提供默认行为。</span><span class="sxs-lookup"><span data-stu-id="e1583-152">When you call the <xref:System.Object.Equals%28System.Object%29> method overload on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don't override <xref:System.Object.Equals%28System.Object%29>.</span></span> <span data-ttu-id="e1583-153">这是 .NET Framework 为 [!INCLUDE[wrt](~/includes/wrt-md.md)] 提供的支持的一部分（请参阅[Windows 应用商店应用和 Windows 运行时 .NET Framework 支持](/dotnet/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime)）。</span><span class="sxs-lookup"><span data-stu-id="e1583-153">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](/dotnet/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime)).</span></span> <span data-ttu-id="e1583-154">[!INCLUDE[wrt](~/includes/wrt-md.md)] 中的类不会继承 <xref:System.Object>，当前未实现 <xref:System.Object.Equals%28System.Object%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-154">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don't inherit <xref:System.Object>, and currently don't implement an <xref:System.Object.Equals%28System.Object%29> method.</span></span> <span data-ttu-id="e1583-155">但是，当你在C#或 Visual Basic 代码中使用它们时，它们看起来有 <xref:System.Object.ToString%2A>、<xref:System.Object.Equals%28System.Object%29>和 <xref:System.Object.GetHashCode%2A> 方法，而 .NET Framework 提供这些方法的默认行为。</span><span class="sxs-lookup"><span data-stu-id="e1583-155">However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e1583-156">用 Visual Basic C#或编写的 [!INCLUDE[wrt](~/includes/wrt-md.md)] 类可以重写 <xref:System.Object.Equals%28System.Object%29> 方法重载。</span><span class="sxs-lookup"><span data-stu-id="e1583-156">[!INCLUDE[wrt](~/includes/wrt-md.md)] classes that are written in C# or Visual Basic can override the <xref:System.Object.Equals%28System.Object%29> method overload.</span></span>  
  
## <a name="notes-for-callers"></a><span data-ttu-id="e1583-157">调用方说明</span><span class="sxs-lookup"><span data-stu-id="e1583-157">Notes for Callers</span></span>  
 <span data-ttu-id="e1583-158">派生类经常重写 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 方法以实现值相等性。</span><span class="sxs-lookup"><span data-stu-id="e1583-158">Derived classes frequently override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to implement value equality.</span></span> <span data-ttu-id="e1583-159">此外，类型通常还向 `Equals` 方法提供附加的强类型重载，通常通过实现 <xref:System.IEquatable%601> 接口。</span><span class="sxs-lookup"><span data-stu-id="e1583-159">In addition, types also frequently provide an additional strongly typed overload to the `Equals` method, typically by implementing the <xref:System.IEquatable%601> interface.</span></span> <span data-ttu-id="e1583-160">当调用 `Equals` 方法来测试相等性时，应了解当前实例是否重写 <xref:System.Object.Equals%2A?displayProperty=nameWithType> 并了解如何解析对 `Equals` 方法的特定调用。</span><span class="sxs-lookup"><span data-stu-id="e1583-160">When you call the `Equals` method to test for equality, you should know whether the current instance overrides <xref:System.Object.Equals%2A?displayProperty=nameWithType> and understand how a particular call to an `Equals` method is resolved.</span></span> <span data-ttu-id="e1583-161">否则，你可能会执行与预期不同的相等性测试，方法可能会返回意外值。</span><span class="sxs-lookup"><span data-stu-id="e1583-161">Otherwise, you may be performing a test for equality that is different from what you intended, and the method may return an unexpected value.</span></span>  
  
 <span data-ttu-id="e1583-162">下面的示例进行了这方面的演示。</span><span class="sxs-lookup"><span data-stu-id="e1583-162">The following example provides an illustration.</span></span> <span data-ttu-id="e1583-163">它实例化三个具有相同字符串的 <xref:System.Text.StringBuilder> 对象，然后对 `Equals` 方法进行四次调用。</span><span class="sxs-lookup"><span data-stu-id="e1583-163">It instantiates three <xref:System.Text.StringBuilder> objects with identical strings, and then makes four calls to `Equals` methods.</span></span> <span data-ttu-id="e1583-164">第一个方法调用返回 `true`，其余三个返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="e1583-164">The first method call returns `true`, and the remaining three return `false`.</span></span>  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs" interactive="try-dotnet" id="Snippet5":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb" id="Snippet5":::
  
 <span data-ttu-id="e1583-165">在第一种情况下，将调用强类型化 <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> 方法重载来测试值相等性。</span><span class="sxs-lookup"><span data-stu-id="e1583-165">In the first case, the strongly typed <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> method overload, which tests for value equality, is called.</span></span> <span data-ttu-id="e1583-166">由于分配给这两个 <xref:System.Text.StringBuilder> 对象的字符串相等，因此该方法返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="e1583-166">Because the strings assigned to the two <xref:System.Text.StringBuilder> objects are equal, the method returns `true`.</span></span> <span data-ttu-id="e1583-167">但 <xref:System.Text.StringBuilder> 不会覆盖 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="e1583-167">However, <xref:System.Text.StringBuilder> does not override <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e1583-168">因此，将 <xref:System.Text.StringBuilder> 对象强制转换为 <xref:System.Object>时，如果将 <xref:System.Text.StringBuilder> 实例分配给类型 <xref:System.Object>的变量，并且 <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> 方法传递两个 <xref:System.Text.StringBuilder> 对象，则将调用默认的 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-168">Because of this, when the <xref:System.Text.StringBuilder> object is cast to an <xref:System.Object>, when a <xref:System.Text.StringBuilder> instance is assigned to a variable of type <xref:System.Object>, and when the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> method is passed two <xref:System.Text.StringBuilder> objects, the default <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="e1583-169">由于 <xref:System.Text.StringBuilder> 是引用类型，因此这等效于将两个 <xref:System.Text.StringBuilder> 对象传递到 <xref:System.Object.ReferenceEquals%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-169">Because <xref:System.Text.StringBuilder> is a reference type, this is equivalent to passing the two <xref:System.Text.StringBuilder> objects to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="e1583-170">尽管所有三个 <xref:System.Text.StringBuilder> 对象都包含相同的字符串，但是它们引用三个不同的对象。</span><span class="sxs-lookup"><span data-stu-id="e1583-170">Although all three <xref:System.Text.StringBuilder> objects contain identical strings, they refer to three distinct objects.</span></span> <span data-ttu-id="e1583-171">因此，这三个方法调用返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="e1583-171">As a result, these three method calls return `false`.</span></span>  
  
 <span data-ttu-id="e1583-172">可以通过调用 <xref:System.Object.ReferenceEquals%2A> 方法，将当前的对象与另一个对象进行比较以便引用相等性。</span><span class="sxs-lookup"><span data-stu-id="e1583-172">You can compare the current object to another object for reference equality by calling the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="e1583-173">在 Visual Basic 中，还可以使用 `is` 关键字（例如 `If Me Is otherObject Then ...`）。</span><span class="sxs-lookup"><span data-stu-id="e1583-173">In Visual Basic, you can also use the `is` keyword (for example, `If Me Is otherObject Then ...`).</span></span>  
  
## <a name="notes-for-inheritors"></a><span data-ttu-id="e1583-174">对继承者的说明</span><span class="sxs-lookup"><span data-stu-id="e1583-174">Notes for Inheritors</span></span>  
 <span data-ttu-id="e1583-175">定义自己的类型时，该类型将继承其基类型的 `Equals` 方法所定义的功能。</span><span class="sxs-lookup"><span data-stu-id="e1583-175">When you define your own type, that type inherits the functionality defined by the `Equals` method of its base type.</span></span> <span data-ttu-id="e1583-176">下表列出了 .NET Framework 中类型的主要类别的 `Equals` 方法的默认实现。</span><span class="sxs-lookup"><span data-stu-id="e1583-176">The following table lists the default implementation of the `Equals` method for the major categories of types in the .NET Framework.</span></span>  
  
|<span data-ttu-id="e1583-177">类型类别</span><span class="sxs-lookup"><span data-stu-id="e1583-177">Type category</span></span>|<span data-ttu-id="e1583-178">定义的相等</span><span class="sxs-lookup"><span data-stu-id="e1583-178">Equality defined by</span></span>|<span data-ttu-id="e1583-179">注释</span><span class="sxs-lookup"><span data-stu-id="e1583-179">Comments</span></span>|  
|-------------------|-------------------------|--------------|  
|<span data-ttu-id="e1583-180">直接从中派生的类 <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="e1583-180">Class derived directly from <xref:System.Object></span></span>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|<span data-ttu-id="e1583-181">引用相等性;等效于调用 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="e1583-181">Reference equality; equivalent to calling <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.</span></span>|  
|<span data-ttu-id="e1583-182">结构</span><span class="sxs-lookup"><span data-stu-id="e1583-182">Structure</span></span>|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="e1583-183">值相等性;使用反射直接进行逐字节比较或逐字段比较。</span><span class="sxs-lookup"><span data-stu-id="e1583-183">Value equality; either direct byte-by-byte comparison or field-by-field comparison using reflection.</span></span>|  
|<span data-ttu-id="e1583-184">枚举</span><span class="sxs-lookup"><span data-stu-id="e1583-184">Enumeration</span></span>|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="e1583-185">值必须具有相同的枚举类型和基础值。</span><span class="sxs-lookup"><span data-stu-id="e1583-185">Values must have the same enumeration type and the same underlying value.</span></span>|  
|<span data-ttu-id="e1583-186">委托</span><span class="sxs-lookup"><span data-stu-id="e1583-186">Delegate</span></span>|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="e1583-187">委托必须具有相同的调用列表类型。</span><span class="sxs-lookup"><span data-stu-id="e1583-187">Delegates must have the same type with identical invocation lists.</span></span>|  
|<span data-ttu-id="e1583-188">接口</span><span class="sxs-lookup"><span data-stu-id="e1583-188">Interface</span></span>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|<span data-ttu-id="e1583-189">引用相等性。</span><span class="sxs-lookup"><span data-stu-id="e1583-189">Reference equality.</span></span>|  
  
 <span data-ttu-id="e1583-190">对于值类型，应始终重写 <xref:System.Object.Equals%2A>，因为依赖于反射的相等性测试会降低性能。</span><span class="sxs-lookup"><span data-stu-id="e1583-190">For a value type, you should always override <xref:System.Object.Equals%2A>, because tests for equality that rely on reflection offer poor performance.</span></span> <span data-ttu-id="e1583-191">您还可以重写引用类型 <xref:System.Object.Equals%2A> 的默认实现，以测试值相等性而不是引用相等性，并定义值相等性的精确含义。</span><span class="sxs-lookup"><span data-stu-id="e1583-191">You can also override the default implementation of <xref:System.Object.Equals%2A> for reference types to test for value equality instead of reference equality and to define the precise meaning of value equality.</span></span> <span data-ttu-id="e1583-192">如果两个对象具有相同的值，则此类实现 <xref:System.Object.Equals%2A> 返回 `true`，即使它们不是相同的实例。</span><span class="sxs-lookup"><span data-stu-id="e1583-192">Such implementations of <xref:System.Object.Equals%2A> return `true` if the two objects have the same value, even if they are not the same instance.</span></span> <span data-ttu-id="e1583-193">类型的实施器决定对象的值是什么，但它通常是存储在对象的实例变量中的部分或全部数据。</span><span class="sxs-lookup"><span data-stu-id="e1583-193">The type's implementer decides what constitutes an object's value, but it is typically some or all the data stored in the instance variables of the object.</span></span> <span data-ttu-id="e1583-194">例如，<xref:System.String> 对象的值基于字符串的字符;<xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> 方法将重写 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 方法，以便为任意两个具有相同顺序的相同字符的字符串实例返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="e1583-194">For example, the value of a <xref:System.String> object is based on the characters of the string; the <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> method overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to return `true` for any two string instances that contain the same characters in the same order.</span></span>  
  
 <span data-ttu-id="e1583-195">下面的示例演示如何重写 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 方法来测试值相等性。</span><span class="sxs-lookup"><span data-stu-id="e1583-195">The following example shows how to override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to test for value equality.</span></span> <span data-ttu-id="e1583-196">它重写 `Person` 类的 <xref:System.Object.Equals%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-196">It overrides the <xref:System.Object.Equals%2A> method for the `Person` class.</span></span> <span data-ttu-id="e1583-197">如果 `Person` 接受其相等的基类实现，则只有当两个 `Person` 对象引用单个对象时，它们才相等。</span><span class="sxs-lookup"><span data-stu-id="e1583-197">If `Person` accepted its base class implementation of equality, two `Person` objects would be equal only if they referenced a single object.</span></span> <span data-ttu-id="e1583-198">但是，在这种情况下，如果两个 `Person` 对象的 `Person.Id` 属性值相同，则两个对象相等。</span><span class="sxs-lookup"><span data-stu-id="e1583-198">However, in this case, two `Person` objects are equal if they have the same value for the `Person.Id` property.</span></span>  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
   
 <span data-ttu-id="e1583-199">除了重写 <xref:System.Object.Equals%2A>之外，还可以实现 <xref:System.IEquatable%601> 接口，以提供强类型化的相等性测试。</span><span class="sxs-lookup"><span data-stu-id="e1583-199">In addition to overriding <xref:System.Object.Equals%2A>, you can implement the <xref:System.IEquatable%601> interface to provide a strongly typed test for equality.</span></span>  
  
 <span data-ttu-id="e1583-200">对于 <xref:System.Object.Equals%28System.Object%29> 方法的所有实现，以下语句必须为 true。</span><span class="sxs-lookup"><span data-stu-id="e1583-200">The following statements must be true for all implementations of the <xref:System.Object.Equals%28System.Object%29> method.</span></span> <span data-ttu-id="e1583-201">在列表中，`x`、`y`和 `z` 表示不**为 null**的对象引用。</span><span class="sxs-lookup"><span data-stu-id="e1583-201">In the list, `x`, `y`, and `z` represent object references that are not **null**.</span></span>  
  
-   <span data-ttu-id="e1583-202">`x.Equals(x)` 返回 `true`，但涉及浮点类型的情况除外。</span><span class="sxs-lookup"><span data-stu-id="e1583-202">`x.Equals(x)` returns `true`, except in cases that involve floating-point types.</span></span> <span data-ttu-id="e1583-203">请参阅[ISO/IEC/IEEE 60559:2011，信息技术--微处理器系统-浮点运算](https://www.iso.org/standard/57469.html)。</span><span class="sxs-lookup"><span data-stu-id="e1583-203">See [ISO/IEC/IEEE 60559:2011, Information technology -- Microprocessor Systems -- Floating-Point arithmetic](https://www.iso.org/standard/57469.html).</span></span>  
  
-   <span data-ttu-id="e1583-204">`x.Equals(y)` 返回与 `y.Equals(x)` 相同的值。</span><span class="sxs-lookup"><span data-stu-id="e1583-204">`x.Equals(y)` returns the same value as `y.Equals(x)`.</span></span>  
  
-   <span data-ttu-id="e1583-205">如果 `x` 和 `y` 均 `NaN`，则 `x.Equals(y)` 返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="e1583-205">`x.Equals(y)` returns `true` if both `x` and `y` are `NaN`.</span></span>  
  
-   <span data-ttu-id="e1583-206">如果 `(x.Equals(y) && y.Equals(z))` 返回 `true`，则 `x.Equals(z)` 返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="e1583-206">If `(x.Equals(y) && y.Equals(z))` returns `true`, then `x.Equals(z)` returns `true`.</span></span>  
  
-   <span data-ttu-id="e1583-207">如果不修改 `x` 和 `y` 引用的对象，则对 `x.Equals(y)` 的后续调用将返回相同的值。</span><span class="sxs-lookup"><span data-stu-id="e1583-207">Successive calls to `x.Equals(y)` return the same value as long as the objects referenced by `x` and `y` are not modified.</span></span>  
  
-   <span data-ttu-id="e1583-208">`x.Equals(null)` 返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="e1583-208">`x.Equals(null)` returns `false`.</span></span>  
  
 <span data-ttu-id="e1583-209"><xref:System.Object.Equals%2A> 的实现不得引发异常;它们应始终返回值。</span><span class="sxs-lookup"><span data-stu-id="e1583-209">Implementations of <xref:System.Object.Equals%2A> must not throw exceptions; they should always return a value.</span></span> <span data-ttu-id="e1583-210">例如，如果 `null``obj`，则 <xref:System.Object.Equals%2A> 方法应返回 `false`，而不是引发 <xref:System.ArgumentNullException>。</span><span class="sxs-lookup"><span data-stu-id="e1583-210">For example, if `obj` is `null`, the <xref:System.Object.Equals%2A> method should return `false` instead of throwing an <xref:System.ArgumentNullException>.</span></span>  
  
 <span data-ttu-id="e1583-211">覆盖 <xref:System.Object.Equals%28System.Object%29>时，请遵循以下准则：</span><span class="sxs-lookup"><span data-stu-id="e1583-211">Follow these guidelines when overriding <xref:System.Object.Equals%28System.Object%29>:</span></span>  
  
-   <span data-ttu-id="e1583-212">实现 <xref:System.IComparable> 的类型必须重写 <xref:System.Object.Equals%28System.Object%29>。</span><span class="sxs-lookup"><span data-stu-id="e1583-212">Types that implement <xref:System.IComparable> must override <xref:System.Object.Equals%28System.Object%29>.</span></span>  
  
-   <span data-ttu-id="e1583-213">重写 <xref:System.Object.Equals%28System.Object%29> 的类型还必须重写 <xref:System.Object.GetHashCode%2A>;否则，哈希表可能无法正常工作。</span><span class="sxs-lookup"><span data-stu-id="e1583-213">Types that override <xref:System.Object.Equals%28System.Object%29> must also override <xref:System.Object.GetHashCode%2A>; otherwise, hash tables  might not work correctly.</span></span>  
  
-   <span data-ttu-id="e1583-214">应考虑实现 <xref:System.IEquatable%601> 接口，以支持强类型化测试是否相等。</span><span class="sxs-lookup"><span data-stu-id="e1583-214">You should consider implementing the <xref:System.IEquatable%601> interface to support strongly typed tests for equality.</span></span> <span data-ttu-id="e1583-215"><xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> 实现应返回与 <xref:System.Object.Equals%2A>一致的结果。</span><span class="sxs-lookup"><span data-stu-id="e1583-215">Your <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> implementation should return results that are consistent with <xref:System.Object.Equals%2A>.</span></span>  
  
-   <span data-ttu-id="e1583-216">如果你的编程语言支持运算符重载，并且你重载给定类型的相等运算符，则还必须重写 <xref:System.Object.Equals%28System.Object%29> 方法才能返回与相等运算符相同的结果。</span><span class="sxs-lookup"><span data-stu-id="e1583-216">If your programming language supports operator overloading and you overload the equality operator for a given type, you must also override the <xref:System.Object.Equals%28System.Object%29> method to return the same result as the equality operator.</span></span> <span data-ttu-id="e1583-217">这有助于确保使用 <xref:System.Object.Equals%2A> （如 <xref:System.Collections.ArrayList> 和 <xref:System.Collections.Hashtable>）的类库代码的行为与应用程序代码使用相等运算符的方式一致。</span><span class="sxs-lookup"><span data-stu-id="e1583-217">This  helps ensure that class library code that uses <xref:System.Object.Equals%2A> (such as <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>) behaves in a manner that is consistent with the way the equality operator is used by application code.</span></span>  
  
### <a name="guidelines-for-reference-types"></a><span data-ttu-id="e1583-218">引用类型的准则</span><span class="sxs-lookup"><span data-stu-id="e1583-218">Guidelines for Reference Types</span></span>  
 <span data-ttu-id="e1583-219">以下准则适用于替代引用类型的 <xref:System.Object.Equals%28System.Object%29>：</span><span class="sxs-lookup"><span data-stu-id="e1583-219">The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a reference type:</span></span>  
  
-   <span data-ttu-id="e1583-220">如果类型的语义基于该类型表示某个值的情况，请考虑重写 <xref:System.Object.Equals%2A>。</span><span class="sxs-lookup"><span data-stu-id="e1583-220">Consider overriding <xref:System.Object.Equals%2A> if the semantics of the type are based on the fact that the type represents some value(s).</span></span>  
  
-   <span data-ttu-id="e1583-221">大多数引用类型不得重载相等运算符，即使它们重写 <xref:System.Object.Equals%2A>也是如此。</span><span class="sxs-lookup"><span data-stu-id="e1583-221">Most reference types must not overload the equality operator, even if they override <xref:System.Object.Equals%2A>.</span></span> <span data-ttu-id="e1583-222">但是，如果要实现的引用类型应具有值语义（如复数类型），则必须重写相等运算符。</span><span class="sxs-lookup"><span data-stu-id="e1583-222">However, if you are implementing a reference type that is intended to have value semantics, such as a complex number type, you must override the equality operator.</span></span>  
  
-   <span data-ttu-id="e1583-223">不应覆盖可变引用类型上的 <xref:System.Object.Equals%2A>。</span><span class="sxs-lookup"><span data-stu-id="e1583-223">You should not override <xref:System.Object.Equals%2A> on a mutable reference type.</span></span> <span data-ttu-id="e1583-224">这是因为，重写 <xref:System.Object.Equals%2A> 要求你还重写 <xref:System.Object.GetHashCode%2A> 方法，如前一部分中所述。</span><span class="sxs-lookup"><span data-stu-id="e1583-224">This is because overriding <xref:System.Object.Equals%2A> requires that you also override the <xref:System.Object.GetHashCode%2A> method, as discussed in the previous section.</span></span> <span data-ttu-id="e1583-225">这意味着可变引用类型的实例的哈希代码在其生存期内可能会更改，这可能会导致对象在哈希表中丢失。</span><span class="sxs-lookup"><span data-stu-id="e1583-225">This means that the hash code of an instance of a mutable reference type can change during its lifetime, which can cause the object to be lost in a hash table.</span></span>  
  
### <a name="guidelines-for-value-types"></a><span data-ttu-id="e1583-226">值类型的准则</span><span class="sxs-lookup"><span data-stu-id="e1583-226">Guidelines for Value Types</span></span>  
 <span data-ttu-id="e1583-227">以下准则适用于重写值类型的 <xref:System.Object.Equals%28System.Object%29>：</span><span class="sxs-lookup"><span data-stu-id="e1583-227">The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a value type:</span></span>  
  
-   <span data-ttu-id="e1583-228">如果要定义包含一个或多个值为引用类型的字段的值类型，则应重写 <xref:System.Object.Equals%28System.Object%29>。</span><span class="sxs-lookup"><span data-stu-id="e1583-228">If you are defining a value type that includes one or more fields whose values are reference types, you should override <xref:System.Object.Equals%28System.Object%29>.</span></span> <span data-ttu-id="e1583-229"><xref:System.ValueType> 提供的 <xref:System.Object.Equals%28System.Object%29> 实现为其字段为所有值类型的值类型执行逐字节的比较，但它使用反射来执行字段包含引用类型的值类型的逐字段比较。</span><span class="sxs-lookup"><span data-stu-id="e1583-229">The <xref:System.Object.Equals%28System.Object%29> implementation provided by <xref:System.ValueType> performs a byte-by-byte comparison for value types whose fields are all value types, but it uses reflection to perform a field-by-field comparison of value types whose fields include reference types.</span></span>  
  
-   <span data-ttu-id="e1583-230">如果重写 <xref:System.Object.Equals%2A> 并且开发语言支持运算符重载，则必须重载相等运算符。</span><span class="sxs-lookup"><span data-stu-id="e1583-230">If you override <xref:System.Object.Equals%2A> and your development language supports operator overloading, you must overload the equality operator.</span></span>  
  
-   <span data-ttu-id="e1583-231">应该实现 <xref:System.IEquatable%601> 接口。</span><span class="sxs-lookup"><span data-stu-id="e1583-231">You should implement the <xref:System.IEquatable%601> interface.</span></span> <span data-ttu-id="e1583-232">调用强类型 <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> 方法可避免对 `obj` 参数进行装箱。</span><span class="sxs-lookup"><span data-stu-id="e1583-232">Calling the strongly typed <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> method avoids boxing the `obj` argument.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e1583-233">下面的示例演示一个 `Point` 类，该类重写 <xref:System.Object.Equals%2A> 方法以提供值相等性，以及一个派生自 `Point`的 `Point3D` 类。</span><span class="sxs-lookup"><span data-stu-id="e1583-233">The following example shows a `Point` class that overrides the <xref:System.Object.Equals%2A> method to provide value equality, and a `Point3D` class that is derived from `Point`.</span></span> <span data-ttu-id="e1583-234">由于 `Point` 重写 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 来测试值相等性，因此不会调用 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-234">Because `Point` overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to test for value equality, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method is not called.</span></span> <span data-ttu-id="e1583-235">但 `Point3D.Equals` 调用 `Point.Equals`，因为 `Point` 以提供值相等性的方式实现 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="e1583-235">However, `Point3D.Equals` calls `Point.Equals` because `Point` implements <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> in a manner that provides value equality.</span></span>  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb" id="Snippet1":::
  
 <span data-ttu-id="e1583-236">`Point.Equals` 方法将进行检查以确保 `obj` 参数不为**null** ，并且它引用与此对象相同的类型的实例。</span><span class="sxs-lookup"><span data-stu-id="e1583-236">The `Point.Equals` method checks to make sure that the `obj` argument is not **null** and that it references an instance of the same type as this object.</span></span> <span data-ttu-id="e1583-237">如果任一检查失败，则该方法将返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="e1583-237">If either check fails, the method returns `false`.</span></span>  
  
 <span data-ttu-id="e1583-238">`Point.Equals` 方法调用 <xref:System.Object.GetType%2A> 方法来确定两个对象的运行时类型是否相同。</span><span class="sxs-lookup"><span data-stu-id="e1583-238">The `Point.Equals` method calls the <xref:System.Object.GetType%2A> method to determine whether the run-time types of the two objects are identical.</span></span> <span data-ttu-id="e1583-239">如果该方法使用了窗体 `obj is Point` in C#或 `TryCast(obj, Point)` Visual Basic 的检查，则该检查将在 `obj` 为 `Point`派生类的实例的情况下返回 `true`，即使 `obj` 和当前实例的运行时类型不相同也是如此。</span><span class="sxs-lookup"><span data-stu-id="e1583-239">If the method used a check of the form `obj is Point` in C# or `TryCast(obj, Point)` in Visual Basic, the check would return `true` in cases where `obj` is an instance of a derived class of `Point`, even though `obj` and the current instance are not of the same run-time type.</span></span> <span data-ttu-id="e1583-240">验证两个对象的类型是否相同，方法将 `obj` 转换为类型 `Point`，并返回比较两个对象的实例字段的结果。</span><span class="sxs-lookup"><span data-stu-id="e1583-240">Having verified that both objects are of the same type, the method casts `obj` to type `Point` and returns the result of comparing the instance fields of the two objects.</span></span>  
  
 <span data-ttu-id="e1583-241">在 `Point3D.Equals`中，将在执行任何其他操作之前调用继承 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>的继承 `Point.Equals` 方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-241">In `Point3D.Equals`, the inherited `Point.Equals` method, which overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, is invoked before anything else is done.</span></span> <span data-ttu-id="e1583-242">因为`Point3D`是一个密封的类 (在 Visual Basic 中为 `NotInheritable`)，签入窗体`obj is Point`C# 中或`TryCast(obj, Point)`在 Visual Basic 中是足以确保`obj`是`Point3D`对象。</span><span class="sxs-lookup"><span data-stu-id="e1583-242">Because `Point3D` is a sealed class (`NotInheritable` in Visual Basic), a check in the form `obj is Point` in C# or `TryCast(obj, Point)` in Visual Basic is adequate to ensure that `obj` is a `Point3D` object.</span></span> <span data-ttu-id="e1583-243">如果它是 `Point3D` 对象，则会将其强制转换为 `Point` 对象，并传递给 <xref:System.Object.Equals%2A>的基类实现。</span><span class="sxs-lookup"><span data-stu-id="e1583-243">If it is a `Point3D` object, it is cast to a `Point` object and passed to the base class implementation of <xref:System.Object.Equals%2A>.</span></span> <span data-ttu-id="e1583-244">仅当继承的 `Point.Equals` 方法返回时 `true` 方法会比较派生类中引入的 `z` 实例字段。</span><span class="sxs-lookup"><span data-stu-id="e1583-244">Only when the inherited `Point.Equals` method returns `true` does the method compare the `z` instance fields introduced in the derived class.</span></span>  
  
 <span data-ttu-id="e1583-245">下面的示例定义了一个 `Rectangle` 类，该类在内部实现一个矩形作为两个 `Point` 对象。</span><span class="sxs-lookup"><span data-stu-id="e1583-245">The following example defines a `Rectangle` class that internally implements a rectangle as two `Point` objects.</span></span> <span data-ttu-id="e1583-246">`Rectangle` 类还将重写 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 以提供值相等性。</span><span class="sxs-lookup"><span data-stu-id="e1583-246">The `Rectangle` class also overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to provide for value equality.</span></span>  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb" id="Snippet1":::

 <span data-ttu-id="e1583-247">某些语言（如C#和） Visual Basic 支持运算符重载。</span><span class="sxs-lookup"><span data-stu-id="e1583-247">Some languages such as C# and Visual Basic support operator overloading.</span></span> <span data-ttu-id="e1583-248">当类型重载相等运算符时，它还必须重写 <xref:System.Object.Equals%28System.Object%29> 方法才能提供相同的功能。</span><span class="sxs-lookup"><span data-stu-id="e1583-248">When a type overloads the equality operator, it must also override the <xref:System.Object.Equals%28System.Object%29> method to provide the same functionality.</span></span> <span data-ttu-id="e1583-249">这通常通过使用重载的相等运算符编写 <xref:System.Object.Equals%28System.Object%29> 方法来完成，如下面的示例中所示。</span><span class="sxs-lookup"><span data-stu-id="e1583-249">This is typically accomplished by writing the <xref:System.Object.Equals%28System.Object%29> method in terms of the overloaded equality operator, as in the following example.</span></span>  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb" id="Snippet1":::
  
 <span data-ttu-id="e1583-250">由于 `Complex` 是值类型，因此不能从派生。</span><span class="sxs-lookup"><span data-stu-id="e1583-250">Because `Complex` is a value type, it cannot be derived from.</span></span>  <span data-ttu-id="e1583-251">因此，<xref:System.Object.Equals%28System.Object%29> 方法的重写不需要调用 <xref:System.Object.GetType%2A> 来确定每个对象的确切运行时类型，但可以改为使用中C#的 `is` 运算符或 Visual Basic 中的 `TypeOf` 运算符来检查 `obj` 参数的类型。</span><span class="sxs-lookup"><span data-stu-id="e1583-251">Therefore, the override to <xref:System.Object.Equals%28System.Object%29> method need not call <xref:System.Object.GetType%2A> to determine the precise run-time type of each object, but can instead use the `is` operator in C# or the `TypeOf` operator in Visual Basic to check the type of the `obj` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA"><span data-ttu-id="e1583-252">要比较的第一个对象。</span><span class="sxs-lookup"><span data-stu-id="e1583-252">The first object to compare.</span></span></param>
        <param name="objB"><span data-ttu-id="e1583-253">要比较的第二个对象。</span><span class="sxs-lookup"><span data-stu-id="e1583-253">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="e1583-254">确定指定的对象实例是否被视为相等。</span><span class="sxs-lookup"><span data-stu-id="e1583-254">Determines whether the specified object instances are considered equal.</span></span></summary>
        <returns><span data-ttu-id="e1583-255">如果对象被视为相等，则为 <see langword="true" />，否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="e1583-255"><see langword="true" /> if the objects are considered equal; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="e1583-256">如果 <paramref name="objA" /> 和 <paramref name="objB" /> 均为 null，此方法返回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="e1583-256">If both <paramref name="objA" /> and <paramref name="objB" /> are **null**, the method returns <see langword="true" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e1583-257">静态 <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> 方法指示两个对象 `objA` 和 `objB`是否相等。</span><span class="sxs-lookup"><span data-stu-id="e1583-257">The static <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method indicates whether two objects, `objA` and  `objB`, are equal.</span></span> <span data-ttu-id="e1583-258">它还使你能够测试值为**null**的对象是否相等。</span><span class="sxs-lookup"><span data-stu-id="e1583-258">It also enables you to test objects whose value is **null** for equality.</span></span> <span data-ttu-id="e1583-259">它比较 `objA` 和 `objB` 的相等性，如下所示：</span><span class="sxs-lookup"><span data-stu-id="e1583-259">It compares `objA` and `objB` for equality as follows:</span></span>  
  
-   <span data-ttu-id="e1583-260">它确定两个对象是否表示相同的对象引用。</span><span class="sxs-lookup"><span data-stu-id="e1583-260">It determines whether the two objects represent the same object reference.</span></span> <span data-ttu-id="e1583-261">如果是这样，该方法将返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="e1583-261">If they do, the method returns `true`.</span></span> <span data-ttu-id="e1583-262">此测试等效于调用 <xref:System.Object.ReferenceEquals%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-262">This test is equivalent to calling the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="e1583-263">此外，如果 `objA` 和 `objB` 均为**null**，则该方法返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="e1583-263">In addition, if both `objA` and `objB` are **null**, the method returns `true`.</span></span>  
  
-   <span data-ttu-id="e1583-264">它确定 `objA` 或 `objB` 是否为**null**。</span><span class="sxs-lookup"><span data-stu-id="e1583-264">It determines whether either `objA` or `objB` is **null**.</span></span> <span data-ttu-id="e1583-265">如果是，它将返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="e1583-265">If so, it returns `false`.</span></span>  
  
-   <span data-ttu-id="e1583-266">如果两个对象不表示相同的对象引用，并且两者都不为**null**，则将调用 `objA`。`Equals`（`objB`）并返回结果。</span><span class="sxs-lookup"><span data-stu-id="e1583-266">If the two objects do not represent the same object reference and neither is **null**, it calls `objA`.`Equals`(`objB`) and returns the result.</span></span> <span data-ttu-id="e1583-267">这意味着，如果 `objA` 重写 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 方法，则调用此重写。</span><span class="sxs-lookup"><span data-stu-id="e1583-267">This means that if `objA` overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, this override is called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e1583-268">下面的示例演示 <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> 方法，并将其与 <xref:System.Object.ReferenceEquals%2A> 方法进行比较。</span><span class="sxs-lookup"><span data-stu-id="e1583-268">The following example illustrates the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method and compares it with the <xref:System.Object.ReferenceEquals%2A> method.</span></span>  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb" id="Snippet1"::: 
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Finalize() cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e1583-269">在垃圾回收将某一对象回收前允许该对象尝试释放资源并执行其他清理操作。</span><span class="sxs-lookup"><span data-stu-id="e1583-269">Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e1583-270"><xref:System.Object.Finalize%2A> 方法用于在销毁对象之前对当前对象占用的非托管资源执行清理操作。</span><span class="sxs-lookup"><span data-stu-id="e1583-270">The <xref:System.Object.Finalize%2A> method is used to perform cleanup operations on unmanaged resources held by the current object before the object is destroyed.</span></span> <span data-ttu-id="e1583-271">方法是受保护的，因此只能通过此类或派生类访问。</span><span class="sxs-lookup"><span data-stu-id="e1583-271">The method is protected and therefore is accessible only through this class or through a derived class.</span></span>  
  
 <span data-ttu-id="e1583-272">本节内容：</span><span class="sxs-lookup"><span data-stu-id="e1583-272">In this section:</span></span>  
  
-   [<span data-ttu-id="e1583-273">终止的工作方式</span><span class="sxs-lookup"><span data-stu-id="e1583-273">How finalization works</span></span>](#How)  
  
-   [<span data-ttu-id="e1583-274">实施者注意事项</span><span class="sxs-lookup"><span data-stu-id="e1583-274">Notes for implementers</span></span>](#Notes)  
  
-   [<span data-ttu-id="e1583-275">SafeHandle 替代项</span><span class="sxs-lookup"><span data-stu-id="e1583-275">The SafeHandle alternative</span></span>](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a><span data-ttu-id="e1583-276">终止的工作方式</span><span class="sxs-lookup"><span data-stu-id="e1583-276">How finalization works</span></span>  
 <span data-ttu-id="e1583-277"><xref:System.Object> 类不提供 <xref:System.Object.Finalize%2A> 方法的实现，垃圾回收器不会将从 <xref:System.Object> 派生的类型标记为完成，除非它们重写 <xref:System.Object.Finalize%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-277">The <xref:System.Object> class provides no implementation for the <xref:System.Object.Finalize%2A> method, and the garbage collector does not mark types derived from <xref:System.Object> for finalization unless they override the <xref:System.Object.Finalize%2A> method.</span></span>  
  
 <span data-ttu-id="e1583-278">如果某个类型确实重写 <xref:System.Object.Finalize%2A> 方法，则垃圾回收器会将该类型的每个实例的条目添加到称为终止队列的内部结构。</span><span class="sxs-lookup"><span data-stu-id="e1583-278">If a type does override the <xref:System.Object.Finalize%2A> method, the garbage collector adds an entry for each instance of the type to an internal structure called the finalization queue.</span></span> <span data-ttu-id="e1583-279">终止队列包含托管堆中的所有对象的条目，在垃圾回收器可以回收内存之前，必须先运行终止代码。</span><span class="sxs-lookup"><span data-stu-id="e1583-279">The finalization queue contains entries for all the objects in the managed heap whose finalization code must run before the garbage collector can reclaim their memory.</span></span> <span data-ttu-id="e1583-280">然后，垃圾回收器会在以下条件下自动调用 <xref:System.Object.Finalize%2A> 方法：</span><span class="sxs-lookup"><span data-stu-id="e1583-280">The garbage collector then calls the <xref:System.Object.Finalize%2A> method automatically under the following conditions:</span></span>  
  
-   <span data-ttu-id="e1583-281">在垃圾回收器发现对象不可访问后，除非已通过调用 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> 方法免除了该对象的终止。</span><span class="sxs-lookup"><span data-stu-id="e1583-281">After the garbage collector has discovered that an object is inaccessible, unless the object has been exempted from finalization by a call to the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="e1583-282">**仅在 .NET Framework**的情况下，在应用程序域的关闭过程中，除非该对象免于终止。</span><span class="sxs-lookup"><span data-stu-id="e1583-282">**On .NET Framework only**, during shutdown of an application domain, unless the object is exempt from finalization.</span></span> <span data-ttu-id="e1583-283">在关闭期间，即使仍可访问的对象也会完成。</span><span class="sxs-lookup"><span data-stu-id="e1583-283">During shutdown, even objects that are still accessible are finalized.</span></span>  
  
 <span data-ttu-id="e1583-284">仅在给定的实例上自动调用 <xref:System.Object.Finalize%2A> 一次，除非该对象是使用 <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> 的机制重新注册的，并且尚未随后调用 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-284"><xref:System.Object.Finalize%2A> is automatically called only once on a given instance, unless the object is re-registered by using a mechanism such as <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> and the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method has not been subsequently called.</span></span>  
  
 <span data-ttu-id="e1583-285"><xref:System.Object.Finalize%2A> 操作具有以下限制：</span><span class="sxs-lookup"><span data-stu-id="e1583-285"><xref:System.Object.Finalize%2A> operations have the following limitations:</span></span>  
  
-   <span data-ttu-id="e1583-286">不确定终结器执行时的准确时间。</span><span class="sxs-lookup"><span data-stu-id="e1583-286">The exact time when the finalizer executes is undefined.</span></span> <span data-ttu-id="e1583-287">若要确保类的实例的资源的确定性版本，请实现 `Close` 方法或提供 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 实现。</span><span class="sxs-lookup"><span data-stu-id="e1583-287">To ensure deterministic release of resources for instances of your class, implement a `Close` method or provide a <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>  
  
-   <span data-ttu-id="e1583-288">不能保证两个对象的终结器以任何特定顺序运行，即使一个对象引用另一个对象也是如此。</span><span class="sxs-lookup"><span data-stu-id="e1583-288">The finalizers of two objects are not guaranteed to run in any specific order, even if one object refers to the other.</span></span> <span data-ttu-id="e1583-289">也就是说，如果对象 A 具有对对象 B 的引用，并且都具有终结器，	在对象 A 的终结器启动时，对象 B 可能已被终结。</span><span class="sxs-lookup"><span data-stu-id="e1583-289">That is, if Object A has a reference to Object B and both have finalizers, Object B might have already been finalized when the finalizer of Object A starts.</span></span>  
  
-   <span data-ttu-id="e1583-290">不指定终结器在其上运行的线程。</span><span class="sxs-lookup"><span data-stu-id="e1583-290">The thread on which the finalizer runs is unspecified.</span></span>  
  
 <span data-ttu-id="e1583-291">在以下异常情况下，<xref:System.Object.Finalize%2A> 方法可能不会运行完成，也可能根本不会运行：</span><span class="sxs-lookup"><span data-stu-id="e1583-291">The <xref:System.Object.Finalize%2A> method might not run to completion or might not run at all under the following exceptional circumstances:</span></span>  
  
-   <span data-ttu-id="e1583-292">如果另一个终结器无限期阻止（进入无限循环，则会尝试获取它永远无法获取的锁定，等等）。</span><span class="sxs-lookup"><span data-stu-id="e1583-292">If another finalizer blocks indefinitely (goes into an infinite loop, tries to obtain a lock it can never obtain, and so on).</span></span> <span data-ttu-id="e1583-293">因为运行时尝试运行终结器来完成，所以如果终结器无限期阻塞，则可能不会调用其他终结器。</span><span class="sxs-lookup"><span data-stu-id="e1583-293">Because the runtime tries to run finalizers to completion, other finalizers might not be called if a finalizer blocks indefinitely.</span></span>  
  
-   <span data-ttu-id="e1583-294">如果进程终止，无需给运行时提供清理的机会。</span><span class="sxs-lookup"><span data-stu-id="e1583-294">If the process terminates without giving the runtime a chance to clean up.</span></span> <span data-ttu-id="e1583-295">在这种情况下，运行时的进程终止通知是 DLL_PROCESS_DETACH 通知。</span><span class="sxs-lookup"><span data-stu-id="e1583-295">In this case, the runtime's first notification of process termination is a DLL_PROCESS_DETACH notification.</span></span>  
  
 <span data-ttu-id="e1583-296">仅在关闭过程中，运行时继续完成对象，但可继续减少可终结对象的数量。</span><span class="sxs-lookup"><span data-stu-id="e1583-296">The runtime continues to finalize objects during shutdown only while the number of finalizable objects continues to decrease.</span></span>  
  
 <span data-ttu-id="e1583-297">如果 <xref:System.Object.Finalize%2A> 的 <xref:System.Object.Finalize%2A> 或重写引发异常，并且运行时不是由覆盖默认策略的应用程序承载，则运行时将终止进程，并且不会执行任何活动的 `try`/`finally` 块或终结器。</span><span class="sxs-lookup"><span data-stu-id="e1583-297">If <xref:System.Object.Finalize%2A> or an override of <xref:System.Object.Finalize%2A> throws an exception, and the runtime is not hosted by an application that overrides the default policy, the runtime terminates the process and no active `try`/`finally` blocks or finalizers are executed.</span></span> <span data-ttu-id="e1583-298">如果终结器无法释放或销毁资源，则此行为可确保进程完整性。</span><span class="sxs-lookup"><span data-stu-id="e1583-298">This behavior ensures process integrity if the finalizer cannot free or destroy resources.</span></span>  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a><span data-ttu-id="e1583-299">重写 Finalize 方法</span><span class="sxs-lookup"><span data-stu-id="e1583-299">Overriding the Finalize method</span></span> 
 <span data-ttu-id="e1583-300">应为使用非托管资源的类（如文件句柄或数据库连接）重写 <xref:System.Object.Finalize%2A>，在垃圾回收过程中，当使用这些资源的托管对象被丢弃时必须释放这些资源。</span><span class="sxs-lookup"><span data-stu-id="e1583-300">You should override <xref:System.Object.Finalize%2A> for a class that uses unmanaged resources, such as file handles or database connections that must be released when the managed object that uses them is discarded during garbage collection.</span></span> <span data-ttu-id="e1583-301">不应为托管对象实现 <xref:System.Object.Finalize%2A> 方法，因为垃圾回收器会自动释放托管资源。</span><span class="sxs-lookup"><span data-stu-id="e1583-301">You shouldn't implement a <xref:System.Object.Finalize%2A> method for managed objects because the garbage collector releases managed resources automatically.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="e1583-302">如果 <xref:System.Runtime.InteropServices.SafeHandle> 对象可用来包装非托管资源，则建议的替代方法是使用安全句柄实现 dispose 模式，而不是重写 <xref:System.Object.Finalize%2A>。</span><span class="sxs-lookup"><span data-stu-id="e1583-302">If a <xref:System.Runtime.InteropServices.SafeHandle> object is available that wraps your unmanaged resource, the recommended alternative is to implement the dispose pattern with a safe handle and not override <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="e1583-303">有关详细信息，请参阅[SafeHandle 替代](#SafeHandle)部分。</span><span class="sxs-lookup"><span data-stu-id="e1583-303">For more information, see [The SafeHandle alternative](#SafeHandle) section.</span></span>  
  
 <span data-ttu-id="e1583-304">默认情况下，<xref:System.Object.Finalize%2A?displayProperty=nameWithType> 方法不执行任何操作，但你应仅在必要时重写 <xref:System.Object.Finalize%2A>，并且仅释放非托管资源。</span><span class="sxs-lookup"><span data-stu-id="e1583-304">The <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method does nothing by default, but you should override <xref:System.Object.Finalize%2A> only if necessary, and only to release unmanaged resources.</span></span> <span data-ttu-id="e1583-305">如果某个终止操作运行，则回收内存要花费更长时间，因为它需要至少两个垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="e1583-305">Reclaiming memory tends to take much longer if a finalization operation runs, because it requires at least two garbage collections.</span></span> <span data-ttu-id="e1583-306">此外，还应覆盖仅用于引用类型的 <xref:System.Object.Finalize%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-306">In addition, you should override the <xref:System.Object.Finalize%2A> method for reference types only.</span></span> <span data-ttu-id="e1583-307">公共语言运行时仅终结引用类型。</span><span class="sxs-lookup"><span data-stu-id="e1583-307">The common language runtime only finalizes reference types.</span></span> <span data-ttu-id="e1583-308">它忽略值类型上的终结器。</span><span class="sxs-lookup"><span data-stu-id="e1583-308">It ignores finalizers on value types.</span></span>  

<span data-ttu-id="e1583-309">`protected`<xref:System.Object.Finalize%2A?displayProperty=nameWithType> 方法的作用域。</span><span class="sxs-lookup"><span data-stu-id="e1583-309">The scope of the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method is `protected`.</span></span> <span data-ttu-id="e1583-310">重写类中的方法时，应保持此有限范围。</span><span class="sxs-lookup"><span data-stu-id="e1583-310">You should maintain this limited scope when you override the method in your class.</span></span> <span data-ttu-id="e1583-311">通过保护 <xref:System.Object.Finalize%2A> 方法，你可以防止应用程序的用户直接调用对象的 <xref:System.Object.Finalize%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-311">By keeping a <xref:System.Object.Finalize%2A> method protected, you prevent users of your application from calling an object's <xref:System.Object.Finalize%2A> method directly.</span></span>
  
 <span data-ttu-id="e1583-312">派生类型中 <xref:System.Object.Finalize%2A> 的每个实现都必须调用其基类型的 <xref:System.Object.Finalize%2A>实现。</span><span class="sxs-lookup"><span data-stu-id="e1583-312">Every implementation of <xref:System.Object.Finalize%2A> in a derived type must call its base type's implementation of <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="e1583-313">这是允许应用程序代码调用 <xref:System.Object.Finalize%2A>的唯一情况。</span><span class="sxs-lookup"><span data-stu-id="e1583-313">This is the only case in which application code is allowed to call <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="e1583-314">对象的 <xref:System.Object.Finalize%2A> 方法不应在其基类以外的任何对象上调用方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-314">An object's <xref:System.Object.Finalize%2A> method shouldn't call a method on any objects other than that of its base class.</span></span> <span data-ttu-id="e1583-315">这是因为调用的其他对象可以与调用对象同时收集，如公共语言运行时关闭的情况。</span><span class="sxs-lookup"><span data-stu-id="e1583-315">This is because the other objects being called could be collected at the same time as the calling object, such as in the case of a common language runtime shutdown.</span></span> 
  
> [!NOTE]
>  <span data-ttu-id="e1583-316">C#编译器不允许重写 <xref:System.Object.Finalize%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-316">The C# compiler does not allow you to override the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="e1583-317">而是通过实现类的[析构函数](/dotnet/csharp/programming-guide/classes-and-structs/destructors)来提供终结器。</span><span class="sxs-lookup"><span data-stu-id="e1583-317">Instead, you provide a finalizer by implementing a [destructor](/dotnet/csharp/programming-guide/classes-and-structs/destructors) for your class.</span></span> <span data-ttu-id="e1583-318">C#析构函数自动调用其基类的析构函数。</span><span class="sxs-lookup"><span data-stu-id="e1583-318">A C# destructor automatically calls the destructor of its base class.</span></span>  
>   
>  <span data-ttu-id="e1583-319">视觉C++对象还提供其自己的语法来实现 <xref:System.Object.Finalize%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-319">Visual C++ also provides its own syntax for implementing the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="e1583-320">有关详细信息，请参阅[如何：定义和使用类和结构C++（/cli）](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)中的 "析构函数和终结器" 一节。</span><span class="sxs-lookup"><span data-stu-id="e1583-320">For more information, see the "Destructors and finalizers" section of [How to: Define and Consume Classes and Structs (C++/CLI)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).</span></span>  
  
 <span data-ttu-id="e1583-321">由于垃圾回收是不确定的，因此，在垃圾回收器执行终止时，您不会精确地知道。</span><span class="sxs-lookup"><span data-stu-id="e1583-321">Because garbage collection is non-deterministic, you do not know precisely when the garbage collector performs finalization.</span></span> <span data-ttu-id="e1583-322">若要立即释放资源，还可以选择实现[dispose 模式](/dotnet/standard/garbage-collection/implementing-dispose)和 <xref:System.IDisposable> 接口。</span><span class="sxs-lookup"><span data-stu-id="e1583-322">To release resources immediately, you can also choose to implement the [dispose pattern](/dotnet/standard/garbage-collection/implementing-dispose) and the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="e1583-323"><xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 实现可由类的使用者调用以释放非托管资源，并且可以在未调用 <xref:System.IDisposable.Dispose%2A> 方法的情况下，使用 <xref:System.Object.Finalize%2A> 方法释放非托管资源。</span><span class="sxs-lookup"><span data-stu-id="e1583-323">The <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation can be called by consumers of your class to free unmanaged resources, and you can use the <xref:System.Object.Finalize%2A> method to free unmanaged resources in the event that the <xref:System.IDisposable.Dispose%2A> method is not called.</span></span>  
  
 <span data-ttu-id="e1583-324"><xref:System.Object.Finalize%2A> 几乎可以执行任何操作，包括 resurrecting 一个对象（即，在垃圾回收过程中清除对象后使对象再次可访问）。</span><span class="sxs-lookup"><span data-stu-id="e1583-324"><xref:System.Object.Finalize%2A> can take almost any action, including resurrecting an object (that is, making the object accessible again) after it has been cleaned up during garbage collection.</span></span> <span data-ttu-id="e1583-325">但是，对象只能复活一次;在垃圾回收过程中，不能在复活对象上调用 <xref:System.Object.Finalize%2A>。</span><span class="sxs-lookup"><span data-stu-id="e1583-325">However, the object can only be resurrected once; <xref:System.Object.Finalize%2A> cannot be called on resurrected objects during garbage collection.</span></span>
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a><span data-ttu-id="e1583-326">SafeHandle 备用方法</span><span class="sxs-lookup"><span data-stu-id="e1583-326">The SafeHandle alternative</span></span>  
 <span data-ttu-id="e1583-327">创建可靠终结器通常很难，因为你无法对应用程序的状态进行假设，并且因为未处理的系统异常（如 <xref:System.OutOfMemoryException> 和 <xref:System.StackOverflowException> 终止终结器）。</span><span class="sxs-lookup"><span data-stu-id="e1583-327">Creating reliable finalizers is often difficult, because you cannot make assumptions about the state of your application, and because unhandled system exceptions such as <xref:System.OutOfMemoryException> and <xref:System.StackOverflowException> terminate the finalizer.</span></span> <span data-ttu-id="e1583-328">您可以使用从 <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> 类派生的对象来包装非托管资源，并在不使用终结器的情况下实现 dispose 模式，而不是为类实现终结器以释放非托管资源。</span><span class="sxs-lookup"><span data-stu-id="e1583-328">Instead of implementing a finalizer for your class to release unmanaged resources, you can use an object that is derived from the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> class to wrap your unmanaged resources, and then implement the dispose pattern without a finalizer.</span></span> <span data-ttu-id="e1583-329">.NET Framework 提供从 <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>派生的 <xref:Microsoft.Win32?displayProperty=nameWithType> 命名空间中的以下类：</span><span class="sxs-lookup"><span data-stu-id="e1583-329">The .NET Framework provides the following classes in the <xref:Microsoft.Win32?displayProperty=nameWithType> namespace that are derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:</span></span>  
  
-   <span data-ttu-id="e1583-330"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 是文件句柄的包装类。</span><span class="sxs-lookup"><span data-stu-id="e1583-330"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle> is a wrapper class for a file handle.</span></span>  
  
-   <span data-ttu-id="e1583-331"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> 是内存映射的文件句柄的包装类。</span><span class="sxs-lookup"><span data-stu-id="e1583-331"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> is a wrapper class for memory-mapped file handles.</span></span>  
  
-   <span data-ttu-id="e1583-332"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> 是指向非托管内存块的指针的包装类。</span><span class="sxs-lookup"><span data-stu-id="e1583-332"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> is a wrapper class for a pointer to a block of unmanaged memory.</span></span>  
  
-   <span data-ttu-id="e1583-333"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>、<xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>和 <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> 是加密句柄的包装类。</span><span class="sxs-lookup"><span data-stu-id="e1583-333"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> are wrapper classes for cryptographic handles.</span></span>  
  
-   <span data-ttu-id="e1583-334"><xref:Microsoft.Win32.SafeHandles.SafePipeHandle> 是管道句柄的包装类。</span><span class="sxs-lookup"><span data-stu-id="e1583-334"><xref:Microsoft.Win32.SafeHandles.SafePipeHandle> is a wrapper class for pipe handles.</span></span>  
  
-   <span data-ttu-id="e1583-335"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> 是注册表项的句柄的包装类。</span><span class="sxs-lookup"><span data-stu-id="e1583-335"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> is a wrapper class for a handle to a registry key.</span></span>  
  
-   <span data-ttu-id="e1583-336"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> 是等待句柄的包装类。</span><span class="sxs-lookup"><span data-stu-id="e1583-336"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> is a wrapper class for a wait handle.</span></span>  
  
 <span data-ttu-id="e1583-337">下面的示例将[dispose 模式](/dotnet/standard/garbage-collection/implementing-dispose)与安全句柄一起使用，而不是重写 <xref:System.Object.Finalize%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-337">The following example uses the [dispose pattern](/dotnet/standard/garbage-collection/implementing-dispose) with safe handles instead of overriding the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="e1583-338">它定义了一个 `FileAssociation` 类，该类包装有关处理具有特定文件扩展名的文件的应用程序的注册表信息。</span><span class="sxs-lookup"><span data-stu-id="e1583-338">It defines a `FileAssociation` class that wraps registry information about the application that handles files with a particular file extension.</span></span> <span data-ttu-id="e1583-339">由于 Windows [RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx)函数调用将 `out` 参数传递到 <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> 构造函数，因此返回了两个注册表句柄。</span><span class="sxs-lookup"><span data-stu-id="e1583-339">The two registry handles returned as `out` parameters by Windows [RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) function calls are passed to the <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> constructor.</span></span> <span data-ttu-id="e1583-340">然后，该类型的受保护 `Dispose` 方法调用 `SafeRegistryHandle.Dispose` 方法来释放这两个句柄。</span><span class="sxs-lookup"><span data-stu-id="e1583-340">The type's protected `Dispose` method then calls the `SafeRegistryHandle.Dispose` method  to free these two handles.</span></span>  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="e1583-341">下面的示例验证当重写 <xref:System.Object.Finalize%2A> 的对象被销毁时调用 <xref:System.Object.Finalize%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-341">The following example verifies that the <xref:System.Object.Finalize%2A> method is called when an object that overrides <xref:System.Object.Finalize%2A> is destroyed.</span></span> <span data-ttu-id="e1583-342">请注意，在生产应用程序中，将重写 <xref:System.Object.Finalize%2A> 方法，以释放由该对象占用的非托管资源。</span><span class="sxs-lookup"><span data-stu-id="e1583-342">Note that, in a production application, the <xref:System.Object.Finalize%2A> method would be overridden to release unmanaged resources held by the object.</span></span> <span data-ttu-id="e1583-343">另请注意， C#该示例提供析构函数，而不是重写 <xref:System.Object.Finalize%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-343">Also note that the C# example provides a destructor instead of overriding the <xref:System.Object.Finalize%2A> method.</span></span>  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 <span data-ttu-id="e1583-344">有关替代 <xref:System.Object.Finalize%2A> 方法的其他示例，请参阅 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-344">For an additional example that overrides the <xref:System.Object.Finalize%2A> method, see the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e1583-345">作为默认哈希函数。</span><span class="sxs-lookup"><span data-stu-id="e1583-345">Serves as the default hash function.</span></span></summary>
        <returns><span data-ttu-id="e1583-346">当前对象的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="e1583-346">A hash code for the current object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e1583-347">哈希代码是一个数字值，用于在基于哈希的集合（如 <xref:System.Collections.Generic.Dictionary%602> 类、<xref:System.Collections.Hashtable> 类或派生自 <xref:System.Collections.DictionaryBase> 类的类型）中插入和标识对象。</span><span class="sxs-lookup"><span data-stu-id="e1583-347">A hash code is a numeric value that is used to insert and identify an object in a hash-based collection such as the <xref:System.Collections.Generic.Dictionary%602> class, the <xref:System.Collections.Hashtable> class, or a type derived from the <xref:System.Collections.DictionaryBase> class.</span></span> <span data-ttu-id="e1583-348"><xref:System.Object.GetHashCode%2A> 方法为需要快速检查对象相等性的算法提供此哈希代码。</span><span class="sxs-lookup"><span data-stu-id="e1583-348">The <xref:System.Object.GetHashCode%2A> method provides this hash code for algorithms that need quick checks of object equality.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e1583-349">有关哈希表中的哈希代码和其他哈希代码算法如何使用哈希代码的信息，请参阅维基百科中的[哈希函数](https://en.wikipedia.org/wiki/Hash_function)条目。</span><span class="sxs-lookup"><span data-stu-id="e1583-349">For information about how hash codes are used in hash tables and for some additional hash code algorithms, see the [Hash Function](https://en.wikipedia.org/wiki/Hash_function) entry in Wikipedia.</span></span>  
  
 <span data-ttu-id="e1583-350">相等的两个对象返回的哈希代码相等。</span><span class="sxs-lookup"><span data-stu-id="e1583-350">Two objects that are equal return hash codes that are equal.</span></span> <span data-ttu-id="e1583-351">但是，反之亦然：相等的哈希代码不意味着对象相等，因为不同（不相等）对象可以具有相同的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="e1583-351">However, the reverse is not true: equal hash codes do not imply object equality, because different (unequal) objects can have identical hash codes.</span></span> <span data-ttu-id="e1583-352">此外，.NET 不保证 <xref:System.Object.GetHashCode%2A> 方法的默认实现，并且此方法返回的值可能在 .NET 实现（例如不同版本的 .NET Framework 和 .NET Core）和平台（例如32位和64位平台）之间有所不同。</span><span class="sxs-lookup"><span data-stu-id="e1583-352">Furthermore, .NET does not guarantee the default implementation of the <xref:System.Object.GetHashCode%2A> method, and the value this method returns may differ between .NET implementations, such as different versions of .NET Framework and .NET Core, and platforms, such as 32-bit and 64-bit platforms.</span></span> <span data-ttu-id="e1583-353">出于这些原因，请不要将此方法的默认实现用作唯一对象标识符以进行哈希处理。</span><span class="sxs-lookup"><span data-stu-id="e1583-353">For these reasons, do not use the default implementation of this method as a unique object identifier for hashing purposes.</span></span> <span data-ttu-id="e1583-354">下面是两个结果：</span><span class="sxs-lookup"><span data-stu-id="e1583-354">Two consequences follow from this:</span></span>  
  
-   <span data-ttu-id="e1583-355">不应假定相等哈希代码意味着对象相等。</span><span class="sxs-lookup"><span data-stu-id="e1583-355">You should not assume that equal hash codes imply object equality.</span></span>  
  
-   <span data-ttu-id="e1583-356">永远不应在创建它的应用程序域之外保留或使用哈希代码，因为相同的对象可能会在应用程序域、进程和平台之间进行哈希运算。</span><span class="sxs-lookup"><span data-stu-id="e1583-356">You should never persist or use a hash code outside the application domain in which it was created, because the same object may hash across application domains, processes, and platforms.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="e1583-357">哈希代码适用于基于哈希表的集合中的高效插入和查找。</span><span class="sxs-lookup"><span data-stu-id="e1583-357">A hash code is intended for efficient insertion and lookup in collections that are based on a hash table.</span></span> <span data-ttu-id="e1583-358">哈希代码不是永久值。</span><span class="sxs-lookup"><span data-stu-id="e1583-358">A hash code is not a permanent value.</span></span> <span data-ttu-id="e1583-359">出于此原因：</span><span class="sxs-lookup"><span data-stu-id="e1583-359">For this reason:</span></span>  
>   
> -   <span data-ttu-id="e1583-360">不要序列化哈希代码值或将其存储在数据库中。</span><span class="sxs-lookup"><span data-stu-id="e1583-360">Do not serialize hash code values or store them in databases.</span></span>  
> -   <span data-ttu-id="e1583-361">不要使用哈希代码作为密钥来检索键控集合中的对象。</span><span class="sxs-lookup"><span data-stu-id="e1583-361">Do not use the hash code as the key to retrieve an object from a keyed collection.</span></span>  
> -   <span data-ttu-id="e1583-362">不要跨应用程序域或进程发送哈希代码。</span><span class="sxs-lookup"><span data-stu-id="e1583-362">Do not send hash codes across application domains or processes.</span></span> <span data-ttu-id="e1583-363">在某些情况下，可以基于每个进程或每个应用程序域来计算哈希代码。</span><span class="sxs-lookup"><span data-stu-id="e1583-363">In some cases, hash codes may be computed on a per-process or per-application domain basis.</span></span>  
> -   <span data-ttu-id="e1583-364">如果需要加密型强哈希，请不要使用哈希代码（而不是加密哈希函数返回的值）。</span><span class="sxs-lookup"><span data-stu-id="e1583-364">Do not use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</span></span> <span data-ttu-id="e1583-365">对于加密哈希，请使用派生自 <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> 或 <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> 类的类。</span><span class="sxs-lookup"><span data-stu-id="e1583-365">For cryptographic hashes, use a class derived from the <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> or <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> class.</span></span>  
> -   <span data-ttu-id="e1583-366">不要测试哈希代码是否相等，以确定两个对象是否相等。</span><span class="sxs-lookup"><span data-stu-id="e1583-366">Do not test for equality of hash codes to determine whether two objects are equal.</span></span> <span data-ttu-id="e1583-367">（不相等的对象可以具有相同的哈希代码。）若要测试是否相等，请调用 <xref:System.Object.ReferenceEquals%2A> 或 <xref:System.Object.Equals%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-367">(Unequal objects can have identical hash codes.) To test for equality, call the <xref:System.Object.ReferenceEquals%2A> or <xref:System.Object.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="e1583-368"><xref:System.Object.GetHashCode%2A> 方法可由派生类型重写。</span><span class="sxs-lookup"><span data-stu-id="e1583-368">The <xref:System.Object.GetHashCode%2A> method can be overridden by a derived type.</span></span> <span data-ttu-id="e1583-369">如果 <xref:System.Object.GetHashCode%2A> 未重写，则通过调用基类的 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 方法来计算引用类型的哈希代码，该方法根据对象的引用计算哈希代码;有关详细信息，请参阅 <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="e1583-369">If <xref:System.Object.GetHashCode%2A> is not overridden, hash codes for reference types are computed by calling the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method of the base class, which computes a hash code based on an object's reference; for more information, see <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e1583-370">换句话说，<xref:System.Object.ReferenceEquals%2A> 方法返回的两个对象 `true` 具有相同的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="e1583-370">In other words, two objects for which the <xref:System.Object.ReferenceEquals%2A> method returns `true` have identical hash codes.</span></span> <span data-ttu-id="e1583-371">如果值类型不重写 <xref:System.Object.GetHashCode%2A>，则基类的 <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> 方法使用反射基于该类型字段的值来计算哈希代码。</span><span class="sxs-lookup"><span data-stu-id="e1583-371">If value types do not override <xref:System.Object.GetHashCode%2A>, the <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> method of the base class uses reflection to compute the hash code based on the values of the type's fields.</span></span> <span data-ttu-id="e1583-372">换句话说，其字段具有相等值的值类型具有相同的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="e1583-372">In other words, value types whose fields have equal values have equal hash codes.</span></span> <span data-ttu-id="e1583-373">有关重写 <xref:System.Object.GetHashCode%2A>的详细信息，请参阅 "对继承者的说明" 部分。</span><span class="sxs-lookup"><span data-stu-id="e1583-373">For more information about overriding <xref:System.Object.GetHashCode%2A>, see the "Notes to Inheritors" section.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="e1583-374">如果重写 <xref:System.Object.GetHashCode%2A> 方法，则还应重写 <xref:System.Object.Equals%2A>，反之亦然。</span><span class="sxs-lookup"><span data-stu-id="e1583-374">If you override the <xref:System.Object.GetHashCode%2A> method, you should also override <xref:System.Object.Equals%2A>, and vice versa.</span></span> <span data-ttu-id="e1583-375">如果重写的 <xref:System.Object.Equals%2A> 方法在测试两个对象是否相等时返回 `true`，则重写的 <xref:System.Object.GetHashCode%2A> 方法必须为这两个对象返回相同的值。</span><span class="sxs-lookup"><span data-stu-id="e1583-375">If your overridden <xref:System.Object.Equals%2A> method returns `true` when two objects are tested for equality, your overridden <xref:System.Object.GetHashCode%2A> method must return the same value for the two objects.</span></span>  
  
 <span data-ttu-id="e1583-376">如果用作哈希表中的键的对象不提供 <xref:System.Object.GetHashCode%2A>的有用实现，则可以通过向 <xref:System.Collections.Hashtable> 类构造函数的重载之一提供 <xref:System.Collections.IEqualityComparer> 实现来指定哈希代码提供程序。</span><span class="sxs-lookup"><span data-stu-id="e1583-376">If an object that is used as a key in a hash table does not provide a useful implementation of <xref:System.Object.GetHashCode%2A>, you can specify a hash code provider by supplying an <xref:System.Collections.IEqualityComparer> implementation to one of the overloads of the <xref:System.Collections.Hashtable> class constructor.</span></span>  
  
## <a name="notes-for-the-wrt"></a><span data-ttu-id="e1583-377">[!INCLUDE[wrt](~/includes/wrt-md.md)] 的说明</span><span class="sxs-lookup"><span data-stu-id="e1583-377">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="e1583-378">对 [!INCLUDE[wrt](~/includes/wrt-md.md)]中的类调用 <xref:System.Object.GetHashCode%2A> 方法时，它将为不重写 <xref:System.Object.GetHashCode%2A>的类提供默认行为。</span><span class="sxs-lookup"><span data-stu-id="e1583-378">When you call the <xref:System.Object.GetHashCode%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don't override <xref:System.Object.GetHashCode%2A>.</span></span> <span data-ttu-id="e1583-379">这是 .NET Framework 为 [!INCLUDE[wrt](~/includes/wrt-md.md)] 提供的支持的一部分（请参阅[Windows 应用商店应用和 Windows 运行时 .NET Framework 支持](/dotnet/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime)）。</span><span class="sxs-lookup"><span data-stu-id="e1583-379">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](/dotnet/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime)).</span></span> <span data-ttu-id="e1583-380">[!INCLUDE[wrt](~/includes/wrt-md.md)] 中的类不会继承 <xref:System.Object>，当前未实现 <xref:System.Object.GetHashCode%2A>。</span><span class="sxs-lookup"><span data-stu-id="e1583-380">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don't inherit <xref:System.Object>, and currently don't implement a <xref:System.Object.GetHashCode%2A>.</span></span> <span data-ttu-id="e1583-381">但是，当你在C#或 Visual Basic 代码中使用它们时，它们看起来有 <xref:System.Object.ToString%2A>、<xref:System.Object.Equals%28System.Object%29>和 <xref:System.Object.GetHashCode%2A> 方法，而 .NET Framework 提供这些方法的默认行为。</span><span class="sxs-lookup"><span data-stu-id="e1583-381">However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e1583-382">用 Visual Basic C#或编写的 [!INCLUDE[wrt](~/includes/wrt-md.md)] 类可以重写 <xref:System.Object.GetHashCode%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-382">[!INCLUDE[wrt](~/includes/wrt-md.md)] classes that are written in C# or Visual Basic can override the <xref:System.Object.GetHashCode%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e1583-383">对于与 <xref:System.Int32> 类型具有相同或更小范围的数值，计算哈希代码的最简单方法之一是只返回该值。</span><span class="sxs-lookup"><span data-stu-id="e1583-383">One of the simplest ways to compute a hash code for a numeric value that has the same or a smaller range than the <xref:System.Int32> type is to simply return that value.</span></span> <span data-ttu-id="e1583-384">下面的示例演示 `Number` 结构的实现。</span><span class="sxs-lookup"><span data-stu-id="e1583-384">The following example shows such an implementation for a `Number` structure.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 <span data-ttu-id="e1583-385">通常，类型具有多个数据字段，这些字段可参与生成哈希代码。</span><span class="sxs-lookup"><span data-stu-id="e1583-385">Frequently, a type has multiple data fields that can participate in generating the hash code.</span></span> <span data-ttu-id="e1583-386">生成哈希代码的一种方法是使用 `XOR (eXclusive OR)` 操作来合并这些字段，如以下示例中所示。</span><span class="sxs-lookup"><span data-stu-id="e1583-386">One way to generate a hash code is to combine these fields using an `XOR (eXclusive OR)` operation, as shown in the following example.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 <span data-ttu-id="e1583-387">前面的示例返回相同的哈希代码（n1、n2）和（n2，n1），因此可能会产生比预期更多的冲突。</span><span class="sxs-lookup"><span data-stu-id="e1583-387">The previous example returns the same hash code for (n1, n2) and (n2, n1), and so may generate more collisions than are desirable.</span></span> <span data-ttu-id="e1583-388">提供了许多解决方案，以便这些情况下的哈希代码不完全相同。</span><span class="sxs-lookup"><span data-stu-id="e1583-388">A number of solutions are available so that hash codes in these cases are not identical.</span></span> <span data-ttu-id="e1583-389">一种是返回 `Tuple` 对象的哈希代码，该对象反映每个字段的顺序。</span><span class="sxs-lookup"><span data-stu-id="e1583-389">One is to return the hash code of a `Tuple` object that reflects the order of each field.</span></span> <span data-ttu-id="e1583-390">下面的示例演示使用 <xref:System.Tuple%602> 类的可能的实现。</span><span class="sxs-lookup"><span data-stu-id="e1583-390">The following example shows a possible implementation that uses the <xref:System.Tuple%602> class.</span></span> <span data-ttu-id="e1583-391">但请注意，实例化 `Tuple` 对象的性能开销可能会显著影响在哈希表中存储大量对象的应用程序的整体性能。</span><span class="sxs-lookup"><span data-stu-id="e1583-391">Note, though, that the performance overhead of instantiating a `Tuple` object may significantly impact the overall performance of an application that stores large numbers of objects in hash tables.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 <span data-ttu-id="e1583-392">第二种替代解决方案涉及通过将连续字段的哈希代码左移两位或更多位，来加权单个哈希代码。</span><span class="sxs-lookup"><span data-stu-id="e1583-392">A second alternative solution involves weighting the individual hash codes by left-shifting the hash codes of successive fields by two or more bits.</span></span> <span data-ttu-id="e1583-393">最佳情况下，超出位31的位应换行，而不是丢弃。</span><span class="sxs-lookup"><span data-stu-id="e1583-393">Optimally, bits shifted beyond bit 31 should wrap around rather than be discarded.</span></span> <span data-ttu-id="e1583-394">由于C#和 Visual Basic 中的左移运算符会丢弃 bits，这需要创建左移和换行方法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="e1583-394">Since bits are discarded by the left-shift operators in both C# and Visual Basic, this requires creating a left shift-and-wrap method like the following:</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 <span data-ttu-id="e1583-395">然后，下面的示例使用此 shift 和 wrap 方法计算前面的示例中使用的 `Point` 结构的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="e1583-395">The following example then uses this shift-and-wrap method to compute the hash code of the `Point` structure used in the previous examples.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="e1583-396">使用哈希函数可以快速生成与对象的值相对应的数字（哈希代码）。</span><span class="sxs-lookup"><span data-stu-id="e1583-396">A hash function is used to quickly generate a number (hash code) that corresponds to the value of an object.</span></span> <span data-ttu-id="e1583-397">哈希函数通常是特定于每个类型的，因此，为实现唯一性，必须使用至少一个实例字段作为输入。</span><span class="sxs-lookup"><span data-stu-id="e1583-397">Hash functions are usually specific to each type and, for uniqueness, must use at least one of the instance fields as input.</span></span> <span data-ttu-id="e1583-398">不应使用静态字段的值来计算哈希代码。</span><span class="sxs-lookup"><span data-stu-id="e1583-398">Hash codes should not be computed by using the values of static fields.</span></span>  
  
<span data-ttu-id="e1583-399">对于从 <see cref="T:System.Object" />派生的类，只有当派生类将相等性定义为引用相等性时，<see langword="GetHashCode" /> 方法才能将基类委托给基类 <see cref="M:System.Object.GetHashCode" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="e1583-399">For classes derived from <see cref="T:System.Object" />, the <see langword="GetHashCode" /> method can delegate to the base class <see cref="M:System.Object.GetHashCode" /> implementation only if the derived class defines equality to be reference equality.</span></span> <span data-ttu-id="e1583-400">引用类型 <see cref="M:System.Object.GetHashCode" /> 的默认实现返回的哈希代码等效于 <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> 方法返回的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="e1583-400">The default implementation of <see cref="M:System.Object.GetHashCode" /> for reference types returns a hash code that is equivalent to the one returned by the <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> method.</span></span> <span data-ttu-id="e1583-401">可以重写不可变引用类型的 <see cref="M:System.Object.GetHashCode" />。</span><span class="sxs-lookup"><span data-stu-id="e1583-401">You can override <see cref="M:System.Object.GetHashCode" /> for immutable reference types.</span></span> <span data-ttu-id="e1583-402">通常，对于可变引用类型，应仅在以下情况下重写 <see cref="M:System.Object.GetHashCode" />：</span><span class="sxs-lookup"><span data-stu-id="e1583-402">In general, for mutable reference types, you should override <see cref="M:System.Object.GetHashCode" /> only if:</span></span> 
<span data-ttu-id="e1583-403">-可以计算不可变的字段中的哈希代码;或</span><span class="sxs-lookup"><span data-stu-id="e1583-403">-   You can compute the hash code from fields that are not mutable; or</span></span> 
<span data-ttu-id="e1583-404">-可以确保可变对象的哈希代码在依赖于其哈希代码的集合中时不会更改。</span><span class="sxs-lookup"><span data-stu-id="e1583-404">-   You can ensure that the hash code of a mutable object does not change while the object is contained in a collection that relies on its hash code.</span></span>  
  
<span data-ttu-id="e1583-405">否则，你可能会认为可变对象会在哈希表中丢失。</span><span class="sxs-lookup"><span data-stu-id="e1583-405">Otherwise, you might think that the mutable object is lost in the hash table.</span></span> <span data-ttu-id="e1583-406">如果选择替代可变引用类型的 <see cref="M:System.Object.GetHashCode" />，您的文档应清楚地说明，当对象存储在哈希表中时，您的类型的用户不应修改对象值。</span><span class="sxs-lookup"><span data-stu-id="e1583-406">If you do choose to override <see cref="M:System.Object.GetHashCode" /> for a mutable reference type, your documentation should make it clear that users of your type should not modify object values while the object is stored in a hash table.</span></span>  
  
<span data-ttu-id="e1583-407">对于值类型，<see cref="M:System.ValueType.GetHashCode" /> 提供使用反射的默认哈希代码实现。</span><span class="sxs-lookup"><span data-stu-id="e1583-407">For value types, <see cref="M:System.ValueType.GetHashCode" /> provides a default hash code implementation that uses reflection.</span></span> <span data-ttu-id="e1583-408">你应考虑重写它以获得更好的性能。</span><span class="sxs-lookup"><span data-stu-id="e1583-408">You should consider overriding it for better performance.</span></span>  
  
 <block subset="none" type="note"><para>  
 <span data-ttu-id="e1583-409">有关以各种方式计算哈希代码的详细信息和示例，请参阅 "示例" 部分。</span><span class="sxs-lookup"><span data-stu-id="e1583-409">For more information and examples that compute hash codes in a variety of ways, see the Examples section.</span></span>  
  
</para></block>  
  
 <span data-ttu-id="e1583-410">哈希函数必须具有以下属性：</span><span class="sxs-lookup"><span data-stu-id="e1583-410">A hash function must have the following properties:</span></span> 
<span data-ttu-id="e1583-411">-如果两个对象的比较结果相等，则每个对象的 <see cref="M:System.Object.GetHashCode" /> 方法必须返回相同的值。</span><span class="sxs-lookup"><span data-stu-id="e1583-411">-   If two objects compare as equal, the <see cref="M:System.Object.GetHashCode" /> method for each object must return the same value.</span></span> <span data-ttu-id="e1583-412">但是，如果两个对象的比较结果不相等，则这两个对象的 <see cref="M:System.Object.GetHashCode" /> 方法不必返回不同的值。</span><span class="sxs-lookup"><span data-stu-id="e1583-412">However, if two objects do not compare as equal, the <see cref="M:System.Object.GetHashCode" /> methods for the two objects do not have to return different values.</span></span>  
  
<span data-ttu-id="e1583-413">-对于对象状态不会修改确定对象的[system.object](xref:System.Object.Equals*)方法返回值的对象状态，对象的 <see cref="M:System.Object.GetHashCode" /> 方法必须始终返回相同的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="e1583-413">-   The <see cref="M:System.Object.GetHashCode" /> method for an object must consistently return the same hash code as long as there is no modification to the object state that determines the return value of the object's [System.Object.Equals](xref:System.Object.Equals*) method.</span></span> <span data-ttu-id="e1583-414">请注意，这仅适用于当前执行的应用程序，并且如果重新运行应用程序，则可以返回不同的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="e1583-414">Note that this is true only for the current execution of an application, and that a different hash code can be returned if the application is run again.</span></span>  
  
<span data-ttu-id="e1583-415">-为了获得最佳性能，哈希函数应为所有输入生成偶数分布，其中包括大量聚集输入。</span><span class="sxs-lookup"><span data-stu-id="e1583-415">-   For the best performance, a hash function should generate an even distribution for all input, including input that is heavily clustered.</span></span> <span data-ttu-id="e1583-416">这意味着，对对象状态的小修改应该会导致对生成的哈希代码进行较大的修改，以获得最佳的哈希表性能。</span><span class="sxs-lookup"><span data-stu-id="e1583-416">An implication is that small modifications to object state should result in large modifications to the resulting hash code for best hash table performance.</span></span>  
  
<span data-ttu-id="e1583-417">-哈希函数的计算成本应较低。</span><span class="sxs-lookup"><span data-stu-id="e1583-417">-   Hash functions should be inexpensive to compute.</span></span>  
  
<span data-ttu-id="e1583-418">-<see cref="M:System.Object.GetHashCode" /> 方法不应引发异常。</span><span class="sxs-lookup"><span data-stu-id="e1583-418">-   The <see cref="M:System.Object.GetHashCode" /> method should not throw exceptions.</span></span>  
  
<span data-ttu-id="e1583-419">例如，<see cref="T:System.String" /> 类提供的 <see cref="M:System.String.GetHashCode" /> 方法的实现返回相同字符串值的相同哈希代码。</span><span class="sxs-lookup"><span data-stu-id="e1583-419">For example, the implementation of the <see cref="M:System.String.GetHashCode" /> method provided by the <see cref="T:System.String" /> class returns identical hash codes for identical string values.</span></span> <span data-ttu-id="e1583-420">因此，如果两个 <see cref="T:System.String" /> 对象表示相同的字符串值，则它们将返回相同的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="e1583-420">Therefore, two <see cref="T:System.String" /> objects return the same hash code if they represent the same string value.</span></span> <span data-ttu-id="e1583-421">此外，该方法使用字符串中的所有字符生成合理的随机分发输出，即使在特定范围内对输入进行群集（例如，许多用户可能包含仅包含较低 128 ASCII 字符的字符串，即使字符串可以包含任何 65535 Unicode 字符）。</span><span class="sxs-lookup"><span data-stu-id="e1583-421">Also, the method uses all the characters in the string to generate reasonably randomly distributed output, even when the input is clustered in certain ranges (for example, many users might have strings that contain only the lower 128 ASCII characters, even though a string can contain any of the 65,535 Unicode characters).</span></span>  
  
<span data-ttu-id="e1583-422">在类上提供良好的哈希函数可能会显著影响将这些对象添加到哈希表的性能。</span><span class="sxs-lookup"><span data-stu-id="e1583-422">Providing a good hash function on a class can significantly affect the performance of adding those objects to a hash table.</span></span> <span data-ttu-id="e1583-423">在具有提供哈希函数的良好实现的键的哈希表中，搜索元素会采用固定时间（例如，O （1）操作）。</span><span class="sxs-lookup"><span data-stu-id="e1583-423">In a hash table with keys that provide a good implementation of a hash function, searching for an element takes constant time (for example, an O(1) operation).</span></span> <span data-ttu-id="e1583-424">如果哈希表中的哈希函数实现不佳，则搜索的性能取决于哈希表中的项数（例如，O （`n`）运算，其中 `n` 是哈希表中的项的数目）。</span><span class="sxs-lookup"><span data-stu-id="e1583-424">In a hash table with a poor implementation of a hash function, the performance of a search depends on the number of items in the hash table (for example, an O(`n`) operation, where `n` is the number of items in the hash table).</span></span> <span data-ttu-id="e1583-425">恶意用户可以输入增加冲突数量的数据，这可能会显著降低依赖于哈希表的应用程序的性能，但在以下情况下：</span><span class="sxs-lookup"><span data-stu-id="e1583-425">A malicious user can input data that increases the number of collisions, which can significantly degrade the performance of applications that depend on hash tables, under the following conditions:</span></span> 
<span data-ttu-id="e1583-426">-哈希函数产生频繁冲突。</span><span class="sxs-lookup"><span data-stu-id="e1583-426">-   When hash functions produce frequent collisions.</span></span>  
  
<span data-ttu-id="e1583-427">-当哈希表中的大量对象产生相等或近似相等的哈希代码时。</span><span class="sxs-lookup"><span data-stu-id="e1583-427">-   When a large proportion of objects in a hash table produce hash codes that are equal or approximately equal to one another.</span></span>  
  
<span data-ttu-id="e1583-428">-当用户输入从中计算哈希代码的数据时。</span><span class="sxs-lookup"><span data-stu-id="e1583-428">-   When users input the data from which the hash code is computed.</span></span>  
  
<span data-ttu-id="e1583-429">重写 <see cref="M:System.Object.GetHashCode" /> 的派生类还必须重写 <see cref="M:System.Object.Equals(System.Object)" />，以保证视为相等的两个对象具有相同的哈希代码;否则，<see cref="T:System.Collections.Hashtable" /> 类型可能无法正常工作。</span><span class="sxs-lookup"><span data-stu-id="e1583-429">Derived classes that override <see cref="M:System.Object.GetHashCode" /> must also override <see cref="M:System.Object.Equals(System.Object)" /> to guarantee that two objects considered equal have the same hash code; otherwise, the <see cref="T:System.Collections.Hashtable" /> type might not work correctly.</span></span></para></block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e1583-430">获取当前实例的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="e1583-430">Gets the <see cref="T:System.Type" /> of the current instance.</span></span></summary>
        <returns><span data-ttu-id="e1583-431">当前实例的准确运行时类型。</span><span class="sxs-lookup"><span data-stu-id="e1583-431">The exact runtime type of the current instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e1583-432">由于 <xref:System.Object?displayProperty=nameWithType> 是 .NET 类型系统中所有类型的基类，因此 <xref:System.Object.GetType%2A> 方法可用于返回表示所有 .NET 类型 <xref:System.Type> 对象。</span><span class="sxs-lookup"><span data-stu-id="e1583-432">Because <xref:System.Object?displayProperty=nameWithType> is the base class for all types in the .NET type system, the <xref:System.Object.GetType%2A> method can be used to return <xref:System.Type> objects that represent all .NET types.</span></span> <span data-ttu-id="e1583-433">.NET 可识别以下五类类型：</span><span class="sxs-lookup"><span data-stu-id="e1583-433">.NET recognizes the following five categories of types:</span></span>  
  
-   <span data-ttu-id="e1583-434">派生自 <xref:System.Object?displayProperty=nameWithType>的类</span><span class="sxs-lookup"><span data-stu-id="e1583-434">Classes, which are derived from <xref:System.Object?displayProperty=nameWithType>,</span></span>  
  
-   <span data-ttu-id="e1583-435">值类型，派生自 <xref:System.ValueType?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="e1583-435">Value types, which are derived from <xref:System.ValueType?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="e1583-436">从 .NET Framework 2.0 开始 <xref:System.Object?displayProperty=nameWithType> 派生的接口。</span><span class="sxs-lookup"><span data-stu-id="e1583-436">Interfaces, which are derived from <xref:System.Object?displayProperty=nameWithType> starting with the .NET Framework 2.0.</span></span>  
  
-   <span data-ttu-id="e1583-437">派生自 <xref:System.Enum?displayProperty=nameWithType>的枚举。</span><span class="sxs-lookup"><span data-stu-id="e1583-437">Enumerations, which are derived from <xref:System.Enum?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="e1583-438">委托，派生自 <xref:System.MulticastDelegate?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="e1583-438">Delegates, which are derived from <xref:System.MulticastDelegate?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="e1583-439">对于具有相同运行时类型 `x` 和 `y` 的两个对象，`Object.ReferenceEquals(x.GetType(),y.GetType())` 返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="e1583-439">For two objects `x` and `y` that have identical runtime types, `Object.ReferenceEquals(x.GetType(),y.GetType())` returns `true`.</span></span> <span data-ttu-id="e1583-440">下面的示例将 <xref:System.Object.GetType%2A> 方法与 <xref:System.Object.ReferenceEquals%2A> 方法一起使用，以确定一个数值是否为与另外两个数值相同的类型。</span><span class="sxs-lookup"><span data-stu-id="e1583-440">The following example uses the <xref:System.Object.GetType%2A> method with the <xref:System.Object.ReferenceEquals%2A> method to determine whether one numeric value is the same type as two other numeric values.</span></span>  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb" id="Snippet1"::: 

> [!NOTE]
>  <span data-ttu-id="e1583-441">若要确定某个对象是否为特定类型，可以使用您的语言的类型比较关键字或构造。</span><span class="sxs-lookup"><span data-stu-id="e1583-441">To determine whether an object is a specific type, you can use your language's type comparison keyword or construct.</span></span> <span data-ttu-id="e1583-442">例如，你可以在中C#使用 Visual Basic 或 `is` 关键字中的 `TypeOf…Is` 构造。</span><span class="sxs-lookup"><span data-stu-id="e1583-442">For example, you can use the `TypeOf…Is` construct in Visual Basic or the `is` keyword in C#.</span></span>  
  
 <span data-ttu-id="e1583-443">派生自 <xref:System.Object>的所有类型都继承 <xref:System.Object.GetType%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-443">The <xref:System.Object.GetType%2A> method is inherited by all types that derive from <xref:System.Object>.</span></span> <span data-ttu-id="e1583-444">这意味着，除了使用自己的语言的比较关键字外，还可以使用 <xref:System.Object.GetType%2A> 方法来确定特定对象的类型，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="e1583-444">This means that, in addition to using your own language's comparison keyword, you can use the <xref:System.Object.GetType%2A> method to determine the type of a particular object, as the following example shows.</span></span>  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb" id="Snippet2":::
  
 <span data-ttu-id="e1583-445"><xref:System.Type> 对象公开与当前 <xref:System.Object>的类关联的元数据。</span><span class="sxs-lookup"><span data-stu-id="e1583-445">The <xref:System.Type> object exposes the metadata associated with the class of the current <xref:System.Object>.</span></span>  
  
   
  
## Examples  

 <span data-ttu-id="e1583-446">下面的代码示例演示 <xref:System.Object.GetType%2A> 返回当前实例的运行时类型。</span><span class="sxs-lookup"><span data-stu-id="e1583-446">The following code example demonstrates that <xref:System.Object.GetType%2A> returns the runtime type of the current instance.</span></span>  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp" id="Snippet1"::: 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e1583-447">创建当前 <see cref="T:System.Object" /> 的浅表副本。</span><span class="sxs-lookup"><span data-stu-id="e1583-447">Creates a shallow copy of the current <see cref="T:System.Object" />.</span></span></summary>
        <returns><span data-ttu-id="e1583-448">当前 <see cref="T:System.Object" /> 的浅表副本。</span><span class="sxs-lookup"><span data-stu-id="e1583-448">A shallow copy of the current <see cref="T:System.Object" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e1583-449"><xref:System.Object.MemberwiseClone%2A> 方法创建一个浅表副本，方法是创建一个新的对象，然后将当前对象的非静态字段复制到新的对象。</span><span class="sxs-lookup"><span data-stu-id="e1583-449">The <xref:System.Object.MemberwiseClone%2A> method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object.</span></span> <span data-ttu-id="e1583-450">如果字段是值类型，则执行字段的逐位副本。</span><span class="sxs-lookup"><span data-stu-id="e1583-450">If a field is a value type, a bit-by-bit copy of the field is performed.</span></span> <span data-ttu-id="e1583-451">如果字段是引用类型，则会复制引用，但不会复制引用的对象;因此，原始对象及其复本引用相同的对象。</span><span class="sxs-lookup"><span data-stu-id="e1583-451">If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.</span></span>  
  
 <span data-ttu-id="e1583-452">例如，假设有一个名为 X 的对象引用对象 A 和 B。对象 B 反过来引用对象 C。X 的浅表副本创建新的对象 X2，后者同时引用对象 A 和 B。与之相比，X 的深层副本会创建一个新的对象 X2，该对象引用作为 A 和 B 的副本的新对象 A2 和 B2，进而引用新的对象 C2，这是 C 的副本。该示例说明了浅层和深层复制操作之间的差异。</span><span class="sxs-lookup"><span data-stu-id="e1583-452">For example, consider an object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy of C. The example illustrates the difference between a shallow and a deep copy operation.</span></span>  
  
 <span data-ttu-id="e1583-453">如果 <xref:System.Object.MemberwiseClone%2A> 方法执行的浅层复制操作无法满足您的需要，则可以通过多种方式实现深层复制操作。</span><span class="sxs-lookup"><span data-stu-id="e1583-453">There are numerous ways to implement a deep copy operation if the shallow copy operation performed by the <xref:System.Object.MemberwiseClone%2A> method does not meet your needs.</span></span> <span data-ttu-id="e1583-454">其中包括：</span><span class="sxs-lookup"><span data-stu-id="e1583-454">These include the following:</span></span>  
  
-   <span data-ttu-id="e1583-455">调用要复制的对象的类构造函数，以创建具有从第一个对象获取的属性值的第二个对象。</span><span class="sxs-lookup"><span data-stu-id="e1583-455">Call a class constructor of the object to be copied to create a second object with property values taken from the first object.</span></span> <span data-ttu-id="e1583-456">这假设对象的值由其类构造函数完全定义。</span><span class="sxs-lookup"><span data-stu-id="e1583-456">This assumes that the values of an object are entirely defined by its class constructor.</span></span>  
  
-   <span data-ttu-id="e1583-457">调用 <xref:System.Object.MemberwiseClone%2A> 方法来创建对象的浅表副本，然后将新对象的值与原始对象的值与原始对象的值相同，以将其值作为引用类型的任何属性或字段。</span><span class="sxs-lookup"><span data-stu-id="e1583-457">Call the <xref:System.Object.MemberwiseClone%2A> method to create a shallow copy of an object, and then assign new objects whose values are the same as the original object to any properties or fields whose values are reference types.</span></span> <span data-ttu-id="e1583-458">该示例中的 `DeepCopy` 方法说明了这种方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-458">The `DeepCopy` method in the example illustrates this approach.</span></span>  
  
-   <span data-ttu-id="e1583-459">序列化要深层复制的对象，然后将序列化的数据还原到其他对象变量。</span><span class="sxs-lookup"><span data-stu-id="e1583-459">Serialize the object to be deep copied, and then restore the serialized data to a different object variable.</span></span>  
  
-   <span data-ttu-id="e1583-460">使用带有递归的反射来执行深层复制操作。</span><span class="sxs-lookup"><span data-stu-id="e1583-460">Use reflection with recursion to perform the deep copy operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e1583-461">下面的示例演示 <xref:System.Object.MemberwiseClone%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-461">The following example illustrates the <xref:System.Object.MemberwiseClone%2A> method.</span></span> <span data-ttu-id="e1583-462">它定义了一个 `ShallowCopy` 方法，该方法调用 <xref:System.Object.MemberwiseClone%2A> 方法对 `Person` 对象执行浅表复制操作。</span><span class="sxs-lookup"><span data-stu-id="e1583-462">It defines a `ShallowCopy` method that calls the <xref:System.Object.MemberwiseClone%2A> method to perform a shallow copy operation on a `Person` object.</span></span> <span data-ttu-id="e1583-463">它还定义了一个 `DeepCopy` 方法，该方法对 `Person` 对象执行深层复制操作。</span><span class="sxs-lookup"><span data-stu-id="e1583-463">It also defines a `DeepCopy` method that performs a deep copy operation on a `Person` object.</span></span>  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb" id="Snippet1":::
  
 <span data-ttu-id="e1583-464">在此示例中，`Person.IdInfo` 属性返回一个 `IdInfo` 对象。</span><span class="sxs-lookup"><span data-stu-id="e1583-464">In this example, the `Person.IdInfo` property returns an `IdInfo` object.</span></span> <span data-ttu-id="e1583-465">如示例中的输出所示，当通过调用 <xref:System.Object.MemberwiseClone%2A> 方法克隆 `Person` 对象时，克隆的 `Person` 对象是原始对象的独立副本，只不过它们共享相同的 `Person.IdInfo` 对象引用。</span><span class="sxs-lookup"><span data-stu-id="e1583-465">As the output from the example shows, when a `Person` object is cloned by calling the <xref:System.Object.MemberwiseClone%2A> method, the cloned `Person` object is an independent copy of the original object, except that they share the same `Person.IdInfo` object reference.</span></span> <span data-ttu-id="e1583-466">因此，修改克隆的 `Person.IdInfo` 属性会更改原始对象的 `Person.IdInfo` 属性。</span><span class="sxs-lookup"><span data-stu-id="e1583-466">As a result, modifying the clone's `Person.IdInfo` property changes the original object's `Person.IdInfo` property.</span></span> <span data-ttu-id="e1583-467">另一方面，执行深层复制操作时，可以修改克隆的 `Person` 对象（包括其 `Person.IdInfo` 属性），而不会影响原始对象。</span><span class="sxs-lookup"><span data-stu-id="e1583-467">On the other hand, when a deep copy operation is performed, the cloned `Person` object, including its `Person.IdInfo` property, can be modified without affecting the original object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA"><span data-ttu-id="e1583-468">要比较的第一个对象。</span><span class="sxs-lookup"><span data-stu-id="e1583-468">The first object to compare.</span></span></param>
        <param name="objB"><span data-ttu-id="e1583-469">要比较的第二个对象。</span><span class="sxs-lookup"><span data-stu-id="e1583-469">The second object  to compare.</span></span></param>
        <summary><span data-ttu-id="e1583-470">确定指定的 <see cref="T:System.Object" /> 实例是否是相同的实例。</span><span class="sxs-lookup"><span data-stu-id="e1583-470">Determines whether the specified <see cref="T:System.Object" /> instances are the same instance.</span></span></summary>
        <returns><span data-ttu-id="e1583-471">如果 <paramref name="objA" /> 是与 <paramref name="objB" /> 相同的实例，或两者均为 null，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="e1583-471"><see langword="true" /> if <paramref name="objA" /> is the same instance as <paramref name="objB" /> or if both are **null**; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e1583-472">与 <xref:System.Object.Equals%2A> 方法和相等运算符不同，<xref:System.Object.ReferenceEquals%2A> 方法不能被重写。</span><span class="sxs-lookup"><span data-stu-id="e1583-472">Unlike the <xref:System.Object.Equals%2A> method and the equality operator, the <xref:System.Object.ReferenceEquals%2A> method cannot be overridden.</span></span> <span data-ttu-id="e1583-473">因此，如果要测试两个对象引用是否相等，并且不确定 `Equals` 方法的实现，则可以调用 <xref:System.Object.ReferenceEquals%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-473">Because of this, if you want to test two object references for equality and you are unsure about the implementation of the `Equals` method, you can call the <xref:System.Object.ReferenceEquals%2A> method.</span></span>  
  
 <span data-ttu-id="e1583-474">但是，在这两种情况下，<xref:System.Object.ReferenceEquals%2A> 方法的返回值可能看起来是异常的：</span><span class="sxs-lookup"><span data-stu-id="e1583-474">However, the return value of the <xref:System.Object.ReferenceEquals%2A> method may appear to be anomalous in these two scenarios:</span></span>  
  
-   <span data-ttu-id="e1583-475">比较值类型时。</span><span class="sxs-lookup"><span data-stu-id="e1583-475">When comparing value types.</span></span> <span data-ttu-id="e1583-476">如果 `objA` 和 `objB` 是值类型，则在将其传递到 <xref:System.Object.ReferenceEquals%2A> 方法之前，会将这些值装箱。</span><span class="sxs-lookup"><span data-stu-id="e1583-476">If `objA` and `objB` are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="e1583-477">这意味着，如果 `objA` 和 `objB` 表示值类型的同一个实例，则 <xref:System.Object.ReferenceEquals%2A> 方法仍返回 `false`，如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="e1583-477">This means that if both `objA` and `objB` represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns `false`, as the following example shows.</span></span>  
  
     [!code-csharp-interactive[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     <span data-ttu-id="e1583-478">有关装箱值类型的信息，请参阅[装箱和取消装箱](/dotnet/csharp/programming-guide/types/boxing-and-unboxing)。</span><span class="sxs-lookup"><span data-stu-id="e1583-478">For information on boxing value types, see [Boxing and Unboxing](/dotnet/csharp/programming-guide/types/boxing-and-unboxing).</span></span>  
  
-   <span data-ttu-id="e1583-479">比较字符串时。</span><span class="sxs-lookup"><span data-stu-id="e1583-479">When comparing strings.</span></span> <span data-ttu-id="e1583-480">如果 `objA` 和 `objB` 为字符串，<xref:System.Object.ReferenceEquals%2A> 方法将在暂存字符串时返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="e1583-480">If `objA` and `objB` are strings, the <xref:System.Object.ReferenceEquals%2A> method returns `true` if the string is interned.</span></span> <span data-ttu-id="e1583-481">它不会执行值相等性测试。</span><span class="sxs-lookup"><span data-stu-id="e1583-481">It does not perform a test for value equality.</span></span>  <span data-ttu-id="e1583-482">在下面的示例中，`s1` 和 `s2` 相等，因为它们是单个暂存字符串的两个实例。</span><span class="sxs-lookup"><span data-stu-id="e1583-482">In the following example, `s1` and `s2` are equal because they are two instances of a single interned string.</span></span> <span data-ttu-id="e1583-483">但 `s3` 和 `s4` 不相等，因为虽然它们具有相同的字符串值，但不会暂存该字符串。</span><span class="sxs-lookup"><span data-stu-id="e1583-483">However, `s3` and `s4` are not equal, because although they have identical string values, that string is not interned.</span></span>  
  
     [!code-csharp-interactive[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     <span data-ttu-id="e1583-484">有关字符串暂留的详细信息，请参阅 <xref:System.String.IsInterned%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="e1583-484">For more information about string interning, see <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  

 <span data-ttu-id="e1583-485">下面的示例使用 <xref:System.Object.ReferenceEquals%2A> 来确定两个对象是否为同一个实例。</span><span class="sxs-lookup"><span data-stu-id="e1583-485">The following example uses <xref:System.Object.ReferenceEquals%2A> to determine if two objects are the same instance.</span></span>  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp-interactive[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e1583-486">返回表示当前对象的字符串。</span><span class="sxs-lookup"><span data-stu-id="e1583-486">Returns a string that represents the current object.</span></span></summary>
        <returns><span data-ttu-id="e1583-487">表示当前对象的字符串。</span><span class="sxs-lookup"><span data-stu-id="e1583-487">A string that represents the current object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e1583-488"><xref:System.Object.ToString%2A?displayProperty=nameWithType> 是 .NET Framework 中的主要格式设置方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-488"><xref:System.Object.ToString%2A?displayProperty=nameWithType> is the major formatting method in the .NET Framework.</span></span> <span data-ttu-id="e1583-489">它将对象转换为其字符串表示形式，以便它适合于显示。</span><span class="sxs-lookup"><span data-stu-id="e1583-489">It converts an object to its string representation so that it is suitable for display.</span></span> <span data-ttu-id="e1583-490">（有关 .NET Framework 中格式设置支持的信息，请参阅[格式设置类型](/dotnet/standard/base-types/formatting-types)。）<xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法的默认实现将返回对象类型的完全限定名称。</span><span class="sxs-lookup"><span data-stu-id="e1583-490">(For information about formatting support in the .NET Framework, see [Formatting Types](/dotnet/standard/base-types/formatting-types).) Default implementations of the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method return the fully qualified name of the object's type.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="e1583-491">您可能已通过从另一类型成员列表中的链接来访问此页。</span><span class="sxs-lookup"><span data-stu-id="e1583-491">You may have reached this page by following the link from the member list of another type.</span></span> <span data-ttu-id="e1583-492">这是因为该类型不会重写 <xref:System.Object.ToString%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="e1583-492">That is because that type does not override <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e1583-493">相反，它会继承 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法的功能。</span><span class="sxs-lookup"><span data-stu-id="e1583-493">Instead, it inherits the functionality of the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="e1583-494">类型经常重写 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法，以提供更适合特定类型的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="e1583-494">Types frequently override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to provide a more suitable string representation of a particular type.</span></span> <span data-ttu-id="e1583-495">类型还经常重载 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法，以提供对格式字符串或区分区域性的格式设置的支持。</span><span class="sxs-lookup"><span data-stu-id="e1583-495">Types also frequently overload the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to provide support for format strings or culture-sensitive formatting.</span></span>  

 <span data-ttu-id="e1583-496">本节内容：</span><span class="sxs-lookup"><span data-stu-id="e1583-496">In this section:</span></span>  
  
 <span data-ttu-id="e1583-497">[默认的对象 ToString （）方法](#Default) </span><span class="sxs-lookup"><span data-stu-id="e1583-497">[The default Object.ToString() method](#Default) </span></span>  
 <span data-ttu-id="e1583-498">[重写对象 ToString （）方法](#Overriding) </span><span class="sxs-lookup"><span data-stu-id="e1583-498">[Overriding the Object.ToString() method](#Overriding) </span></span>  
 <span data-ttu-id="e1583-499">[重载 ToString 方法](#Overloading) </span><span class="sxs-lookup"><span data-stu-id="e1583-499">[Overloading the ToString method](#Overloading) </span></span>  
 <span data-ttu-id="e1583-500">[扩展对象 ToString 方法](#Extending) </span><span class="sxs-lookup"><span data-stu-id="e1583-500">[Extending the Object.ToString method](#Extending) </span></span>  
 [<span data-ttu-id="e1583-501">Windows 运行时的说明</span><span class="sxs-lookup"><span data-stu-id="e1583-501">Notes for the Windows Runtime</span></span>](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a><span data-ttu-id="e1583-502">默认的对象 ToString （）方法</span><span class="sxs-lookup"><span data-stu-id="e1583-502">The default Object.ToString() method</span></span>  
 <span data-ttu-id="e1583-503"><xref:System.Object.ToString%2A> 方法的默认实现返回 <xref:System.Object>类型的完全限定名称，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="e1583-503">The default implementation of the <xref:System.Object.ToString%2A> method returns the fully qualified name of the type of the <xref:System.Object>, as the following example shows.</span></span>  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb" id="Snippet1":::
  
 <span data-ttu-id="e1583-504">由于 <xref:System.Object> 是 .NET Framework 中所有引用类型的基类，因此此行为是由不重写 <xref:System.Object.ToString%2A> 方法的引用类型继承的。</span><span class="sxs-lookup"><span data-stu-id="e1583-504">Because <xref:System.Object> is the base class of all reference types in the .NET Framework, this behavior is inherited by reference types that do not override the <xref:System.Object.ToString%2A> method.</span></span> <span data-ttu-id="e1583-505">下面的示例阐释了这一点。</span><span class="sxs-lookup"><span data-stu-id="e1583-505">The following example illustrates this.</span></span> <span data-ttu-id="e1583-506">它定义了一个名为 `Object1` 的类，该类接受所有 <xref:System.Object> 成员的默认实现。</span><span class="sxs-lookup"><span data-stu-id="e1583-506">It defines a class named `Object1` that accepts the default implementation of all <xref:System.Object> members.</span></span> <span data-ttu-id="e1583-507">它的 <xref:System.Object.ToString%2A> 方法返回对象的完全限定类型名称。</span><span class="sxs-lookup"><span data-stu-id="e1583-507">Its <xref:System.Object.ToString%2A> method returns the object's fully qualified type name.</span></span>  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp" id="Snippet2":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb" id="Snippet2":::  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a><span data-ttu-id="e1583-508">重写对象 ToString （）方法</span><span class="sxs-lookup"><span data-stu-id="e1583-508">Overriding the Object.ToString() method</span></span>  
 <span data-ttu-id="e1583-509">类型通常会重写 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法，以返回表示对象实例的字符串。</span><span class="sxs-lookup"><span data-stu-id="e1583-509">Types commonly override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return a string that represents the object instance.</span></span> <span data-ttu-id="e1583-510">例如，基类型（如 <xref:System.Char>、<xref:System.Int32>和 <xref:System.String>）提供返回对象所表示的值的字符串形式的 <xref:System.Object.ToString%2A> 实现。</span><span class="sxs-lookup"><span data-stu-id="e1583-510">For example, the base types such as <xref:System.Char>, <xref:System.Int32>, and <xref:System.String> provide <xref:System.Object.ToString%2A> implementations that return the string form of the value that the object represents.</span></span> <span data-ttu-id="e1583-511">下面的示例定义了一个类，`Object2`，它重写 <xref:System.Object.ToString%2A> 方法以返回类型名称及其值。</span><span class="sxs-lookup"><span data-stu-id="e1583-511">The following example defines a class, `Object2`, that overrides the <xref:System.Object.ToString%2A> method to return the type name along with its value.</span></span>  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp" id="Snippet3":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb" id="Snippet3":::
  
 <span data-ttu-id="e1583-512">下表列出了 .NET 中的类型类别，并指示它们是否覆盖 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-512">The following table lists the type categories in .NET and indicates whether or not they override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
|<span data-ttu-id="e1583-513">类型类别</span><span class="sxs-lookup"><span data-stu-id="e1583-513">Type category</span></span>|<span data-ttu-id="e1583-514">重写对象 ToString （）</span><span class="sxs-lookup"><span data-stu-id="e1583-514">Overrides Object.ToString()</span></span>|<span data-ttu-id="e1583-515">行为</span><span class="sxs-lookup"><span data-stu-id="e1583-515">Behavior</span></span>|  
|-------------------|-----------------------------------|--------------|  
|<span data-ttu-id="e1583-516">类</span><span class="sxs-lookup"><span data-stu-id="e1583-516">Class</span></span>|<span data-ttu-id="e1583-517">n/a</span><span class="sxs-lookup"><span data-stu-id="e1583-517">n/a</span></span>|<span data-ttu-id="e1583-518">n/a</span><span class="sxs-lookup"><span data-stu-id="e1583-518">n/a</span></span>|  
|<span data-ttu-id="e1583-519">结构</span><span class="sxs-lookup"><span data-stu-id="e1583-519">Structure</span></span>|<span data-ttu-id="e1583-520">是 (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)</span><span class="sxs-lookup"><span data-stu-id="e1583-520">Yes (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)</span></span>|<span data-ttu-id="e1583-521">与 `Object.ToString()` 相同</span><span class="sxs-lookup"><span data-stu-id="e1583-521">Same as `Object.ToString()`</span></span>|  
|<span data-ttu-id="e1583-522">枚举</span><span class="sxs-lookup"><span data-stu-id="e1583-522">Enumeration</span></span>|<span data-ttu-id="e1583-523">是 (<xref:System.Enum.ToString?displayProperty=nameWithType>)</span><span class="sxs-lookup"><span data-stu-id="e1583-523">Yes (<xref:System.Enum.ToString?displayProperty=nameWithType>)</span></span>|<span data-ttu-id="e1583-524">成员名称</span><span class="sxs-lookup"><span data-stu-id="e1583-524">The member name</span></span>|  
|<span data-ttu-id="e1583-525">接口</span><span class="sxs-lookup"><span data-stu-id="e1583-525">Interface</span></span>|<span data-ttu-id="e1583-526">否</span><span class="sxs-lookup"><span data-stu-id="e1583-526">No</span></span>|<span data-ttu-id="e1583-527">n/a</span><span class="sxs-lookup"><span data-stu-id="e1583-527">n/a</span></span>|  
|<span data-ttu-id="e1583-528">委托</span><span class="sxs-lookup"><span data-stu-id="e1583-528">Delegate</span></span>|<span data-ttu-id="e1583-529">No</span><span class="sxs-lookup"><span data-stu-id="e1583-529">No</span></span>|<span data-ttu-id="e1583-530">n/a</span><span class="sxs-lookup"><span data-stu-id="e1583-530">n/a</span></span>|  
  
 <span data-ttu-id="e1583-531">有关替代 <xref:System.Object.ToString%2A>的其他信息，请参阅对继承者的说明部分。</span><span class="sxs-lookup"><span data-stu-id="e1583-531">See the Notes to Inheritors section for additional information on overriding <xref:System.Object.ToString%2A>.</span></span>  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a><span data-ttu-id="e1583-532">重载 ToString 方法</span><span class="sxs-lookup"><span data-stu-id="e1583-532">Overloading the ToString method</span></span>  
 <span data-ttu-id="e1583-533">除了重写无参数 <xref:System.Object.ToString?displayProperty=nameWithType> 方法以外，许多类型还重载了 `ToString` 方法来提供接受参数的方法的版本。</span><span class="sxs-lookup"><span data-stu-id="e1583-533">In addition to overriding the parameterless <xref:System.Object.ToString?displayProperty=nameWithType> method, many types overload the `ToString` method to provide versions of the method that accept parameters.</span></span> <span data-ttu-id="e1583-534">最常见的是，这样做是为了提供对可变格式设置和区分区域性的格式设置的支持。</span><span class="sxs-lookup"><span data-stu-id="e1583-534">Most commonly, this is done to provide support for variable formatting and culture-sensitive formatting.</span></span>  
  
 <span data-ttu-id="e1583-535">下面的示例重载 `ToString` 方法，以返回包含 `Automobile` 类的各种字段值的结果字符串。</span><span class="sxs-lookup"><span data-stu-id="e1583-535">The following example overloads the `ToString` method to return a result string that includes the value of various fields of an `Automobile` class.</span></span> <span data-ttu-id="e1583-536">它定义了四个格式字符串： G，它返回模型名称和年份;D：返回模型名称、年份和门的数量;C，返回柱面的名称、年份和数量;和，返回包含所有四个字段值的字符串。</span><span class="sxs-lookup"><span data-stu-id="e1583-536">It defines four format strings: G, which returns the model name and year; D, which returns the model name, year, and number of doors; C, which returns the model name, year, and number of cylinders; and A, which returns a string with all four field values.</span></span>  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs" interactive="try-dotnet" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb" id="Snippet4"::: 
  
 <span data-ttu-id="e1583-537">下面的示例调用重载的 <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 方法来显示货币值的区分区域性的格式设置。</span><span class="sxs-lookup"><span data-stu-id="e1583-537">The following example calls the overloaded <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method to display culture-sensitive formatting of a currency value.</span></span>  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 <span data-ttu-id="e1583-538">有关格式字符串和区分区域性的格式设置的详细信息，请参阅[格式设置类型](/dotnet/standard/base-types/formatting-types)。</span><span class="sxs-lookup"><span data-stu-id="e1583-538">For more information on format strings and culture-sensitive formatting, see [Formatting Types](/dotnet/standard/base-types/formatting-types).</span></span> <span data-ttu-id="e1583-539">有关数字值支持的格式字符串，请参阅[标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings)和[自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="e1583-539">For the format strings supported by numeric values, see [Standard Numeric Format Strings](/dotnet/standard/base-types/standard-numeric-format-strings) and [Custom Numeric Format Strings](/dotnet/standard/base-types/custom-numeric-format-strings).</span></span> <span data-ttu-id="e1583-540">有关日期和时间值支持的格式字符串，请参阅[标准日期和时间格式字符串](/dotnet/standard/base-types/standard-date-and-time-format-strings)和[自定义日期和时间格式字符串](/dotnet/standard/base-types/custom-date-and-time-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="e1583-540">For the format strings supported by date and time values, see [Standard Date and Time Format Strings](/dotnet/standard/base-types/standard-date-and-time-format-strings) and [Custom Date and Time Format Strings](/dotnet/standard/base-types/custom-date-and-time-format-strings).</span></span>  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a><span data-ttu-id="e1583-541">扩展对象 ToString 方法</span><span class="sxs-lookup"><span data-stu-id="e1583-541">Extending the Object.ToString method</span></span>  
 <span data-ttu-id="e1583-542">因为某一类型继承了默认 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法，所以你可能会发现它不需要的行为，并需要对其进行更改。</span><span class="sxs-lookup"><span data-stu-id="e1583-542">Because a type inherits the default <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, you may find its behavior undesirable and want to change it.</span></span> <span data-ttu-id="e1583-543">这对于数组和集合类尤其如此。</span><span class="sxs-lookup"><span data-stu-id="e1583-543">This is particularly true of arrays and collection classes.</span></span> <span data-ttu-id="e1583-544">尽管可能需要数组或集合类的 `ToString` 方法来显示其成员的值，但它将显示类型完全限定的类型名称，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="e1583-544">While you may expect the `ToString` method of an array or collection class to display the values of its members, it instead displays the type fully qualified type name, as the following example shows.</span></span>  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs" interactive="try-dotnet-method" id="Snippet6":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb" id="Snippet6":::
  
 <span data-ttu-id="e1583-545">您可以使用多个选项来生成所需的结果字符串。</span><span class="sxs-lookup"><span data-stu-id="e1583-545">You have several options to produce the result string that you'd like.</span></span>  
  
-   <span data-ttu-id="e1583-546">如果类型是数组、集合对象或实现 <xref:System.Collections.IEnumerable> 或 <xref:System.Collections.Generic.IEnumerable%601> 接口的对象，则可以使用中C#的 `foreach` 语句或 Visual Basic 中的 `For Each...Next` 构造来枚举其元素。</span><span class="sxs-lookup"><span data-stu-id="e1583-546">If the type is an array, a collection object, or an object that implements the <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601> interfaces, you can enumerate its elements by using the `foreach` statement in C# or the `For Each...Next` construct in Visual Basic.</span></span>  
  
-   <span data-ttu-id="e1583-547">如果类不 `sealed` （在中C#）或 `NotInheritable` （在 Visual Basic 中），则可以开发从要自定义其 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法的基类继承的包装类。</span><span class="sxs-lookup"><span data-stu-id="e1583-547">If the class is not `sealed` (in C#) or `NotInheritable` (in Visual Basic), you can develop a wrapper class that inherits from the base class whose <xref:System.Object.ToString%2A?displayProperty=nameWithType> method you want to customize.</span></span> <span data-ttu-id="e1583-548">至少需要执行以下操作：</span><span class="sxs-lookup"><span data-stu-id="e1583-548">At a minimum, this requires that you do the following:</span></span>  
  
    1.  <span data-ttu-id="e1583-549">实现任何所需的构造函数。</span><span class="sxs-lookup"><span data-stu-id="e1583-549">Implement any necessary constructors.</span></span> <span data-ttu-id="e1583-550">派生类不继承它们的基类构造函数。</span><span class="sxs-lookup"><span data-stu-id="e1583-550">Derived classes do not inherit their base class constructors.</span></span>  
  
    2.  <span data-ttu-id="e1583-551">重写 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法，以返回所需的结果字符串。</span><span class="sxs-lookup"><span data-stu-id="e1583-551">Override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the result string that you'd like.</span></span>  
  
     <span data-ttu-id="e1583-552">下面的示例定义了 <xref:System.Collections.Generic.List%601> 类的包装类。</span><span class="sxs-lookup"><span data-stu-id="e1583-552">The following example defines a wrapper class for the <xref:System.Collections.Generic.List%601> class.</span></span> <span data-ttu-id="e1583-553">它重写 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法，以显示集合的每个方法的值，而不是完全限定的类型名称。</span><span class="sxs-lookup"><span data-stu-id="e1583-553">It overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to display the value of each method of the collection rather than the fully qualified type name.</span></span>  
  
     :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs" interactive="try-dotnet" id="Snippet7":::
     :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb" id="Snippet7"::: 
  
-   <span data-ttu-id="e1583-554">开发可返回所需结果字符串的[扩展方法](/dotnet/standard/design-guidelines/extension-methods)。</span><span class="sxs-lookup"><span data-stu-id="e1583-554">Develop an [extension method](/dotnet/standard/design-guidelines/extension-methods) that returns the result string that you want.</span></span> <span data-ttu-id="e1583-555">请注意，不能以这种方式重写默认 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法（即，扩展类（in C#）或模块（在 Visual Basic 中）不能具有名为 `ToString` 的无参数方法，而调用该方法来代替原始类型的 `ToString` 方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-555">Note that you can't override the default <xref:System.Object.ToString%2A?displayProperty=nameWithType> method in this way (that is, your extension class (in C#) or module (in Visual Basic) cannot have a parameterless method named `ToString` that is called in place of the original type's `ToString` method.</span></span> <span data-ttu-id="e1583-556">必须为无参数 `ToString` 替换提供其他名称。</span><span class="sxs-lookup"><span data-stu-id="e1583-556">You'll have to provide some other name for your parameterless `ToString` replacement.</span></span>  
  
     <span data-ttu-id="e1583-557">下面的示例定义了两个扩展 <xref:System.Collections.Generic.List%601> 类的方法：一个无参数 `ToString2` 方法，以及一个具有表示格式字符串的 <xref:System.String> 参数的 `ToString` 方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-557">The following example defines two methods that extend the <xref:System.Collections.Generic.List%601> class: a parameterless `ToString2` method, and a `ToString` method with a <xref:System.String> parameter that represents a format string.</span></span>  
  
     :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs" interactive="try-dotnet" id="Snippet8":::
     :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb" id="Snippet8"::: 
  
<a name="WinRT"></a>   
## <a name="notes-for-the-wrt"></a><span data-ttu-id="e1583-558">[!INCLUDE[wrt](~/includes/wrt-md.md)] 的说明</span><span class="sxs-lookup"><span data-stu-id="e1583-558">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="e1583-559">对 [!INCLUDE[wrt](~/includes/wrt-md.md)]中的类调用 <xref:System.Object.ToString%2A> 方法时，它将为不重写 <xref:System.Object.ToString%2A>的类提供默认行为。</span><span class="sxs-lookup"><span data-stu-id="e1583-559">When you call the <xref:System.Object.ToString%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don't override <xref:System.Object.ToString%2A>.</span></span> <span data-ttu-id="e1583-560">这是 .NET Framework 为 [!INCLUDE[wrt](~/includes/wrt-md.md)] 提供的支持的一部分（请参阅[Windows 应用商店应用和 Windows 运行时 .NET Framework 支持](/dotnet/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime)）。</span><span class="sxs-lookup"><span data-stu-id="e1583-560">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](/dotnet/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime)).</span></span> <span data-ttu-id="e1583-561">[!INCLUDE[wrt](~/includes/wrt-md.md)] 中的类不会继承 <xref:System.Object>，并不总是实现 <xref:System.Object.ToString%2A>。</span><span class="sxs-lookup"><span data-stu-id="e1583-561">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don't inherit <xref:System.Object>, and don't always implement a <xref:System.Object.ToString%2A>.</span></span> <span data-ttu-id="e1583-562">但是，当你在C#或 Visual Basic 代码中使用它们时，它们始终具有 <xref:System.Object.ToString%2A>、<xref:System.Object.Equals%28System.Object%29>和 <xref:System.Object.GetHashCode%2A> 方法，而 .NET Framework 提供这些方法的默认行为。</span><span class="sxs-lookup"><span data-stu-id="e1583-562">However, they always appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides a default behavior for these methods.</span></span>  
  
 <span data-ttu-id="e1583-563">从 [!INCLUDE[net_v451](~/includes/net-v451-md.md)]开始，公共语言运行时将对 [!INCLUDE[wrt](~/includes/wrt-md.md)] 对象使用[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) ，然后再回退到 <xref:System.Object.ToString%2A?displayProperty=nameWithType>的默认实现。</span><span class="sxs-lookup"><span data-stu-id="e1583-563">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], the common language runtime will use [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) on a [!INCLUDE[wrt](~/includes/wrt-md.md)] object before falling back to the default implementation of <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e1583-564">用 Visual Basic C#或编写的 [!INCLUDE[wrt](~/includes/wrt-md.md)] 类可以重写 <xref:System.Object.ToString%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="e1583-564">[!INCLUDE[wrt](~/includes/wrt-md.md)] classes that are written in C# or Visual Basic can override the <xref:System.Object.ToString%2A> method.</span></span>  
  
### <a name="the-wrt-and-the-istringable-interface"></a><span data-ttu-id="e1583-565">[!INCLUDE[wrt](~/includes/wrt-md.md)] 和 IStringable 接口</span><span class="sxs-lookup"><span data-stu-id="e1583-565">The [!INCLUDE[wrt](~/includes/wrt-md.md)] and the IStringable Interface</span></span>  
 <span data-ttu-id="e1583-566">从 [!INCLUDE[win81](~/includes/win81-md.md)]开始，[!INCLUDE[wrt](~/includes/wrt-md.md)] 包括[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)接口，该接口的单一方法[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)提供的基本格式设置支持与 <xref:System.Object.ToString%2A?displayProperty=nameWithType>提供的基本格式设置支持相媲美。</span><span class="sxs-lookup"><span data-stu-id="e1583-566">Starting with [!INCLUDE[win81](~/includes/win81-md.md)], the [!INCLUDE[wrt](~/includes/wrt-md.md)] includes an [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface whose single method, [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), provides basic formatting support comparable to that provided by <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e1583-567">若要防止歧义，不应在托管类型上实现[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 。</span><span class="sxs-lookup"><span data-stu-id="e1583-567">To prevent ambiguity, you should not implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on managed types.</span></span>  
  
 <span data-ttu-id="e1583-568">当本机代码或使用 JavaScript 或C++/cx 等语言编写的代码调用托管对象时，它们看起来实现了[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)。</span><span class="sxs-lookup"><span data-stu-id="e1583-568">When managed objects are called by native code or by code written in languages such as JavaScript or C++/CX, they appear to implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span></span> <span data-ttu-id="e1583-569">公共语言运行时将从[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)自动将调用路由到事件[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)中的 <xref:System.Object.ToString%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="e1583-569">The common language runtime will automatically route calls from [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) to <xref:System.Object.ToString%2A?displayProperty=nameWithType> in the event [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) is not implemented on the managed object.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="e1583-570">由于公共语言运行时自动实现 [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] 应用中所有托管类型的[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) ，因此，我们建议你不要提供自己的[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)实现。</span><span class="sxs-lookup"><span data-stu-id="e1583-570">Because the common language runtime auto-implements [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) for all managed types in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] apps, we recommend that you do not provide your own [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation.</span></span> <span data-ttu-id="e1583-571">在[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)从 [!INCLUDE[wrt](~/includes/wrt-md.md)]、/Cx 或 JavaScript 调用 `ToString` 时， C++实现 IStringable 可能会导致意外的行为。</span><span class="sxs-lookup"><span data-stu-id="e1583-571">Implementing [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) may result in unintended behavior when calling `ToString` from the [!INCLUDE[wrt](~/includes/wrt-md.md)], C++/CX, or JavaScript.</span></span>  
  
 <span data-ttu-id="e1583-572">如果选择在 [!INCLUDE[wrt](~/includes/wrt-md.md)] 组件中导出的公共托管类型中实现[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) ，则以下限制适用：</span><span class="sxs-lookup"><span data-stu-id="e1583-572">If you do choose to implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) in a public managed type that is exported in a [!INCLUDE[wrt](~/includes/wrt-md.md)] component, the following restrictions apply:</span></span>  
  
- <span data-ttu-id="e1583-573">你只能在 "类实现" 关系中定义[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)接口，如下所示：</span><span class="sxs-lookup"><span data-stu-id="e1583-573">You can define the [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface only in a "class implements" relationship, as follows:</span></span>

    ```csharp
    public class NewClass : IStringable
    ```

    ```vb
    Public Class NewClass : Implements IStringable
    ```

-   <span data-ttu-id="e1583-574">无法在接口上实现[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) 。</span><span class="sxs-lookup"><span data-stu-id="e1583-574">You cannot implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on an interface.</span></span>  
  
-   <span data-ttu-id="e1583-575">不能将参数声明为[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)类型。</span><span class="sxs-lookup"><span data-stu-id="e1583-575">You cannot declare a parameter to be of type [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span></span>  
  
-   <span data-ttu-id="e1583-576">[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)不能是方法、属性或字段的返回类型。</span><span class="sxs-lookup"><span data-stu-id="e1583-576">[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) cannot be the return type of a method, property, or field.</span></span>  
  
-   <span data-ttu-id="e1583-577">你无法通过使用如下所示的方法定义，从基类中隐藏[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)实现：</span><span class="sxs-lookup"><span data-stu-id="e1583-577">You cannot hide your [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation from base classes by using a method definition such as the following:</span></span>  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     <span data-ttu-id="e1583-578">相反， [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)实现必须始终重写基类实现。</span><span class="sxs-lookup"><span data-stu-id="e1583-578">Instead, the [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation must always override the base class implementation.</span></span> <span data-ttu-id="e1583-579">只能通过对强类型类实例调用 `ToString` 实现来隐藏该实现。</span><span class="sxs-lookup"><span data-stu-id="e1583-579">You can hide a `ToString` implementation only by invoking it on a strongly typed class instance.</span></span>  
  
 <span data-ttu-id="e1583-580">请注意，在各种条件下，从本机代码到实现[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)或隐藏其[ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)实现的托管类型的调用可能会产生意外行为。</span><span class="sxs-lookup"><span data-stu-id="e1583-580">Note that under a variety of conditions, calls from native code to a managed type that implements [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) or hides its [ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation can produce unexpected behavior.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="e1583-581">实现自己的类型时，应重写 <see cref="M:System.Object.ToString" /> 方法，以返回对这些类型有意义的值。</span><span class="sxs-lookup"><span data-stu-id="e1583-581">When you implement your own types, you should override the <see cref="M:System.Object.ToString" /> method to return values that are meaningful for those types.</span></span> <span data-ttu-id="e1583-582">需要更好地控制格式 <see cref="M:System.Object.ToString" /> 设置的派生类可以实现 <see cref="T:System.IFormattable" /> 接口。</span><span class="sxs-lookup"><span data-stu-id="e1583-582">Derived classes that require more control over formatting than <see cref="M:System.Object.ToString" /> provides can implement the <see cref="T:System.IFormattable" /> interface.</span></span> <span data-ttu-id="e1583-583">通过其 <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> 方法，您可以定义用于控制格式设置的格式字符串，并使用可提供特定于区域性的格式设置 <see cref="T:System.IFormatProvider" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="e1583-583">Its <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> method enables you to define format strings that control formatting and to use an <see cref="T:System.IFormatProvider" /> object that can provide for culture-specific formatting.</span></span>  
  
<span data-ttu-id="e1583-584"><see cref="M:System.Object.ToString" /> 方法的覆盖应遵循以下准则：</span><span class="sxs-lookup"><span data-stu-id="e1583-584">Overrides of the <see cref="M:System.Object.ToString" /> method should follow these guidelines:</span></span> 
<span data-ttu-id="e1583-585">-返回的字符串应该是友好的，可供人们阅读。</span><span class="sxs-lookup"><span data-stu-id="e1583-585">-   The returned string should be friendly and readable by humans.</span></span>  
  
<span data-ttu-id="e1583-586">-返回的字符串应唯一标识对象实例的值。</span><span class="sxs-lookup"><span data-stu-id="e1583-586">-   The returned string should uniquely identify the value of the object instance.</span></span>  
  
<span data-ttu-id="e1583-587">-返回的字符串应尽可能短，以便调试器能够显示它。</span><span class="sxs-lookup"><span data-stu-id="e1583-587">-   The returned string should be as short as possible so that it is suitable for display by a debugger.</span></span>  
  
<span data-ttu-id="e1583-588">-<see cref="M:System.Object.ToString" /> 重写不应返回 <see cref="F:System.String.Empty" /> 或空字符串。</span><span class="sxs-lookup"><span data-stu-id="e1583-588">-   Your <see cref="M:System.Object.ToString" /> override should not return <see cref="F:System.String.Empty" /> or a null string.</span></span>  
  
<span data-ttu-id="e1583-589">-<see cref="M:System.Object.ToString" /> 重写不应引发异常。</span><span class="sxs-lookup"><span data-stu-id="e1583-589">-   Your <see cref="M:System.Object.ToString" /> override should not throw an exception.</span></span>  
  
<span data-ttu-id="e1583-590">-如果实例的字符串表示形式区分区域性或可通过多种方式进行格式化，则实现 <see cref="T:System.IFormattable" /> 接口。</span><span class="sxs-lookup"><span data-stu-id="e1583-590">-   If the string representation of an instance is culture-sensitive or can be formatted in multiple ways, implement the <see cref="T:System.IFormattable" /> interface.</span></span>  
  
<span data-ttu-id="e1583-591">-如果返回的字符串包含敏感信息，则应首先请求适当的权限。</span><span class="sxs-lookup"><span data-stu-id="e1583-591">-   If the returned string includes sensitive information, you should first demand an appropriate permission.</span></span> <span data-ttu-id="e1583-592">如果请求成功，则可以返回敏感信息;否则，应返回排除敏感信息的字符串。</span><span class="sxs-lookup"><span data-stu-id="e1583-592">If the demand succeeds, you can return the sensitive information; otherwise, you should return a string that excludes the sensitive information.</span></span>  
  
<span data-ttu-id="e1583-593">-<see cref="M:System.Object.ToString" /> 重写应没有可观察到的副作用，以避免调试中的复杂。</span><span class="sxs-lookup"><span data-stu-id="e1583-593">-   Your <see cref="M:System.Object.ToString" /> override should have no observable side effects to avoid complications in debugging.</span></span> <span data-ttu-id="e1583-594">例如，对 <see cref="M:System.Object.ToString" /> 方法的调用不应更改实例字段的值。</span><span class="sxs-lookup"><span data-stu-id="e1583-594">For example, a call to the <see cref="M:System.Object.ToString" /> method should not change the value of instance fields.</span></span>  
  
<span data-ttu-id="e1583-595">-如果你的类型实现了分析方法（或 <see langword="Parse" /> 或 <see langword="TryParse" /> 方法、构造函数或从字符串实例化类型实例的其他静态方法），则应确保 <see cref="M:System.Object.ToString" /> 方法返回的字符串可以转换为对象实例。</span><span class="sxs-lookup"><span data-stu-id="e1583-595">-   If your type implements a parsing method (or <see langword="Parse" /> or <see langword="TryParse" /> method, a constructor, or some other static method that instantiates an instance of the type from a string), you should ensure that the string returned by the <see cref="M:System.Object.ToString" /> method can be converted to an object instance.</span></span></para></block>
        <related type="Article" href="/dotnet/standard/base-types/formatting-types"><span data-ttu-id="e1583-596">设置 .NET 中类型的格式</span><span class="sxs-lookup"><span data-stu-id="e1583-596">Formatting Types in .NET</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
