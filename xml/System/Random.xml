<Type Name="Random" FullName="System.Random">
  <Metadata><Meta Name="ms.openlocfilehash" Value="00db721815702567549c552cd6395aed57802e2c" /><Meta Name="ms.sourcegitcommit" Value="81ab118287bf69d10df7204c332592eac20b1b60" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="12/11/2019" /><Meta Name="ms.locfileid" Value="75003892" /></Metadata><TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="93d50-101">表示伪随机数生成器，这是一种能够产生满足某些随机性统计需求的数字序列的设备。</span><span class="sxs-lookup"><span data-stu-id="93d50-101">Represents a pseudo-random number generator, which is a device that produces a sequence of numbers that meet certain statistical requirements for randomness.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93d50-102">伪随机数的选择与有限的一组数字相同。</span><span class="sxs-lookup"><span data-stu-id="93d50-102">Pseudo-random numbers are chosen with equal probability from a finite set of numbers.</span></span> <span data-ttu-id="93d50-103">选择的数字不是完全随机的，因为使用数学算法来选择它们，但它们在实际情况下是完全随机的。</span><span class="sxs-lookup"><span data-stu-id="93d50-103">The chosen numbers are not completely random because a mathematical algorithm is used to select them, but they are sufficiently random for practical purposes.</span></span> <span data-ttu-id="93d50-104"><xref:System.Random> 类的当前实现基于 Donald Knuth 的 subtractive 随机数生成器算法的修改版本。</span><span class="sxs-lookup"><span data-stu-id="93d50-104">The current implementation of the <xref:System.Random> class is based on a modified version of Donald E. Knuth's subtractive random number generator algorithm.</span></span> <span data-ttu-id="93d50-105">有关详细信息，请参阅 d。</span><span class="sxs-lookup"><span data-stu-id="93d50-105">For more information, see D. E.</span></span> <span data-ttu-id="93d50-106">Knuth.</span><span class="sxs-lookup"><span data-stu-id="93d50-106">Knuth.</span></span> <span data-ttu-id="93d50-107">*计算机编程（卷2： Seminumerical 算法）的艺术*。</span><span class="sxs-lookup"><span data-stu-id="93d50-107">*The Art of Computer Programming, Volume 2: Seminumerical Algorithms*.</span></span> <span data-ttu-id="93d50-108">Addison-Wesley，读取，MA，第三版，1997。</span><span class="sxs-lookup"><span data-stu-id="93d50-108">Addison-Wesley, Reading, MA, third edition, 1997.</span></span>  
  
 <span data-ttu-id="93d50-109">若要生成加密的安全随机数（如适合创建随机密码的随机数），请使用 <xref:System.Security.Cryptography.RNGCryptoServiceProvider> 类或从 <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>派生类。</span><span class="sxs-lookup"><span data-stu-id="93d50-109">To generate a cryptographically secure random number, such as one that's suitable for creating a random password, use the <xref:System.Security.Cryptography.RNGCryptoServiceProvider> class or derive a class from <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="93d50-110">本主题内容：</span><span class="sxs-lookup"><span data-stu-id="93d50-110">In this topic:</span></span>  
  
 <span data-ttu-id="93d50-111">[实例化随机数生成器](#Instantiate) </span><span class="sxs-lookup"><span data-stu-id="93d50-111">[Instantiating the random number generator](#Instantiate) </span></span>  
 <span data-ttu-id="93d50-112">[避免多个实例化](#Multiple) </span><span class="sxs-lookup"><span data-stu-id="93d50-112">[Avoiding multiple instantiations](#Multiple) </span></span>  
 <span data-ttu-id="93d50-113">[System.web 类和 thread 安全网](#ThreadSafety) </span><span class="sxs-lookup"><span data-stu-id="93d50-113">[The System.Random class and thread safety](#ThreadSafety) </span></span>  
 <span data-ttu-id="93d50-114">[生成不同类型的随机数](#Functionality) </span><span class="sxs-lookup"><span data-stu-id="93d50-114">[Generating different types of random numbers](#Functionality) </span></span>  
 <span data-ttu-id="93d50-115">[替换自己的算法](#Overriding) </span><span class="sxs-lookup"><span data-stu-id="93d50-115">[Substituting your own algorithm](#Overriding) </span></span>  
 <span data-ttu-id="93d50-116">[如何使用 "系统随机](#Operations)..." </span><span class="sxs-lookup"><span data-stu-id="93d50-116">[How do you use System.Random to…](#Operations) </span></span>  
 [<span data-ttu-id="93d50-117">检索相同的随机值序列</span><span class="sxs-lookup"><span data-stu-id="93d50-117">Retrieve the same sequence of random values</span></span>](#Same)  
 [<span data-ttu-id="93d50-118">检索随机值的唯一序列</span><span class="sxs-lookup"><span data-stu-id="93d50-118">Retrieve unique sequences of random values</span></span>](#Unique)  
 [<span data-ttu-id="93d50-119">检索指定范围内的整数</span><span class="sxs-lookup"><span data-stu-id="93d50-119">Retrieve integers in a specified range</span></span>](#Range)  
 [<span data-ttu-id="93d50-120">检索指定位数的整数</span><span class="sxs-lookup"><span data-stu-id="93d50-120">Retrieve integers with a specified number of digits</span></span>](#Digits)  
 [<span data-ttu-id="93d50-121">检索指定范围内的浮点值</span><span class="sxs-lookup"><span data-stu-id="93d50-121">Retrieve floating-point values in a specified range</span></span>](#Floats)  
 [<span data-ttu-id="93d50-122">生成随机布尔值</span><span class="sxs-lookup"><span data-stu-id="93d50-122">Generate random Boolean values</span></span>](#Boolean)  
 [<span data-ttu-id="93d50-123">生成随机的64位整数</span><span class="sxs-lookup"><span data-stu-id="93d50-123">Generate random 64-bit integers</span></span>](#Long)  
 [<span data-ttu-id="93d50-124">检索指定范围内的字节</span><span class="sxs-lookup"><span data-stu-id="93d50-124">Retrieve bytes in a specified range</span></span>](#Bytes)  
 [<span data-ttu-id="93d50-125">随机检索数组或集合中的元素</span><span class="sxs-lookup"><span data-stu-id="93d50-125">Retrieve an element from an array or collection at random</span></span>](#Array)  
 [<span data-ttu-id="93d50-126">从数组或集合中检索唯一元素</span><span class="sxs-lookup"><span data-stu-id="93d50-126">Retrieve a unique element from an array or collection</span></span>](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a><span data-ttu-id="93d50-127">实例化随机数生成器</span><span class="sxs-lookup"><span data-stu-id="93d50-127">Instantiating the random number generator</span></span>  
 <span data-ttu-id="93d50-128">通过向 <xref:System.Random.%23ctor%2A> 类构造函数提供种子值（伪随机数生成算法的起始值）来实例化随机数生成器。</span><span class="sxs-lookup"><span data-stu-id="93d50-128">You instantiate the random number generator by providing a seed value (a starting value for the pseudo-random number generation algorithm) to a <xref:System.Random.%23ctor%2A> class constructor.</span></span>  <span data-ttu-id="93d50-129">可以显式或隐式提供种子值：</span><span class="sxs-lookup"><span data-stu-id="93d50-129">You can supply the seed value either explicitly or implicitly:</span></span>  
  
-   <span data-ttu-id="93d50-130"><xref:System.Random.%23ctor%28System.Int32%29> 构造函数使用您提供的显式种子值。</span><span class="sxs-lookup"><span data-stu-id="93d50-130">The <xref:System.Random.%23ctor%28System.Int32%29> constructor uses an explicit seed value that you supply.</span></span>  
  
-   <span data-ttu-id="93d50-131"><xref:System.Random.%23ctor> 构造函数使用系统时钟提供种子值。</span><span class="sxs-lookup"><span data-stu-id="93d50-131">The <xref:System.Random.%23ctor> constructor uses the system clock to provide a seed value.</span></span> <span data-ttu-id="93d50-132">这是实例化随机数生成器最常见的方法。</span><span class="sxs-lookup"><span data-stu-id="93d50-132">This is the most common way of instantiating the random number generator.</span></span>  
  
 <span data-ttu-id="93d50-133">如果对单独的 <xref:System.Random> 对象使用相同的种子，则它们将生成相同的随机数字序列。</span><span class="sxs-lookup"><span data-stu-id="93d50-133">If the same seed is used for separate <xref:System.Random> objects, they will generate the same series of random numbers.</span></span> <span data-ttu-id="93d50-134">这对于创建处理随机值的测试套件或用于重放从随机数派生其数据的游戏很有用。</span><span class="sxs-lookup"><span data-stu-id="93d50-134">This can be useful for creating a test suite that processes random values, or for replaying games that derive their data from random numbers.</span></span> <span data-ttu-id="93d50-135">但请注意，在不同版本的 .NET Framework 下运行的进程中的 <xref:System.Random> 对象可能会返回不同的随机数字序列，即使它们是用相同的种子值实例化的，也是如此。</span><span class="sxs-lookup"><span data-stu-id="93d50-135">However, note that <xref:System.Random> objects in processes running under different versions of the .NET Framework may return different series of random numbers even if they're instantiated with identical seed values.</span></span>  
  
 <span data-ttu-id="93d50-136">若要生成不同的随机数序列，可以使种子值依赖于时间，从而使用 <xref:System.Random>的每个新实例生成不同的序列。</span><span class="sxs-lookup"><span data-stu-id="93d50-136">To produce different sequences of random numbers, you can make the seed value time-dependent, thereby producing a different series with each new instance of <xref:System.Random>.</span></span> <span data-ttu-id="93d50-137">参数化 <xref:System.Random.%23ctor%28System.Int32%29> 构造函数可以根据当前时间中的计时周期数来获取 <xref:System.Int32> 值，而无参数 <xref:System.Random.%23ctor> 构造函数使用系统时钟生成其种子值。</span><span class="sxs-lookup"><span data-stu-id="93d50-137">The parameterized <xref:System.Random.%23ctor%28System.Int32%29> constructor can take an <xref:System.Int32> value based on the number of ticks in the current time, whereas the parameterless <xref:System.Random.%23ctor> constructor uses the system clock to generate its seed value.</span></span> <span data-ttu-id="93d50-138">但是，仅在 .NET Framework 上，由于时钟具有有限的分辨率，因此使用无参数构造函数在 close 中创建不同的 <xref:System.Random> 对象会创建随机数字生成器，它们生成相同的随机数序列。</span><span class="sxs-lookup"><span data-stu-id="93d50-138">However, on the .NET Framework only, because the clock has finite resolution, using the parameterless constructor to create different <xref:System.Random> objects in close succession creates random number generators that produce identical sequences of random numbers.</span></span> <span data-ttu-id="93d50-139">下面的示例演示了在 .NET Framework 应用程序中连续实例化的两个 <xref:System.Random> 对象如何生成相同系列的随机数。</span><span class="sxs-lookup"><span data-stu-id="93d50-139">The following example illustrates how two <xref:System.Random> objects that are instantiated in close succession in a .NET Framework application generate an identical series of random numbers.</span></span> <span data-ttu-id="93d50-140">在大多数 Windows 系统上，<xref:System.Random> 在15毫秒内创建的对象可能具有相同的种子值。</span><span class="sxs-lookup"><span data-stu-id="93d50-140">On most Windows systems, <xref:System.Random> objects created within 15 milliseconds of one another are likely to have identical seed values.</span></span>  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
<span data-ttu-id="93d50-141">若要避免此问题，请创建单个 <xref:System.Random> 对象，而不是多个对象。</span><span class="sxs-lookup"><span data-stu-id="93d50-141">To avoid this problem, create a single <xref:System.Random> object instead of multiple objects.</span></span> <span data-ttu-id="93d50-142">请注意，.NET Core 中的 `Random` 类没有此限制。</span><span class="sxs-lookup"><span data-stu-id="93d50-142">Note that the `Random` class in .NET Core does not have this limitation.</span></span>
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a><span data-ttu-id="93d50-143">避免多个实例化</span><span class="sxs-lookup"><span data-stu-id="93d50-143">Avoiding multiple instantiations</span></span>  
 <span data-ttu-id="93d50-144">在 .NET Framework 上，在紧凑循环中初始化两个随机数生成器，或在快速连续创建两个随机数生成器，它们可以生成相同的随机数序列。</span><span class="sxs-lookup"><span data-stu-id="93d50-144">On the .NET Framework, initializing two random number generators in a tight loop or in rapid succession creates two random number generators that can produce identical sequences of random numbers.</span></span> <span data-ttu-id="93d50-145">在大多数情况下，这并不是开发人员的意图，可能会导致性能问题，因为实例化和初始化随机数生成器的过程相对较高。</span><span class="sxs-lookup"><span data-stu-id="93d50-145">In most cases, this is not the developer's intent and can lead to performance issues, because instantiating and initializing a random number generator is a relatively expensive process.</span></span>  
  
 <span data-ttu-id="93d50-146">若要提高性能，并避免无意中创建生成相同数值序列的单独随机数生成器，建议您创建一个 <xref:System.Random> 对象，以便在一段时间内生成许多随机数，而不是创建新的 <xref:System.Random> 对象以生成一个随机数。</span><span class="sxs-lookup"><span data-stu-id="93d50-146">Both to improve performance and to avoid inadvertently creating separate random number generators that generate identical numeric sequences, we recommend that you create one <xref:System.Random> object to generate many random numbers over time, instead of creating new <xref:System.Random> objects to generate one random number.</span></span>  
  
 <span data-ttu-id="93d50-147">但 <xref:System.Random> 类不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="93d50-147">However, the <xref:System.Random> class isn't thread safe.</span></span> <span data-ttu-id="93d50-148">如果从多个线程调用 <xref:System.Random> 方法，请遵循下一节中所述的准则。</span><span class="sxs-lookup"><span data-stu-id="93d50-148">If you call <xref:System.Random> methods from multiple threads, follow the guidelines discussed in the next section.</span></span>  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a><span data-ttu-id="93d50-149">System.web 类和线程安全</span><span class="sxs-lookup"><span data-stu-id="93d50-149">The System.Random class and thread safety</span></span>  
 <span data-ttu-id="93d50-150">建议你创建单个 <xref:System.Random> 实例来生成应用所需的所有随机数，而不是实例化单个 <xref:System.Random> 对象。</span><span class="sxs-lookup"><span data-stu-id="93d50-150">Instead of instantiating individual <xref:System.Random> objects, we recommend that you create a single <xref:System.Random> instance to generate all the random numbers needed by your app.</span></span> <span data-ttu-id="93d50-151">但 <xref:System.Random> 对象不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="93d50-151">However, <xref:System.Random> objects are not thread safe.</span></span> <span data-ttu-id="93d50-152">如果你的应用程序从多个线程调用 <xref:System.Random> 方法，则必须使用同步对象来确保每次只有一个线程可以访问随机数生成器。</span><span class="sxs-lookup"><span data-stu-id="93d50-152">If your app calls <xref:System.Random> methods from multiple threads, you must use a synchronization object to ensure that only one thread can access the random number generator at a time.</span></span> <span data-ttu-id="93d50-153">如果不确保以线程安全的方式访问 <xref:System.Random> 对象，则调用返回随机数的方法将返回0。</span><span class="sxs-lookup"><span data-stu-id="93d50-153">If you don't ensure that the <xref:System.Random> object is accessed in a thread-safe way, calls to methods that return random numbers return 0.</span></span>  
  
 <span data-ttu-id="93d50-154">下面的示例使用C# [lock 语句](~/docs/csharp/language-reference/keywords/lock-statement.md)和 Visual Basic [SyncLock 语句](~/docs/visual-basic/language-reference/statements/synclock-statement.md)来确保由11个线程在线程安全的方式下访问单个随机数生成器。</span><span class="sxs-lookup"><span data-stu-id="93d50-154">The following example uses the C# [lock Statement](~/docs/csharp/language-reference/keywords/lock-statement.md) and the Visual Basic [SyncLock statement](~/docs/visual-basic/language-reference/statements/synclock-statement.md) to ensure that a single random number generator is accessed by 11 threads in a thread-safe manner.</span></span> <span data-ttu-id="93d50-155">每个线程都会生成2000000的随机数字，计算生成的随机数数并计算它们的总和，然后在完成执行后更新所有线程的总数。</span><span class="sxs-lookup"><span data-stu-id="93d50-155">Each thread generates 2 million random numbers, counts the number of random numbers generated and calculates their sum, and then updates the totals for all threads when it finishes executing.</span></span>  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 <span data-ttu-id="93d50-156">该示例通过以下方式确保线程安全：</span><span class="sxs-lookup"><span data-stu-id="93d50-156">The example ensures thread-safety in the following ways:</span></span>  
  
-   <span data-ttu-id="93d50-157"><xref:System.ThreadStaticAttribute> 属性用于定义线程本地变量，这些变量跟踪每个线程生成的随机数总数及其总和。</span><span class="sxs-lookup"><span data-stu-id="93d50-157">The <xref:System.ThreadStaticAttribute> attribute is used to define thread-local variables that track the total number of random numbers generated and their sum for each thread.</span></span>  
  
-   <span data-ttu-id="93d50-158">锁（中C#的 `lock` 语句和 Visual Basic 中的 `SyncLock` 语句）可保护对所有线程上生成的总数和所有随机数的总和的变量的访问。</span><span class="sxs-lookup"><span data-stu-id="93d50-158">A lock (the `lock` statement in C# and the `SyncLock` statement in Visual Basic) protects access to the variables for the total count and sum of all random numbers generated on all threads.</span></span>  
  
-   <span data-ttu-id="93d50-159">信号量（<xref:System.Threading.CountdownEvent> 对象）用于确保在所有其他线程都完成执行之前，主线程将会阻塞。</span><span class="sxs-lookup"><span data-stu-id="93d50-159">A semaphore (the <xref:System.Threading.CountdownEvent> object) is used to ensure that the main thread blocks until all other threads complete execution.</span></span>  
  
-   <span data-ttu-id="93d50-160">该示例通过确定两次对随机数生成方法的连续调用是否返回0来检查随机数生成器是否已损坏。</span><span class="sxs-lookup"><span data-stu-id="93d50-160">The example checks whether the random number generator has become corrupted by determining whether two consecutive calls to random number generation methods return 0.</span></span> <span data-ttu-id="93d50-161">如果检测到损坏，则该示例使用 <xref:System.Threading.CancellationTokenSource> 对象发送所有线程都应被取消。</span><span class="sxs-lookup"><span data-stu-id="93d50-161">If corruption is detected, the example uses the <xref:System.Threading.CancellationTokenSource> object to signal that all threads should be canceled.</span></span>  
  
-   <span data-ttu-id="93d50-162">在生成每个随机数之前，每个线程都会检查 <xref:System.Threading.CancellationToken> 对象的状态。</span><span class="sxs-lookup"><span data-stu-id="93d50-162">Before generating each random number, each thread checks the state of the <xref:System.Threading.CancellationToken> object.</span></span> <span data-ttu-id="93d50-163">如果请求取消，则该示例调用 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> 方法来取消线程。</span><span class="sxs-lookup"><span data-stu-id="93d50-163">If cancellation is requested, the example calls the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method to cancel the thread.</span></span>  
  
 <span data-ttu-id="93d50-164">下面的示例与第一个示例相同，只不过它使用 <xref:System.Threading.Tasks.Task> 对象和 lambda 表达式，而不是 <xref:System.Threading.Thread> 对象。</span><span class="sxs-lookup"><span data-stu-id="93d50-164">The following example is identical to the first, except that it uses a <xref:System.Threading.Tasks.Task> object and a lambda expression instead of <xref:System.Threading.Thread> objects.</span></span>  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 <span data-ttu-id="93d50-165">它与第一个示例在以下方面有所不同：</span><span class="sxs-lookup"><span data-stu-id="93d50-165">It differs from the first example in the following ways:</span></span>  
  
-   <span data-ttu-id="93d50-166">用于跟踪生成的随机数数量及其在每个任务中的总和的变量对于任务而言是本地的，因此无需使用 <xref:System.ThreadStaticAttribute> 特性。</span><span class="sxs-lookup"><span data-stu-id="93d50-166">The variables to keep track of the number of random numbers generated and their sum in each task are local to the task, so there is no need to use the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
-   <span data-ttu-id="93d50-167">静态 <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> 方法用于确保主线程在所有任务完成之前未完成。</span><span class="sxs-lookup"><span data-stu-id="93d50-167">The static <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method is used to ensure that the main thread doesn't complete before all tasks have finished.</span></span> <span data-ttu-id="93d50-168">不需要 <xref:System.Threading.CountdownEvent> 的对象。</span><span class="sxs-lookup"><span data-stu-id="93d50-168">There is no need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
-   <span data-ttu-id="93d50-169">任务取消导致的异常在 <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> 方法中出现。</span><span class="sxs-lookup"><span data-stu-id="93d50-169">The exception that results from task cancellation is surfaced in the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="93d50-170">在上面的示例中，它由每个线程处理。</span><span class="sxs-lookup"><span data-stu-id="93d50-170">In the previous example, it is handled by each thread.</span></span>  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a><span data-ttu-id="93d50-171">生成不同类型的随机数</span><span class="sxs-lookup"><span data-stu-id="93d50-171">Generating different types of random numbers</span></span>  
 <span data-ttu-id="93d50-172">随机数生成器提供了一些方法，使您可以生成以下类型的随机数：</span><span class="sxs-lookup"><span data-stu-id="93d50-172">The random number generator provides methods that let you generate the following kinds of random numbers:</span></span>  
  
-   <span data-ttu-id="93d50-173">一系列 <xref:System.Byte> 值。</span><span class="sxs-lookup"><span data-stu-id="93d50-173">A series of <xref:System.Byte> values.</span></span> <span data-ttu-id="93d50-174">通过将初始化为要方法返回到 <xref:System.Random.NextBytes%2A> 方法的元素数的数组，来确定字节值的数目。</span><span class="sxs-lookup"><span data-stu-id="93d50-174">You determine the number of byte values by passing an array initialized to the number of elements you want the method to return to the <xref:System.Random.NextBytes%2A> method.</span></span> <span data-ttu-id="93d50-175">下面的示例生成20个字节。</span><span class="sxs-lookup"><span data-stu-id="93d50-175">The following example generates 20 bytes.</span></span>  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   <span data-ttu-id="93d50-176">一个整数。</span><span class="sxs-lookup"><span data-stu-id="93d50-176">A single integer.</span></span> <span data-ttu-id="93d50-177">您可以通过调用 <xref:System.Random.Next> 方法来选择是否希望从0到最大值（<xref:System.Int32.MaxValue?displayProperty=nameWithType>-1）的整数，或者通过调用 <xref:System.Random.Next%28System.Int32%29> 方法，从0到特定值之间的整数，或者通过调用 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 方法来选择值范围内的整数。</span><span class="sxs-lookup"><span data-stu-id="93d50-177">You can choose whether you want an integer from 0 to a maximum value (<xref:System.Int32.MaxValue?displayProperty=nameWithType> - 1) by calling the <xref:System.Random.Next> method, an integer between 0 and a specific value by calling the <xref:System.Random.Next%28System.Int32%29> method, or an integer within a range of values by calling the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="93d50-178">在参数化重载中，指定的最大值是独占的;也就是说，生成的实际最大数目小于指定值。</span><span class="sxs-lookup"><span data-stu-id="93d50-178">In the parameterized overloads, the specified maximum value is exclusive; that is, the actual maximum number generated is one less than the specified value.</span></span>  
  
     <span data-ttu-id="93d50-179">下面的示例调用 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 方法，以便在-10 和10之间生成10个随机数。</span><span class="sxs-lookup"><span data-stu-id="93d50-179">The following example calls the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method to generate 10 random numbers between -10 and 10.</span></span> <span data-ttu-id="93d50-180">请注意，方法的第二个参数指定方法返回的随机值的范围的上限。</span><span class="sxs-lookup"><span data-stu-id="93d50-180">Note that the second argument to the method specifies the exclusive upper bound of the range of random values returned by the method.</span></span> <span data-ttu-id="93d50-181">换言之，该方法可以返回的最大整数是小于此值的整数。</span><span class="sxs-lookup"><span data-stu-id="93d50-181">In other words, the largest integer that the method can return is one less than this value.</span></span>  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   <span data-ttu-id="93d50-182">通过调用 <xref:System.Random.NextDouble%2A> 方法，从0.0 到小于1.0 的单个浮点值。</span><span class="sxs-lookup"><span data-stu-id="93d50-182">A single floating-point value from 0.0 to less than 1.0 by calling the <xref:System.Random.NextDouble%2A> method.</span></span> <span data-ttu-id="93d50-183">方法返回的随机数的上限上限为1，因此它的实际上限为0.99999999999999978。</span><span class="sxs-lookup"><span data-stu-id="93d50-183">The exclusive upper bound of the random number returned by the method is 1, so its actual upper bound is 0.99999999999999978.</span></span> <span data-ttu-id="93d50-184">下面的示例生成10个随机浮点数。</span><span class="sxs-lookup"><span data-stu-id="93d50-184">The following example generates 10 random floating-point numbers.</span></span>  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  <span data-ttu-id="93d50-185"><xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 方法允许您指定返回的随机数的范围。</span><span class="sxs-lookup"><span data-stu-id="93d50-185">The <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method allows you to specify the range of the returned random number.</span></span> <span data-ttu-id="93d50-186">但 `maxValue` 参数（指定上限返回的数字）是一个独占的，而不是包含的值。</span><span class="sxs-lookup"><span data-stu-id="93d50-186">However, the `maxValue` parameter, which specifies the upper range returned number, is an exclusive, not an inclusive, value.</span></span> <span data-ttu-id="93d50-187">这意味着方法调用 `Next(0, 100)` 返回介于0到99之间的值，而不是介于0和100之间。</span><span class="sxs-lookup"><span data-stu-id="93d50-187">This means that the method call `Next(0, 100)` returns a value between 0 and 99, and not between 0 and 100.</span></span>  
  
 <span data-ttu-id="93d50-188">你还可以将此类任务用于如下所示的任务：生成[随机](#Boolean)的 <xref:System.Random> 类、生成随机[浮点值，范围为0到1以外的范围](#Floats)，生成[随机的64位整数](#Long)，并[从数组或集合中随机检索唯一元素](#UniqueArray)。</span><span class="sxs-lookup"><span data-stu-id="93d50-188">You can also use the <xref:System.Random> class for such tasks as generating [random T:System.Boolean values](#Boolean), generating [random floating point values with a range other than 0 to 1](#Floats), generating [random 64-bit integers](#Long), and [randomly retrieving a unique element from an array or collection](#UniqueArray).</span></span> <span data-ttu-id="93d50-189">对于这些任务和其他常见任务，请参阅[如何使用系统](#Operations)</span><span class="sxs-lookup"><span data-stu-id="93d50-189">For these and other common tasks, see the [How do you use System.Random to…](#Operations)</span></span> <span data-ttu-id="93d50-190">。</span><span class="sxs-lookup"><span data-stu-id="93d50-190">section.</span></span>  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a><span data-ttu-id="93d50-191">替换自己的算法</span><span class="sxs-lookup"><span data-stu-id="93d50-191">Substituting your own algorithm</span></span>  
 <span data-ttu-id="93d50-192">可以通过从 <xref:System.Random> 类继承并提供随机数生成算法来实现自己的随机数生成器。</span><span class="sxs-lookup"><span data-stu-id="93d50-192">You can implement your own random number generator by inheriting from the <xref:System.Random> class and supplying your random number generation algorithm.</span></span> <span data-ttu-id="93d50-193">若要提供自己的算法，必须重写实现随机数生成算法的 <xref:System.Random.Sample%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="93d50-193">To supply your own algorithm, you must override the <xref:System.Random.Sample%2A> method, which implements the random number generation algorithm.</span></span> <span data-ttu-id="93d50-194">还应覆盖 <xref:System.Random.Next>、<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>和 <xref:System.Random.NextBytes%2A> 方法，以确保它们调用重写的 <xref:System.Random.Sample%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="93d50-194">You should also override the <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, and <xref:System.Random.NextBytes%2A> methods to ensure that they call your overridden <xref:System.Random.Sample%2A> method.</span></span> <span data-ttu-id="93d50-195">不需要重写 <xref:System.Random.Next%28System.Int32%29> 和 <xref:System.Random.NextDouble%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="93d50-195">You don't have to override the <xref:System.Random.Next%28System.Int32%29> and <xref:System.Random.NextDouble%2A> methods.</span></span>  
  
 <span data-ttu-id="93d50-196">有关派生自 <xref:System.Random> 类并修改其默认伪随机数生成器的示例，请参阅 <xref:System.Random.Sample%2A> 参考页。</span><span class="sxs-lookup"><span data-stu-id="93d50-196">For an example that derives from the <xref:System.Random> class and modifies its default pseudo-random number generator, see the <xref:System.Random.Sample%2A> reference page.</span></span>  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a><span data-ttu-id="93d50-197">如何使用 "系统随机 ..."</span><span class="sxs-lookup"><span data-stu-id="93d50-197">How do you use System.Random to…</span></span>  
 <span data-ttu-id="93d50-198">以下部分讨论并为你可能想要在应用程序中使用随机数的一些方式提供示例代码。</span><span class="sxs-lookup"><span data-stu-id="93d50-198">The following sections discuss and provide sample code for some of the ways you might want to use random numbers in your app.</span></span>  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a><span data-ttu-id="93d50-199">检索相同的随机值序列</span><span class="sxs-lookup"><span data-stu-id="93d50-199">Retrieve the same sequence of random values</span></span>  
 <span data-ttu-id="93d50-200">有时，您想要在软件测试方案和游戏游戏中生成相同的随机数字序列。</span><span class="sxs-lookup"><span data-stu-id="93d50-200">Sometimes you want to generate the same sequence of random numbers in software test scenarios and in game playing.</span></span> <span data-ttu-id="93d50-201">用相同的随机数序列进行测试，可以检测回归和确认 bug 修复。</span><span class="sxs-lookup"><span data-stu-id="93d50-201">Testing with the same sequence of random numbers allows you to detect regressions and confirm bug fixes.</span></span> <span data-ttu-id="93d50-202">在游戏中使用相同的随机数字序列可重播以前的游戏。</span><span class="sxs-lookup"><span data-stu-id="93d50-202">Using the same sequence of random number in games allows you to replay previous games.</span></span>  
  
 <span data-ttu-id="93d50-203">您可以通过向 <xref:System.Random.%23ctor%28System.Int32%29> 构造函数提供相同的种子值，生成相同的随机数字序列。</span><span class="sxs-lookup"><span data-stu-id="93d50-203">You can generate the same sequence of random numbers by providing the same seed value to the <xref:System.Random.%23ctor%28System.Int32%29> constructor.</span></span> <span data-ttu-id="93d50-204">种子值为伪随机数生成算法提供起始值。</span><span class="sxs-lookup"><span data-stu-id="93d50-204">The seed value provides a starting value for the pseudo-random number generation algorithm.</span></span> <span data-ttu-id="93d50-205">下面的示例使用100100作为任意种子值来实例化 <xref:System.Random> 的对象，显示20个随机浮点值，并保留种子值。</span><span class="sxs-lookup"><span data-stu-id="93d50-205">The following example uses 100100 as an arbitrary seed value to instantiate the <xref:System.Random> object, displays 20 random floating-point values, and persists the seed value.</span></span> <span data-ttu-id="93d50-206">然后，它将还原种子值，实例化新的随机数生成器，并显示相同的20个随机浮点值。</span><span class="sxs-lookup"><span data-stu-id="93d50-206">It then restores the seed value, instantiates a new random number generator, and displays the same 20 random floating-point values.</span></span>  <span data-ttu-id="93d50-207">请注意，如果在 .NET Framework 的不同版本上运行，则该示例可能生成不同的随机数字序列。</span><span class="sxs-lookup"><span data-stu-id="93d50-207">Note that the example may produce different sequences of random numbers if run on different versions of the .NET Framework.</span></span>  
  
 [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]
 [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]
 [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a><span data-ttu-id="93d50-208">检索随机数的唯一序列</span><span class="sxs-lookup"><span data-stu-id="93d50-208">Retrieve unique sequences of random numbers</span></span>  
 <span data-ttu-id="93d50-209">向 <xref:System.Random> 类的实例提供不同的种子值会导致每个随机数生成器生成不同的值序列。</span><span class="sxs-lookup"><span data-stu-id="93d50-209">Providing different seed values to instances of the <xref:System.Random> class causes each random number generator to produce a different sequence of values.</span></span> <span data-ttu-id="93d50-210">可以通过调用 <xref:System.Random.%23ctor%28System.Int32%29> 构造函数或通过调用 <xref:System.Random.%23ctor> 构造函数隐式地提供种子值。</span><span class="sxs-lookup"><span data-stu-id="93d50-210">You can provide a seed value either explicitly by calling the <xref:System.Random.%23ctor%28System.Int32%29> constructor, or implicitly by calling the <xref:System.Random.%23ctor> constructor.</span></span> <span data-ttu-id="93d50-211">大多数开发人员调用使用系统时钟的无参数构造函数。</span><span class="sxs-lookup"><span data-stu-id="93d50-211">Most developers call the parameterless constructor, which uses the system clock.</span></span> <span data-ttu-id="93d50-212">下面的示例使用此方法实例化两个 <xref:System.Random> 实例。</span><span class="sxs-lookup"><span data-stu-id="93d50-212">The following example uses this approach to instantiate two <xref:System.Random> instances.</span></span> <span data-ttu-id="93d50-213">每个实例都显示一系列10个随机整数。</span><span class="sxs-lookup"><span data-stu-id="93d50-213">Each instance displays a series of 10 random integers.</span></span>  
  
 [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 <span data-ttu-id="93d50-214">但是，由于其有限的解决方法，系统时钟不会检测到大约15毫秒的时间差异。</span><span class="sxs-lookup"><span data-stu-id="93d50-214">However, because of its finite resolution, the system clock doesn't detect time differences that are less than approximately 15 milliseconds.</span></span> <span data-ttu-id="93d50-215">因此，如果你的代码调用 .NET Framework 上的 <xref:System.Random.%23ctor> 重载以便连续实例化两个 <xref:System.Random> 对象，则可能会无意中提供具有相同种子值的对象。</span><span class="sxs-lookup"><span data-stu-id="93d50-215">Therefore, if your code calls the <xref:System.Random.%23ctor> overload on the .NET Framework to instantiate two <xref:System.Random> objects in succession, you might inadvertently be providing the objects with identical seed values.</span></span> <span data-ttu-id="93d50-216">（.NET Core 中的 <xref:System.Random> 类没有此限制。）若要在上面的示例中查看此示例，请注释掉 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 方法调用，然后再次编译并运行该示例。</span><span class="sxs-lookup"><span data-stu-id="93d50-216">(The <xref:System.Random> class in .NET Core does not have this limitation.) To see this in the previous example, comment out the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method call, and compile and run the example again.</span></span>  
  
 <span data-ttu-id="93d50-217">为了防止发生这种情况，我们建议您实例化单个 <xref:System.Random> 对象，而不是多个对象。</span><span class="sxs-lookup"><span data-stu-id="93d50-217">To prevent this from happening, we recommend that you instantiate a single <xref:System.Random> object rather than multiple ones.</span></span> <span data-ttu-id="93d50-218">但是，由于 <xref:System.Random> 不是线程安全的，因此，如果从多个线程访问 <xref:System.Random> 实例，则必须使用某个同步设备;有关详细信息，请参阅本主题前面[的随机类和线程安全](#ThreadSafety)。</span><span class="sxs-lookup"><span data-stu-id="93d50-218">However, since <xref:System.Random> isn't thread safe, you must use some synchronization device if you access a <xref:System.Random> instance from multiple threads; for more information, see [The Random class and thread safety](#ThreadSafety) earlier in this topic.</span></span> <span data-ttu-id="93d50-219">另外，还可以使用延迟机制，如上一示例中使用的 <xref:System.Threading.Thread.Sleep%2A> 方法，以确保实例化的时间间隔超过15毫秒。</span><span class="sxs-lookup"><span data-stu-id="93d50-219">Alternately, you can use a delay mechanism, such as the <xref:System.Threading.Thread.Sleep%2A> method used in the previous example, to ensure that the instantiations occur more than 15 millisecond apart.</span></span>  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a><span data-ttu-id="93d50-220">检索指定范围内的整数</span><span class="sxs-lookup"><span data-stu-id="93d50-220">Retrieve integers in a specified range</span></span>  
 <span data-ttu-id="93d50-221">您可以通过调用 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 方法来检索指定范围内的整数，这允许您指定要随机数生成器返回的数字的下限和上限。</span><span class="sxs-lookup"><span data-stu-id="93d50-221">You can retrieve integers in a specified range by calling the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method, which lets you specify both the lower and the upper bound of the numbers you'd like the random number generator to return.</span></span> <span data-ttu-id="93d50-222">上限是专用的，而不是包含的值。</span><span class="sxs-lookup"><span data-stu-id="93d50-222">The upper bound is an exclusive, not an inclusive, value.</span></span> <span data-ttu-id="93d50-223">也就是说，它不包含在由方法返回的值范围内。</span><span class="sxs-lookup"><span data-stu-id="93d50-223">That is, it isn't included in the range of values returned by the method.</span></span> <span data-ttu-id="93d50-224">下面的示例使用此方法生成介于-10 和10之间的随机整数。</span><span class="sxs-lookup"><span data-stu-id="93d50-224">The following example uses this method to generate random integers between -10 and 10.</span></span> <span data-ttu-id="93d50-225">请注意，它指定11，它比所需的值大一，作为方法调用中 `maxValue` 参数的值。</span><span class="sxs-lookup"><span data-stu-id="93d50-225">Note that it specifies 11, which is one greater than the desired value, as the value of the `maxValue` argument in the method call.</span></span>  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a><span data-ttu-id="93d50-226">检索指定位数的整数</span><span class="sxs-lookup"><span data-stu-id="93d50-226">Retrieve integers with a specified number of digits</span></span>  
 <span data-ttu-id="93d50-227">可以调用 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 方法来检索具有指定位数的数字。</span><span class="sxs-lookup"><span data-stu-id="93d50-227">You can call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method to retrieve numbers with a specified number of digits.</span></span> <span data-ttu-id="93d50-228">例如，若要检索具有四位数的数字（即从1000到9999的数字），请调用 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 方法，其 `minValue` 值为1000，`maxValue` 值为10000，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="93d50-228">For example, to retrieve numbers with four digits (that is, numbers that range from 1000 to 9999), you call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method with a `minValue` value of 1000 and a `maxValue` value of 10000, as the following example shows.</span></span>  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a><span data-ttu-id="93d50-229">检索指定范围内的浮点值</span><span class="sxs-lookup"><span data-stu-id="93d50-229">Retrieve floating-point values in a specified range</span></span>  
 <span data-ttu-id="93d50-230"><xref:System.Random.NextDouble%2A> 方法返回介于0和1之间的随机浮点值。</span><span class="sxs-lookup"><span data-stu-id="93d50-230">The <xref:System.Random.NextDouble%2A> method returns random floating-point values that range from 0 to less than 1.</span></span> <span data-ttu-id="93d50-231">但是，您通常需要在其他某个范围内生成随机值。</span><span class="sxs-lookup"><span data-stu-id="93d50-231">However, you'll often want to generate random values in some other range.</span></span>  
  
 <span data-ttu-id="93d50-232">如果所需的最小值和最大值之间的间隔为1，则可以将所需起始间隔和0之间的差值添加到 <xref:System.Random.NextDouble%2A> 方法返回的数字。</span><span class="sxs-lookup"><span data-stu-id="93d50-232">If the interval between the minimum and maximum desired values is 1, you can add the difference between the desired starting interval and 0 to the number returned by the <xref:System.Random.NextDouble%2A> method.</span></span> <span data-ttu-id="93d50-233">下面的示例将生成10个介于-1 和0之间的随机数。</span><span class="sxs-lookup"><span data-stu-id="93d50-233">The following example does this to generate 10 random numbers between -1 and 0.</span></span>  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 <span data-ttu-id="93d50-234">若要生成其下限为0但上限大于1的随机浮点数（或者在负数的情况下，其下限小于-1 且上限为0），则将该随机数乘以非零界限。</span><span class="sxs-lookup"><span data-stu-id="93d50-234">To generate random floating-point numbers whose lower bound is 0 but upper bound is greater than 1 (or, in the case of negative numbers, whose lower bound is less than -1 and upper bound is 0), multiply the random number by the non-zero bound.</span></span> <span data-ttu-id="93d50-235">下面的示例将生成20000000随机浮点数，范围为0到 <xref:System.Int64.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="93d50-235">The following example does this to generate 20 million random floating-point numbers that range from 0 to <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="93d50-236">中的还显示方法所生成的随机值的分布。</span><span class="sxs-lookup"><span data-stu-id="93d50-236">In also displays the distribution of the random values generated by the method.</span></span>  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 <span data-ttu-id="93d50-237">若要在两个任意值之间生成随机浮点数，如 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 方法对整数执行运算，请使用以下公式：</span><span class="sxs-lookup"><span data-stu-id="93d50-237">To generate random floating-point numbers between two arbitrary values, like the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method does for integers, use the following formula:</span></span>  
  
```csharp  
Random.NextDouble() * (maxValue - minValue) + minValue  
```  
  
 <span data-ttu-id="93d50-238">下面的示例生成1000000到11.0 范围10.0 内的随机数字，并显示其分布。</span><span class="sxs-lookup"><span data-stu-id="93d50-238">The following example generates 1 million random numbers that range from 10.0 to 11.0, and displays their distribution.</span></span>  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a><span data-ttu-id="93d50-239">生成随机布尔值</span><span class="sxs-lookup"><span data-stu-id="93d50-239">Generate random Boolean values</span></span>  
 <span data-ttu-id="93d50-240"><xref:System.Random> 类不提供生成 <xref:System.Boolean> 值的方法。</span><span class="sxs-lookup"><span data-stu-id="93d50-240">The <xref:System.Random> class doesn't provide methods that generate <xref:System.Boolean> values.</span></span> <span data-ttu-id="93d50-241">但是，您可以定义自己的类或方法来执行此操作。</span><span class="sxs-lookup"><span data-stu-id="93d50-241">However, you can define your own class or method to do that.</span></span> <span data-ttu-id="93d50-242">下面的示例定义了一个使用单个方法 `NextBoolean``BooleanGenerator`的类。</span><span class="sxs-lookup"><span data-stu-id="93d50-242">The following example defines a class, `BooleanGenerator`, with a single method, `NextBoolean`.</span></span> <span data-ttu-id="93d50-243">`BooleanGenerator` 类将 <xref:System.Random> 对象存储为私有变量。</span><span class="sxs-lookup"><span data-stu-id="93d50-243">The `BooleanGenerator` class stores a <xref:System.Random> object as a private variable.</span></span> <span data-ttu-id="93d50-244">`NextBoolean` 方法调用 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 方法并将结果传递给 <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="93d50-244">The `NextBoolean` method calls the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method and passes the result to the <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="93d50-245">请注意，使用2作为参数来指定随机数的上限。</span><span class="sxs-lookup"><span data-stu-id="93d50-245">Note that 2 is used as the argument to specify the upper bound of the random number.</span></span> <span data-ttu-id="93d50-246">由于这是一个独占值，因此该方法调用返回0或1。</span><span class="sxs-lookup"><span data-stu-id="93d50-246">Since this is an exclusive value, the method call returns either 0 or 1.</span></span>  
  
 [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 <span data-ttu-id="93d50-247">该示例只是定义了一个方法，而不是创建一个单独的类来生成随机 <xref:System.Boolean> 值。</span><span class="sxs-lookup"><span data-stu-id="93d50-247">Instead of creating a separate class to generate random <xref:System.Boolean> values, the example could simply have defined a single method.</span></span> <span data-ttu-id="93d50-248">但是，在这种情况下，应将 <xref:System.Random> 对象定义为类级变量，以避免在每个方法调用中实例化新的 <xref:System.Random> 实例。</span><span class="sxs-lookup"><span data-stu-id="93d50-248">In that case, however, the <xref:System.Random> object should have been defined as a class-level variable to avoid instantiating a new <xref:System.Random> instance in each method call.</span></span> <span data-ttu-id="93d50-249">在 Visual Basic 中，随机实例可以定义为 `NextBoolean` 方法中的[静态](~/docs/visual-basic/language-reference/modifiers/static.md)变量。</span><span class="sxs-lookup"><span data-stu-id="93d50-249">In Visual Basic, the Random instance can be defined as a [Static](~/docs/visual-basic/language-reference/modifiers/static.md) variable in the `NextBoolean` method.</span></span>  <span data-ttu-id="93d50-250">下面的示例提供了一个实现。</span><span class="sxs-lookup"><span data-stu-id="93d50-250">The following example provides an implementation.</span></span>  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a><span data-ttu-id="93d50-251">生成随机的64位整数</span><span class="sxs-lookup"><span data-stu-id="93d50-251">Generate random 64-bit integers</span></span>  
 <span data-ttu-id="93d50-252"><xref:System.Random.Next%2A> 方法的重载将返回32位整数。</span><span class="sxs-lookup"><span data-stu-id="93d50-252">The overloads of the <xref:System.Random.Next%2A> method return 32-bit integers.</span></span> <span data-ttu-id="93d50-253">但是，在某些情况下，可能需要使用64位整数。</span><span class="sxs-lookup"><span data-stu-id="93d50-253">However, in some cases, you might want to work with 64-bit integers.</span></span> <span data-ttu-id="93d50-254">你可以按如下所示进行操作：</span><span class="sxs-lookup"><span data-stu-id="93d50-254">You can do this as follows:</span></span>  
  
1.  <span data-ttu-id="93d50-255">调用 <xref:System.Random.NextDouble%2A> 方法以检索双精度浮点值。</span><span class="sxs-lookup"><span data-stu-id="93d50-255">Call the <xref:System.Random.NextDouble%2A> method to retrieve a double-precision floating point value.</span></span>  
  
2.  <span data-ttu-id="93d50-256">通过 <xref:System.Int64.MaxValue?displayProperty=nameWithType>将该值相乘。</span><span class="sxs-lookup"><span data-stu-id="93d50-256">Multiply that value by <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="93d50-257">下面的示例使用此方法生成20000000个随机长整数，并将它们分类为10个等组。</span><span class="sxs-lookup"><span data-stu-id="93d50-257">The following example uses this technique to generate 20 million random long integers and categorizes them in 10 equal groups.</span></span> <span data-ttu-id="93d50-258">然后，它通过将每个组中的数字从0计算到 <xref:System.Int64.MaxValue?displayProperty=nameWithType>来计算随机数的分布。</span><span class="sxs-lookup"><span data-stu-id="93d50-258">It then evaluates the distribution of the random numbers by counting the number in each group from 0 to <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="93d50-259">如示例中的输出所示，在长整数的范围内，数值的分布将更多或更少。</span><span class="sxs-lookup"><span data-stu-id="93d50-259">As the output from the example shows, the numbers are distributed more or less equally through the range of a long integer.</span></span>  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 <span data-ttu-id="93d50-260">使用位操作的一种替代方法不会生成真正的随机数字。</span><span class="sxs-lookup"><span data-stu-id="93d50-260">An alternative technique that uses bit manipulation does not generate truly random numbers.</span></span> <span data-ttu-id="93d50-261">此方法调用 <xref:System.Random.Next> 来生成两个整数，按32位左移一位，并将它们 Or 在一起。</span><span class="sxs-lookup"><span data-stu-id="93d50-261">This technique calls <xref:System.Random.Next> to generate two integers, left-shifts one by 32 bits, and ORs them together.</span></span> <span data-ttu-id="93d50-262">此方法有两个限制：</span><span class="sxs-lookup"><span data-stu-id="93d50-262">This technique has two limitations:</span></span>  
  
1.  <span data-ttu-id="93d50-263">因为位31是符号位，所以生成的长整型值的值始终为0。</span><span class="sxs-lookup"><span data-stu-id="93d50-263">Because bit 31 is the sign bit, the value in bit 31 of the resulting long integer is always 0.</span></span>  <span data-ttu-id="93d50-264">为此，可以生成一个随机0或1，左移第31位，并将其与原始随机长整数 Or。</span><span class="sxs-lookup"><span data-stu-id="93d50-264">This can be addressed by generating a random 0 or 1, left-shifting it 31 bits, and ORing it with the original random long integer.</span></span>  
  
2.  <span data-ttu-id="93d50-265">更严肃，因为 <xref:System.Random.Next> 返回的值将为0，所以如果范围为 0x0-0x00000000FFFFFFFF 的任何随机数，都将有很多。</span><span class="sxs-lookup"><span data-stu-id="93d50-265">More seriously, because the probability that the value returned by <xref:System.Random.Next> will be 0, there will be few if any random numbers in the range 0x0-0x00000000FFFFFFFF.</span></span>  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a><span data-ttu-id="93d50-266">检索指定范围内的字节</span><span class="sxs-lookup"><span data-stu-id="93d50-266">Retrieve bytes in a specified range</span></span>  
 <span data-ttu-id="93d50-267">利用 <xref:System.Random.Next%2A> 方法的重载，可以指定随机数的范围，但 <xref:System.Random.NextBytes%2A> 方法不能。</span><span class="sxs-lookup"><span data-stu-id="93d50-267">The overloads of the <xref:System.Random.Next%2A> method allow you to specify the range of random numbers, but the <xref:System.Random.NextBytes%2A> method does not.</span></span> <span data-ttu-id="93d50-268">下面的示例实现一个 `NextBytes` 方法，该方法允许你指定返回的字节范围。</span><span class="sxs-lookup"><span data-stu-id="93d50-268">The following example implements a `NextBytes` method that lets you specify the range of the returned bytes.</span></span> <span data-ttu-id="93d50-269">它定义派生自 <xref:System.Random> 的 `Random2` 类，并重载其 `NextBytes` 方法。</span><span class="sxs-lookup"><span data-stu-id="93d50-269">It defines a `Random2` class that derives from <xref:System.Random> and overloads its `NextBytes` method.</span></span>  
  
 [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 <span data-ttu-id="93d50-270">`NextBytes(Byte[], Byte, Byte)` 方法包装对 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 方法的调用，并指定最小值和一个大于我们希望在字节数组中返回的最大值（在本例中为0和101）。</span><span class="sxs-lookup"><span data-stu-id="93d50-270">The `NextBytes(Byte[], Byte, Byte)` method wraps a call to the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method and specifies the minimum value and one greater than the maximum value (in this case, 0 and 101) that we want returned in the byte array.</span></span> <span data-ttu-id="93d50-271">由于我们确信 <xref:System.Random.Next%2A> 方法返回的整数值在 <xref:System.Byte> 数据类型的范围内，因此可以安全地将它们强制转换（在中C#）或将它们从整数转换（在 Visual Basic 中）。</span><span class="sxs-lookup"><span data-stu-id="93d50-271">Because we are sure that the integer values returned by the <xref:System.Random.Next%2A> method are within the range of the <xref:System.Byte> data type, we can safely cast them (in C#) or convert them (in Visual Basic) from integers to bytes.</span></span>  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a><span data-ttu-id="93d50-272">随机检索数组或集合中的元素</span><span class="sxs-lookup"><span data-stu-id="93d50-272">Retrieve an element from an array or collection at random</span></span>  
 <span data-ttu-id="93d50-273">随机数字通常用作索引来检索数组或集合中的值。</span><span class="sxs-lookup"><span data-stu-id="93d50-273">Random numbers often serve as indexes to retrieve values from arrays or collections.</span></span> <span data-ttu-id="93d50-274">若要检索随机索引值，可以调用 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 方法，并使用数组的下限作为其 `minValue` 参数的值，并将该数组的下限作为其 `maxValue` 参数的值。</span><span class="sxs-lookup"><span data-stu-id="93d50-274">To retrieve a random index value, you can call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method, and use the lower bound of the array as the value of its `minValue` argument and one greater than the upper bound of the array as the value of its `maxValue` argument.</span></span> <span data-ttu-id="93d50-275">对于从零开始的数组，这等效于其 <xref:System.Array.Length%2A> 属性，或大于 <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> 方法返回的值的数组。</span><span class="sxs-lookup"><span data-stu-id="93d50-275">For a zero-based array, this is equivalent to its <xref:System.Array.Length%2A> property, or one greater than the value returned by the <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="93d50-276">下面的示例从城市数组中随机检索美国中的城市名称。</span><span class="sxs-lookup"><span data-stu-id="93d50-276">The following example randomly retrieves the name of a city in the United States from an array of cities.</span></span>  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a><span data-ttu-id="93d50-277">从数组或集合中检索唯一元素</span><span class="sxs-lookup"><span data-stu-id="93d50-277">Retrieve a unique element from an array or collection</span></span>  
 <span data-ttu-id="93d50-278">随机数生成器始终可以返回重复值。</span><span class="sxs-lookup"><span data-stu-id="93d50-278">A random number generator can always return duplicate values.</span></span> <span data-ttu-id="93d50-279">当数字范围变小或生成的值的数目变大时，重复的概率会增大。</span><span class="sxs-lookup"><span data-stu-id="93d50-279">As the range of numbers becomes smaller or the number of values generated becomes larger, the probability of duplicates grows.</span></span> <span data-ttu-id="93d50-280">如果随机值必须是唯一的，则会生成更多的数字来补偿重复项，从而导致性能日趋下降。</span><span class="sxs-lookup"><span data-stu-id="93d50-280">If random values must be unique, more numbers are generated to compensate for duplicates, resulting in increasingly poor performance.</span></span>  
  
 <span data-ttu-id="93d50-281">可以通过多种方法来处理这种情况。</span><span class="sxs-lookup"><span data-stu-id="93d50-281">There are a number of techniques to handle this scenario.</span></span> <span data-ttu-id="93d50-282">一种常见的解决方法是创建包含要检索的值的数组或集合，以及包含随机浮点数的并行数组。</span><span class="sxs-lookup"><span data-stu-id="93d50-282">One common solution is to create an array or collection that contains the values to be retrieved, and a parallel array that contains random floating-point numbers.</span></span> <span data-ttu-id="93d50-283">第二个数组是在第一个数组创建时用随机数字填充的，而 <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> 方法用于使用并行数组中的值对第一个数组进行排序。</span><span class="sxs-lookup"><span data-stu-id="93d50-283">The second array is populated with random numbers at the time the first array is created, and the <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> method is used to sort the first array by using the values in the parallel array.</span></span>  
  
 <span data-ttu-id="93d50-284">例如，如果您正在开发纸牌游戏，则需要确保每张卡片仅使用一次。</span><span class="sxs-lookup"><span data-stu-id="93d50-284">For example, if you're developing a Solitaire game, you want to ensure that each card is used only once.</span></span> <span data-ttu-id="93d50-285">您可以创建可用于对卡片组进行排序的随机数字的并行数组，而不是生成用于检索卡并跟踪该卡是否已被处理的随机数。</span><span class="sxs-lookup"><span data-stu-id="93d50-285">Instead of generating random numbers to retrieve a card and tracking whether that card has already been dealt, you can create a parallel array of random numbers that can be used to sort the deck.</span></span> <span data-ttu-id="93d50-286">对卡片组进行排序后，你的应用程序可以维护一个指针来指示卡片上下一张卡片的索引。</span><span class="sxs-lookup"><span data-stu-id="93d50-286">Once the deck is sorted, your app can maintain a pointer to indicate the index of the next card on the deck.</span></span>  
  
 <span data-ttu-id="93d50-287">下面的示例阐释了这种方法。</span><span class="sxs-lookup"><span data-stu-id="93d50-287">The following example illustrates this approach.</span></span> <span data-ttu-id="93d50-288">它定义了一个 `Card` 类，该类表示一个纸牌，并使用一类 `Dealer` 类来处理有序的卡片。</span><span class="sxs-lookup"><span data-stu-id="93d50-288">It defines a `Card` class that represents a playing card and a `Dealer` class that deals a deck of shuffled cards.</span></span> <span data-ttu-id="93d50-289">`Dealer` 类构造函数填充了两个数组：一个 `deck` 数组，该类具有类范围并表示了卡片组中的所有卡片;和一个本地 `order` 数组，其元素数与 `deck` 数组的元素数相同，并使用随机生成的 <xref:System.Double> 值进行填充。</span><span class="sxs-lookup"><span data-stu-id="93d50-289">The `Dealer` class constructor populates two arrays: a `deck` array that has class scope and that represents all the cards in the deck; and a local `order` array that has the same number of elements as the `deck` array and is populated with randomly generated <xref:System.Double> values.</span></span>  <span data-ttu-id="93d50-290">然后调用 <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> 方法，根据 `order` 数组中的值对 `deck` 数组进行排序。</span><span class="sxs-lookup"><span data-stu-id="93d50-290">The <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> method is then called to sort the `deck` array based on the values in the `order` array.</span></span>  
  
 [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## Examples  
 <span data-ttu-id="93d50-291">下面的示例创建一个随机数生成器，并调用它的 <xref:System.Random.NextBytes%2A>、<xref:System.Random.Next%2A>和 <xref:System.Random.NextDouble%2A> 方法，以生成不同范围内的随机数序列。</span><span class="sxs-lookup"><span data-stu-id="93d50-291">The following example creates a single random number generator and calls its <xref:System.Random.NextBytes%2A>, <xref:System.Random.Next%2A>, and <xref:System.Random.NextDouble%2A> methods to generate sequences of random numbers within different ranges.</span></span>  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 <span data-ttu-id="93d50-292">下面的示例生成一个随机整数，该整数将用作索引以检索数组中的字符串值。</span><span class="sxs-lookup"><span data-stu-id="93d50-292">The following example generates a random integer that it uses as an index to retrieve a string value from an array.</span></span>  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para><span data-ttu-id="93d50-293">在 .NET Framework 1.0 和1.1 中，从 <see cref="T:System.Random" /> 派生的类的最小实现需要重写 <see cref="M:System.Random.Sample" /> 方法，以定义新的或修改的算法来生成随机数。</span><span class="sxs-lookup"><span data-stu-id="93d50-293">In the .NET Framework 1.0 and 1.1, a minimum implementation of a class derived from <see cref="T:System.Random" /> required overriding the <see cref="M:System.Random.Sample" /> method to define a new or modified algorithm for generating random numbers.</span></span> <span data-ttu-id="93d50-294">然后，派生类可以依赖于 <see cref="M:System.Random.Next" />、<see cref="M:System.Random.Next(System.Int32)" />、<see cref="M:System.Random.Next(System.Int32,System.Int32)" />、<see cref="M:System.Random.NextBytes(System.Byte[])" />和 <see cref="M:System.Random.NextDouble" /> 方法的基类实现来调用 <see cref="M:System.Random.Sample" /> 方法的派生类实现。</span><span class="sxs-lookup"><span data-stu-id="93d50-294">The derived class could then rely on the base class implementation of the <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32)" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.NextBytes(System.Byte[])" />, and <see cref="M:System.Random.NextDouble" /> methods to call the derived class implementation of the <see cref="M:System.Random.Sample" /> method.</span></span>  
  
<span data-ttu-id="93d50-295">在 .NET Framework 2.0 及更高版本中，<see cref="M:System.Random.Next" />、<see cref="M:System.Random.Next(System.Int32,System.Int32)" />和 <see cref="M:System.Random.NextBytes(System.Byte[])" /> 方法的行为已更改，因此这些方法不一定调用 <see cref="M:System.Random.Sample" /> 方法的派生类实现。</span><span class="sxs-lookup"><span data-stu-id="93d50-295">In the .NET Framework 2.0 and later, the behavior of the <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, and <see cref="M:System.Random.NextBytes(System.Byte[])" /> methods have changed so that these methods do not necessarily call the derived class implementation of the <see cref="M:System.Random.Sample" /> method.</span></span> <span data-ttu-id="93d50-296">因此，派生自面向 .NET Framework 2.0 及更高版本的 <see cref="T:System.Random" /> 的类也应重写这三个方法。</span><span class="sxs-lookup"><span data-stu-id="93d50-296">As a result, classes derived from <see cref="T:System.Random" /> that target the .NET Framework 2.0 and later should also override these three methods.</span></span></para></block>
    <block subset="none" type="usage"><para><span data-ttu-id="93d50-297">不保证 <see cref="T:System.Random" /> 类中随机数生成器的实现在 .NET Framework 的主要版本中保持不变。</span><span class="sxs-lookup"><span data-stu-id="93d50-297">The implementation of the random number generator in the <see cref="T:System.Random" /> class isn't guaranteed to remain the same across major versions of the .NET Framework.</span></span> <span data-ttu-id="93d50-298">因此，不应假定同一种子会导致在不同版本的 .NET Framework 中产生相同的伪随机序列。</span><span class="sxs-lookup"><span data-stu-id="93d50-298">As a result, you shouldn't assume that the same seed will result in the same pseudo-random sequence in different versions of the .NET Framework.</span></span></para></block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="93d50-299">初始化 <see cref="T:System.Random" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="93d50-299">Initializes a new instance of the <see cref="T:System.Random" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="93d50-300">使用与时间相关的默认种子值，初始化 <see cref="T:System.Random" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="93d50-300">Initializes a new instance of the <see cref="T:System.Random" /> class, using a time-dependent default seed value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="93d50-301">默认种子值派生自系统时钟，后者具有有限的分辨率。</span><span class="sxs-lookup"><span data-stu-id="93d50-301">The default seed value is derived from the system clock, which has finite resolution.</span></span> <span data-ttu-id="93d50-302">因此，仅在 .NET Framework 上，通过调用无参数构造函数来连续创建的不同 <xref:System.Random> 对象将具有相同的默认种子值，因此，将生成相同的随机数集。</span><span class="sxs-lookup"><span data-stu-id="93d50-302">As a result, on the .NET Framework only, different <xref:System.Random> objects that are created in close succession by a call to the parameterless constructor will have identical default seed values and, therefore, will produce identical sets of random numbers.</span></span> <span data-ttu-id="93d50-303">可以通过使用单个 <xref:System.Random> 对象生成所有随机数来避免此问题。</span><span class="sxs-lookup"><span data-stu-id="93d50-303">This problem can be avoided by using a single <xref:System.Random> object to generate all random numbers.</span></span> <span data-ttu-id="93d50-304">还可以通过生成自己的随机种子值并将其传递给 <xref:System.Random.%23ctor%28System.Int32%29> 构造函数来解决此情况。</span><span class="sxs-lookup"><span data-stu-id="93d50-304">You can also work around it by generating your own random seed value and passing it to the <xref:System.Random.%23ctor%28System.Int32%29> constructor.</span></span> <span data-ttu-id="93d50-305">有关详细信息，请参阅 <xref:System.Random.%23ctor%28System.Int32%29> 构造函数。</span><span class="sxs-lookup"><span data-stu-id="93d50-305">For more information, see the <xref:System.Random.%23ctor%28System.Int32%29> constructor.</span></span> <span data-ttu-id="93d50-306">请注意，此限制不适用于 .NET Core。</span><span class="sxs-lookup"><span data-stu-id="93d50-306">Note that this limitation does not apply to .NET Core.</span></span>  
  
 <span data-ttu-id="93d50-307">如果希望随机数生成器生成一系列随机数字，请调用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="93d50-307">Call this constructor if you want your random number generator to generate a random sequence of numbers.</span></span> <span data-ttu-id="93d50-308">若要生成与不同随机数生成器相同的固定随机数序列，请使用固定种子值调用 <xref:System.Random.%23ctor%28System.Int32%29> 构造函数。</span><span class="sxs-lookup"><span data-stu-id="93d50-308">To generate a fixed  sequence of random numbers that will be the same for different random number generators, call the <xref:System.Random.%23ctor%28System.Int32%29> constructor with a fixed seed value .</span></span> <span data-ttu-id="93d50-309">此 <xref:System.Random> 构造函数重载在测试使用随机数的应用时经常使用。</span><span class="sxs-lookup"><span data-stu-id="93d50-309">This <xref:System.Random> constructor overload is frequently used when testing apps that use random numbers.</span></span>  
  
 <span data-ttu-id="93d50-310">实例化随机数生成器后，可以调用单个 <xref:System.Random> 方法，如 <xref:System.Random.Next> 或 <xref:System.Random.NextDouble>，以生成随机数。</span><span class="sxs-lookup"><span data-stu-id="93d50-310">Once you've instantiated the random number generator, you call individual <xref:System.Random> methods, such as <xref:System.Random.Next> or <xref:System.Random.NextDouble>, to generate random numbers.</span></span>  
  
   
  
## Examples

<span data-ttu-id="93d50-311">下面的示例使用无参数构造函数实例化三个 <xref:System.Random> 对象，并为每个对象显示五个随机整数的序列。</span><span class="sxs-lookup"><span data-stu-id="93d50-311">The following example uses the parameterless constructor to instantiate three <xref:System.Random> objects and displays a sequence of five random integers for each.</span></span> <span data-ttu-id="93d50-312">如果它在 .NET Framework 上运行，因为前两个 <xref:System.Random> 对象是连续创建的，所以它们是使用基于系统时钟的相同种子值实例化的，因此它们生成相同的随机数序列。</span><span class="sxs-lookup"><span data-stu-id="93d50-312">If it is run on .NET Framework, because the first two <xref:System.Random> objects are created in close succession, they are instantiated using identical seed values based on the system clock and, therefore, they produce an identical sequence of random numbers.</span></span> <span data-ttu-id="93d50-313">另一方面，如果调用 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 方法导致两秒钟的延迟，则会调用第三个 <xref:System.Random> 对象的无参数构造函数。</span><span class="sxs-lookup"><span data-stu-id="93d50-313">On the other hand, the parameterless constructor of the third <xref:System.Random> object is called after a two-second delay caused by calling the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="93d50-314">因为这会为第三个 <xref:System.Random> 对象生成不同的种子值，所以它会产生不同的随机数字序列。</span><span class="sxs-lookup"><span data-stu-id="93d50-314">Because this produces a different seed value for the third <xref:System.Random> object, it produces a different sequence of random numbers.</span></span>  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed"><span data-ttu-id="93d50-315">用来计算伪随机数序列起始值的数字。</span><span class="sxs-lookup"><span data-stu-id="93d50-315">A number used to calculate a starting value for the pseudo-random number sequence.</span></span> <span data-ttu-id="93d50-316">如果指定的是负数，则使用其绝对值。</span><span class="sxs-lookup"><span data-stu-id="93d50-316">If a negative number is specified, the absolute value of the number is used.</span></span></param>
        <summary><span data-ttu-id="93d50-317">使用指定的种子值初始化 <see cref="T:System.Random" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="93d50-317">Initializes a new instance of the <see cref="T:System.Random" /> class, using the specified seed value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93d50-318">为不同的 <xref:System.Random> 对象提供完全相同的种子值会导致每个实例生成相同的随机数字序列。</span><span class="sxs-lookup"><span data-stu-id="93d50-318">Providing an identical seed value to different <xref:System.Random> objects causes each instance to produce identical sequences of random numbers.</span></span> <span data-ttu-id="93d50-319">这种情况通常在测试依赖随机数生成器的应用时完成。</span><span class="sxs-lookup"><span data-stu-id="93d50-319">This is often done when testing apps that rely on random number generators.</span></span>  
  
 <span data-ttu-id="93d50-320">如果应用程序需要不同的随机数序列，请用不同的种子值重复调用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="93d50-320">If your application requires different random number sequences, invoke this constructor repeatedly with different seed values.</span></span> <span data-ttu-id="93d50-321">生成唯一种子值的一种方法是使其与时间相关。</span><span class="sxs-lookup"><span data-stu-id="93d50-321">One way to produce a unique seed value is to make it time-dependent.</span></span> <span data-ttu-id="93d50-322">例如，从系统时钟派生种子值，因为 <xref:System.Random.%23ctor> 重载。</span><span class="sxs-lookup"><span data-stu-id="93d50-322">For example, derive the seed value from the system clock, as the <xref:System.Random.%23ctor> overload does.</span></span> <span data-ttu-id="93d50-323">但是，系统时钟可能没有足够的分辨率来为此构造函数提供不同的种子值调用。</span><span class="sxs-lookup"><span data-stu-id="93d50-323">However, the system clock might not have sufficient resolution to provide different invocations of this constructor with a different seed value.</span></span> <span data-ttu-id="93d50-324">在 .NET Framework 中，这会生成随机数字生成器，生成相同的伪随机数序列，如以下示例中的前两个 <xref:System.Random> 对象所示。</span><span class="sxs-lookup"><span data-stu-id="93d50-324">On the .NET Framework, this results in random number generators that generate identical sequences of pseudo-random numbers, as illustrated by the first two <xref:System.Random> objects in the following example.</span></span> <span data-ttu-id="93d50-325">若要防止出现这种情况，请应用一种算法来区分每个调用中的种子值，或调用 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 方法，以确保为每个构造函数提供不同的种子值。</span><span class="sxs-lookup"><span data-stu-id="93d50-325">To prevent this, apply an algorithm to differentiate the seed value in each invocation, or call the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to ensure that you provide each constructor with a different seed value.</span></span>  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 <span data-ttu-id="93d50-326">另一种方法是实例化单个 <xref:System.Random> 对象，该对象用于在应用程序中生成所有随机数。</span><span class="sxs-lookup"><span data-stu-id="93d50-326">Another option is to instantiate a single <xref:System.Random> object that you use to generate all the random numbers in your application.</span></span> <span data-ttu-id="93d50-327">这会产生略微改善的性能，因为实例化随机数生成器相当昂贵。</span><span class="sxs-lookup"><span data-stu-id="93d50-327">This yields slightly better performance, since instantiating a random number generator is fairly expensive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93d50-328">下面的示例使用使用 seed 参数的类构造函数创建 <xref:System.Random> 对象，并生成随机整数和双精度序列。</span><span class="sxs-lookup"><span data-stu-id="93d50-328">The following example creates <xref:System.Random> objects with the class constructor that takes a seed parameter and generates a sequence of random integers and doubles.</span></span> <span data-ttu-id="93d50-329">该示例演示了在用构造函数和 seed 参数再次创建 <xref:System.Random> 对象时生成相同的序列。</span><span class="sxs-lookup"><span data-stu-id="93d50-329">The example illustrates that the same sequence is generated when the <xref:System.Random> object is created again with the constructor and seed parameter.</span></span>  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="93d50-330">返回一个随机整数。</span><span class="sxs-lookup"><span data-stu-id="93d50-330">Returns a random integer.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="93d50-331">返回一个非负随机整数。</span><span class="sxs-lookup"><span data-stu-id="93d50-331">Returns a non-negative random integer.</span></span></summary>
        <returns><span data-ttu-id="93d50-332">大于或等于 0 且小于 <see cref="F:System.Int32.MaxValue" /> 的 32 位有符号整数。</span><span class="sxs-lookup"><span data-stu-id="93d50-332">A 32-bit signed integer that is greater than or equal to 0 and less than <see cref="F:System.Int32.MaxValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93d50-333"><xref:System.Random.Next%2A?displayProperty=nameWithType> 生成一个随机数值，其值范围为0到小于 <xref:System.Int32.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="93d50-333"><xref:System.Random.Next%2A?displayProperty=nameWithType> generates a random number whose value ranges from 0 to less than <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="93d50-334">若要生成其值范围从0到其他正数的随机数，请使用 <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> 方法重载。</span><span class="sxs-lookup"><span data-stu-id="93d50-334">To generate a random number whose value ranges from 0 to some other positive number, use the <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="93d50-335">若要在不同的范围内生成随机数字，请使用 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 方法重载。</span><span class="sxs-lookup"><span data-stu-id="93d50-335">To generate a random number within a different range, use the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93d50-336">下面的示例对 <xref:System.Random.Next%2A> 方法进行重复调用，以生成用户请求的特定数量的随机数字。</span><span class="sxs-lookup"><span data-stu-id="93d50-336">The following example makes repeated calls to the <xref:System.Random.Next%2A> method to generate a specific number of random numbers requested by the user.</span></span> <span data-ttu-id="93d50-337"><xref:System.Console.ReadLine%2A?displayProperty=nameWithType> 方法用于获取客户输入。</span><span class="sxs-lookup"><span data-stu-id="93d50-337">The <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> method is used to get customer input.</span></span>  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 <span data-ttu-id="93d50-338">下面的示例从 <xref:System.Random> 中派生一个类，以生成一个随机数序列，其分布不同于基类的 <xref:System.Random.Sample%2A> 方法所生成的统一分布。</span><span class="sxs-lookup"><span data-stu-id="93d50-338">The following example derives a class from <xref:System.Random> to generate a sequence of random numbers whose distribution differs from the uniform distribution generated by the <xref:System.Random.Sample%2A> method of the base class.</span></span> <span data-ttu-id="93d50-339">它重写 <xref:System.Random.Sample%2A> 方法以提供随机数的分布，并重写 <xref:System.Random.Next%2A?displayProperty=nameWithType> 方法以使用一系列随机数。</span><span class="sxs-lookup"><span data-stu-id="93d50-339">It overrides the <xref:System.Random.Sample%2A> method to provide the distribution of random numbers, and overrides the <xref:System.Random.Next%2A?displayProperty=nameWithType> method to use series of random numbers.</span></span>  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="93d50-340">从 .NET Framework 版本2.0 开始，如果从 <see cref="T:System.Random" /> 派生一个类并重写 <see cref="M:System.Random.Sample" /> 方法，则不会在对 <see cref="M:System.Random.Next" /> 该方法的基类实现的调用中使用 <see cref="M:System.Random.Sample" /> 方法的派生类实现提供的分布。</span><span class="sxs-lookup"><span data-stu-id="93d50-340">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the <see cref="M:System.Random.Next" /> method.</span></span> <span data-ttu-id="93d50-341">相反，将使用基 <see cref="T:System.Random" /> 类返回的统一分布。</span><span class="sxs-lookup"><span data-stu-id="93d50-341">Instead, the uniform distribution returned by the base <see cref="T:System.Random" /> class is used.</span></span> <span data-ttu-id="93d50-342">此行为可提高 <see cref="T:System.Random" /> 类的整体性能。</span><span class="sxs-lookup"><span data-stu-id="93d50-342">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span></span> <span data-ttu-id="93d50-343">若要修改此行为以调用派生类中的 <see cref="M:System.Random.Sample" /> 方法，还必须重写 <see cref="M:System.Random.Next" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="93d50-343">To modify this behavior to call the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the <see cref="M:System.Random.Next" /> method.</span></span></para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue"><span data-ttu-id="93d50-344">要生成的随机数的上限（随机数不能取该上限值）。</span><span class="sxs-lookup"><span data-stu-id="93d50-344">The exclusive upper bound of the random number to be generated.</span></span> <span data-ttu-id="93d50-345"><paramref name="maxValue" /> 必须大于或等于 0。</span><span class="sxs-lookup"><span data-stu-id="93d50-345"><paramref name="maxValue" /> must be greater than or equal to 0.</span></span></param>
        <summary><span data-ttu-id="93d50-346">返回一个小于所指定最大值的非负随机整数。</span><span class="sxs-lookup"><span data-stu-id="93d50-346">Returns a non-negative random integer that is less than the specified maximum.</span></span></summary>
        <returns><span data-ttu-id="93d50-347">大于或等于零且小于 <paramref name="maxValue" /> 的 32 位有符号整数，即：返回值的范围通常包括零但不包括 <paramref name="maxValue" />。</span><span class="sxs-lookup"><span data-stu-id="93d50-347">A 32-bit signed integer that is greater than or equal to 0, and less than <paramref name="maxValue" />; that is, the range of return values ordinarily includes 0 but not <paramref name="maxValue" />.</span></span> <span data-ttu-id="93d50-348">但是，如果 <paramref name="maxValue" /> 等于 0，则返回 <paramref name="maxValue" />。</span><span class="sxs-lookup"><span data-stu-id="93d50-348">However, if <paramref name="maxValue" /> equals 0, <paramref name="maxValue" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93d50-349"><xref:System.Random.Next%28System.Int32%29> 重载返回介于0到 `maxValue`-1 之间的随机整数。</span><span class="sxs-lookup"><span data-stu-id="93d50-349">The <xref:System.Random.Next%28System.Int32%29> overload returns random integers that range from 0 to `maxValue` - 1.</span></span> <span data-ttu-id="93d50-350">但是，如果 `maxValue` 是0，则该方法返回0。</span><span class="sxs-lookup"><span data-stu-id="93d50-350">However, if `maxValue` is 0, the method returns 0.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93d50-351">下面的示例将生成具有 <xref:System.Random.Next%2A> 方法的各种重载的随机整数。</span><span class="sxs-lookup"><span data-stu-id="93d50-351">The following example generates random integers with various overloads of the <xref:System.Random.Next%2A> method.</span></span>  
  
 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 <span data-ttu-id="93d50-352">下面的示例生成一个随机整数，该整数将用作索引以检索数组中的字符串值。</span><span class="sxs-lookup"><span data-stu-id="93d50-352">The following example generates a random integer that it uses as an index to retrieve a string value from an array.</span></span> <span data-ttu-id="93d50-353">由于数组的最高索引小于其长度，因此 <xref:System.Array.Length%2A?displayProperty=nameWithType> 属性的值以 `maxValue` 参数的形式提供。</span><span class="sxs-lookup"><span data-stu-id="93d50-353">Because the highest index of the array is one less than its length, the value of the <xref:System.Array.Length%2A?displayProperty=nameWithType> property is supplied as a the `maxValue` parameter.</span></span>  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="93d50-354"><paramref name="maxValue" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="93d50-354"><paramref name="maxValue" /> is less than 0.</span></span></exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue"><span data-ttu-id="93d50-355">返回的随机数的下界（随机数可取该下界值）。</span><span class="sxs-lookup"><span data-stu-id="93d50-355">The inclusive lower bound of the random number returned.</span></span></param>
        <param name="maxValue"><span data-ttu-id="93d50-356">返回的随机数的上界（随机数不能取该上界值）。</span><span class="sxs-lookup"><span data-stu-id="93d50-356">The exclusive upper bound of the random number returned.</span></span> <span data-ttu-id="93d50-357"><paramref name="maxValue" /> 必须大于或等于 <paramref name="minValue" />。</span><span class="sxs-lookup"><span data-stu-id="93d50-357"><paramref name="maxValue" /> must be greater than or equal to <paramref name="minValue" />.</span></span></param>
        <summary><span data-ttu-id="93d50-358">返回在指定范围内的任意整数。</span><span class="sxs-lookup"><span data-stu-id="93d50-358">Returns a random integer that is within a specified range.</span></span></summary>
        <returns><span data-ttu-id="93d50-359">一个大于等于 <paramref name="minValue" /> 且小于 <paramref name="maxValue" /> 的 32 位带符号整数，即：返回的值范围包括 <paramref name="minValue" /> 但不包括 <paramref name="maxValue" />。</span><span class="sxs-lookup"><span data-stu-id="93d50-359">A 32-bit signed integer greater than or equal to <paramref name="minValue" /> and less than <paramref name="maxValue" />; that is, the range of return values includes <paramref name="minValue" /> but not <paramref name="maxValue" />.</span></span> <span data-ttu-id="93d50-360">如果 <paramref name="minValue" /> 等于 <paramref name="maxValue" />，则返回 <paramref name="minValue" />。</span><span class="sxs-lookup"><span data-stu-id="93d50-360">If <paramref name="minValue" /> equals <paramref name="maxValue" />, <paramref name="minValue" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93d50-361"><xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 重载返回从 `minValue` 到 `maxValue` 的随机整数。</span><span class="sxs-lookup"><span data-stu-id="93d50-361">The <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> overload returns random integers that range from `minValue` to `maxValue` - 1.</span></span> <span data-ttu-id="93d50-362">但是，如果 `maxValue` 等于 `minValue`，则该方法返回 `minValue`。</span><span class="sxs-lookup"><span data-stu-id="93d50-362">However, if `maxValue` equals `minValue`, the method returns `minValue`.</span></span>  
  
 <span data-ttu-id="93d50-363">与 <xref:System.Random.Next%2A> 方法的其他重载不同，此方法仅返回非负值，此方法可以返回负随机整数。</span><span class="sxs-lookup"><span data-stu-id="93d50-363">Unlike the other overloads of the <xref:System.Random.Next%2A> method, which return only non-negative values, this method can return a negative random integer.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93d50-364">下面的示例使用 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 方法生成具有三个不同范围的随机整数。</span><span class="sxs-lookup"><span data-stu-id="93d50-364">The following example uses the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to generate random integers with three distinct ranges.</span></span> <span data-ttu-id="93d50-365">请注意，该示例的确切输出取决于传递到 <xref:System.Random> 类构造函数的系统提供的种子值。</span><span class="sxs-lookup"><span data-stu-id="93d50-365">Note that the exact output from the example depends on the system-supplied seed value passed to the <xref:System.Random> class constructor.</span></span>  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 <span data-ttu-id="93d50-366">下面的示例生成一个随机整数，该整数将用作索引以检索数组中的字符串值。</span><span class="sxs-lookup"><span data-stu-id="93d50-366">The following example generates a random integer that it uses as an index to retrieve a string value from an array.</span></span> <span data-ttu-id="93d50-367">由于数组的最高索引小于其长度，因此 <xref:System.Array.Length%2A?displayProperty=nameWithType> 属性的值以 `maxValue` 参数的形式提供。</span><span class="sxs-lookup"><span data-stu-id="93d50-367">Because the highest index of the array is one less than its length, the value of the <xref:System.Array.Length%2A?displayProperty=nameWithType> property is supplied as a the `maxValue` parameter.</span></span>  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="93d50-368"><paramref name="minValue" /> 大于 <paramref name="maxValue" />。</span><span class="sxs-lookup"><span data-stu-id="93d50-368"><paramref name="minValue" /> is greater than <paramref name="maxValue" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="93d50-369">从 .NET Framework 版本2.0 开始，如果从 <see cref="T:System.Random" /> 派生一个类并重写 <see cref="M:System.Random.Sample" /> 方法，则如果 <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> 和 <paramref name="minValue" /> 参数之间的差异大于 <paramref name="maxValue" />，则不会在对 <see cref="F:System.Int32.MaxValue" />方法重载的基类实现的调用中使用 <see cref="M:System.Random.Sample" /> 方法的派生类实现时所提供的分布。</span><span class="sxs-lookup"><span data-stu-id="93d50-369">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> method overload if the difference between the <paramref name="minValue" /> and <paramref name="maxValue" /> parameters is greater than <see cref="F:System.Int32.MaxValue" />.</span></span> <span data-ttu-id="93d50-370">相反，将使用基 <see cref="T:System.Random" /> 类返回的统一分布。</span><span class="sxs-lookup"><span data-stu-id="93d50-370">Instead, the uniform distribution returned by the base <see cref="T:System.Random" /> class is used.</span></span> <span data-ttu-id="93d50-371">此行为可提高 <see cref="T:System.Random" /> 类的整体性能。</span><span class="sxs-lookup"><span data-stu-id="93d50-371">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span></span> <span data-ttu-id="93d50-372">若要修改此行为以调用派生类中的 <see cref="M:System.Random.Sample" /> 方法，还必须重写 <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> 方法重载。</span><span class="sxs-lookup"><span data-stu-id="93d50-372">To modify this behavior to call the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> method overload.</span></span></para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="93d50-373">要用随机数填充的数组。</span><span class="sxs-lookup"><span data-stu-id="93d50-373">The array to be filled with random numbers.</span></span></param>
        <summary><span data-ttu-id="93d50-374">用随机数填充指定字节数组的元素。</span><span class="sxs-lookup"><span data-stu-id="93d50-374">Fills the elements of a specified array of bytes with random numbers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93d50-375">字节数组的每个元素都设置为一个大于或等于0且小于或等于 <xref:System.Byte.MaxValue>的随机数。</span><span class="sxs-lookup"><span data-stu-id="93d50-375">Each element of the array of bytes is set to a random number greater than or equal to 0, and less than or equal to <xref:System.Byte.MaxValue>.</span></span>  
  
 <span data-ttu-id="93d50-376">例如，若要生成适用于创建随机密码的加密安全随机数字，请使用诸如 <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>的方法。</span><span class="sxs-lookup"><span data-stu-id="93d50-376">For example, to generate a cryptographically secured random number suitable for creating a random password, use a method such as <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93d50-377">下面的示例演示如何使用 <xref:System.Random.NextBytes%2A> 方法来使用随机字节值填充字节数组。</span><span class="sxs-lookup"><span data-stu-id="93d50-377">The following example demonstrates how to use the <xref:System.Random.NextBytes%2A> method to fill an array of bytes with random byte values.</span></span>  
  
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="93d50-378"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="93d50-378"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="93d50-379">从 .NET Framework 版本2.0 开始，如果从 <see cref="T:System.Random" /> 派生一个类并重写 <see cref="M:System.Random.Sample" /> 方法，则不会在对 <see cref="M:System.Random.NextBytes(System.Byte[])" /> 该方法的基类实现的调用中使用 <see cref="M:System.Random.Sample" /> 方法的派生类实现提供的分布。</span><span class="sxs-lookup"><span data-stu-id="93d50-379">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the <see cref="M:System.Random.NextBytes(System.Byte[])" /> method.</span></span> <span data-ttu-id="93d50-380">相反，将使用基 <see cref="T:System.Random" /> 类返回的统一分布。</span><span class="sxs-lookup"><span data-stu-id="93d50-380">Instead, the uniform distribution returned by the base <see cref="T:System.Random" /> class is used.</span></span> <span data-ttu-id="93d50-381">此行为可提高 <see cref="T:System.Random" /> 类的整体性能。</span><span class="sxs-lookup"><span data-stu-id="93d50-381">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span></span> <span data-ttu-id="93d50-382">若要修改此行为以调用派生类中的 <see cref="M:System.Random.Sample" /> 方法，还必须重写 <see cref="M:System.Random.NextBytes(System.Byte[])" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="93d50-382">To modify this behavior to call the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the <see cref="M:System.Random.NextBytes(System.Byte[])" /> method.</span></span></para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="93d50-383">要用随机数填充的数组。</span><span class="sxs-lookup"><span data-stu-id="93d50-383">The array to be filled with random numbers.</span></span></param>
        <summary><span data-ttu-id="93d50-384">用随机数填充指定字节范围的元素。</span><span class="sxs-lookup"><span data-stu-id="93d50-384">Fills the elements of a specified span of bytes with random numbers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="93d50-385">字节跨度的每个元素都设置为一个大于或等于0且小于或等于 <xref:System.Byte.MaxValue>的随机数。</span><span class="sxs-lookup"><span data-stu-id="93d50-385">Each element of the span of bytes is set to a random number greater than or equal to 0 and less than or equal to <xref:System.Byte.MaxValue>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="93d50-386">返回一个大于或等于 0.0 且小于 1.0 的随机浮点数。</span><span class="sxs-lookup"><span data-stu-id="93d50-386">Returns a random floating-point number that is greater than or equal to 0.0, and less than 1.0.</span></span></summary>
        <returns><span data-ttu-id="93d50-387">大于或等于 0.0 且小于 1.0 的双精度浮点数。</span><span class="sxs-lookup"><span data-stu-id="93d50-387">A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93d50-388">此方法返回的随机数的实际上限为0.99999999999999978。</span><span class="sxs-lookup"><span data-stu-id="93d50-388">The actual upper bound of the random number returned by this method is 0.99999999999999978.</span></span>  
  
 <span data-ttu-id="93d50-389">若要在0.0 和1.0 以外的范围内检索随机浮点值，请参阅 <xref:System.Random> 类主题的 "在指定范围内检索浮点值" 部分。</span><span class="sxs-lookup"><span data-stu-id="93d50-389">To retrieve random floating-point values within a range other than 0.0 and 1.0, see the "Retrieve floating-point values in a specified range" section of the <xref:System.Random> class topic.</span></span>  
  
 <span data-ttu-id="93d50-390">此方法是受保护方法的公共版本，<xref:System.Random.Sample%2A>。</span><span class="sxs-lookup"><span data-stu-id="93d50-390">This method is the public version of the protected method, <xref:System.Random.Sample%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93d50-391">下面的示例使用 <xref:System.Random.NextDouble%2A> 方法来生成随机双精度序列。</span><span class="sxs-lookup"><span data-stu-id="93d50-391">The following example uses the <xref:System.Random.NextDouble%2A> method to generate sequences of random doubles.</span></span>  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 <span data-ttu-id="93d50-392">下面的示例调用 <xref:System.Random.NextDouble%2A> 方法来生成100的随机数，并显示它们的频率分布。</span><span class="sxs-lookup"><span data-stu-id="93d50-392">The following example calls the <xref:System.Random.NextDouble%2A> method to generate 100 random numbers and displays their frequency distribution.</span></span>  
  
 [!code-csharp[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="93d50-393">返回一个介于 0.0 和 1.0 之间的随机浮点数。</span><span class="sxs-lookup"><span data-stu-id="93d50-393">Returns a random floating-point number between 0.0 and 1.0.</span></span></summary>
        <returns><span data-ttu-id="93d50-394">大于或等于 0.0 且小于 1.0 的双精度浮点数。</span><span class="sxs-lookup"><span data-stu-id="93d50-394">A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93d50-395">若要生成不同的随机分发或不同的随机数生成器原则，请从 <xref:System.Random> 类中派生一个类，并重写 <xref:System.Random.Sample%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="93d50-395">To produce a different random distribution or a different random number generator principle, derive a class from the <xref:System.Random> class and override the <xref:System.Random.Sample%2A> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="93d50-396">`protected`<xref:System.Random.Sample%2A> 方法，这意味着只能在 <xref:System.Random> 类及其派生类中访问此方法。</span><span class="sxs-lookup"><span data-stu-id="93d50-396">The <xref:System.Random.Sample%2A> method is `protected`, which means that it is accessible only within the <xref:System.Random> class and its derived classes.</span></span> <span data-ttu-id="93d50-397">若要从 <xref:System.Random> 实例生成0到1之间的随机数字，请调用 <xref:System.Random.NextDouble%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="93d50-397">To generate a random number between 0 and 1 from a <xref:System.Random> instance, call the <xref:System.Random.NextDouble%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93d50-398">下面的示例从 <xref:System.Random> 派生一个类，并重写 <xref:System.Random.Sample%2A> 方法以生成随机数的分布。</span><span class="sxs-lookup"><span data-stu-id="93d50-398">The following example derives a class from <xref:System.Random> and overrides the <xref:System.Random.Sample%2A> method to generate a distribution of random numbers.</span></span> <span data-ttu-id="93d50-399">此分布不同于基类的 <xref:System.Random.Sample%2A> 方法生成的统一分布。</span><span class="sxs-lookup"><span data-stu-id="93d50-399">This distribution is different than the uniform distribution generated by the <xref:System.Random.Sample%2A> method of the base class.</span></span>  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="93d50-400">从 .NET Framework 版本2.0 开始，如果从 <see cref="T:System.Random" /> 派生一个类并重写 <see cref="M:System.Random.Sample" /> 方法，则不会在调用以下方法的基类实现时使用 <see cref="M:System.Random.Sample" /> 方法的派生类实现提供的分布：</span><span class="sxs-lookup"><span data-stu-id="93d50-400">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the following methods:</span></span> 
<span data-ttu-id="93d50-401">-   <see cref="M:System.Random.NextBytes(System.Byte[])" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="93d50-401">-   The <see cref="M:System.Random.NextBytes(System.Byte[])" /> method.</span></span>  
  
<span data-ttu-id="93d50-402">-   <see cref="M:System.Random.Next" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="93d50-402">-   The <see cref="M:System.Random.Next" /> method.</span></span>  
  
<span data-ttu-id="93d50-403">-<see cref="M:System.Random.Next(System.Int32,System.Int32)" /> 方法（如果为（<paramref name="maxValue" /> - <paramref name="minValue" />）大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="93d50-403">-   The <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> method, if (<paramref name="maxValue" /> - <paramref name="minValue" />) is greater than <see cref="F:System.Int32.MaxValue" />.</span></span>  
  
<span data-ttu-id="93d50-404">相反，将使用基 <see cref="T:System.Random" /> 类提供的统一分布。</span><span class="sxs-lookup"><span data-stu-id="93d50-404">Instead, the uniform distribution provided by the base <see cref="T:System.Random" /> class is used.</span></span> <span data-ttu-id="93d50-405">此行为可提高 <see cref="T:System.Random" /> 类的整体性能。</span><span class="sxs-lookup"><span data-stu-id="93d50-405">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span></span> <span data-ttu-id="93d50-406">若要修改此行为以调用派生类中 <see cref="M:System.Random.Sample" /> 方法的实现，还必须重写这三个成员的行为。</span><span class="sxs-lookup"><span data-stu-id="93d50-406">To modify this behavior to call the implementation of the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the behavior of these three members.</span></span> <span data-ttu-id="93d50-407">说明如示例所示。</span><span class="sxs-lookup"><span data-stu-id="93d50-407">The example provides an illustration.</span></span></para></block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>
