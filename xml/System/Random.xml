<Type Name="Random" FullName="System.Random">
  <Metadata><Meta Name="ms.openlocfilehash" Value="916c65c91bc8149c39c4b831ff081c57573e821e" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86600884" /></Metadata><TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Random extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime.Extensions" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Runtime.Extensions" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示伪随机数生成器，这是一种能够产生满足某些随机性统计要求的数字序列的算法。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 伪随机数的选择与有限的一组数字相同。 选择的数字不是完全随机的，因为使用数学算法来选择它们，但它们在实际情况下是完全随机的。 类的当前实现 <xref:System.Random> 基于 Donald Knuth 的 subtractive 随机数生成器算法的修改版本。 有关详细信息，请参阅 d。 Knuth. *计算机编程（卷2： Seminumerical 算法）的艺术*。 Addison-Wesley，读取，MA，第三版，1997。  
  
 若要生成加密的安全随机数（如适合创建随机密码的随机数），请使用 <xref:System.Security.Cryptography.RNGCryptoServiceProvider> 类或从派生类 <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType> 。  
  
 本主题内容：  
  
 [实例化随机数生成器](#Instantiate)   
 [避免多个实例化](#Multiple)   
 [System.web 类和线程安全](#ThreadSafety)   
 [生成不同类型的随机数](#Functionality)   
 [替换自己的算法](#Overriding)   
 [如何使用 "系统随机 ..."](#Operations)   
 [检索相同的随机值序列](#Same)  
 [检索随机值的唯一序列](#Unique)  
 [检索指定范围内的整数](#Range)  
 [检索指定位数的整数](#Digits)  
 [检索指定范围内的浮点值](#Floats)  
 [生成随机布尔值](#Boolean)  
 [生成随机的64位整数](#Long)  
 [检索指定范围内的字节](#Bytes)  
 [随机检索数组或集合中的元素](#Array)  
 [从数组或集合中检索唯一元素](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a>实例化随机数生成器  
 通过向类构造函数提供) 伪随机数生成算法开始值 (的种子值来实例化随机数生成器 <xref:System.Random.%23ctor%2A> 。  可以显式或隐式提供种子值：  
  
-   <xref:System.Random.%23ctor%28System.Int32%29>构造函数使用您提供的显式种子值。  
  
-   <xref:System.Random.%23ctor>构造函数使用默认种子值。 这是实例化随机数生成器最常见的方法。  
  
 在 .NET Framework 中，默认种子值取决于时间。 在 .NET Core 中，默认种子值由线程静态伪随机数生成器生成。
  
 如果对单独的对象使用相同的种子 <xref:System.Random> ，则它们将生成相同的随机数字序列。 这对于创建处理随机值的测试套件或用于重放从随机数派生其数据的游戏很有用。 但请注意， <xref:System.Random> 在不同版本的 .NET Framework 下运行的进程中的对象可能返回不同序列的随机数字，即使它们是用相同的种子值实例化的，也是如此。  
  
 若要生成不同的随机数序列，可以使种子值依赖于时间，从而使用的每个新实例生成不同的序列 <xref:System.Random> 。 参数化 <xref:System.Random.%23ctor%28System.Int32%29> 构造函数可以根据 <xref:System.Int32> 当前时间中的计时周期数来获取值，而无参数 <xref:System.Random.%23ctor> 构造函数使用系统时钟生成其种子值。 但是，仅在 .NET Framework 上，由于时钟具有有限的分辨率，因此使用无参数构造函数来连续创建不同的 <xref:System.Random> 对象会创建随机数字生成器，这些生成器生成相同的随机数序列。 下面的示例演示如何 <xref:System.Random> 在 .NET Framework 应用程序中连续实例化的两个对象生成相同的随机数序列。 在大多数 Windows 系统上，在 <xref:System.Random> 15 毫秒内创建的对象有可能具有相同的种子值。  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp-interactive[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
若要避免此问题，请创建单个 <xref:System.Random> 对象，而不是多个对象。 请注意， `Random` .Net Core 中的类没有此限制。
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a>避免多个实例化  
 在 .NET Framework 上，在紧凑循环中初始化两个随机数生成器，或在快速连续创建两个随机数生成器，它们可以生成相同的随机数序列。 在大多数情况下，这并不是开发人员的意图，可能会导致性能问题，因为实例化和初始化随机数生成器的过程相对较高。  
  
 若要提高性能，并避免无意中创建生成相同数值序列的单独随机数生成器，建议您创建一个 <xref:System.Random> 对象，以便在一段时间内生成许多随机数，而不是创建新的 <xref:System.Random> 对象以生成一个随机数。  
  
 但是， <xref:System.Random> 该类不是线程安全的。 如果 <xref:System.Random> 从多个线程调用方法，请遵循下一节中所述的准则。  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a>System.web 类和线程安全  
 <xref:System.Random>建议您创建一个 <xref:System.Random> 实例来生成应用程序所需的所有随机数，而不是实例化单个对象。 但是， <xref:System.Random> 对象不是线程安全的。 如果你的应用程序 <xref:System.Random> 从多个线程调用方法，则必须使用同步对象来确保每次只有一个线程可以访问随机数生成器。 如果不确保以 <xref:System.Random> 线程安全的方式访问对象，则调用返回随机数的方法将返回0。  
  
 下面的示例使用 c # [Lock 语句](/dotnet/csharp/language-reference/keywords/lock-statement) 和 Visual Basic [SyncLock 语句](/dotnet/visual-basic/language-reference/statements/synclock-statement) 来确保11个线程以线程安全的方式访问单个随机数生成器。 每个线程都会生成2000000的随机数字，计算生成的随机数数并计算它们的总和，然后在完成执行后更新所有线程的总数。  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 该示例通过以下方式确保线程安全：  
  
-   <xref:System.ThreadStaticAttribute>特性用于定义线程本地变量，这些变量跟踪每个线程生成的随机数总数及其总和。  
  
-   Lock (`lock` c # 中的语句和 `SyncLock` Visual Basic) 中的语句，来保护对所有线程上生成的所有随机数的总数和总和的变量的访问。  
  
-   使用对象) 的信号量 (， <xref:System.Threading.CountdownEvent> 以确保在所有其他线程都完成执行之前，主线程阻塞。  
  
-   该示例通过确定两次对随机数生成方法的连续调用是否返回0来检查随机数生成器是否已损坏。 如果检测到损坏，此示例将使用 <xref:System.Threading.CancellationTokenSource> 对象来指示应取消所有线程。  
  
-   在生成每个随机数之前，每个线程都会检查对象的状态 <xref:System.Threading.CancellationToken> 。 如果请求取消，则该示例调用 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> 方法来取消线程。  
  
 下面的示例与第一个示例相同，只不过它使用 <xref:System.Threading.Tasks.Task> 对象和 lambda 表达式而不是 <xref:System.Threading.Thread> 对象。  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 它与第一个示例在以下方面有所不同：  
  
-   用于跟踪生成的随机数数量及其在每个任务中的总和的变量对于任务而言是本地的，因此无需使用 <xref:System.ThreadStaticAttribute> 特性。  
  
-   静态 <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> 方法用于确保主线程在所有任务完成之前未完成。 不需要 <xref:System.Threading.CountdownEvent> 对象。  
  
-   任务取消导致的异常在方法中出现 <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> 。 在上面的示例中，它由每个线程处理。  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a>生成不同类型的随机数  
 随机数生成器提供了一些方法，使您可以生成以下类型的随机数：  
  
-   一系列 <xref:System.Byte> 值。 通过将初始化为要方法返回给方法的元素数的数组，来确定字节值的数目 <xref:System.Random.NextBytes%2A> 。 下面的示例生成20个字节。  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp-interactive[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   一个整数。 您可以通过调用方法，选择是否希望从0到最大值 (-1) 的整数，或者通过调用方法，从 <xref:System.Int32.MaxValue?displayProperty=nameWithType> <xref:System.Random.Next> 0 到指定值之间的整数， <xref:System.Random.Next%28System.Int32%29> 或者通过调用方法来选择值范围内的整数 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 。 在参数化重载中，指定的最大值是独占的;也就是说，生成的实际最大数目小于指定值。  
  
     下面的示例调用 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 方法以在-10 和10之间生成10个随机数。 请注意，方法的第二个参数指定方法返回的随机值的范围的上限。 换言之，该方法可以返回的最大整数是小于此值的整数。  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp-interactive[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   通过调用方法，从0.0 到小于1.0 的单个浮点值 <xref:System.Random.NextDouble%2A> 。 方法返回的随机数的上限上限为1，因此它的实际上限为0.99999999999999978。 下面的示例生成10个随机浮点数。  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp-interactive[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>方法允许您指定返回的随机数的范围。 但是， `maxValue` 用于指定上限返回数字的参数是一个独占的，而不是包含的值。 这意味着方法调用 `Next(0, 100)` 返回0到99之间的值，而不是介于0和100之间。  
  
 你还可以使用 <xref:System.Random> 类来执行此类任务，如生成随机的维 [值](#Boolean)、生成随机 [浮点值（范围不是0到 1](#Floats)）、生成 [随机64位整数](#Long)以及 [从数组或集合中随机检索唯一元素](#UniqueArray)。 对于这些任务和其他常见任务，请参阅 [如何使用系统](#Operations) 部分。  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a>替换自己的算法  
 可以通过从 <xref:System.Random> 类继承并提供随机数生成算法来实现自己的随机数生成器。 若要提供自己的算法，必须重写 <xref:System.Random.Sample%2A> 实现随机数生成算法的方法。 还应重写 <xref:System.Random.Next> 、 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 和方法， <xref:System.Random.NextBytes%2A> 以确保它们调用重写的 <xref:System.Random.Sample%2A> 方法。 不需要重写 <xref:System.Random.Next%28System.Int32%29> 和 <xref:System.Random.NextDouble%2A> 方法。  
  
 有关从 <xref:System.Random> 类派生并修改其默认伪随机数生成器的示例，请参阅 <xref:System.Random.Sample%2A> 引用页。  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a>如何使用 "系统随机 ..."  
 以下部分讨论并为你可能想要在应用程序中使用随机数的一些方式提供示例代码。  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a>检索相同的随机值序列  
 有时，您想要在软件测试方案和游戏游戏中生成相同的随机数字序列。 用相同的随机数序列进行测试，可以检测回归和确认 bug 修复。 在游戏中使用相同的随机数字序列可重播以前的游戏。  
  
 可以通过向构造函数提供相同的种子值，生成相同的随机数字序列 <xref:System.Random.%23ctor%28System.Int32%29> 。 种子值为伪随机数生成算法提供起始值。 下面的示例使用100100作为用于实例化对象的任意种子值 <xref:System.Random> ，显示20个随机浮点值，并保留种子值。 然后，它将还原种子值，实例化新的随机数生成器，并显示相同的20个随机浮点值。  请注意，如果在 .NET Framework 的不同版本上运行，则该示例可能生成不同的随机数字序列。  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs" interactive="try-dotnet" id="Snippet12":::
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp" id="Snippet12":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb" id="Snippet12":::
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a>检索随机数的唯一序列  
 向类的实例提供不同的种子值 <xref:System.Random> 会导致每个随机数生成器生成不同的值序列。 可以通过调用 <xref:System.Random.%23ctor%28System.Int32%29> 构造函数或通过调用构造函数隐式地提供种子值 <xref:System.Random.%23ctor> 。 大多数开发人员调用使用系统时钟的无参数构造函数。 下面的示例使用此方法实例化两个 <xref:System.Random> 实例。 每个实例都显示一系列10个随机整数。  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp" id="Snippet13":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs" interactive="try-dotnet" id="Snippet13":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb" id="Snippet13":::

 但是，由于其有限的解决方法，系统时钟不会检测到大约15毫秒的时间差异。 因此，如果你的代码调用 <xref:System.Random.%23ctor> .NET Framework 上的重载来连续实例化两个 <xref:System.Random> 对象，则可能会无意中提供具有相同种子值的对象。  (<xref:System.Random> .Net Core 中的类不存在此限制。 ) 在前面的示例中，请注释掉 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 方法调用，然后再次编译并运行该示例。  
  
 为了防止发生这种情况，我们建议您实例化单个 <xref:System.Random> 对象，而不是多个对象。 但是，由于 <xref:System.Random> 不是线程安全的，因此，如果从多个线程访问实例，则必须使用某个同步设备 <xref:System.Random> ; 有关详细信息，请参阅本主题前面 [的随机类和线程安全](#ThreadSafety) 。 另外，还可以使用延迟机制（例如 <xref:System.Threading.Thread.Sleep%2A> 上一示例中使用的方法），以确保实例化的时间间隔超过15毫秒。  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a>检索指定范围内的整数  
 您可以通过调用方法来检索指定范围内的整数 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> ，这允许您指定要随机数生成器返回的数字的下限和上限。 上限是专用的，而不是包含的值。 也就是说，它不包含在由方法返回的值范围内。 下面的示例使用此方法生成介于-10 和10之间的随机整数。 请注意，它指定11，它比所需的值大1，作为 `maxValue` 方法调用中的参数的值。  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp-interactive[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a>检索指定位数的整数  
 可以调用 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 方法来检索具有指定位数的数字。 例如，若要检索具有四位数的数字 (即，范围为1000到 9999) ，请调用 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 方法，值为1000， `minValue` 值为 `maxValue` 10000，如下面的示例所示。  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp-interactive[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a>检索指定范围内的浮点值  
 <xref:System.Random.NextDouble%2A>方法返回介于0到小于1之间的随机浮点值。 但是，您通常需要在其他某个范围内生成随机值。  
  
 如果所需的最小值和最大值之间的间隔为1，则可以将所需起始间隔和0之间的差值添加到该方法返回的数字 <xref:System.Random.NextDouble%2A> 。 下面的示例将生成10个介于-1 和0之间的随机数。  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp-interactive[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 若要生成其下限为0但上限大于 1 (的随机浮点数，或在负数的情况下，其下限小于-1 且上限为 0) ，则将随机数乘以非零界限。 下面的示例将生成20000000随机浮点数，范围为0到 <xref:System.Int64.MaxValue?displayProperty=nameWithType> 。 中的还显示方法所生成的随机值的分布。  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp-interactive[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 若要在两个任意值之间生成随机浮点数，如 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 方法对整数执行运算，请使用以下公式：  
  
```csharp  
Random.NextDouble() * (maxValue - minValue) + minValue  
```  
  
 下面的示例生成1000000到11.0 范围10.0 内的随机数字，并显示其分布。  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp-interactive[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a>生成随机布尔值  
 <xref:System.Random>类不提供用于生成值的方法 <xref:System.Boolean> 。 但是，您可以定义自己的类或方法来执行此操作。 下面的示例定义了一个 `BooleanGenerator` 具有单个方法的类 `NextBoolean` 。 `BooleanGenerator`类将对象存储 <xref:System.Random> 为私有变量。 `NextBoolean`方法调用 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 方法，并将结果传递给 <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> 方法。 请注意，使用2作为参数来指定随机数的上限。 由于这是一个独占值，因此该方法调用返回0或1。  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp" id="Snippet8":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs" interactive="try-dotnet" id="Snippet8":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb" id="Snippet8":::
  
 该示例只是定义了一个方法，而不是创建一个单独的类来生成随机 <xref:System.Boolean> 值。 但是，在这种情况下， <xref:System.Random> 应将对象定义为类级变量，以避免 <xref:System.Random> 在每个方法调用中实例化新的实例。 在 Visual Basic 中，可以在方法中将随机实例定义为 [静态](/dotnet/visual-basic/language-reference/modifiers/static) 变量 `NextBoolean` 。  下面的示例提供了一个实现。  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp-interactive[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a>生成随机的64位整数  
 方法的重载 <xref:System.Random.Next%2A> 返回32位整数。 但是，在某些情况下，可能需要使用64位整数。 你可以按如下所示进行操作：  
  
1.  调用 <xref:System.Random.NextDouble%2A> 方法以检索双精度浮点值。  
  
2.  将该值乘以 <xref:System.Int64.MaxValue?displayProperty=nameWithType> 。  
  
 下面的示例使用此方法生成20000000个随机长整数，并将它们分类为10个等组。 然后，它通过将每个组中的数字从0计算到来计算随机数的分布 <xref:System.Int64.MaxValue?displayProperty=nameWithType> 。 如示例中的输出所示，在长整数的范围内，数值的分布将更多或更少。  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp-interactive[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 使用位操作的一种替代方法不会生成真正的随机数字。 此方法调用 <xref:System.Random.Next> 以生成两个整数，左移一个32位，并将它们 or 在一起。 此方法有两个限制：  
  
1.  因为位31是符号位，所以生成的长整型值的值始终为0。  为此，可以生成一个随机0或1，左移第31位，并将其与原始随机长整数 Or。  
  
2.  更严肃，因为返回的值的概率 <xref:System.Random.Next> 将为0，因此，如果范围为 0x0-0x00000000FFFFFFFF 的任何随机数，将会有很多。  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a>检索指定范围内的字节  
 方法的重载 <xref:System.Random.Next%2A> 允许您指定随机数的范围，但方法不允许 <xref:System.Random.NextBytes%2A> 。 下面的示例实现了一个 `NextBytes` 方法，该方法允许你指定返回的字节范围。 它定义 `Random2` 派生自的类 <xref:System.Random> ，并重载其 `NextBytes` 方法。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp" id="Snippet9":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs" interactive="try-dotnet" id="Snippet9":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb" id="Snippet9":::

 `NextBytes(Byte[], Byte, Byte)`方法包装对方法的调用， <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 并指定最小值和大于最大值的值（在本例中为0和 101) ，在字节数组中返回） (。 由于我们确定方法返回的整数值在 <xref:System.Random.Next%2A> 数据类型的范围内 <xref:System.Byte> ，因此可以安全地将它们强制转换为 c # 中的 () 或将它们 (在 Visual Basic 中) 从整数转换为字节。  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a>随机检索数组或集合中的元素  
 随机数字通常用作索引来检索数组或集合中的值。 若要检索随机索引值，可以调用 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> 方法，并使用数组的下限作为其参数的值，并将该数组的下限 `minValue` 作为其参数的值 `maxValue` 。 对于从零开始的数组，这等效于其 <xref:System.Array.Length%2A> 属性，或大于方法返回的值的数组 <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> 。 下面的示例从城市数组中随机检索美国中的城市名称。  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp-interactive[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a>从数组或集合中检索唯一元素  
 随机数生成器始终可以返回重复值。 当数字范围变小或生成的值的数目变大时，重复的概率会增大。 如果随机值必须是唯一的，则会生成更多的数字来补偿重复项，从而导致性能日趋下降。  
  
 可以通过多种方法来处理这种情况。 一种常见的解决方法是创建包含要检索的值的数组或集合，以及包含随机浮点数的并行数组。 第二个数组是在创建第一个数组时用随机数字填充的，该 <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> 方法用于通过使用并行数组中的值对第一个数组进行排序。  
  
 例如，如果您正在开发纸牌游戏，则需要确保每张卡片仅使用一次。 您可以创建可用于对卡片组进行排序的随机数字的并行数组，而不是生成用于检索卡并跟踪该卡是否已被处理的随机数。 对卡片组进行排序后，你的应用程序可以维护一个指针来指示卡片上下一张卡片的索引。  
  
 下面的示例阐释了这种方法。 它定义了一个 `Card` 类，该类表示一个纸牌，一个类 `Dealer` 用于处理一组无序的卡片。 `Dealer`类构造函数填充了两个数组：一个 `deck` 数组，该数组具有类范围并表示了卡片组中的所有卡片; 和一个本地 `order` 数组，该数组具有与数组相同的元素数 `deck` ，并使用随机生成的 <xref:System.Double> 值填充该数组。  <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType>然后调用方法， `deck` 根据数组中的值对数组进行排序 `order` 。  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp" id="Snippet11":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs" interactive="try-dotnet" id="Snippet11":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb" id="Snippet11":::
  
## Examples  

 下面的示例创建一个随机数生成器，并调用其 <xref:System.Random.NextBytes%2A> 、 <xref:System.Random.Next%2A> 和 <xref:System.Random.NextDouble%2A> 方法来生成不同范围内的随机数字序列。  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp-interactive[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 下面的示例生成一个随机整数，该整数将用作索引以检索数组中的字符串值。  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp-interactive[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>在 .NET Framework 1.0 和1.1 中，从所需的派生的类的最小实现是， <see cref="T:System.Random" /> <see cref="M:System.Random.Sample" /> 用于定义新的或修改的算法来生成随机数。 然后，派生类可以依赖于、、、和方法的基类实现 <see cref="M:System.Random.Next" /> <see cref="M:System.Random.Next(System.Int32)" /> <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> <see cref="M:System.Random.NextBytes(System.Byte[])" /> <see cref="M:System.Random.NextDouble" /> 来调用方法的派生类实现 <see cref="M:System.Random.Sample" /> 。  
  
在 .NET Framework 2.0 及更高版本中， <see cref="M:System.Random.Next" /> 、 <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> 和方法的行为 <see cref="M:System.Random.NextBytes(System.Byte[])" /> 已更改，因此这些方法不一定调用方法的派生类实现 <see cref="M:System.Random.Sample" /> 。 因此，从该目标派生的、 <see cref="T:System.Random" /> .NET Framework 2.0 及更高版本的类也应该重写这三个方法。</para></block>
    <block subset="none" type="usage"><para>不保证类中随机数生成器的实现在 <see cref="T:System.Random" /> .NET Framework 的主要版本中保持不变。 因此，不应假定同一种子会导致在不同版本的 .NET Framework 中产生相同的伪随机序列。</para></block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Random" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Random" />使用默认种子值初始化类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks
在 .NET Framework 中，默认种子值派生自系统时钟，后者具有有限的分辨率。 因此， <xref:System.Random> 通过调用无参数的构造函数而创建的不同对象具有相同的默认种子值，因此会产生相同的随机数集。 您可以通过使用单个 <xref:System.Random> 对象生成所有随机数来避免此问题。 还可以通过生成自己的随机种子值并将其传递给构造函数来解决此情况 <xref:System.Random.%23ctor%28System.Int32%29> 。 有关详细信息，请参阅 <xref:System.Random.%23ctor%28System.Int32%29> 构造函数。 

在 .NET Core 中，默认种子值由线程静态的伪随机数生成器生成，因此，上述限制不适用。 <xref:System.Random>连续创建的不同对象在 .Net Core 中生成不同的随机数集。
  
 如果希望随机数生成器生成一系列随机数字，请调用此构造函数。 若要生成与不同随机数生成器相同的固定随机数序列，请 <xref:System.Random.%23ctor%28System.Int32%29> 使用固定种子值调用构造函数。 <xref:System.Random>测试使用随机数字的应用时，经常使用此构造函数重载。  
  
 在实例化随机数生成器后，调用各个 <xref:System.Random> 方法（如 <xref:System.Random.Next> 或 <xref:System.Random.NextDouble> ）以生成随机数字。  
  
   
  
## Examples

下面的示例使用无参数构造函数实例化三个 <xref:System.Random> 对象，并为每个对象显示五个随机整数的序列。 如果它在 .NET Framework 上运行，因为前两个 <xref:System.Random> 对象是连续创建的，所以它们是使用基于系统时钟的相同种子值进行实例化的，因此，它们生成相同的随机数序列。 另一方面，如果 <xref:System.Random> 调用方法导致两秒钟的延迟，则会调用第三个对象的无参数构造函数 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 。 因为这会为第三个对象产生不同的种子值 <xref:System.Random> ，所以它会产生不同的随机数字序列。  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed">用来计算伪随机数序列起始值的数字。 如果指定的是负数，则使用其绝对值。</param>
        <summary>使用指定的种子值初始化 <see cref="T:System.Random" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为不同的对象提供相同的种子值 <xref:System.Random> 会导致每个实例生成相同的随机数序列。 这种情况通常在测试依赖随机数生成器的应用时完成。  
  
 如果应用程序需要不同的随机数序列，请用不同的种子值重复调用此构造函数。 生成唯一种子值的一种方法是使其与时间相关。 例如，从系统时钟派生种子值，因为 <xref:System.Random.%23ctor> 重载会。 但是，系统时钟可能没有足够的分辨率来为此构造函数提供不同的种子值调用。 在 .NET Framework 中，这会生成随机数字生成器，生成相同的伪随机数序列，如以下示例中的前两个 <xref:System.Random> 对象所示。 若要防止出现这种情况，请应用一种算法来区分每个调用中的种子值，或调用 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 方法以确保为每个构造函数提供不同的种子值。  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 另一种方法是实例化单个 <xref:System.Random> 对象，用于在应用程序中生成所有随机数。 这会产生略微改善的性能，因为实例化随机数生成器相当昂贵。  
  
   
  
## Examples  
 下面的示例 <xref:System.Random> 使用类构造函数创建对象，该类构造函数采用 seed 参数并生成随机整数和双精度序列。 该示例说明了在 <xref:System.Random> 再次创建具有构造函数和 seed 参数的对象时，将生成相同的序列。  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个随机整数。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个非负随机整数。</summary>
        <returns>大于或等于 0 且小于 <see cref="F:System.Int32.MaxValue" /> 的 32 位有符号整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%2A?displayProperty=nameWithType> 生成值范围从0到小于的随机数 <xref:System.Int32.MaxValue?displayProperty=nameWithType> 。 若要生成其值范围从0到其他正数的随机数字，请使用 <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> 方法重载。 若要在不同的范围内生成随机数字，请使用 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 方法重载。  
  
   
  
## Examples  
 下面的示例对方法进行重复调用 <xref:System.Random.Next%2A> ，以生成用户请求的特定数量的随机数字。 <xref:System.Console.ReadLine%2A?displayProperty=nameWithType>方法用于获取客户输入。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp" id="Snippet5":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs" interactive="try-dotnet-method" id="Snippet5":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb" id="Snippet5":::
  
 下面的示例从派生一个类 <xref:System.Random> ，以生成一个随机数序列，其分布不同于基类的方法所生成的统一分布 <xref:System.Random.Sample%2A> 。 它重写 <xref:System.Random.Sample%2A> 方法以提供随机数的分布，并重写 <xref:System.Random.Next%2A?displayProperty=nameWithType> 方法以使用随机数字序列。  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb" id="Snippet1":::  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>从 .NET Framework 版本2.0 开始，如果从派生类 <see cref="T:System.Random" /> 并重写 <see cref="M:System.Random.Sample" /> 方法，则 <see cref="M:System.Random.Sample" /> 不会在调用方法的基类实现时使用方法的派生类实现提供的分布 <see cref="M:System.Random.Next" /> 。 相反，将使用基类返回的统一分布 <see cref="T:System.Random" /> 。 此行为可改善类的整体性能 <see cref="T:System.Random" /> 。 若要修改此行为以调用 <see cref="M:System.Random.Sample" /> 派生类中的方法，还必须重写 <see cref="M:System.Random.Next" /> 方法。</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue">要生成的随机数的上限（随机数不能取该上限值）。 <paramref name="maxValue" /> 必须大于或等于 0。</param>
        <summary>返回一个小于所指定最大值的非负随机整数。</summary>
        <returns>大于或等于零且小于 <paramref name="maxValue" /> 的 32 位有符号整数，即：返回值的范围通常包括零但不包括 <paramref name="maxValue" />。 但是，如果 <paramref name="maxValue" /> 等于 0，则返回 <paramref name="maxValue" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%28System.Int32%29>重载返回介于0到-1 之间的随机整数 `maxValue` 。 但是，如果 `maxValue` 为0，则该方法返回0。  
  
   
  
## Examples  
 下面的示例生成包含方法的各种重载的随机整数 <xref:System.Random.Next%2A> 。  

 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp-interactive[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 下面的示例生成一个随机整数，该整数将用作索引以检索数组中的字符串值。 由于数组的最高索引小于其长度，因此该属性的值 <xref:System.Array.Length%2A?displayProperty=nameWithType> 作为 `maxValue` 参数提供。  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp-interactive[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue" /> 小于 0。</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue">返回的随机数的下界（随机数可取该下界值）。</param>
        <param name="maxValue">返回的随机数的上界（随机数不能取该上界值）。 <paramref name="maxValue" /> 必须大于或等于 <paramref name="minValue" />。</param>
        <summary>返回在指定范围内的任意整数。</summary>
        <returns>一个大于等于 <paramref name="minValue" /> 且小于 <paramref name="maxValue" /> 的 32 位带符号整数，即：返回的值范围包括 <paramref name="minValue" /> 但不包括 <paramref name="maxValue" />。 如果 <paramref name="minValue" /> 等于 <paramref name="maxValue" />，则返回 <paramref name="minValue" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>重载返回介于-1 之间的随机 `minValue` 整数 `maxValue` 。 但是，如果 `maxValue` equals `minValue` ，则该方法返回 `minValue` 。  
  
 不同于方法的其他重载 <xref:System.Random.Next%2A> ，后者仅返回非负值，此方法可以返回负随机整数。  
  
   
  
## Examples  
 下面的示例使用 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 方法生成具有三个不同范围的随机整数。 请注意，该示例的确切输出取决于传递给类构造函数的系统提供的种子值 <xref:System.Random> 。  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp-interactive[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 下面的示例生成一个随机整数，该整数将用作索引以检索数组中的字符串值。 由于数组的最高索引小于其长度，因此该属性的值 <xref:System.Array.Length%2A?displayProperty=nameWithType> 作为 `maxValue` 参数提供。  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp-interactive[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="minValue" /> 大于 <paramref name="maxValue" />。</exception>
        <block subset="none" type="overrides"><para>从 .NET Framework 版本2.0 开始，如果从派生类 <see cref="T:System.Random" /> 并重写 <see cref="M:System.Random.Sample" /> 方法，则 <see cref="M:System.Random.Sample" /> <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> 如果和参数之间的差异大于，则不会将方法的派生类实现提供的分布用于方法重载的基类实现 <paramref name="minValue" /> <paramref name="maxValue" /> <see cref="F:System.Int32.MaxValue" /> 。 相反，将使用基类返回的统一分布 <see cref="T:System.Random" /> 。 此行为可改善类的整体性能 <see cref="T:System.Random" /> 。 若要修改此行为以调用 <see cref="M:System.Random.Sample" /> 派生类中的方法，还必须重写 <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> 方法重载。</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">要用随机数填充的数组。</param>
        <summary>用随机数填充指定字节数组的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 字节数组的每个元素都设置为一个大于或等于0且小于或等于的随机数字 <xref:System.Byte.MaxValue> 。  
  
 例如，若要生成适用于创建随机密码的加密安全随机数字，请使用方法（如） <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType> 。  
  
   
  
## Examples

 下面的示例演示如何使用 <xref:System.Random.NextBytes%2A> 方法来填充包含随机字节值的字节数组。  
 
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp-interactive[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="overrides"><para>从 .NET Framework 版本2.0 开始，如果从派生类 <see cref="T:System.Random" /> 并重写 <see cref="M:System.Random.Sample" /> 方法，则 <see cref="M:System.Random.Sample" /> 不会在调用方法的基类实现时使用方法的派生类实现提供的分布 <see cref="M:System.Random.NextBytes(System.Byte[])" /> 。 相反，将使用基类返回的统一分布 <see cref="T:System.Random" /> 。 此行为可改善类的整体性能 <see cref="T:System.Random" /> 。 若要修改此行为以调用 <see cref="M:System.Random.Sample" /> 派生类中的方法，还必须重写 <see cref="M:System.Random.NextBytes(System.Byte[])" /> 方法。</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">要用随机数填充的数组。</param>
        <summary>用随机数填充指定字节范围的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

字节跨度的每个元素都设置为一个大于或等于0且小于或等于的随机数字 <xref:System.Byte.MaxValue> 。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个大于或等于 0.0 且小于 1.0 的随机浮点数。</summary>
        <returns>大于或等于 0.0 且小于 1.0 的双精度浮点数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回的随机数的实际上限为0.99999999999999978。  
  
 若要在0.0 和1.0 以外的范围内检索随机浮点值，请参阅类主题中的 "在指定范围内检索浮点值" 部分 <xref:System.Random> 。  
  
 此方法是受保护方法的公共版本 <xref:System.Random.Sample%2A> 。  
  
   
  
## Examples  

 下面的示例使用 <xref:System.Random.NextDouble%2A> 方法来生成随机双精度序列。  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 下面的示例调用 <xref:System.Random.NextDouble%2A> 方法以生成100的随机数字，并显示它们的频率分布。  
  
 [!code-csharp-interactive[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个介于 0.0 和 1.0 之间的随机浮点数。</summary>
        <returns>大于或等于 0.0 且小于 1.0 的双精度浮点数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要生成不同的随机分发或不同的随机数生成器原则，请从类派生一个类 <xref:System.Random> 并重写 <xref:System.Random.Sample%2A> 方法。  
  
> [!IMPORTANT]
>  <xref:System.Random.Sample%2A>方法为 `protected` ，这意味着只能在 <xref:System.Random> 类及其派生类中访问。 若要从实例生成0到1之间的随机数字 <xref:System.Random> ，请调用 <xref:System.Random.NextDouble%2A> 方法。  
  
   
  
## Examples  
 下面的示例从派生一个类 <xref:System.Random> ，并重写 <xref:System.Random.Sample%2A> 方法以生成随机数的分布。 此分布不同于基类的方法所生成的统一分布 <xref:System.Random.Sample%2A> 。  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>从 .NET Framework 版本2.0 开始，如果从派生类 <see cref="T:System.Random" /> 并重写 <see cref="M:System.Random.Sample" /> 方法，则 <see cref="M:System.Random.Sample" /> 不会在调用以下方法的基类实现时使用由方法的派生类实现提供的分发： 
-   <see cref="M:System.Random.NextBytes(System.Byte[])" /> 方法。  
  
-   <see cref="M:System.Random.Next" /> 方法。  
  
- <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> 如果 (<paramref name="maxValue" />  -  <paramref name="minValue" />) 大于，则为方法 <see cref="F:System.Int32.MaxValue" /> 。  
  
而是使用由基类提供的统一分布 <see cref="T:System.Random" /> 。 此行为可改善类的整体性能 <see cref="T:System.Random" /> 。 若要修改此行为以调用 <see cref="M:System.Random.Sample" /> 派生类中的方法的实现，还必须重写这三个成员的行为。 说明如示例所示。</para></block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>
