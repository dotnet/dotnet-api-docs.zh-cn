<Type Name="MulticastDelegate" FullName="System.MulticastDelegate">
  <Metadata><Meta Name="ms.openlocfilehash" Value="65ee97b8694276d9da7ce4b54ca8dcd54304c92f" /><Meta Name="ms.sourcegitcommit" Value="b6b9d5f3f9c7eb43f14a8a1a68d044603cb8ed73" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/18/2020" /><Meta Name="ms.locfileid" Value="83524829" /></Metadata><TypeSignature Language="C#" Value="public abstract class MulticastDelegate : Delegate" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit MulticastDelegate extends System.Delegate" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.MulticastDelegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MulticastDelegate&#xA;Inherits Delegate" />
  <TypeSignature Language="C++ CLI" Value="public ref class MulticastDelegate abstract : Delegate" />
  <TypeSignature Language="F#" Value="type MulticastDelegate = class&#xA;    inherit Delegate" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit MulticastDelegate extends System.Delegate" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit MulticastDelegate extends System.Delegate" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Delegate</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="694bc-101">表示多路广播委托；即，其调用列表中可以拥有多个元素的委托。</span><span class="sxs-lookup"><span data-stu-id="694bc-101">Represents a multicast delegate; that is, a delegate that can have more than one element in its invocation list.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="694bc-102"><xref:System.MulticastDelegate> 是一种特殊的类。</span><span class="sxs-lookup"><span data-stu-id="694bc-102"><xref:System.MulticastDelegate> is a special class.</span></span> <span data-ttu-id="694bc-103">编译器和其他工具可从此类派生，但您不能从它显式派生。</span><span class="sxs-lookup"><span data-stu-id="694bc-103">Compilers and other tools can derive from this class, but you cannot derive from it explicitly.</span></span> <span data-ttu-id="694bc-104"><xref:System.Delegate> 类也是如此。</span><span class="sxs-lookup"><span data-stu-id="694bc-104">The same is true of the <xref:System.Delegate> class.</span></span>  
  
 <span data-ttu-id="694bc-105">除了委托类型继承自 <xref:System.MulticastDelegate>的方法之外，公共语言运行时还提供两种特殊方法： `BeginInvoke` 和 `EndInvoke`。</span><span class="sxs-lookup"><span data-stu-id="694bc-105">In addition to the methods that delegate types inherit from <xref:System.MulticastDelegate>, the common language runtime provides two special methods: `BeginInvoke` and `EndInvoke`.</span></span> <span data-ttu-id="694bc-106">有关这些方法的详细信息，请参阅[异步调用同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。</span><span class="sxs-lookup"><span data-stu-id="694bc-106">For more information about these methods, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
 <span data-ttu-id="694bc-107"><xref:System.MulticastDelegate> 具有一个链接列表，这些委托称为调用列表，由一个或多个元素组成。</span><span class="sxs-lookup"><span data-stu-id="694bc-107">A <xref:System.MulticastDelegate> has a linked list of delegates, called an invocation list, consisting of one or more elements.</span></span> <span data-ttu-id="694bc-108">调用多播委托时，调用列表中的委托将按它们出现的顺序进行同步调用。</span><span class="sxs-lookup"><span data-stu-id="694bc-108">When a multicast delegate is invoked, the delegates in the invocation list are called synchronously in the order in which they appear.</span></span> <span data-ttu-id="694bc-109">如果在列表执行过程中出现错误，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="694bc-109">If an error occurs during execution of the list then an exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="694bc-110">下面的示例定义了一个类 `StringContainer`，该类包含字符串的集合。</span><span class="sxs-lookup"><span data-stu-id="694bc-110">The following example defines a class, `StringContainer`, which includes a collection of strings.</span></span> <span data-ttu-id="694bc-111">其成员之一是 `CheckAndDisplayDelegate` 委托，用于显示存储在满足特定条件的 `StringContainer` 对象中的字符串。</span><span class="sxs-lookup"><span data-stu-id="694bc-111">One of its members is the `CheckAndDisplayDelegate` delegate, which is used to display strings stored in a `StringContainer` object that satisfy particular criteria.</span></span> <span data-ttu-id="694bc-112">委托采用单个字符串作为参数，并返回 `void` （或者在 Visual Basic 中，它是一个 `Sub` 过程）。</span><span class="sxs-lookup"><span data-stu-id="694bc-112">The delegate takes a single string as a parameter and returns `void` (or, in Visual Basic, it's a `Sub` procedure).</span></span> <span data-ttu-id="694bc-113">它还包括一个 `DisplayAllQualified`的方法，该方法具有一个参数，即一个 `CheckAndDisplayDelegate` 委托。</span><span class="sxs-lookup"><span data-stu-id="694bc-113">It also includes a method, `DisplayAllQualified`, that has a single parameter, a `CheckAndDisplayDelegate` delegate.</span></span> <span data-ttu-id="694bc-114">这允许调用方法，并显示一组基于委托包含的方法进行筛选的字符串。</span><span class="sxs-lookup"><span data-stu-id="694bc-114">This allows the method to be called and to display a set of strings that are filtered based on the methods that the delegate contains.</span></span>  
  
 <span data-ttu-id="694bc-115">该示例还定义了一个实用工具类 `StringExtensions`，该类具有两种方法：</span><span class="sxs-lookup"><span data-stu-id="694bc-115">The example also defines a utility class, `StringExtensions`, that has two methods:</span></span>  
  
-   <span data-ttu-id="694bc-116">`ConStart`，用于显示以辅音开头的字符串。</span><span class="sxs-lookup"><span data-stu-id="694bc-116">`ConStart`, which displays strings that begin with a consonant.</span></span>  
  
-   <span data-ttu-id="694bc-117">`VowelStart`，用于显示以元音开头的字符串。</span><span class="sxs-lookup"><span data-stu-id="694bc-117">`VowelStart`, which displays strings that begin with a vowel.</span></span>  
  
 <span data-ttu-id="694bc-118">请注意，这两种方法都包含一个字符串参数并返回 `void`。</span><span class="sxs-lookup"><span data-stu-id="694bc-118">Note that both methods include a single string parameter and return `void`.</span></span> <span data-ttu-id="694bc-119">换言之，这两种方法都可以分配给 `CheckAndDisplayDelegate` 委托。</span><span class="sxs-lookup"><span data-stu-id="694bc-119">In other words, both methods can be assigned to the  `CheckAndDisplayDelegate` delegate.</span></span>  
  
 <span data-ttu-id="694bc-120">`Test.Main` 方法是应用程序入口点。</span><span class="sxs-lookup"><span data-stu-id="694bc-120">The `Test.Main` method is the application entry point.</span></span> <span data-ttu-id="694bc-121">它实例化一个 `StringContainer` 对象，使用字符串填充该对象，并创建两个调用单个方法的 `CheckAndDisplayDelegate` 委托，`conStart` 和 `vowelStart`。</span><span class="sxs-lookup"><span data-stu-id="694bc-121">It instantiates a `StringContainer` object, populates it with strings, and creates two `CheckAndDisplayDelegate` delegates, `conStart` and `vowelStart`, that invoke a single method.</span></span> <span data-ttu-id="694bc-122">然后，它调用 <xref:System.Delegate.Combine%2A?displayProperty=nameWithType> 方法来创建 `multipleDelegates` 委托，该委托最初包含 `ConStart` 和 `VowelStart` 委托。</span><span class="sxs-lookup"><span data-stu-id="694bc-122">It then calls the <xref:System.Delegate.Combine%2A?displayProperty=nameWithType> method to create the `multipleDelegates` delegate, which initially contains the `ConStart` and  `VowelStart` delegates.</span></span> <span data-ttu-id="694bc-123">请注意，当调用 `multipleDelegates` 委托时，它将按原始顺序显示集合中的所有字符串。</span><span class="sxs-lookup"><span data-stu-id="694bc-123">Note that when the `multipleDelegates` delegate is invoked, it displays all the strings in the collection in their original order.</span></span> <span data-ttu-id="694bc-124">这是因为每个字母都单独传递给每个委托，每个字母仅满足这两个委托之一的筛选条件。</span><span class="sxs-lookup"><span data-stu-id="694bc-124">This is because each letter is passed separately to each delegate, and each letter meets the filtering criteria of only one of the two delegates.</span></span> <span data-ttu-id="694bc-125">最后，在调用 <xref:System.Delegate.Remove%2A?displayProperty=nameWithType> 和 <xref:System.Delegate.Combine%2A?displayProperty=nameWithType>后，`multipleDelegates` 包含两个 `conStart` 委托。</span><span class="sxs-lookup"><span data-stu-id="694bc-125">Finally, after calls to <xref:System.Delegate.Remove%2A?displayProperty=nameWithType> and <xref:System.Delegate.Combine%2A?displayProperty=nameWithType>, `multipleDelegates` contains two `conStart` delegates.</span></span> <span data-ttu-id="694bc-126">调用时，`StringContainer` 对象中的每个字符串都显示两次。</span><span class="sxs-lookup"><span data-stu-id="694bc-126">When it is invoked, each string in the `StringContainer` object is displayed twice.</span></span>  
  
 [!code-cpp[Multicast Delegate Introduction#1](~/samples/snippets/cpp/VS_Snippets_CLR/Multicast Delegate Introduction/CPP/delegatestring.cpp#1)]
 [!code-csharp[Multicast Delegate Introduction#1](~/samples/snippets/csharp/VS_Snippets_CLR/Multicast Delegate Introduction/CS/delegatestring.cs#1)]
 [!code-vb[Multicast Delegate Introduction#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Multicast Delegate Introduction/VB/delegatestring.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="694bc-127">初始化 <see cref="T:System.MulticastDelegate" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="694bc-127">Initializes a new instance of the <see cref="T:System.MulticastDelegate" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MulticastDelegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MulticastDelegate(System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new MulticastDelegate : obj * string -&gt; MulticastDelegate" Usage="new System.MulticastDelegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="target" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="method" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="694bc-128">在其上定义 <paramref name="method" /> 的对象。</span><span class="sxs-lookup"><span data-stu-id="694bc-128">The object on which <paramref name="method" /> is defined.</span></span></param>
        <param name="method"><span data-ttu-id="694bc-129">为其创建委托的方法的名称。</span><span class="sxs-lookup"><span data-stu-id="694bc-129">The name of the method for which a delegate is created.</span></span></param>
        <summary><span data-ttu-id="694bc-130">初始化 <see cref="T:System.MulticastDelegate" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="694bc-130">Initializes a new instance of the <see cref="T:System.MulticastDelegate" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="694bc-131">不能在应用程序代码中使用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="694bc-131">This constructor cannot be used in application code.</span></span> <span data-ttu-id="694bc-132">若要通过指定实例方法的名称来创建委托，请使用 <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> 方法的重载，该重载指定方法名称和目标对象。</span><span class="sxs-lookup"><span data-stu-id="694bc-132">To create a delegate by specifying the name of an instance method, use an overload of the <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> method that specifies a method name and a target object.</span></span> <span data-ttu-id="694bc-133">例如，<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29?displayProperty=nameWithType> 方法重载将为具有指定名称的实例方法创建委托。</span><span class="sxs-lookup"><span data-stu-id="694bc-133">For example, the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29?displayProperty=nameWithType> method overload creates a delegate for an instance method with a specified name.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="694bc-134">无法创建抽象类的实例，或者此成员是使用晚期绑定机制调用的。</span><span class="sxs-lookup"><span data-stu-id="694bc-134">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MulticastDelegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MulticastDelegate(Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new MulticastDelegate : Type * string -&gt; MulticastDelegate" Usage="new System.MulticastDelegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="target" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="method" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="694bc-135">在其上定义 <paramref name="method" /> 的对象的类型。</span><span class="sxs-lookup"><span data-stu-id="694bc-135">The type of object on which <paramref name="method" /> is defined.</span></span></param>
        <param name="method"><span data-ttu-id="694bc-136">为其创建委托的静态方法的名称。</span><span class="sxs-lookup"><span data-stu-id="694bc-136">The name of the static method for which a delegate is created.</span></span></param>
        <summary><span data-ttu-id="694bc-137">初始化 <see cref="T:System.MulticastDelegate" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="694bc-137">Initializes a new instance of the <see cref="T:System.MulticastDelegate" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="694bc-138">不能在应用程序代码中使用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="694bc-138">This constructor cannot be used in application code.</span></span> <span data-ttu-id="694bc-139">若要通过指定静态方法的名称来创建委托，请使用 <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> 方法的重载，该重载指定方法名称，但不指定目标对象。</span><span class="sxs-lookup"><span data-stu-id="694bc-139">To create a delegate by specifying the name of a static method, use an overload of the <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> method that specifies a method name but does not specify a target object.</span></span> <span data-ttu-id="694bc-140">例如，<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29?displayProperty=nameWithType> 方法重载将为具有指定名称的方法创建一个静态委托。</span><span class="sxs-lookup"><span data-stu-id="694bc-140">For example, the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29?displayProperty=nameWithType> method overload creates a static delegate for a method with a specified name.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="694bc-141">无法创建抽象类的实例，或者此成员是使用晚期绑定机制调用的。</span><span class="sxs-lookup"><span data-stu-id="694bc-141">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected override sealed Delegate CombineImpl (Delegate follow);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Delegate CombineImpl(class System.Delegate follow) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function CombineImpl (follow As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override Delegate ^ CombineImpl(Delegate ^ follow);" />
      <MemberSignature Language="F#" Value="override this.CombineImpl : Delegate -&gt; Delegate" Usage="multicastDelegate.CombineImpl follow" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="follow" Type="System.Delegate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="follow"><span data-ttu-id="694bc-142">将与此委托进行合并的委托。</span><span class="sxs-lookup"><span data-stu-id="694bc-142">The delegate to combine with this delegate.</span></span></param>
        <summary><span data-ttu-id="694bc-143">将此 <see cref="T:System.Delegate" /> 与指定的 <see cref="T:System.Delegate" /> 合并，以形成一个新委托。</span><span class="sxs-lookup"><span data-stu-id="694bc-143">Combines this <see cref="T:System.Delegate" /> with the specified <see cref="T:System.Delegate" /> to form a new delegate.</span></span></summary>
        <returns><span data-ttu-id="694bc-144">一个委托，它是 <see cref="T:System.MulticastDelegate" /> 调用列表的新根。</span><span class="sxs-lookup"><span data-stu-id="694bc-144">A delegate that is the new root of the <see cref="T:System.MulticastDelegate" /> invocation list.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="694bc-145"><paramref name="follow" /> 没有与此实例相同的类型。</span><span class="sxs-lookup"><span data-stu-id="694bc-145"><paramref name="follow" /> does not have the same type as this instance.</span></span></exception>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="694bc-146">无法创建抽象类的实例，或者此成员是使用晚期绑定机制调用的。</span><span class="sxs-lookup"><span data-stu-id="694bc-146">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected override sealed object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="override this.DynamicInvokeImpl : obj[] -&gt; obj" Usage="multicastDelegate.DynamicInvokeImpl args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" Index="0" FrameworkAlternate="netframework-1.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="args"><span data-ttu-id="694bc-147">要传递给封装的方法的参数。</span><span class="sxs-lookup"><span data-stu-id="694bc-147">The arguments to pass to the encapsulated method.</span></span></param>
        <summary><span data-ttu-id="694bc-148">处理整个调用列表。</span><span class="sxs-lookup"><span data-stu-id="694bc-148">Processes the full invocation list.</span></span></summary>
        <returns><span data-ttu-id="694bc-149"><see cref="T:System.Object" /> 类型的数组，包含封装的方法的返回值。</span><span class="sxs-lookup"><span data-stu-id="694bc-149">An array of type <see cref="T:System.Object" /> that contains the return value of the encapsulated method.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="694bc-150">无法创建抽象类的实例，或者此成员是使用晚期绑定机制调用的。</span><span class="sxs-lookup"><span data-stu-id="694bc-150">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span></span>

          <span data-ttu-id="694bc-151">- 或 -</span><span class="sxs-lookup"><span data-stu-id="694bc-151">-or-</span></span>

          <span data-ttu-id="694bc-152">尝试调用调用方没有访问权的方法（即私有方法）。</span><span class="sxs-lookup"><span data-stu-id="694bc-152">There is an attempt to invoke a method to which the caller does not have access (that is, a private method).</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="694bc-153">参数的数目、顺序或类型无效。</span><span class="sxs-lookup"><span data-stu-id="694bc-153">The number, order, or type of parameters is invalid.</span></span></exception>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="694bc-154">封装的方法不是静态的，且目标对象为 null。</span><span class="sxs-lookup"><span data-stu-id="694bc-154">An encapsulated method is not static, and the target object is null.</span></span>

          <span data-ttu-id="694bc-155">- 或 -</span><span class="sxs-lookup"><span data-stu-id="694bc-155">-or-</span></span>

          <span data-ttu-id="694bc-156">尝试对某个对象或类调用一个方法，但该对象或类不支持该方法。</span><span class="sxs-lookup"><span data-stu-id="694bc-156">There is an attempt to invoke a method on an object or class that does not support the method.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="694bc-157">封装的方法之一引发异常。</span><span class="sxs-lookup"><span data-stu-id="694bc-157">One of the encapsulated methods throws an exception.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override sealed bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="multicastDelegate.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="694bc-158">要与此实例比较的对象。</span><span class="sxs-lookup"><span data-stu-id="694bc-158">The object to compare with this instance.</span></span></param>
        <summary><span data-ttu-id="694bc-159">确定此多路广播委托和指定的对象是否相等。</span><span class="sxs-lookup"><span data-stu-id="694bc-159">Determines whether this multicast delegate and the specified object are equal.</span></span></summary>
        <returns><span data-ttu-id="694bc-160">如果 <paramref name="obj" /> 和此实例具有相同的调用列表，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="694bc-160"><see langword="true" /> if <paramref name="obj" /> and this instance have the same invocation lists; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="694bc-161">如果两个委托不 `null` 并且具有完全相同的类型，则两个委托的调用列表将包含相同的元素数，并且第一个委托的调用列表中的每个元素都等于第二个委托的调用列表中的相应元素。</span><span class="sxs-lookup"><span data-stu-id="694bc-161">Two delegates are equal if they are not `null` and are of exactly the same type, their invocation lists contain the same number of elements, and every element in the invocation list of the first delegate is equal to the corresponding element in the invocation list of the second delegate.</span></span>  
  
 <span data-ttu-id="694bc-162">如果两个调用列表元素在同一目标实例上调用相同的实例方法，或者它们调用相同的静态方法，则它们是相等的。</span><span class="sxs-lookup"><span data-stu-id="694bc-162">Two invocation list elements are equal if they invoke the same instance method on the same target instance, or they invoke the same static method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="694bc-163">无法创建抽象类的实例，或者此成员是使用晚期绑定机制调用的。</span><span class="sxs-lookup"><span data-stu-id="694bc-163">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override sealed int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="multicastDelegate.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="694bc-164">返回此实例的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="694bc-164">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="694bc-165">32 位有符号整数哈希代码。</span><span class="sxs-lookup"><span data-stu-id="694bc-165">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="694bc-166">无法创建抽象类的实例，或者此成员是使用晚期绑定机制调用的。</span><span class="sxs-lookup"><span data-stu-id="694bc-166">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public override sealed Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberSignature Language="F#" Value="override this.GetInvocationList : unit -&gt; Delegate[]" Usage="multicastDelegate.GetInvocationList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="694bc-167">按照调用顺序返回此多路广播委托的调用列表。</span><span class="sxs-lookup"><span data-stu-id="694bc-167">Returns the invocation list of this multicast delegate, in invocation order.</span></span></summary>
        <returns><span data-ttu-id="694bc-168">一个委托数组，这些委托的调用列表合起来与此实例的调用列表一致。</span><span class="sxs-lookup"><span data-stu-id="694bc-168">An array of delegates whose invocation lists collectively match the invocation list of this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="694bc-169">数组包含一组委托，每个委托都有一个项的调用列表。</span><span class="sxs-lookup"><span data-stu-id="694bc-169">The array contains a set of delegates, each with an invocation list of one entry.</span></span> <span data-ttu-id="694bc-170">按顺序调用这些委托（按照它们在数组中出现的顺序）生成与调用当前实例相同的结果。</span><span class="sxs-lookup"><span data-stu-id="694bc-170">Invoking these delegates sequentially, in the order they appear in the array, produces the same results as invoking the current instance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="694bc-171">无法创建抽象类的实例，或者此成员是使用晚期绑定机制调用的。</span><span class="sxs-lookup"><span data-stu-id="694bc-171">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberSignature Language="F#" Value="override this.GetMethodImpl : unit -&gt; System.Reflection.MethodInfo" Usage="multicastDelegate.GetMethodImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="694bc-172">返回由当前的 <see cref="T:System.MulticastDelegate" /> 表示的静态方法。</span><span class="sxs-lookup"><span data-stu-id="694bc-172">Returns a static method represented by the current <see cref="T:System.MulticastDelegate" />.</span></span></summary>
        <returns><span data-ttu-id="694bc-173">由当前的 <see cref="T:System.MulticastDelegate" /> 表示的静态方法。</span><span class="sxs-lookup"><span data-stu-id="694bc-173">A static method represented by the current <see cref="T:System.MulticastDelegate" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="694bc-174">如果 <xref:System.MulticastDelegate> 表示多个方法，则只返回一个方法。</span><span class="sxs-lookup"><span data-stu-id="694bc-174">If the <xref:System.MulticastDelegate> represents multiple methods, only one method is returned.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public override void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="multicastDelegate.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="694bc-175">一个对象，它保存将此实例序列化或反序列化所需的全部数据。</span><span class="sxs-lookup"><span data-stu-id="694bc-175">An object that holds all the data needed to serialize or deserialize this instance.</span></span></param>
        <param name="context"><span data-ttu-id="694bc-176">（保留）存储和检索序列化数据的位置。</span><span class="sxs-lookup"><span data-stu-id="694bc-176">(Reserved) The location where serialized data is stored and retrieved.</span></span></param>
        <summary><span data-ttu-id="694bc-177">用序列化该实例所需的所有数据填充 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="694bc-177">Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object with all the data needed to serialize this instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="694bc-178">此方法存储序列化此实例所需 `info` 中的所有信息。</span><span class="sxs-lookup"><span data-stu-id="694bc-178">This method stores all the information in `info` necessary to serialize this instance.</span></span>  
  
 <span data-ttu-id="694bc-179">`context` 参数是保留参数，当前未在执行此方法时使用。</span><span class="sxs-lookup"><span data-stu-id="694bc-179">The `context` parameter is reserved and is not currently used in the execution of this method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="694bc-180"><paramref name="info" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="694bc-180"><paramref name="info" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="694bc-181">无法创建抽象类的实例，或者此成员是使用晚期绑定机制调用的。</span><span class="sxs-lookup"><span data-stu-id="694bc-181">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span></span></exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException"><span data-ttu-id="694bc-182">发生了序列化错误。</span><span class="sxs-lookup"><span data-stu-id="694bc-182">A serialization error occurred.</span></span></exception>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (MulticastDelegate d1, MulticastDelegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.MulticastDelegate d1, class System.MulticastDelegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.op_Equality(System.MulticastDelegate,System.MulticastDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As MulticastDelegate, d2 As MulticastDelegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(MulticastDelegate ^ d1, MulticastDelegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : MulticastDelegate * MulticastDelegate -&gt; bool" Usage="d1 = d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.MulticastDelegate" />
        <Parameter Name="d2" Type="System.MulticastDelegate" />
      </Parameters>
      <Docs>
        <param name="d1"><span data-ttu-id="694bc-183">左操作数。</span><span class="sxs-lookup"><span data-stu-id="694bc-183">The left operand.</span></span></param>
        <param name="d2"><span data-ttu-id="694bc-184">右操作数。</span><span class="sxs-lookup"><span data-stu-id="694bc-184">The right operand.</span></span></param>
        <summary><span data-ttu-id="694bc-185">确定两个 <see cref="T:System.MulticastDelegate" /> 对象是否相等。</span><span class="sxs-lookup"><span data-stu-id="694bc-185">Determines whether two <see cref="T:System.MulticastDelegate" /> objects are equal.</span></span></summary>
        <returns><span data-ttu-id="694bc-186">如果 <paramref name="d1" /> 和 <paramref name="d2" /> 具有相同的调用列表，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="694bc-186"><see langword="true" /> if <paramref name="d1" /> and <paramref name="d2" /> have the same invocation lists; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="694bc-187">如果两个委托不 `null` 并且具有完全相同的类型，则两个委托的调用列表将包含相同的元素数，并且第一个委托的调用列表中的每个元素都等于第二个委托的调用列表中的相应元素。</span><span class="sxs-lookup"><span data-stu-id="694bc-187">Two delegates are equal if they are not `null` and are of exactly the same type, their invocation lists contain the same number of elements, and every element in the invocation list of the first delegate is equal to the corresponding element in the invocation list of the second delegate.</span></span>  
  
 <span data-ttu-id="694bc-188">如果两个调用列表元素在同一目标实例上调用相同的实例方法，或者它们调用相同的静态方法，则它们是相等的。</span><span class="sxs-lookup"><span data-stu-id="694bc-188">Two invocation list elements are equal if they invoke the same instance method on the same target instance, or they invoke the same static method.</span></span>  
  
 <span data-ttu-id="694bc-189">此运算符的等效方法是 <xref:System.MulticastDelegate.Equals%28System.Object%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="694bc-189">The equivalent method for this operator is <xref:System.MulticastDelegate.Equals%28System.Object%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="694bc-190">无法创建抽象类的实例，或者此成员是使用晚期绑定机制调用的。</span><span class="sxs-lookup"><span data-stu-id="694bc-190">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (MulticastDelegate d1, MulticastDelegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.MulticastDelegate d1, class System.MulticastDelegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.op_Inequality(System.MulticastDelegate,System.MulticastDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As MulticastDelegate, d2 As MulticastDelegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(MulticastDelegate ^ d1, MulticastDelegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : MulticastDelegate * MulticastDelegate -&gt; bool" Usage="System.MulticastDelegate.op_Inequality (d1, d2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.MulticastDelegate" />
        <Parameter Name="d2" Type="System.MulticastDelegate" />
      </Parameters>
      <Docs>
        <param name="d1"><span data-ttu-id="694bc-191">左操作数。</span><span class="sxs-lookup"><span data-stu-id="694bc-191">The left operand.</span></span></param>
        <param name="d2"><span data-ttu-id="694bc-192">右操作数。</span><span class="sxs-lookup"><span data-stu-id="694bc-192">The right operand.</span></span></param>
        <summary><span data-ttu-id="694bc-193">确定两个 <see cref="T:System.MulticastDelegate" /> 对象是否不相等。</span><span class="sxs-lookup"><span data-stu-id="694bc-193">Determines whether two <see cref="T:System.MulticastDelegate" /> objects are not equal.</span></span></summary>
        <returns><span data-ttu-id="694bc-194">如果 <paramref name="d1" /> 和 <paramref name="d2" /> 没有相同的调用列表，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="694bc-194"><see langword="true" /> if <paramref name="d1" /> and <paramref name="d2" /> do not have the same invocation lists; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="694bc-195">如果两个委托不 `null` 并且具有完全相同的类型，则两个委托的调用列表将包含相同的元素数，并且第一个委托的调用列表中的每个元素都等于第二个委托的调用列表中的相应元素。</span><span class="sxs-lookup"><span data-stu-id="694bc-195">Two delegates are equal if they are not `null` and are of exactly the same type, their invocation lists contain the same number of elements, and every element in the invocation list of the first delegate is equal to the corresponding element in the invocation list of the second delegate.</span></span>  
  
 <span data-ttu-id="694bc-196">如果两个调用列表元素在同一目标实例上调用相同的实例方法，或者它们调用相同的静态方法，则它们是相等的。</span><span class="sxs-lookup"><span data-stu-id="694bc-196">Two invocation list elements are equal if they invoke the same instance method on the same target instance, or they invoke the same static method.</span></span>  
  
 <span data-ttu-id="694bc-197">此运算符的等效方法是 <xref:System.MulticastDelegate.Equals%28System.Object%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="694bc-197">The equivalent method for this operator is <xref:System.MulticastDelegate.Equals%28System.Object%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="694bc-198">无法创建抽象类的实例，或者此成员是使用晚期绑定机制调用的。</span><span class="sxs-lookup"><span data-stu-id="694bc-198">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected override sealed Delegate RemoveImpl (Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Delegate RemoveImpl(class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MulticastDelegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function RemoveImpl (value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override Delegate ^ RemoveImpl(Delegate ^ value);" />
      <MemberSignature Language="F#" Value="override this.RemoveImpl : Delegate -&gt; Delegate" Usage="multicastDelegate.RemoveImpl value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Delegate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="694bc-199">要在调用列表中搜索的委托。</span><span class="sxs-lookup"><span data-stu-id="694bc-199">The delegate to search for in the invocation list.</span></span></param>
        <summary><span data-ttu-id="694bc-200">从此 <see cref="T:System.MulticastDelegate" /> 的调用列表中移除与指定委托相等的元素。</span><span class="sxs-lookup"><span data-stu-id="694bc-200">Removes an element from the invocation list of this <see cref="T:System.MulticastDelegate" /> that is equal to the specified delegate.</span></span></summary>
        <returns><span data-ttu-id="694bc-201">如果在此实例的调用列表中找到 <paramref name="value" />，则为其调用列表中没有 <paramref name="value" /> 的新 <see cref="T:System.Delegate" />；否则为此实例（带有其原始调用列表）。</span><span class="sxs-lookup"><span data-stu-id="694bc-201">If <paramref name="value" /> is found in the invocation list for this instance, then a new <see cref="T:System.Delegate" /> without <paramref name="value" /> in its invocation list; otherwise, this instance with its original invocation list.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="694bc-202">无法创建抽象类的实例，或者此成员是使用晚期绑定机制调用的。</span><span class="sxs-lookup"><span data-stu-id="694bc-202">Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
