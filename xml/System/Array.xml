<Type Name="Array" FullName="System.Array">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fa0802b83a5186f80b4fce102fc78233425db7d4" /><Meta Name="ms.sourcegitcommit" Value="de90f7a1ff1a8b0fdd63acd018eae2b71b1df5d9" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="12/10/2019" /><Meta Name="ms.locfileid" Value="74998672" /></Metadata><TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Array" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Array&#xA;Implements ICloneable, IList, IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Array abstract : ICloneable, System::Collections::IList, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <TypeSignature Language="F#" Value="type Array = class&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IList&#xA;    interface IEnumerable&#xA;    interface IStructuralComparable&#xA;    interface IStructuralEquatable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="08e41-101">提供一些方法，用于创建、处理、搜索数组并对数组进行排序，从而充当公共语言运行时中所有数组的基类。</span><span class="sxs-lookup"><span data-stu-id="08e41-101">Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the base class for all arrays in the common language runtime.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-102"><xref:System.Array> 类不是 <xref:System.Collections> 命名空间的一部分。</span><span class="sxs-lookup"><span data-stu-id="08e41-102">The <xref:System.Array> class is not part of the <xref:System.Collections> namespaces.</span></span> <span data-ttu-id="08e41-103">但是，它仍被视为集合，因为它基于 <xref:System.Collections.IList> 接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-103">However, it is still considered a collection because it is based on the <xref:System.Collections.IList> interface.</span></span>  
  
 <span data-ttu-id="08e41-104"><xref:System.Array> 类是支持数组的语言实现的基类。</span><span class="sxs-lookup"><span data-stu-id="08e41-104">The <xref:System.Array> class is the base class for language implementations that support arrays.</span></span> <span data-ttu-id="08e41-105">但是，只有系统和编译器才能从 <xref:System.Array> 类显式派生。</span><span class="sxs-lookup"><span data-stu-id="08e41-105">However, only the system and compilers can derive explicitly from the <xref:System.Array> class.</span></span> <span data-ttu-id="08e41-106">用户应使用该语言提供的数组构造。</span><span class="sxs-lookup"><span data-stu-id="08e41-106">Users should employ the array constructs provided by the language.</span></span>  
  
 <span data-ttu-id="08e41-107">元素是 <xref:System.Array>中的值。</span><span class="sxs-lookup"><span data-stu-id="08e41-107">An element is a value in an <xref:System.Array>.</span></span> <span data-ttu-id="08e41-108"><xref:System.Array> 的长度是它可以包含的元素总数。</span><span class="sxs-lookup"><span data-stu-id="08e41-108">The length of an <xref:System.Array> is the total number of elements it can contain.</span></span> <span data-ttu-id="08e41-109"><xref:System.Array> 的下限是其第一个元素的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-109">The lower bound of an <xref:System.Array> is the index of its first element.</span></span> <span data-ttu-id="08e41-110"><xref:System.Array> 可以具有任何下限，但默认情况下它的下限为零。</span><span class="sxs-lookup"><span data-stu-id="08e41-110">An <xref:System.Array> can have any lower bound, but it has a lower bound of zero by default.</span></span> <span data-ttu-id="08e41-111">使用 <xref:System.Array.CreateInstance%2A>创建 <xref:System.Array> 类的实例时，可以定义其他下限。多维 <xref:System.Array> 每个维度可以具有不同的界限。</span><span class="sxs-lookup"><span data-stu-id="08e41-111">A different lower bound can be defined when creating an instance of the <xref:System.Array> class using <xref:System.Array.CreateInstance%2A>.A multidimensional <xref:System.Array> can have different bounds for each dimension.</span></span> <span data-ttu-id="08e41-112">数组最多可以有32个维度。</span><span class="sxs-lookup"><span data-stu-id="08e41-112">An array can have a maximum of 32 dimensions.</span></span>  
  
 <span data-ttu-id="08e41-113">与 <xref:System.Collections> 命名空间中的类不同，<xref:System.Array> 具有固定的容量。</span><span class="sxs-lookup"><span data-stu-id="08e41-113">Unlike the classes in the <xref:System.Collections> namespaces, <xref:System.Array> has a fixed capacity.</span></span> <span data-ttu-id="08e41-114">要增加容量，必须创建具有所需容量的新 <xref:System.Array> 对象，将旧 <xref:System.Array> 对象中的元素复制到新的 <xref:System.Array>，并删除旧的。</span><span class="sxs-lookup"><span data-stu-id="08e41-114">To increase the capacity, you must create a new <xref:System.Array> object with the required capacity, copy the elements from the old <xref:System.Array> object to the new one, and delete the old <xref:System.Array>.</span></span>  

 <span data-ttu-id="08e41-115">数组大小限制为总计4000000000个元素，在任何给定维度中限制为0X7FEFFFFF 的最大索引（字节数组的0X7FFFFFC7 和单字节结构的数组）。</span><span class="sxs-lookup"><span data-stu-id="08e41-115">The array size is limited to a total of 4 billion elements, and to a maximum index of 0X7FEFFFFF in any given dimension (0X7FFFFFC7 for byte arrays and arrays of single-byte structures).</span></span>
  
 <span data-ttu-id="08e41-116">**仅 .NET Framework：** 默认情况下，<xref:System.Array> 的最大大小为2千兆字节（GB）。</span><span class="sxs-lookup"><span data-stu-id="08e41-116">**.NET Framework only:** By default, the maximum size of an <xref:System.Array> is 2 gigabytes (GB).</span></span> <span data-ttu-id="08e41-117">在64位环境中，可以通过将[gcAllowVeryLargeObjects](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md)配置元素的 `enabled` 特性设置为运行时环境中 `true` 来避免大小限制。</span><span class="sxs-lookup"><span data-stu-id="08e41-117">In a 64-bit environment, you can avoid the size restriction by setting the `enabled` attribute of the [gcAllowVeryLargeObjects](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) configuration element to `true` in the run-time environment.</span></span>
  
 <span data-ttu-id="08e41-118">一维数组实现 <xref:System.Collections.Generic.IList%601?displayProperty=nameWithType>、<xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType>、<xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>、<xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType> 和 <xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType> 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-118">Single-dimensional arrays implement the <xref:System.Collections.Generic.IList%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType> and <xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType> generic interfaces.</span></span> <span data-ttu-id="08e41-119">实现在运行时提供给数组，因此，泛型接口不会出现在 <xref:System.Array> 类的声明语法中。</span><span class="sxs-lookup"><span data-stu-id="08e41-119">The implementations are provided to arrays at run time, and as a result, the generic interfaces do not appear in the declaration syntax for the <xref:System.Array> class.</span></span> <span data-ttu-id="08e41-120">此外，没有可通过将数组强制转换为泛型接口类型（显式接口实现）来访问的接口成员的引用主题。</span><span class="sxs-lookup"><span data-stu-id="08e41-120">In addition,  there are no reference topics for interface members that are accessible only by casting an array to the generic interface type (explicit interface implementations).</span></span> <span data-ttu-id="08e41-121">将数组转换为这些接口之一时要注意的关键一点是，添加、插入或删除元素的成员引发 <xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="08e41-121">The key thing to be aware of when you cast an array to one of these interfaces is that members which add, insert, or remove elements throw <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="08e41-122"><xref:System.Type> 对象提供了有关数组类型声明的信息。</span><span class="sxs-lookup"><span data-stu-id="08e41-122"><xref:System.Type> objects provide information about array type declarations.</span></span> <span data-ttu-id="08e41-123">具有相同数组类型 <xref:System.Array> 对象共享同一 <xref:System.Type> 对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-123"><xref:System.Array> objects with the same array type share the same <xref:System.Type> object.</span></span>  
  
 <span data-ttu-id="08e41-124"><xref:System.Type.IsArray%2A?displayProperty=nameWithType> 和 <xref:System.Type.GetElementType%2A?displayProperty=nameWithType> 可能不会通过 <xref:System.Array> 返回预期结果，因为如果将数组强制转换为类型 <xref:System.Array>，则结果为对象，而不是数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-124"><xref:System.Type.IsArray%2A?displayProperty=nameWithType> and <xref:System.Type.GetElementType%2A?displayProperty=nameWithType> might not return the expected results with <xref:System.Array> because if an array is cast to the type <xref:System.Array>, the result is an object, not an array.</span></span> <span data-ttu-id="08e41-125">也就是说，`typeof(System.Array).IsArray` 返回 `false`，`typeof(System.Array).GetElementType` 返回 `null`。</span><span class="sxs-lookup"><span data-stu-id="08e41-125">That is, `typeof(System.Array).IsArray` returns `false`, and `typeof(System.Array).GetElementType` returns `null`.</span></span>  
  
 <span data-ttu-id="08e41-126"><xref:System.Array.Copy%2A?displayProperty=nameWithType> 方法不仅复制相同类型的数组中的元素，还复制不同类型的标准数组之间的元素;它自动处理类型强制转换。</span><span class="sxs-lookup"><span data-stu-id="08e41-126">The <xref:System.Array.Copy%2A?displayProperty=nameWithType> method copies elements not only between arrays of the same type but also between standard arrays of different types; it handles type casting automatically.</span></span>  
  
 <span data-ttu-id="08e41-127">某些方法（例如 <xref:System.Array.CreateInstance%2A>、<xref:System.Array.Copy%2A>、<xref:System.Array.CopyTo%2A>、<xref:System.Array.GetValue%2A>和 <xref:System.Array.SetValue%2A>）提供接受64位整数作为参数以容纳大容量数组的重载。</span><span class="sxs-lookup"><span data-stu-id="08e41-127">Some methods, such as <xref:System.Array.CreateInstance%2A>, <xref:System.Array.Copy%2A>, <xref:System.Array.CopyTo%2A>, <xref:System.Array.GetValue%2A>, and <xref:System.Array.SetValue%2A>, provide overloads that accept 64-bit integers as parameters to accommodate large capacity arrays.</span></span> <span data-ttu-id="08e41-128"><xref:System.Array.LongLength%2A> 和 <xref:System.Array.GetLongLength%2A> 返回64位整数，指示数组的长度。</span><span class="sxs-lookup"><span data-stu-id="08e41-128"><xref:System.Array.LongLength%2A> and <xref:System.Array.GetLongLength%2A> return 64-bit integers indicating the length of the array.</span></span>  
  
 <span data-ttu-id="08e41-129">不保证 <xref:System.Array> 进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-129">The <xref:System.Array> is not guaranteed to be sorted.</span></span>  <span data-ttu-id="08e41-130">必须先对 <xref:System.Array> 进行排序，然后才能执行需要对 <xref:System.Array> 排序的操作（如 <xref:System.Array.BinarySearch%2A>）。</span><span class="sxs-lookup"><span data-stu-id="08e41-130">You must sort the <xref:System.Array> prior to performing operations (such as <xref:System.Array.BinarySearch%2A>) that require the <xref:System.Array> to be sorted.</span></span>  
  
 <span data-ttu-id="08e41-131">不支持使用本机代码中的指针的 <xref:System.Array> 对象，它将引发若干方法的 <xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="08e41-131">Using an <xref:System.Array> object of pointers in native code is not supported and will throw a <xref:System.NotSupportedException> for several methods.</span></span>  
  
   
  
## Examples  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]
 
 <span data-ttu-id="08e41-132">下面的代码示例演示 <xref:System.Array.Copy%2A?displayProperty=nameWithType> 如何在类型为 integer 的数组和 <xref:System.Object>类型的数组之间复制元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-132">The following code example shows how <xref:System.Array.Copy%2A?displayProperty=nameWithType> copies elements between an array of type integer and an array of type <xref:System.Object>.</span></span>  
  
 [!code-cpp[Classic Array Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source.cs#1)]
 [!code-vb[Classic Array Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source.vb#1)]  
  
 <span data-ttu-id="08e41-133">下面的代码示例创建并初始化一个 <xref:System.Array> 并显示其属性和元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-133">The following code example creates and initializes an <xref:System.Array> and displays its properties and its elements.</span></span>  
  
 [!code-cpp[Classic Array Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source3.cpp#2)]
 [!code-csharp-interactive[Classic Array Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source3.cs#2)]
 [!code-vb[Classic Array Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source3.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="08e41-134">此类型的公共静态（<see langword="Shared" /> Visual Basic）成员是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="08e41-134">Public static (<see langword="Shared" /> in Visual Basic) members of this type are thread safe.</span></span> <span data-ttu-id="08e41-135">但不保证所有实例成员都是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="08e41-135">Any instance members are not guaranteed to be thread safe.</span></span>  
  
<span data-ttu-id="08e41-136">此实现不为 <see cref="T:System.Array" />提供同步（线程安全）包装;但是，基于 <see cref="T:System.Array" /> .NET Framework 类使用 <see cref="P:System.Array.SyncRoot" /> 属性提供其自己的同步版本的集合。</span><span class="sxs-lookup"><span data-stu-id="08e41-136">This implementation does not provide a synchronized (thread safe) wrapper for an <see cref="T:System.Array" />; however, .NET Framework classes based on <see cref="T:System.Array" /> provide their own synchronized version of the collection using the <see cref="P:System.Array.SyncRoot" /> property.</span></span>  
  
<span data-ttu-id="08e41-137">枚举整个集合本质上不是一个线程安全的过程。</span><span class="sxs-lookup"><span data-stu-id="08e41-137">Enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="08e41-138">即使某个集合已同步，其他线程仍可以修改该集合，这会导致枚举数引发异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-138">Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</span></span> <span data-ttu-id="08e41-139">若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改所导致的异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-139">To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</span></span></threadsafe>
    <altmember cref="T:System.Object" />
    <altmember cref="T:System.Type" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-140">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-140">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
    <related type="Article" href="~/docs/csharp/programming-guide/arrays/index.md"><span data-ttu-id="08e41-141">数组（C# 编程指南）</span><span class="sxs-lookup"><span data-stu-id="08e41-141">Arrays (C# Programming Guide)</span></span></related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/arrays/index.md"><span data-ttu-id="08e41-142">Visual Basic 中的数组</span><span class="sxs-lookup"><span data-stu-id="08e41-142">Arrays in Visual Basic</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="AsReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; AsReadOnly&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.AsReadOnly``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsReadOnly(Of T) (array As T()) As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member AsReadOnly : 'T[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="System.Array.AsReadOnly array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-143">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-143">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-144">要包装在只读 <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> 包装器中的从零开始的一维数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-144">The one-dimensional, zero-based array to wrap in a read-only <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> wrapper.</span></span></param>
        <summary><span data-ttu-id="08e41-145">返回指定数组的只读包装。</span><span class="sxs-lookup"><span data-stu-id="08e41-145">Returns a read-only wrapper for the specified array.</span></span></summary>
        <returns><span data-ttu-id="08e41-146">指定数组的只读 <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> 包装。</span><span class="sxs-lookup"><span data-stu-id="08e41-146">A read-only <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> wrapper for the specified array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-147">若要防止对数组进行任何修改，只需要通过此包装公开数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-147">To prevent any modifications to the array, expose the array only through this wrapper.</span></span>  
  
 <span data-ttu-id="08e41-148">只读集合就是一个集合，其中包含阻止修改集合的包装器;因此，如果对基础集合进行了更改，只读集合将反映这些更改。</span><span class="sxs-lookup"><span data-stu-id="08e41-148">A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection; therefore, if changes are made to the underlying collection, the read-only collection reflects those changes.</span></span>  
  
 <span data-ttu-id="08e41-149">此方法为 O （1）操作。</span><span class="sxs-lookup"><span data-stu-id="08e41-149">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-150">下面的示例在只读 <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>中包装数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-150">The following example wraps an array in a read-only <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span></span>  
  
 [!code-cpp[System.Array.AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CPP/arrayasreadonly.cpp#1)]
 [!code-csharp[System.Array.AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CS/arrayasreadonly.cs#1)]
 [!code-vb[System.Array.AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.AsReadOnly/VB/arrayasreadonly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-151"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-151"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="08e41-152">使用二进制搜索算法在一维的排序 <see cref="T:System.Array" /> 中搜索值。</span><span class="sxs-lookup"><span data-stu-id="08e41-152">Searches a one-dimensional sorted <see cref="T:System.Array" /> for a value, using a binary search algorithm.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="08e41-153">要搜索的排序一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-153">The sorted one-dimensional <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="08e41-154">要搜索的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-154">The object to search for.</span></span></param>
        <summary><span data-ttu-id="08e41-155">使用由数组中每个元素和指定对象实现的 <see cref="T:System.IComparable" /> 接口，在整个一维排序数组中搜索特定元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-155">Searches an entire one-dimensional sorted array for a specific element, using the <see cref="T:System.IComparable" /> interface implemented by each element of the array and by the specified object.</span></span></summary>
        <returns><span data-ttu-id="08e41-156">如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。</span><span class="sxs-lookup"><span data-stu-id="08e41-156">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="08e41-157">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。</span><span class="sxs-lookup"><span data-stu-id="08e41-157">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="08e41-158">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。</span><span class="sxs-lookup"><span data-stu-id="08e41-158">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="08e41-159">如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</span><span class="sxs-lookup"><span data-stu-id="08e41-159">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-160">此方法不支持搜索包含负索引的数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-160">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="08e41-161">在调用此方法之前，必须对 `array` 进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-161">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="08e41-162">如果 <xref:System.Array> 不包含指定的值，则该方法将返回一个负整数。</span><span class="sxs-lookup"><span data-stu-id="08e41-162">If the <xref:System.Array> does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="08e41-163">可以将按位求补运算符（~ in C#，`Not` 在 Visual Basic 中）应用于负结果，以生成索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-163">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result  to produce an index.</span></span> <span data-ttu-id="08e41-164">如果此索引大于数组的上限，则没有元素大于数组中的 `value`。</span><span class="sxs-lookup"><span data-stu-id="08e41-164">If this index is one greater than the upper bound of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="08e41-165">否则，它是大于 `value`的第一个元素的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-165">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="08e41-166">`value` 或 `array` 的每个元素都必须实现用于比较的 <xref:System.IComparable> 接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-166">Either `value` or every element of `array` must implement the <xref:System.IComparable> interface, which is used for comparisons.</span></span> <span data-ttu-id="08e41-167">根据 <xref:System.IComparable> 实现定义的排序顺序，`array` 的元素必须已经按递增的值排序;否则，结果可能不正确。</span><span class="sxs-lookup"><span data-stu-id="08e41-167">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable> implementation; otherwise, the result might be incorrect.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-168">如果`value` 未实现 <xref:System.IComparable> 接口，则在搜索开始之前，不会为 <xref:System.IComparable> 测试 `array` 的元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-168">If`value` does not implement the <xref:System.IComparable> interface, the elements of `array` are not tested for <xref:System.IComparable> before the search begins.</span></span> <span data-ttu-id="08e41-169">如果搜索遇到不实现 <xref:System.IComparable>的元素，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-169">An exception is thrown if the search encounters an element that does not implement <xref:System.IComparable>.</span></span>  
  
 <span data-ttu-id="08e41-170">允许重复元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-170">Duplicate elements are allowed.</span></span> <span data-ttu-id="08e41-171">如果 <xref:System.Array> 包含多个等于 `value`的元素，则此方法只返回其中一个匹配项的索引，而不是第一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-171">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="08e41-172">`null` 始终可以与任何其他引用类型进行比较;因此，与 `null` 的比较不会产生异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-172">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-173">对于测试的每个元素，`value` 会传递到适当的 <xref:System.IComparable> 实现，即使 `value` 是 `null`。</span><span class="sxs-lookup"><span data-stu-id="08e41-173">For every element tested, `value` is passed to the appropriate <xref:System.IComparable> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="08e41-174">也就是说，<xref:System.IComparable> 实现确定给定元素如何与 `null`进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-174">That is, the <xref:System.IComparable> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="08e41-175">此方法是 O （log `n`）操作，其中 `n` 是 `array`的 <xref:System.Array.Length%2A>。</span><span class="sxs-lookup"><span data-stu-id="08e41-175">This method is an O(log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-176">下面的代码示例演示如何使用 <xref:System.Array.BinarySearch%2A> 来查找 <xref:System.Array>中的特定对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-176">The following code example shows how to use <xref:System.Array.BinarySearch%2A> to locate a specific object in an <xref:System.Array>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-177">创建数组时，其元素采用升序排序顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-177">The array is created with its elements in ascending sort order.</span></span> <span data-ttu-id="08e41-178"><xref:System.Array.BinarySearch%2A> 方法要求数组按升序排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-178">The <xref:System.Array.BinarySearch%2A> method requires the array to be sorted in ascending order.</span></span>  
  
 [!code-cpp[Classic Array.BinarySearch Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.BinarySearch Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CS/source.cs#1)]
 [!code-vb[Classic Array.BinarySearch Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-179"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-179"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="08e41-180"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="08e41-180"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-181"><paramref name="value" /> 的类型与 <paramref name="array" />的元素不兼容。</span><span class="sxs-lookup"><span data-stu-id="08e41-181"><paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="08e41-182"><paramref name="value" /> 不实现 <see cref="T:System.IComparable" /> 接口，并且搜索遇到不实现 <see cref="T:System.IComparable" /> 接口的元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-182"><paramref name="value" /> does not implement the <see cref="T:System.IComparable" /> interface, and the search encounters an element that does not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-183">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-183">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="08e41-184">要搜索的排序一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-184">The sorted one-dimensional <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="08e41-185">要搜索的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-185">The object to search for.</span></span></param>
        <param name="comparer"><span data-ttu-id="08e41-186">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-186">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.</span></span>  
  
<span data-ttu-id="08e41-187">或</span><span class="sxs-lookup"><span data-stu-id="08e41-187">-or-</span></span> 
 <span data-ttu-id="08e41-188">若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-188"><see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="08e41-189">使用指定 <see cref="T:System.Collections.IComparer" /> 接口，在整个一维排序数组中搜索值。</span><span class="sxs-lookup"><span data-stu-id="08e41-189">Searches an entire one-dimensional sorted array for a value using the specified <see cref="T:System.Collections.IComparer" /> interface.</span></span></summary>
        <returns><span data-ttu-id="08e41-190">如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。</span><span class="sxs-lookup"><span data-stu-id="08e41-190">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="08e41-191">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。</span><span class="sxs-lookup"><span data-stu-id="08e41-191">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="08e41-192">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。</span><span class="sxs-lookup"><span data-stu-id="08e41-192">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="08e41-193">如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</span><span class="sxs-lookup"><span data-stu-id="08e41-193">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-194">此方法不支持搜索包含负索引的数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-194">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="08e41-195">在调用此方法之前，必须对 `array` 进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-195">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="08e41-196">如果 <xref:System.Array> 不包含指定的值，则该方法将返回一个负整数。</span><span class="sxs-lookup"><span data-stu-id="08e41-196">If the <xref:System.Array> does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="08e41-197">可以将按位求补运算符（~ in C#，`Not` 在 Visual Basic 中）应用于负结果，以生成索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-197">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result  to produce an index.</span></span> <span data-ttu-id="08e41-198">如果此索引大于数组的上限，则没有元素大于数组中的 `value`。</span><span class="sxs-lookup"><span data-stu-id="08e41-198">If this index is one greater than the upper bound of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="08e41-199">否则，它是大于 `value`的第一个元素的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-199">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="08e41-200">比较器自定义元素的比较方式。</span><span class="sxs-lookup"><span data-stu-id="08e41-200">The comparer customizes how the elements are compared.</span></span> <span data-ttu-id="08e41-201">例如，可以将 <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> 用作比较器来执行不区分大小写的字符串搜索。</span><span class="sxs-lookup"><span data-stu-id="08e41-201">For example, you can use a <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> as the comparer to perform case-insensitive string searches.</span></span>  
  
 <span data-ttu-id="08e41-202">如果未 `null``comparer`，则使用指定的 <xref:System.Collections.IComparer> 实现将 `array` 的元素与指定的值进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-202">If `comparer` is not `null`, the elements of `array` are compared to the specified value using the specified <xref:System.Collections.IComparer> implementation.</span></span> <span data-ttu-id="08e41-203">`array` 的元素必须已经按 `comparer`定义的排序顺序按递增的值排序;否则，结果可能不正确。</span><span class="sxs-lookup"><span data-stu-id="08e41-203">The elements of `array` must already be sorted in increasing value according to the sort order defined by `comparer`; otherwise, the result might be incorrect.</span></span>  
  
 <span data-ttu-id="08e41-204">如果 `null``comparer`，则使用由元素本身或指定的值提供的 <xref:System.IComparable> 实现进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-204">If`comparer` is `null`, the comparison is done using the <xref:System.IComparable> implementation provided by the element itself or by the specified value.</span></span> <span data-ttu-id="08e41-205">根据 <xref:System.IComparable> 实现定义的排序顺序，`array` 的元素必须已经按递增的值排序;否则，结果可能不正确。</span><span class="sxs-lookup"><span data-stu-id="08e41-205">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable> implementation; otherwise, the result might be incorrect.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-206">如果 `comparer` `null` 并且 `value` 未实现 <xref:System.IComparable> 接口，则在搜索开始之前，不会对 `array` 的元素进行测试。<xref:System.IComparable></span><span class="sxs-lookup"><span data-stu-id="08e41-206">If `comparer` is `null` and `value` does not implement the <xref:System.IComparable> interface, the elements of `array` are not tested for <xref:System.IComparable> before the search begins.</span></span> <span data-ttu-id="08e41-207">如果搜索遇到不实现 <xref:System.IComparable>的元素，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-207">An exception is thrown if the search encounters an element that does not implement <xref:System.IComparable>.</span></span>  
  
 <span data-ttu-id="08e41-208">允许重复元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-208">Duplicate elements are allowed.</span></span> <span data-ttu-id="08e41-209">如果 <xref:System.Array> 包含多个等于 `value`的元素，则此方法只返回其中一个匹配项的索引，而不是第一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-209">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="08e41-210">`null` 始终可以与任何其他引用类型进行比较;因此，与 `null` 的比较不会产生异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-210">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-211">对于测试的每个元素，`value` 会传递到适当的 <xref:System.IComparable> 实现，即使 `value` 是 `null`。</span><span class="sxs-lookup"><span data-stu-id="08e41-211">For every element tested, `value` is passed to the appropriate <xref:System.IComparable> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="08e41-212">也就是说，<xref:System.IComparable> 实现确定给定元素如何与 `null`进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-212">That is, the <xref:System.IComparable> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="08e41-213">此方法是 O （log `n`）操作，其中 `n` 是 `array`的 <xref:System.Array.Length%2A>。</span><span class="sxs-lookup"><span data-stu-id="08e41-213">This method is an O(log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-214"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-214"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="08e41-215"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="08e41-215"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-216"><paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="value" /> 的类型与 <paramref name="array" />的元素不兼容。</span><span class="sxs-lookup"><span data-stu-id="08e41-216"><paramref name="comparer" /> is <see langword="null" />, and <paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="08e41-217"><paramref name="comparer" /> 为 <see langword="null" />，<paramref name="value" /> 不实现 <see cref="T:System.IComparable" /> 接口，并且搜索遇到不实现 <see cref="T:System.IComparable" /> 接口的元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-217"><paramref name="comparer" /> is <see langword="null" />, <paramref name="value" /> does not implement the <see cref="T:System.IComparable" /> interface, and the search encounters an element that does not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-218">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-218">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="08e41-219">要搜索的排序一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-219">The sorted one-dimensional <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="index"><span data-ttu-id="08e41-220">要搜索的范围的起始索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-220">The starting index of the range to search.</span></span></param>
        <param name="length"><span data-ttu-id="08e41-221">要搜索的范围的长度。</span><span class="sxs-lookup"><span data-stu-id="08e41-221">The length of the range to search.</span></span></param>
        <param name="value"><span data-ttu-id="08e41-222">要搜索的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-222">The object to search for.</span></span></param>
        <summary><span data-ttu-id="08e41-223">使用由一维排序数组中每个元素和指定的值实现的 <see cref="T:System.IComparable" /> 接口，在该数组的一个元素范围内搜索值。</span><span class="sxs-lookup"><span data-stu-id="08e41-223">Searches a range of elements in a one-dimensional sorted array for a value, using the <see cref="T:System.IComparable" /> interface implemented by each element of the array and by the specified value.</span></span></summary>
        <returns><span data-ttu-id="08e41-224">如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。</span><span class="sxs-lookup"><span data-stu-id="08e41-224">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="08e41-225">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。</span><span class="sxs-lookup"><span data-stu-id="08e41-225">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="08e41-226">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。</span><span class="sxs-lookup"><span data-stu-id="08e41-226">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="08e41-227">如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</span><span class="sxs-lookup"><span data-stu-id="08e41-227">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-228">此方法不支持搜索包含负索引的数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-228">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="08e41-229">在调用此方法之前，必须对 `array` 进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-229">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="08e41-230">如果 <xref:System.Array> 不包含指定的值，则该方法将返回一个负整数。</span><span class="sxs-lookup"><span data-stu-id="08e41-230">If the <xref:System.Array> does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="08e41-231">可以将按位求补运算符（~ in C#，`Not` 在 Visual Basic 中）应用于负结果，以生成索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-231">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result to produce an index.</span></span> <span data-ttu-id="08e41-232">如果此索引大于数组的上限，则没有元素大于数组中的 `value`。</span><span class="sxs-lookup"><span data-stu-id="08e41-232">If this index is one greater than the upper bound of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="08e41-233">否则，它是大于 `value`的第一个元素的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-233">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="08e41-234">`value` 或 `array` 的每个元素都必须实现用于比较的 <xref:System.IComparable> 接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-234">Either `value` or every element of `array` must implement the <xref:System.IComparable> interface, which is used for comparisons.</span></span> <span data-ttu-id="08e41-235">根据 <xref:System.IComparable> 实现定义的排序顺序，`array` 的元素必须已经按递增的值排序;否则，结果可能不正确。</span><span class="sxs-lookup"><span data-stu-id="08e41-235">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable> implementation; otherwise, the result might be incorrect.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-236">如果 `value` 未实现 <xref:System.IComparable> 接口，则在搜索开始之前，不会为 <xref:System.IComparable> 测试 `array` 的元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-236">If `value` does not implement the <xref:System.IComparable> interface, the elements of `array` are not tested for <xref:System.IComparable> before the search begins.</span></span> <span data-ttu-id="08e41-237">如果搜索遇到不实现 <xref:System.IComparable>的元素，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-237">An exception is thrown if the search encounters an element that does not implement <xref:System.IComparable>.</span></span>  
  
 <span data-ttu-id="08e41-238">允许重复元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-238">Duplicate elements are allowed.</span></span> <span data-ttu-id="08e41-239">如果 <xref:System.Array> 包含多个等于 `value`的元素，则此方法只返回其中一个匹配项的索引，而不是第一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-239">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="08e41-240">`null` 始终可以与任何其他引用类型进行比较;因此，与 `null` 的比较不会产生异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-240">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-241">对于测试的每个元素，`value` 会传递到适当的 <xref:System.IComparable> 实现，即使 `value` 是 `null`。</span><span class="sxs-lookup"><span data-stu-id="08e41-241">For every element tested, `value` is passed to the appropriate <xref:System.IComparable> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="08e41-242">也就是说，<xref:System.IComparable> 实现确定给定元素如何与 `null`进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-242">That is, the <xref:System.IComparable> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="08e41-243">此方法是一个 O （log `n`）操作，其中 `n` 是 `length`的。</span><span class="sxs-lookup"><span data-stu-id="08e41-243">This method is an O(log `n`) operation, where `n` is `length`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-244"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-244"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="08e41-245"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="08e41-245"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-246"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="08e41-246"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
<span data-ttu-id="08e41-247">或</span><span class="sxs-lookup"><span data-stu-id="08e41-247">-or-</span></span> 
 <span data-ttu-id="08e41-248"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-248"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-249"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-249"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span>  
  
<span data-ttu-id="08e41-250">或</span><span class="sxs-lookup"><span data-stu-id="08e41-250">-or-</span></span> 
 <span data-ttu-id="08e41-251"><paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</span><span class="sxs-lookup"><span data-stu-id="08e41-251"><paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="08e41-252"><paramref name="value" /> 不实现 <see cref="T:System.IComparable" /> 接口，并且搜索遇到不实现 <see cref="T:System.IComparable" /> 接口的元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-252"><paramref name="value" /> does not implement the <see cref="T:System.IComparable" /> interface, and the search encounters an element that does not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-253">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-253">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="08e41-254">要搜索的排序一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-254">The sorted one-dimensional <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="index"><span data-ttu-id="08e41-255">要搜索的范围的起始索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-255">The starting index of the range to search.</span></span></param>
        <param name="length"><span data-ttu-id="08e41-256">要搜索的范围的长度。</span><span class="sxs-lookup"><span data-stu-id="08e41-256">The length of the range to search.</span></span></param>
        <param name="value"><span data-ttu-id="08e41-257">要搜索的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-257">The object to search for.</span></span></param>
        <param name="comparer"><span data-ttu-id="08e41-258">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-258">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.</span></span>  
  
<span data-ttu-id="08e41-259">或</span><span class="sxs-lookup"><span data-stu-id="08e41-259">-or-</span></span> 
 <span data-ttu-id="08e41-260">若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-260"><see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="08e41-261">使用指定 <see cref="T:System.Collections.IComparer" /> 接口，在一维排序数组的某个元素范围中搜索值。</span><span class="sxs-lookup"><span data-stu-id="08e41-261">Searches a range of elements in a one-dimensional sorted array for a value, using the specified <see cref="T:System.Collections.IComparer" /> interface.</span></span></summary>
        <returns><span data-ttu-id="08e41-262">如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。</span><span class="sxs-lookup"><span data-stu-id="08e41-262">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="08e41-263">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。</span><span class="sxs-lookup"><span data-stu-id="08e41-263">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="08e41-264">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。</span><span class="sxs-lookup"><span data-stu-id="08e41-264">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="08e41-265">如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</span><span class="sxs-lookup"><span data-stu-id="08e41-265">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-266">此方法不支持搜索包含负索引的数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-266">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="08e41-267">在调用此方法之前，必须对 `array` 进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-267">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="08e41-268">如果 <xref:System.Array> 不包含指定的值，则该方法将返回一个负整数。</span><span class="sxs-lookup"><span data-stu-id="08e41-268">If the <xref:System.Array> does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="08e41-269">可以将按位求补运算符（~ in C#，`Not` 在 Visual Basic 中）应用于负结果，以生成索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-269">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result  to produce an index.</span></span> <span data-ttu-id="08e41-270">如果此索引大于数组的上限，则没有元素大于数组中的 `value`。</span><span class="sxs-lookup"><span data-stu-id="08e41-270">If this index is one greater than the upper bound of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="08e41-271">否则，它是大于 `value`的第一个元素的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-271">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="08e41-272">比较器自定义元素的比较方式。</span><span class="sxs-lookup"><span data-stu-id="08e41-272">The comparer customizes how the elements are compared.</span></span> <span data-ttu-id="08e41-273">例如，可以将 <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> 用作比较器来执行不区分大小写的字符串搜索。</span><span class="sxs-lookup"><span data-stu-id="08e41-273">For example, you can use a <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> as the comparer to perform case-insensitive string searches.</span></span>  
  
 <span data-ttu-id="08e41-274">如果未 `null``comparer`，则使用指定的 <xref:System.Collections.IComparer> 实现将 `array` 的元素与指定的值进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-274">If `comparer` is not `null`, the elements of `array` are compared to the specified value using the specified <xref:System.Collections.IComparer> implementation.</span></span> <span data-ttu-id="08e41-275">`array` 的元素必须已经按 `comparer`定义的排序顺序按递增的值排序;否则，结果可能不正确。</span><span class="sxs-lookup"><span data-stu-id="08e41-275">The elements of `array` must already be sorted in increasing value according to the sort order defined by `comparer`; otherwise, the result might be incorrect.</span></span>  
  
 <span data-ttu-id="08e41-276">如果 `null``comparer`，则使用由元素本身或指定的值提供的 <xref:System.IComparable> 实现进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-276">If `comparer` is `null`, the comparison is done using the <xref:System.IComparable> implementation provided by the element itself or by the specified value.</span></span> <span data-ttu-id="08e41-277">根据 <xref:System.IComparable> 实现定义的排序顺序，`array` 的元素必须已经按递增的值排序;否则，结果可能不正确。</span><span class="sxs-lookup"><span data-stu-id="08e41-277">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable> implementation; otherwise, the result might be incorrect.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-278">如果 `comparer` `null` 并且 `value` 未实现 <xref:System.IComparable> 接口，则在搜索开始之前，不会对 `array` 的元素进行测试。<xref:System.IComparable></span><span class="sxs-lookup"><span data-stu-id="08e41-278">If `comparer` is `null` and `value` does not implement the <xref:System.IComparable> interface, the elements of `array` are not tested for <xref:System.IComparable> before the search begins.</span></span> <span data-ttu-id="08e41-279">如果搜索遇到不实现 <xref:System.IComparable>的元素，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-279">An exception is thrown if the search encounters an element that does not implement <xref:System.IComparable>.</span></span>  
  
 <span data-ttu-id="08e41-280">允许重复元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-280">Duplicate elements are allowed.</span></span> <span data-ttu-id="08e41-281">如果 <xref:System.Array> 包含多个等于 `value`的元素，则此方法只返回其中一个匹配项的索引，而不是第一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-281">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="08e41-282">`null` 始终可以与任何其他引用类型进行比较;因此，使用 <xref:System.IComparable>时，与 `null` 的比较不会生成异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-282">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception when using <xref:System.IComparable>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-283">对于测试的每个元素，`value` 会传递到适当的 <xref:System.IComparable> 实现，即使 `value` 是 `null`。</span><span class="sxs-lookup"><span data-stu-id="08e41-283">For every element tested, `value` is passed to the appropriate <xref:System.IComparable> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="08e41-284">也就是说，<xref:System.IComparable> 实现确定给定元素如何与 `null`进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-284">That is, the <xref:System.IComparable> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="08e41-285">此方法是一个 O （log `n`）操作，其中 `n` 是 `length`的。</span><span class="sxs-lookup"><span data-stu-id="08e41-285">This method is an O(log `n`) operation, where `n` is `length`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-286"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-286"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="08e41-287"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="08e41-287"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-288"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="08e41-288"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
<span data-ttu-id="08e41-289">或</span><span class="sxs-lookup"><span data-stu-id="08e41-289">-or-</span></span> 
 <span data-ttu-id="08e41-290"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-290"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-291"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-291"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span>  
  
<span data-ttu-id="08e41-292">或</span><span class="sxs-lookup"><span data-stu-id="08e41-292">-or-</span></span> 
 <span data-ttu-id="08e41-293"><paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</span><span class="sxs-lookup"><span data-stu-id="08e41-293"><paramref name="comparer" /> is <see langword="null" />, and <paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="08e41-294"><paramref name="comparer" /> 为 <see langword="null" />，<paramref name="value" /> 不实现 <see cref="T:System.IComparable" /> 接口，并且搜索遇到不实现 <see cref="T:System.IComparable" /> 接口的元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-294"><paramref name="comparer" /> is <see langword="null" />, <paramref name="value" /> does not implement the <see cref="T:System.IComparable" /> interface, and the search encounters an element that does not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-295">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-295">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-296">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-296">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-297">要搜索的从零开始的一维排序 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-297">The sorted one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="08e41-298">要搜索的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-298">The object to search for.</span></span></param>
        <summary><span data-ttu-id="08e41-299">使用由 <see cref="T:System.Array" /> 中每个元素和指定对象实现的 <see cref="T:System.IComparable`1" /> 泛型接口，在整个一维排序数组中搜索特定元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-299">Searches an entire one-dimensional sorted array for a specific element, using the <see cref="T:System.IComparable`1" /> generic interface implemented by each element of the <see cref="T:System.Array" /> and by the specified object.</span></span></summary>
        <returns><span data-ttu-id="08e41-300">如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。</span><span class="sxs-lookup"><span data-stu-id="08e41-300">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="08e41-301">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。</span><span class="sxs-lookup"><span data-stu-id="08e41-301">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="08e41-302">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。</span><span class="sxs-lookup"><span data-stu-id="08e41-302">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="08e41-303">如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</span><span class="sxs-lookup"><span data-stu-id="08e41-303">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-304">此方法不支持搜索包含负索引的数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-304">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="08e41-305">在调用此方法之前，必须对 `array` 进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-305">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="08e41-306">如果 `array` 不包含指定的值，则该方法将返回一个负整数。</span><span class="sxs-lookup"><span data-stu-id="08e41-306">If `array` does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="08e41-307">可以将按位求补运算符（~ in C#，`Not` 在 Visual Basic 中）应用于负结果，以生成索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-307">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result  to produce an index.</span></span> <span data-ttu-id="08e41-308">如果此索引等于数组的大小，则没有大于数组中 `value` 的元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-308">If this index is equal to the size of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="08e41-309">否则，它是大于 `value`的第一个元素的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-309">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="08e41-310">`T` 必须实现 <xref:System.IComparable%601> 泛型接口，该接口用于比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-310">`T` must implement the <xref:System.IComparable%601> generic interface, which is used for comparisons.</span></span> <span data-ttu-id="08e41-311">根据 <xref:System.IComparable%601> 实现定义的排序顺序，`array` 的元素必须已经按递增的值排序;否则，结果可能不正确。</span><span class="sxs-lookup"><span data-stu-id="08e41-311">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable%601> implementation; otherwise, the result might be incorrect.</span></span>  
  
 <span data-ttu-id="08e41-312">允许重复元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-312">Duplicate elements are allowed.</span></span> <span data-ttu-id="08e41-313">如果 <xref:System.Array> 包含多个等于 `value`的元素，则此方法只返回其中一个匹配项的索引，而不是第一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-313">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="08e41-314">`null` 始终可以与任何其他引用类型进行比较;因此，与 `null` 的比较不会产生异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-314">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-315">对于测试的每个元素，`value` 会传递到适当的 <xref:System.IComparable%601> 实现，即使 `value` 是 `null`。</span><span class="sxs-lookup"><span data-stu-id="08e41-315">For every element tested, `value` is passed to the appropriate <xref:System.IComparable%601> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="08e41-316">也就是说，<xref:System.IComparable%601> 实现确定给定元素如何与 `null`进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-316">That is, the <xref:System.IComparable%601> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="08e41-317">此方法是 O （log `n`）操作，其中 `n` 是 `array`的 <xref:System.Array.Length%2A>。</span><span class="sxs-lookup"><span data-stu-id="08e41-317">This method is an O(log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-318">下面的代码示例演示 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> 泛型方法重载和 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> 泛型方法重载。</span><span class="sxs-lookup"><span data-stu-id="08e41-318">The following code example demonstrates the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> generic method overload and the <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> generic method overload.</span></span> <span data-ttu-id="08e41-319">创建一个字符串数组，无特定顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-319">An array of strings is created, in no particular order.</span></span>  
  
 <span data-ttu-id="08e41-320">显示、排序并再次显示数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-320">The array is displayed, sorted, and displayed again.</span></span> <span data-ttu-id="08e41-321">必须对数组进行排序才能使用 <xref:System.Array.BinarySearch%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-321">Arrays must be sorted in order to use the <xref:System.Array.BinarySearch%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-322">对 <xref:System.Array.Sort%2A> 和 <xref:System.Array.BinarySearch%2A> 泛型方法的调用与对其非泛型方法的调用没有任何区别，因为 Visual Basic、 C#和C++从第一个参数的类型推断泛型类型参数的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-322">The calls to the <xref:System.Array.Sort%2A> and <xref:System.Array.BinarySearch%2A> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</span></span> <span data-ttu-id="08e41-323">如果使用[Ildasm （IL 拆装器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)检查 Microsoft 中间语言（MSIL），可以看到正在调用泛型方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-323">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 <span data-ttu-id="08e41-324">然后，使用 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> 泛型方法重载搜索两个字符串，一个字符串不在数组中，另一个是。</span><span class="sxs-lookup"><span data-stu-id="08e41-324">The <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> generic method overload is then used to search for two strings, one that is not in the array and one that is.</span></span> <span data-ttu-id="08e41-325"><xref:System.Array.BinarySearch%2A> 方法的数组和返回值将传递给 `ShowWhere` 泛型方法，该方法显示索引值（如果找到该字符串），否则在搜索字符串位于数组中的元素之间将会出现该方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-325">The array and the return value of the <xref:System.Array.BinarySearch%2A> method are passed to the `ShowWhere` generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</span></span> <span data-ttu-id="08e41-326">如果字符串不在数组中，则索引为负; 因此 `ShowWhere` 方法采用按位求补（ C#和中的 ~ 运算符C++，在 Visual Basic 中 `Xor`-1）来获取列表中大于搜索字符串的第一个元素的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-326">The index is negative if the string is not in the array, so the `ShowWhere` method takes the bitwise complement (the ~ operator in C# and Visual C++, `Xor`-1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</span></span>  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-327"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-327"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="08e41-328"><paramref name="T" /> 不实现 <see cref="T:System.IComparable`1" /> 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-328"><paramref name="T" /> does not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-329">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-329">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-330">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-330">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-331">要搜索的从零开始的一维排序 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-331">The sorted one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="08e41-332">要搜索的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-332">The object to search for.</span></span></param>
        <param name="comparer"><span data-ttu-id="08e41-333">比较元素时要使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-333">The <see cref="T:System.Collections.Generic.IComparer`1" /> implementation to use when comparing elements.</span></span>  
  
<span data-ttu-id="08e41-334">或</span><span class="sxs-lookup"><span data-stu-id="08e41-334">-or-</span></span> 
 <span data-ttu-id="08e41-335">若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable`1" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-335"><see langword="null" /> to use the <see cref="T:System.IComparable`1" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="08e41-336">使用指定 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口，在整个一维排序数组中搜索值。</span><span class="sxs-lookup"><span data-stu-id="08e41-336">Searches an entire one-dimensional sorted array for a value using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</span></span></summary>
        <returns><span data-ttu-id="08e41-337">如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。</span><span class="sxs-lookup"><span data-stu-id="08e41-337">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="08e41-338">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。</span><span class="sxs-lookup"><span data-stu-id="08e41-338">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="08e41-339">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。</span><span class="sxs-lookup"><span data-stu-id="08e41-339">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="08e41-340">如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</span><span class="sxs-lookup"><span data-stu-id="08e41-340">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-341">此方法不支持搜索包含负索引的数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-341">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="08e41-342">在调用此方法之前，必须对 `array` 进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-342">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="08e41-343">如果 <xref:System.Array> 不包含指定的值，则该方法将返回一个负整数。</span><span class="sxs-lookup"><span data-stu-id="08e41-343">If the <xref:System.Array> does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="08e41-344">可以将按位求补运算符（~ in C#，`Not` 在 Visual Basic 中）应用于负结果，以生成索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-344">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result to produce an index.</span></span> <span data-ttu-id="08e41-345">如果此索引等于数组的大小，则没有大于数组中 `value` 的元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-345">If this index is equal to the size of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="08e41-346">否则，它是大于 `value`的第一个元素的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-346">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="08e41-347">比较器自定义元素的比较方式。</span><span class="sxs-lookup"><span data-stu-id="08e41-347">The comparer customizes how the elements are compared.</span></span> <span data-ttu-id="08e41-348">例如，可以将 <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> 用作比较器来执行不区分大小写的字符串搜索。</span><span class="sxs-lookup"><span data-stu-id="08e41-348">For example, you can use a <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> as the comparer to perform case-insensitive string searches.</span></span>  
  
 <span data-ttu-id="08e41-349">如果未 `null``comparer`，则使用指定的 <xref:System.Collections.Generic.IComparer%601> 泛型接口实现将 `array` 的元素与指定的值进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-349">If `comparer` is not `null`, the elements of `array` are compared to the specified value using the specified <xref:System.Collections.Generic.IComparer%601> generic interface implementation.</span></span> <span data-ttu-id="08e41-350">`array` 的元素必须已经按 `comparer`定义的排序顺序按递增的值排序;否则，结果可能不正确。</span><span class="sxs-lookup"><span data-stu-id="08e41-350">The elements of `array` must already be sorted in increasing value according to the sort order defined by `comparer`; otherwise, the result might be incorrect.</span></span>  
  
 <span data-ttu-id="08e41-351">如果 `null``comparer`，则使用 `T`提供的 <xref:System.IComparable%601> 泛型接口实现进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-351">If `comparer` is `null`, the comparison is done using the <xref:System.IComparable%601> generic interface implementation provided by `T`.</span></span> <span data-ttu-id="08e41-352">根据 <xref:System.IComparable%601> 实现定义的排序顺序，`array` 的元素必须已经按递增的值排序;否则，结果可能不正确。</span><span class="sxs-lookup"><span data-stu-id="08e41-352">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable%601> implementation; otherwise, the result might be incorrect.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-353">如果 `comparer` `null` 并且 `value` 未实现 <xref:System.IComparable%601> 泛型接口，则在搜索开始之前，不会对 `array` 的元素进行测试。<xref:System.IComparable%601></span><span class="sxs-lookup"><span data-stu-id="08e41-353">If `comparer` is `null` and `value` does not implement the <xref:System.IComparable%601> generic interface, the elements of `array` are not tested for <xref:System.IComparable%601> before the search begins.</span></span> <span data-ttu-id="08e41-354">如果搜索遇到不实现 <xref:System.IComparable%601>的元素，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-354">An exception is thrown if the search encounters an element that does not implement <xref:System.IComparable%601>.</span></span>  
  
 <span data-ttu-id="08e41-355">允许重复元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-355">Duplicate elements are allowed.</span></span> <span data-ttu-id="08e41-356">如果 <xref:System.Array> 包含多个等于 `value`的元素，则此方法只返回其中一个匹配项的索引，而不是第一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-356">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="08e41-357">`null` 始终可以与任何其他引用类型进行比较;因此，与 `null` 的比较不会产生异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-357">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-358">对于测试的每个元素，`value` 会传递到适当的 <xref:System.IComparable%601> 实现，即使 `value` 是 `null`。</span><span class="sxs-lookup"><span data-stu-id="08e41-358">For every element tested, `value` is passed to the appropriate <xref:System.IComparable%601> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="08e41-359">也就是说，<xref:System.IComparable%601> 实现确定给定元素如何与 `null`进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-359">That is, the <xref:System.IComparable%601> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="08e41-360">此方法是 O （log `n`）操作，其中 `n` 是 `array`的 <xref:System.Array.Length%2A>。</span><span class="sxs-lookup"><span data-stu-id="08e41-360">This method is an O(log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-361">下面的示例演示 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 泛型方法重载和 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 泛型方法重载。</span><span class="sxs-lookup"><span data-stu-id="08e41-361">The following example demonstrates the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload and the <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload.</span></span>  
  
 <span data-ttu-id="08e41-362">此代码示例定义了一个名为 `ReverseCompare`的字符串的替代比较器，该比较器实现了 `IComparer<string>` （`IComparer(Of String)` Visual Basic C++，`IComparer<String^>` Visual）泛型接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-362">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="08e41-363">比较器调用 <xref:System.String.CompareTo%28System.String%29> 方法，并反转比较数的顺序，以便字符串排序为高到低而不是低到高。</span><span class="sxs-lookup"><span data-stu-id="08e41-363">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="08e41-364">显示、排序并再次显示数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-364">The array is displayed, sorted, and displayed again.</span></span> <span data-ttu-id="08e41-365">必须对数组进行排序才能使用 <xref:System.Array.BinarySearch%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-365">Arrays must be sorted in order to use the <xref:System.Array.BinarySearch%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-366">对 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 和 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 泛型方法的调用与对其非泛型方法的调用没有任何区别，因为 Visual Basic、 C#和C++从第一个参数的类型推断泛型类型参数的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-366">The calls to the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> and <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</span></span> <span data-ttu-id="08e41-367">如果使用[Ildasm （IL 拆装器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)检查 Microsoft 中间语言（MSIL），可以看到正在调用泛型方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-367">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 <span data-ttu-id="08e41-368">然后，使用 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 泛型方法重载搜索两个字符串，一个字符串不在数组中，另一个是。</span><span class="sxs-lookup"><span data-stu-id="08e41-368">The <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload is then used to search for two strings, one that is not in the array and one that is.</span></span> <span data-ttu-id="08e41-369"><xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 方法的数组和返回值将传递给 `ShowWhere` 泛型方法，该方法显示索引值（如果找到该字符串），否则在搜索字符串位于数组中的元素之间将会出现该方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-369">The array and the return value of the <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> method are passed to the `ShowWhere` generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</span></span> <span data-ttu-id="08e41-370">如果字符串不是 n 数组，则索引为负; 因此 `ShowWhere` 方法采用按位求补（ C#和中的 ~ 运算符C++，在 Visual Basic 中 `Xor`-1）来获取列表中大于搜索字符串的第一个元素的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-370">The index is negative if the string is not n the array, so the `ShowWhere` method takes the bitwise complement (the ~ operator in C# and Visual C++, `Xor` -1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</span></span>  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-371"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-371"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-372"><paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</span><span class="sxs-lookup"><span data-stu-id="08e41-372"><paramref name="comparer" /> is <see langword="null" />, and <paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="08e41-373"><paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="T" /> 不实现 <see cref="T:System.IComparable`1" /> 泛型接口</span><span class="sxs-lookup"><span data-stu-id="08e41-373"><paramref name="comparer" /> is <see langword="null" />, and <paramref name="T" /> does not implement the <see cref="T:System.IComparable`1" /> generic interface</span></span></exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-374">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-374">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-375">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-375">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-376">要搜索的从零开始的一维排序 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-376">The sorted one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="index"><span data-ttu-id="08e41-377">要搜索的范围的起始索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-377">The starting index of the range to search.</span></span></param>
        <param name="length"><span data-ttu-id="08e41-378">要搜索的范围的长度。</span><span class="sxs-lookup"><span data-stu-id="08e41-378">The length of the range to search.</span></span></param>
        <param name="value"><span data-ttu-id="08e41-379">要搜索的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-379">The object to search for.</span></span></param>
        <summary><span data-ttu-id="08e41-380">使用由 <see cref="T:System.Array" /> 中每个元素和指定值实现的 <see cref="T:System.IComparable`1" /> 泛型接口，在一维排序数组的某个元素范围中搜索值。</span><span class="sxs-lookup"><span data-stu-id="08e41-380">Searches a range of elements in a one-dimensional sorted array for a value, using the <see cref="T:System.IComparable`1" /> generic interface implemented by each element of the <see cref="T:System.Array" /> and by the specified value.</span></span></summary>
        <returns><span data-ttu-id="08e41-381">如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。</span><span class="sxs-lookup"><span data-stu-id="08e41-381">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="08e41-382">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。</span><span class="sxs-lookup"><span data-stu-id="08e41-382">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="08e41-383">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。</span><span class="sxs-lookup"><span data-stu-id="08e41-383">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="08e41-384">如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</span><span class="sxs-lookup"><span data-stu-id="08e41-384">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-385">此方法不支持搜索包含负索引的数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-385">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="08e41-386">在调用此方法之前，必须对 `array` 进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-386">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="08e41-387">如果数组不包含指定的值，则该方法返回一个负整数。</span><span class="sxs-lookup"><span data-stu-id="08e41-387">If the array does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="08e41-388">可以将按位求补运算符（~ in C#，`Not` 在 Visual Basic 中）应用于负结果，以生成索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-388">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result  to produce an index.</span></span> <span data-ttu-id="08e41-389">如果此索引等于数组的大小，则没有大于数组中 `value` 的元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-389">If this index is equal to the size of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="08e41-390">否则，它是大于 `value`的第一个元素的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-390">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="08e41-391">`T` 必须实现 <xref:System.IComparable%601> 泛型接口，该接口用于比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-391">`T` must implement the <xref:System.IComparable%601> generic interface, which is used for comparisons.</span></span> <span data-ttu-id="08e41-392">根据 <xref:System.IComparable%601> 实现定义的排序顺序，`array` 的元素必须已经按递增的值排序;否则，结果可能不正确。</span><span class="sxs-lookup"><span data-stu-id="08e41-392">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable%601> implementation; otherwise, the result might be incorrect.</span></span>  
  
 <span data-ttu-id="08e41-393">允许重复元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-393">Duplicate elements are allowed.</span></span> <span data-ttu-id="08e41-394">如果 <xref:System.Array> 包含多个等于 `value`的元素，则此方法只返回其中一个匹配项的索引，而不是第一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-394">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="08e41-395">`null` 始终可以与任何其他引用类型进行比较;因此，与 `null` 的比较不会产生异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-395">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-396">对于测试的每个元素，`value` 会传递到适当的 <xref:System.IComparable%601> 实现，即使 `value` 是 `null`。</span><span class="sxs-lookup"><span data-stu-id="08e41-396">For every element tested, `value` is passed to the appropriate <xref:System.IComparable%601> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="08e41-397">也就是说，<xref:System.IComparable%601> 实现确定给定元素如何与 `null`进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-397">That is, the <xref:System.IComparable%601> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="08e41-398">此方法是一个 O （log `n`）操作，其中 `n` 是 `length`的。</span><span class="sxs-lookup"><span data-stu-id="08e41-398">This method is an O(log `n`) operation, where `n` is `length`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-399"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-399"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-400"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="08e41-400"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
<span data-ttu-id="08e41-401">或</span><span class="sxs-lookup"><span data-stu-id="08e41-401">-or-</span></span> 
 <span data-ttu-id="08e41-402"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-402"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-403"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-403"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span>  
  
<span data-ttu-id="08e41-404">或</span><span class="sxs-lookup"><span data-stu-id="08e41-404">-or-</span></span> 
 <span data-ttu-id="08e41-405"><paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</span><span class="sxs-lookup"><span data-stu-id="08e41-405"><paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="08e41-406"><paramref name="T" /> 不实现 <see cref="T:System.IComparable`1" /> 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-406"><paramref name="T" /> does not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-407">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-407">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-408">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-408">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-409">要搜索的从零开始的一维排序 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-409">The sorted one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="index"><span data-ttu-id="08e41-410">要搜索的范围的起始索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-410">The starting index of the range to search.</span></span></param>
        <param name="length"><span data-ttu-id="08e41-411">要搜索的范围的长度。</span><span class="sxs-lookup"><span data-stu-id="08e41-411">The length of the range to search.</span></span></param>
        <param name="value"><span data-ttu-id="08e41-412">要搜索的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-412">The object to search for.</span></span></param>
        <param name="comparer"><span data-ttu-id="08e41-413">比较元素时要使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-413">The <see cref="T:System.Collections.Generic.IComparer`1" /> implementation to use when comparing elements.</span></span>  
  
<span data-ttu-id="08e41-414">或</span><span class="sxs-lookup"><span data-stu-id="08e41-414">-or-</span></span> 
 <span data-ttu-id="08e41-415">若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable`1" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-415"><see langword="null" /> to use the <see cref="T:System.IComparable`1" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="08e41-416">使用指定 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口，在一维排序数组的某个元素范围中搜索值。</span><span class="sxs-lookup"><span data-stu-id="08e41-416">Searches a range of elements in a one-dimensional sorted array for a value, using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</span></span></summary>
        <returns><span data-ttu-id="08e41-417">如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。</span><span class="sxs-lookup"><span data-stu-id="08e41-417">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="08e41-418">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。</span><span class="sxs-lookup"><span data-stu-id="08e41-418">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="08e41-419">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。</span><span class="sxs-lookup"><span data-stu-id="08e41-419">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="08e41-420">如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</span><span class="sxs-lookup"><span data-stu-id="08e41-420">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-421">此方法不支持搜索包含负索引的数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-421">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="08e41-422">在调用此方法之前，必须对 `array` 进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-422">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="08e41-423">如果数组不包含指定的值，则该方法返回一个负整数。</span><span class="sxs-lookup"><span data-stu-id="08e41-423">If the array does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="08e41-424">可以将按位求补运算符（~ in C#，`Not` 在 Visual Basic 中）应用于负结果，以生成索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-424">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result  to produce an index.</span></span> <span data-ttu-id="08e41-425">如果此索引等于数组的大小，则没有大于数组中 `value` 的元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-425">If this index is equal to the size of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="08e41-426">否则，它是大于 `value`的第一个元素的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-426">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="08e41-427">比较器自定义元素的比较方式。</span><span class="sxs-lookup"><span data-stu-id="08e41-427">The comparer customizes how the elements are compared.</span></span> <span data-ttu-id="08e41-428">例如，可以将 <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> 用作比较器来执行不区分大小写的字符串搜索。</span><span class="sxs-lookup"><span data-stu-id="08e41-428">For example, you can use a <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> as the comparer to perform case-insensitive string searches.</span></span>  
  
 <span data-ttu-id="08e41-429">如果未 `null``comparer`，则使用指定的 <xref:System.Collections.Generic.IComparer%601> 泛型接口实现将 `array` 的元素与指定的值进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-429">If `comparer` is not `null`, the elements of `array` are compared to the specified value using the specified <xref:System.Collections.Generic.IComparer%601> generic interface implementation.</span></span> <span data-ttu-id="08e41-430">`array` 的元素必须已经按 `comparer`定义的排序顺序按递增的值排序;否则，结果可能不正确。</span><span class="sxs-lookup"><span data-stu-id="08e41-430">The elements of `array` must already be sorted in increasing value according to the sort order defined by `comparer`; otherwise, the result might be incorrect.</span></span>  
  
 <span data-ttu-id="08e41-431">如果 `null``comparer`，则使用为类型 `T`提供的 <xref:System.IComparable%601> 泛型接口实现进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-431">If `comparer` is `null`, the comparison is done using the <xref:System.IComparable%601> generic interface implementation provided for type `T`.</span></span> <span data-ttu-id="08e41-432">根据 <xref:System.IComparable%601> 实现定义的排序顺序，`array` 的元素必须已经按递增的值排序;否则，结果可能不正确。</span><span class="sxs-lookup"><span data-stu-id="08e41-432">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable%601> implementation; otherwise, the result might be incorrect.</span></span>  
  
 <span data-ttu-id="08e41-433">允许重复元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-433">Duplicate elements are allowed.</span></span> <span data-ttu-id="08e41-434">如果 <xref:System.Array> 包含多个等于 `value`的元素，则此方法只返回其中一个匹配项的索引，而不是第一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-434">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="08e41-435">`null` 始终可以与任何其他引用类型进行比较;因此，使用 <xref:System.IComparable%601>时，与 `null` 的比较不会生成异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-435">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception when using <xref:System.IComparable%601>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-436">对于测试的每个元素，`value` 会传递到适当的 <xref:System.IComparable%601> 实现，即使 `value` 是 `null`。</span><span class="sxs-lookup"><span data-stu-id="08e41-436">For every element tested, `value` is passed to the appropriate <xref:System.IComparable%601> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="08e41-437">也就是说，<xref:System.IComparable%601> 实现确定给定元素如何与 `null`进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-437">That is, the <xref:System.IComparable%601> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="08e41-438">此方法是一个 O （log `n`）操作，其中 `n` 是 `length`的。</span><span class="sxs-lookup"><span data-stu-id="08e41-438">This method is an O(log `n`) operation, where `n` is `length`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-439"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-439"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-440"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="08e41-440"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
<span data-ttu-id="08e41-441">或</span><span class="sxs-lookup"><span data-stu-id="08e41-441">-or-</span></span> 
 <span data-ttu-id="08e41-442"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-442"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-443"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-443"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span>  
  
<span data-ttu-id="08e41-444">或</span><span class="sxs-lookup"><span data-stu-id="08e41-444">-or-</span></span> 
 <span data-ttu-id="08e41-445"><paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</span><span class="sxs-lookup"><span data-stu-id="08e41-445"><paramref name="comparer" /> is <see langword="null" />, and <paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="08e41-446"><paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="T" /> 不实现 <see cref="T:System.IComparable`1" /> 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-446"><paramref name="comparer" /> is <see langword="null" />, and <paramref name="T" /> does not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-447">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-447">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clear(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Clear : Array * int * int -&gt; unit" Usage="System.Array.Clear (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="08e41-448">需要清除其元素的数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-448">The array whose elements need to be cleared.</span></span></param>
        <param name="index"><span data-ttu-id="08e41-449">要清除的一系列元素的起始索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-449">The starting index of the range of elements to clear.</span></span></param>
        <param name="length"><span data-ttu-id="08e41-450">要清除的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-450">The number of elements to clear.</span></span></param>
        <summary><span data-ttu-id="08e41-451">将数组中的某个范围的元素设置为每个元素类型的默认值。</span><span class="sxs-lookup"><span data-stu-id="08e41-451">Sets a range of elements in an array to the default value of each element type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-452">此方法将数组中的每个元素重置为元素类型的默认值。</span><span class="sxs-lookup"><span data-stu-id="08e41-452">This method resets each element in an array to the element type's default value.</span></span> <span data-ttu-id="08e41-453">它将引用类型的元素（包括 <xref:System.String> 元素）设置为 `null`，并将值类型的元素设置为下表中显示的默认值。</span><span class="sxs-lookup"><span data-stu-id="08e41-453">It sets elements of reference types (including <xref:System.String> elements) to `null`, and sets elements of value types to the default values shown in the following table.</span></span>  
  
|<span data-ttu-id="08e41-454">类型</span><span class="sxs-lookup"><span data-stu-id="08e41-454">Type</span></span>|<span data-ttu-id="08e41-455">值</span><span class="sxs-lookup"><span data-stu-id="08e41-455">Value</span></span>|  
|----------|-----------|  
|<xref:System.Boolean>|`false`|  
|<span data-ttu-id="08e41-456">所有整型和浮点型数值类型</span><span class="sxs-lookup"><span data-stu-id="08e41-456">All integral and floating point numeric types</span></span>|<span data-ttu-id="08e41-457">0（零）</span><span class="sxs-lookup"><span data-stu-id="08e41-457">0 (zero)</span></span>|  
|<xref:System.DateTime>|<xref:System.DateTime.MinValue?displayProperty=nameWithType>|  
|<span data-ttu-id="08e41-458">其他值类型</span><span class="sxs-lookup"><span data-stu-id="08e41-458">Other value types</span></span>|<span data-ttu-id="08e41-459">类型字段的默认值</span><span class="sxs-lookup"><span data-stu-id="08e41-459">Default value of the type's fields</span></span>|  
  
 <span data-ttu-id="08e41-460">已清除元素的范围在多维数组的行与行之间进行换行。</span><span class="sxs-lookup"><span data-stu-id="08e41-460">The range of cleared elements wrap from row to row in a multi-dimensional array.</span></span>  
  
 <span data-ttu-id="08e41-461">此方法仅清除元素的值;它不会删除元素本身。</span><span class="sxs-lookup"><span data-stu-id="08e41-461">This method only clears the values of the elements; it does not delete the elements themselves.</span></span> <span data-ttu-id="08e41-462">数组具有固定的大小;因此，无法添加或删除元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-462">An array has a fixed size; therefore, elements cannot be added or removed.</span></span>  
  
 <span data-ttu-id="08e41-463">此方法是一个 O （`n`）操作，其中 `n` 是 `length`的。</span><span class="sxs-lookup"><span data-stu-id="08e41-463">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-464">下面的示例使用 <xref:System.Array.Clear%2A> 方法来重置一维二维数组中的整数值。</span><span class="sxs-lookup"><span data-stu-id="08e41-464">The following example uses the <xref:System.Array.Clear%2A> method to reset integer values in a one-dimensional, two-dimensional, and three-dimensional array.</span></span>  
  
 [!code-csharp[System.Array.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/example.cs#1)]
 [!code-vb[System.Array.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/example.vb#1)]  
  
 <span data-ttu-id="08e41-465">下面的示例定义了一个 `TimeZoneTime` 结构，该结构包含一个 <xref:System.TimeZoneInfo> 字段和一个 <xref:System.DateTimeOffset> 字段。</span><span class="sxs-lookup"><span data-stu-id="08e41-465">The following example defines a `TimeZoneTime` structure that includes a <xref:System.TimeZoneInfo> field and a <xref:System.DateTimeOffset> field.</span></span> <span data-ttu-id="08e41-466">然后，它调用 <xref:System.Array.Clear%2A> 方法，以清除 `TimeZoneTime` 值的两元素数组中的一个元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-466">It then calls the <xref:System.Array.Clear%2A> method to clear one element in a two-element array of `TimeZoneTime` values.</span></span> <span data-ttu-id="08e41-467">方法将已清除元素的值设置为 <xref:System.TimeZoneInfo> 对象的默认值，此值为 `null`，而 <xref:System.DateTimeOffset> 对象的默认值 <xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="08e41-467">The method sets the value of the cleared element to the default value of a <xref:System.TimeZoneInfo> object, which is `null`, and the default value of a <xref:System.DateTimeOffset> object, which is <xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Array.Clear#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/clearstruct1.cs#2)]
 [!code-vb[System.Array.Clear#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/clearstruct1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-468"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-468"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="08e41-469"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="08e41-469"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
<span data-ttu-id="08e41-470">或</span><span class="sxs-lookup"><span data-stu-id="08e41-470">-or-</span></span> 
 <span data-ttu-id="08e41-471"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-471"><paramref name="length" /> is less than zero.</span></span>  
  
<span data-ttu-id="08e41-472">或</span><span class="sxs-lookup"><span data-stu-id="08e41-472">-or-</span></span> 
<span data-ttu-id="08e41-473"><paramref name="index" /> 和 <paramref name="length" /> 大于 <paramref name="array" /> 的大小。</span><span class="sxs-lookup"><span data-stu-id="08e41-473">The sum of <paramref name="index" /> and <paramref name="length" /> is greater than the size of <paramref name="array" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Clone() cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Clone();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; obj" Usage="array.Clone " FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="array.Clone " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public virtual object Clone ();" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="08e41-474">创建 <see cref="T:System.Array" /> 的浅表副本。</span><span class="sxs-lookup"><span data-stu-id="08e41-474">Creates a shallow copy of the <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="08e41-475"><see cref="T:System.Array" /> 的浅表副本。</span><span class="sxs-lookup"><span data-stu-id="08e41-475">A shallow copy of the <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-476"><xref:System.Array> 的浅表副本仅复制 <xref:System.Array>的元素，无论它们是引用类型还是值类型，但不复制引用所引用的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-476">A shallow copy of an <xref:System.Array> copies only the elements of the <xref:System.Array>, whether they are reference types or value types, but it does not copy the objects that the references refer to.</span></span> <span data-ttu-id="08e41-477">新 <xref:System.Array> 中的引用指向原始 <xref:System.Array> 中的引用所指向的相同对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-477">The references in the new <xref:System.Array> point to the same objects that the references in the original <xref:System.Array> point to.</span></span>  
  
 <span data-ttu-id="08e41-478">与此相反，<xref:System.Array> 的深层副本会复制元素以及元素直接或间接引用的所有内容。</span><span class="sxs-lookup"><span data-stu-id="08e41-478">In contrast, a deep copy of an <xref:System.Array> copies the elements and everything directly or indirectly referenced by the elements.</span></span>  
  
 <span data-ttu-id="08e41-479">克隆的 <xref:System.Type> 与原始 <xref:System.Array>相同。</span><span class="sxs-lookup"><span data-stu-id="08e41-479">The clone is of the same <xref:System.Type> as the original <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="08e41-480">此方法是一个 O （`n`）操作，其中 `n` 是 <xref:System.Array.Length%2A>的。</span><span class="sxs-lookup"><span data-stu-id="08e41-480">This method is an O(`n`) operation, where `n` is <xref:System.Array.Length%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-481">下面的代码示例克隆一个 <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> 数组，并演示浅表副本的行为。</span><span class="sxs-lookup"><span data-stu-id="08e41-481">The following code example clones a <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> array and demonstrates the behavior of a shallow copy.</span></span>  
  
 [!code-cpp[System.Array.Clone#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Clone/CPP/arrayclone.cpp#1)]
 [!code-csharp[System.Array.Clone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clone/CS/arrayclone.cs#1)]
 [!code-vb[System.Array.Clone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clone/VB/arrayclone.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ConstrainedCopy">
      <MemberSignature Language="C#" Value="public static void ConstrainedCopy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConstrainedCopy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConstrainedCopy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ConstrainedCopy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member ConstrainedCopy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.ConstrainedCopy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationArray" Type="System.Array" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationIndex" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceArray"><span data-ttu-id="08e41-482">包含要复制的数据的 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-482">The <see cref="T:System.Array" /> that contains the data to copy.</span></span></param>
        <param name="sourceIndex"><span data-ttu-id="08e41-483">一个 32 位整数，它表示 <paramref name="sourceArray" /> 中复制开始处的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-483">A 32-bit integer that represents the index in the <paramref name="sourceArray" /> at which copying begins.</span></span></param>
        <param name="destinationArray"><span data-ttu-id="08e41-484">接收数据的 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-484">The <see cref="T:System.Array" /> that receives the data.</span></span></param>
        <param name="destinationIndex"><span data-ttu-id="08e41-485">一个 32 位整数，它表示 <paramref name="destinationArray" /> 中存储开始处的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-485">A 32-bit integer that represents the index in the <paramref name="destinationArray" /> at which storing begins.</span></span></param>
        <param name="length"><span data-ttu-id="08e41-486">一个 32 位整数，它表示要复制的元素数目。</span><span class="sxs-lookup"><span data-stu-id="08e41-486">A 32-bit integer that represents the number of elements to copy.</span></span></param>
        <summary><span data-ttu-id="08e41-487">复制 <see cref="T:System.Array" /> 中的一系列元素（从指定的源索引开始），并将它们粘贴到另一 <see cref="T:System.Array" /> 中（从指定的目标索引开始）。</span><span class="sxs-lookup"><span data-stu-id="08e41-487">Copies a range of elements from an <see cref="T:System.Array" /> starting at the specified source index and pastes them to another <see cref="T:System.Array" /> starting at the specified destination index.</span></span>  <span data-ttu-id="08e41-488">保证在复制未成功完成的情况下撤消所有更改。</span><span class="sxs-lookup"><span data-stu-id="08e41-488">Guarantees that all changes are undone if the copy does not succeed completely.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-489">`sourceArray` 和 `destinationArray` 参数必须具有相同的维数。</span><span class="sxs-lookup"><span data-stu-id="08e41-489">The `sourceArray` and `destinationArray` parameters must have the same number of dimensions.</span></span>  <span data-ttu-id="08e41-490">`sourceArray` 类型必须与 `destinationArray` 类型相同或派生。否则，会引发 <xref:System.ArrayTypeMismatchException>。</span><span class="sxs-lookup"><span data-stu-id="08e41-490">The `sourceArray` type must be the same as or derived from the `destinationArray` type; otherwise, an <xref:System.ArrayTypeMismatchException> is thrown.</span></span>  <span data-ttu-id="08e41-491">与 <xref:System.Array.Copy%2A>不同，<xref:System.Array.ConstrainedCopy%2A> 在执行任何操作之前验证数组类型的兼容性。</span><span class="sxs-lookup"><span data-stu-id="08e41-491">Unlike <xref:System.Array.Copy%2A>, <xref:System.Array.ConstrainedCopy%2A> verifies the compatibility of the array types before performing any operation.</span></span>  
  
 <span data-ttu-id="08e41-492">在多维数组之间复制时，数组的行为类似于一维数组，其中的行（或列）在概念上是端到端的布局。</span><span class="sxs-lookup"><span data-stu-id="08e41-492">When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end.</span></span> <span data-ttu-id="08e41-493">例如，如果一个数组有三行（或两列），其中每个行都有四个元素，则从该数组的开头复制六个元素将复制第一行（或列）的所有四个元素和第二行（或列）的前两个元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-493">For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</span></span> <span data-ttu-id="08e41-494">若要从第三行（或列）的第二个元素开始复制，`sourceIndex` 必须是第一行（或列）加上第二行（或列）加两行的上限。</span><span class="sxs-lookup"><span data-stu-id="08e41-494">To start copying from the second element of the third row (or column), `sourceIndex` must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</span></span>  
  
 <span data-ttu-id="08e41-495">如果 `sourceArray` 和 `destinationArray` 重叠，此方法的行为就像在覆盖 `destinationArray` 之前，在临时位置保留 `sourceArray` 的原始值。</span><span class="sxs-lookup"><span data-stu-id="08e41-495">If `sourceArray` and `destinationArray` overlap, this method behaves as if the original values of `sourceArray` were preserved in a temporary location before `destinationArray` is overwritten.</span></span>  
  
 <span data-ttu-id="08e41-496">[C++]</span><span class="sxs-lookup"><span data-stu-id="08e41-496">[C++]</span></span>  
  
 <span data-ttu-id="08e41-497">此方法等效于标准 C/C++函数 `memmove`，而不是 `memcpy`。</span><span class="sxs-lookup"><span data-stu-id="08e41-497">This method is equivalent to the standard C/C++ function `memmove`, not `memcpy`.</span></span>  
  
 <span data-ttu-id="08e41-498">数组可以是引用类型的数组或值类型数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-498">The arrays can be reference-type arrays or value-type arrays.</span></span>  <span data-ttu-id="08e41-499">如果 `sourceArray` 和 `destinationArray` 均为引用类型数组，或是 <xref:System.Object>类型的数组，则执行浅表复制。</span><span class="sxs-lookup"><span data-stu-id="08e41-499">If `sourceArray` and `destinationArray` are both reference-type arrays or are both arrays of type <xref:System.Object>, a shallow copy is performed.</span></span> <span data-ttu-id="08e41-500"><xref:System.Array> 的浅表副本是新 <xref:System.Array>，它包含对与原始 <xref:System.Array>相同的元素的引用。</span><span class="sxs-lookup"><span data-stu-id="08e41-500">A shallow copy of an <xref:System.Array> is a new <xref:System.Array> containing references to the same elements as the original <xref:System.Array>.</span></span> <span data-ttu-id="08e41-501">不复制元素本身或元素所引用的任何内容。</span><span class="sxs-lookup"><span data-stu-id="08e41-501">The elements themselves or anything referenced by the elements are not copied.</span></span> <span data-ttu-id="08e41-502">与此相反，<xref:System.Array> 的深层副本会复制元素以及元素直接或间接引用的所有内容。</span><span class="sxs-lookup"><span data-stu-id="08e41-502">In contrast, a deep copy of an <xref:System.Array> copies the elements and everything directly or indirectly referenced by the elements.</span></span>  
  
 <span data-ttu-id="08e41-503">如果此方法在复制时引发异常，则 `destinationArray` 保持不变;因此，可以在受约束的执行区域（<xref:System.Runtime.ConstrainedExecution.Cer>）中使用 <xref:System.Array.ConstrainedCopy%2A>。</span><span class="sxs-lookup"><span data-stu-id="08e41-503">If this method throws an exception while copying, the `destinationArray` remains unchanged; therefore, <xref:System.Array.ConstrainedCopy%2A> can be used within a constrained execution region (<xref:System.Runtime.ConstrainedExecution.Cer>).</span></span>  
  
 <span data-ttu-id="08e41-504">此方法是一个 O （`n`）操作，其中 `n` 是 `length`的。</span><span class="sxs-lookup"><span data-stu-id="08e41-504">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-505"><paramref name="sourceArray" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-505"><paramref name="sourceArray" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="08e41-506">或</span><span class="sxs-lookup"><span data-stu-id="08e41-506">-or-</span></span> 
 <span data-ttu-id="08e41-507"><paramref name="destinationArray" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-507"><paramref name="destinationArray" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="08e41-508"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 具有不同的秩。</span><span class="sxs-lookup"><span data-stu-id="08e41-508"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</span></span></exception>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="08e41-509"><paramref name="sourceArray" /> 类型与 <paramref name="destinationArray" /> 类型不同，且不派生自后者。</span><span class="sxs-lookup"><span data-stu-id="08e41-509">The <paramref name="sourceArray" /> type is neither the same as nor derived from the <paramref name="destinationArray" /> type.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="08e41-510"><paramref name="sourceArray" /> 中至少有一个元素无法转换为 <paramref name="destinationArray" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-510">At least one element in <paramref name="sourceArray" /> cannot be cast to the type of <paramref name="destinationArray" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-511"><paramref name="sourceIndex" /> 少于 <paramref name="sourceArray" /> 的第一个维度的下限。</span><span class="sxs-lookup"><span data-stu-id="08e41-511"><paramref name="sourceIndex" /> is less than the lower bound of the first dimension of <paramref name="sourceArray" />.</span></span>  
  
<span data-ttu-id="08e41-512">或</span><span class="sxs-lookup"><span data-stu-id="08e41-512">-or-</span></span> 
 <span data-ttu-id="08e41-513"><paramref name="destinationIndex" /> 少于 <paramref name="destinationArray" /> 的第一个维度的下限。</span><span class="sxs-lookup"><span data-stu-id="08e41-513"><paramref name="destinationIndex" /> is less than the lower bound of the first dimension of <paramref name="destinationArray" />.</span></span>  
  
<span data-ttu-id="08e41-514">或</span><span class="sxs-lookup"><span data-stu-id="08e41-514">-or-</span></span> 
 <span data-ttu-id="08e41-515"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-515"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-516"><paramref name="length" /> 大于从 <paramref name="sourceIndex" /> 到 <paramref name="sourceArray" /> 末尾的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-516"><paramref name="length" /> is greater than the number of elements from <paramref name="sourceIndex" /> to the end of <paramref name="sourceArray" />.</span></span>  
  
<span data-ttu-id="08e41-517">或</span><span class="sxs-lookup"><span data-stu-id="08e41-517">-or-</span></span> 
 <span data-ttu-id="08e41-518"><paramref name="length" /> 大于从 <paramref name="destinationIndex" /> 到 <paramref name="destinationArray" /> 末尾的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-518"><paramref name="length" /> is greater than the number of elements from <paramref name="destinationIndex" /> to the end of <paramref name="destinationArray" />.</span></span></exception>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.Clone" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.Cer" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput[] ConvertAll&lt;TInput,TOutput&gt; (TInput[] array, Converter&lt;TInput,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput[] ConvertAll&lt;TInput, TOutput&gt;(!!TInput[] array, class System.Converter`2&lt;!!TInput, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertAll(Of TInput, TOutput) (array As TInput(), converter As Converter(Of TInput, TOutput)) As TOutput()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput, typename TOutput&gt;&#xA; static cli::array &lt;TOutput&gt; ^ ConvertAll(cli::array &lt;TInput&gt; ^ array, Converter&lt;TInput, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="static member ConvertAll : 'Input[] * Converter&lt;'Input, 'Output&gt; -&gt; 'Output[]" Usage="System.Array.ConvertAll (array, converter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="TInput[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="converter" Type="System.Converter&lt;TInput,TOutput&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TInput"><span data-ttu-id="08e41-519">源数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-519">The type of the elements of the source array.</span></span></typeparam>
        <typeparam name="TOutput"><span data-ttu-id="08e41-520">目标数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-520">The type of the elements of the target array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-521">要转换为目标类型的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-521">The one-dimensional, zero-based <see cref="T:System.Array" /> to convert to a target type.</span></span></param>
        <param name="converter"><span data-ttu-id="08e41-522">用于将每个元素从一种类型转换为另一种类型的 <see cref="T:System.Converter`2" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-522">A <see cref="T:System.Converter`2" /> that converts each element from one type to another type.</span></span></param>
        <summary><span data-ttu-id="08e41-523">将一种类型的数组转换为另一种类型的数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-523">Converts an array of one type to an array of another type.</span></span></summary>
        <returns><span data-ttu-id="08e41-524">目标类型的数组，包含从源数组转换而来的元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-524">An array of the target type containing the converted elements from the source array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-525"><xref:System.Converter%602> 是对方法的委托，该方法将对象转换为目标类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-525">The <xref:System.Converter%602> is a delegate to a method that converts an object to the target type.</span></span>  <span data-ttu-id="08e41-526">`array` 的元素分别传递到 <xref:System.Converter%602>，转换后的元素保存在新数组中。</span><span class="sxs-lookup"><span data-stu-id="08e41-526">The elements of `array` are individually passed to the <xref:System.Converter%602>, and the converted elements are saved in the new array.</span></span>  
  
 <span data-ttu-id="08e41-527">源 `array` 保持不变。</span><span class="sxs-lookup"><span data-stu-id="08e41-527">The source `array` remains unchanged.</span></span>  
  
 <span data-ttu-id="08e41-528">此方法是一个 O （`n`）操作，其中 `n` 是 `array`的 <xref:System.Array.Length%2A>。</span><span class="sxs-lookup"><span data-stu-id="08e41-528">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-529">下面的代码示例定义了一个名为 `PointFToPoint` 的方法，该方法将 <xref:System.Drawing.PointF> 结构转换为 <xref:System.Drawing.Point> 结构。</span><span class="sxs-lookup"><span data-stu-id="08e41-529">The following code example defines a method named `PointFToPoint` that converts a <xref:System.Drawing.PointF> structure to a <xref:System.Drawing.Point> structure.</span></span> <span data-ttu-id="08e41-530">然后，该示例创建一个 <xref:System.Drawing.PointF> 结构的数组，创建一个 `Converter<PointF, Point>` 委托（在 Visual Basic 中为`Converter(Of PointF, Point)`）以表示 `PointFToPoint` 方法，并将该委托传递给 <xref:System.Array.ConvertAll%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-530">The example then creates an array of <xref:System.Drawing.PointF> structures, creates a `Converter<PointF, Point>` delegate (`Converter(Of PointF, Point)` in Visual Basic) to represent the `PointFToPoint` method, and passes the delegate to the <xref:System.Array.ConvertAll%2A> method.</span></span> <span data-ttu-id="08e41-531"><xref:System.Array.ConvertAll%2A> 方法将输入列表的每个元素传递到 `PointFToPoint` 方法，并将转换后的元素放入 <xref:System.Drawing.Point> 结构的新列表中。</span><span class="sxs-lookup"><span data-stu-id="08e41-531">The <xref:System.Array.ConvertAll%2A> method passes each element of the input list to the `PointFToPoint` method and puts the converted elements into a new list of <xref:System.Drawing.Point> structures.</span></span> <span data-ttu-id="08e41-532">将显示这两个列表。</span><span class="sxs-lookup"><span data-stu-id="08e41-532">Both lists are displayed.</span></span>  
  
 [!code-cpp[Array_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[Array_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_ConvertAll/cs/source.cs#1)]
 [!code-vb[Array_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-533"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-533"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="08e41-534">或</span><span class="sxs-lookup"><span data-stu-id="08e41-534">-or-</span></span> 
 <span data-ttu-id="08e41-535"><paramref name="converter" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-535"><paramref name="converter" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="08e41-536">将一个 <see cref="T:System.Array" /> 的一部分元素复制到另一个 <see cref="T:System.Array" /> 中，并根据需要执行类型转换和装箱。</span><span class="sxs-lookup"><span data-stu-id="08e41-536">Copies a range of elements in one <see cref="T:System.Array" /> to another <see cref="T:System.Array" /> and performs type casting and boxing as required.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray"><span data-ttu-id="08e41-537">包含要复制的数据的 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-537">The <see cref="T:System.Array" /> that contains the data to copy.</span></span></param>
        <param name="destinationArray"><span data-ttu-id="08e41-538">接收数据的 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-538">The <see cref="T:System.Array" /> that receives the data.</span></span></param>
        <param name="length"><span data-ttu-id="08e41-539">一个 32 位整数，它表示要复制的元素数目。</span><span class="sxs-lookup"><span data-stu-id="08e41-539">A 32-bit integer that represents the number of elements to copy.</span></span></param>
        <summary><span data-ttu-id="08e41-540">从第一个元素开始复制 <see cref="T:System.Array" /> 中的一系列元素，将它们粘贴到另一 <see cref="T:System.Array" /> 中（从第一个元素开始）。</span><span class="sxs-lookup"><span data-stu-id="08e41-540">Copies a range of elements from an <see cref="T:System.Array" /> starting at the first element and pastes them into another <see cref="T:System.Array" /> starting at the first element.</span></span> <span data-ttu-id="08e41-541">长度指定为 32 位整数。</span><span class="sxs-lookup"><span data-stu-id="08e41-541">The length is specified as a 32-bit integer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-542">`sourceArray` 和 `destinationArray` 参数必须具有相同的维数。</span><span class="sxs-lookup"><span data-stu-id="08e41-542">The `sourceArray` and `destinationArray` parameters must have the same number of dimensions.</span></span> <span data-ttu-id="08e41-543">此外，`destinationArray` 必须已设置了维度，并且必须具有足够数量的元素来容纳所复制的数据。</span><span class="sxs-lookup"><span data-stu-id="08e41-543">In addition, `destinationArray` must already have been dimensioned and must have a sufficient number of elements to accommodate the copied data.</span></span>  
  
 <span data-ttu-id="08e41-544">在多维数组之间复制时，数组的行为类似于一维数组，其中的行（或列）在概念上是端到端的布局。</span><span class="sxs-lookup"><span data-stu-id="08e41-544">When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end to end.</span></span> <span data-ttu-id="08e41-545">例如，如果一个数组有三行（或两列），其中每个行都有四个元素，则从该数组的开头复制六个元素将复制第一行（或列）的所有四个元素和第二行（或列）的前两个元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-545">For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</span></span>  
  
 <span data-ttu-id="08e41-546">如果 `sourceArray` 和 `destinationArray` 重叠，此方法的行为就像在覆盖 `destinationArray` 之前，在临时位置保留 `sourceArray` 的原始值。</span><span class="sxs-lookup"><span data-stu-id="08e41-546">If `sourceArray` and `destinationArray` overlap, this method behaves as if the original values of `sourceArray` were preserved in a temporary location before `destinationArray` is overwritten.</span></span>  
  
 <span data-ttu-id="08e41-547">[C++]</span><span class="sxs-lookup"><span data-stu-id="08e41-547">[C++]</span></span>  
  
 <span data-ttu-id="08e41-548">此方法等效于标准 C/C++函数 `memmove`，而不是 `memcpy`。</span><span class="sxs-lookup"><span data-stu-id="08e41-548">This method is equivalent to the standard C/C++ function `memmove`, not `memcpy`.</span></span>  
  
 <span data-ttu-id="08e41-549">数组可以是引用类型的数组或值类型数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-549">The arrays can be reference-type arrays or value-type arrays.</span></span> <span data-ttu-id="08e41-550">根据需要执行类型 downcasting。</span><span class="sxs-lookup"><span data-stu-id="08e41-550">Type downcasting is performed, as required.</span></span>  
  
-   <span data-ttu-id="08e41-551">从引用类型数组复制到值类型数组时，每个元素都将取消装箱，然后复制。</span><span class="sxs-lookup"><span data-stu-id="08e41-551">When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</span></span> <span data-ttu-id="08e41-552">从值类型的数组复制到引用类型的数组时，每个元素都进行装箱，然后复制。</span><span class="sxs-lookup"><span data-stu-id="08e41-552">When copying from a value-type array to a reference-type array, each element is boxed and then copied.</span></span>  
  
-   <span data-ttu-id="08e41-553">从引用类型或值类型数组复制到 <xref:System.Object> 数组时，将创建一个 <xref:System.Object> 来保存每个值或引用，然后将其复制。</span><span class="sxs-lookup"><span data-stu-id="08e41-553">When copying from a reference-type or value-type array to an <xref:System.Object> array, an <xref:System.Object> is created to hold each value or reference and then copied.</span></span> <span data-ttu-id="08e41-554">在从 <xref:System.Object> 数组复制到引用类型或值类型数组时，如果不可能进行赋值，则会引发 <xref:System.InvalidCastException>。</span><span class="sxs-lookup"><span data-stu-id="08e41-554">When copying from an <xref:System.Object> array to a reference-type or value-type array and the assignment is not possible, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
-   <span data-ttu-id="08e41-555">如果 `sourceArray` 和 `destinationArray` 均为引用类型数组，或是 <xref:System.Object>类型的数组，则执行浅表复制。</span><span class="sxs-lookup"><span data-stu-id="08e41-555">If `sourceArray` and `destinationArray` are both reference-type arrays or are both arrays of type <xref:System.Object>, a shallow copy is performed.</span></span> <span data-ttu-id="08e41-556"><xref:System.Array> 的浅表副本是新 <xref:System.Array>，它包含对与原始 <xref:System.Array>相同的元素的引用。</span><span class="sxs-lookup"><span data-stu-id="08e41-556">A shallow copy of an <xref:System.Array> is a new <xref:System.Array> containing references to the same elements as the original <xref:System.Array>.</span></span> <span data-ttu-id="08e41-557">不复制元素本身或元素所引用的任何内容。</span><span class="sxs-lookup"><span data-stu-id="08e41-557">The elements themselves or anything referenced by the elements are not copied.</span></span> <span data-ttu-id="08e41-558">与此相反，<xref:System.Array> 的深层副本会复制元素以及元素直接或间接引用的所有内容。</span><span class="sxs-lookup"><span data-stu-id="08e41-558">In contrast, a deep copy of an <xref:System.Array> copies the elements and everything directly or indirectly referenced by the elements.</span></span>  
  
 <span data-ttu-id="08e41-559">如果数组的类型不兼容，则会引发 <xref:System.ArrayTypeMismatchException>。</span><span class="sxs-lookup"><span data-stu-id="08e41-559">An <xref:System.ArrayTypeMismatchException> is thrown if the arrays are of incompatible types.</span></span> <span data-ttu-id="08e41-560">类型兼容性定义如下：</span><span class="sxs-lookup"><span data-stu-id="08e41-560">Type compatibility is defined as follows:</span></span>  
  
-   <span data-ttu-id="08e41-561">类型与自身兼容。</span><span class="sxs-lookup"><span data-stu-id="08e41-561">A type is compatible with itself.</span></span>  
  
-   <span data-ttu-id="08e41-562">值类型与 <xref:System.Object> 和具有该值类型实现的接口类型兼容。</span><span class="sxs-lookup"><span data-stu-id="08e41-562">A value type is compatible with <xref:System.Object> and with an interface type implemented by that value type.</span></span> <span data-ttu-id="08e41-563">仅当某个值类型直接实现该接口时，才会将该值类型视为已连接。</span><span class="sxs-lookup"><span data-stu-id="08e41-563">A value type is considered connected to an interface only if it implements that interface directly.</span></span> <span data-ttu-id="08e41-564">断开连接的类型不兼容。</span><span class="sxs-lookup"><span data-stu-id="08e41-564">Disconnected types are not compatible.</span></span>  
  
-   <span data-ttu-id="08e41-565">如果从源类型到目标类型的复制是扩大转换，则两个内部（预定义）值类型是兼容的。</span><span class="sxs-lookup"><span data-stu-id="08e41-565">Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</span></span> <span data-ttu-id="08e41-566">扩大转换从不会丢失信息，而收缩转换可能会丢失信息。</span><span class="sxs-lookup"><span data-stu-id="08e41-566">A widening conversion never loses information, whereas a narrowing conversion can lose information.</span></span> <span data-ttu-id="08e41-567">例如，将32位有符号整数转换为64位有符号整数是扩大转换，将64位有符号整数转换为32位带符号整数是收缩转换。</span><span class="sxs-lookup"><span data-stu-id="08e41-567">For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</span></span> <span data-ttu-id="08e41-568">有关转换的详细信息，请参阅 <xref:System.Convert>。</span><span class="sxs-lookup"><span data-stu-id="08e41-568">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
-   <span data-ttu-id="08e41-569">Nonintrinsic （用户定义）值类型仅与自身兼容。</span><span class="sxs-lookup"><span data-stu-id="08e41-569">A nonintrinsic (user-defined) value type is compatible only with itself.</span></span>  
  
-   <span data-ttu-id="08e41-570">枚举具有到 <xref:System.Enum> 及其基础类型的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="08e41-570">Enumerations have an implicit conversion to <xref:System.Enum> and to their underlying type.</span></span>  
  
 <span data-ttu-id="08e41-571">如果 `sourceArray` 中的每个元素都需要向下转换（例如，从基类到派生类或从接口到对象），并且不能将一个或多个元素强制转换为 `destinationArray`中的相应类型，则会引发 <xref:System.InvalidCastException>。</span><span class="sxs-lookup"><span data-stu-id="08e41-571">If every element in `sourceArray` requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in `destinationArray`, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
 <span data-ttu-id="08e41-572">如果此方法在复制时引发异常，则 `destinationArray` 的状态为 undefined。</span><span class="sxs-lookup"><span data-stu-id="08e41-572">If this method throws an exception while copying, the state of `destinationArray` is undefined.</span></span>  
  
 <span data-ttu-id="08e41-573">此方法是一个 O （`n`）操作，其中 `n` 是 `length`的。</span><span class="sxs-lookup"><span data-stu-id="08e41-573">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-574"><paramref name="sourceArray" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-574"><paramref name="sourceArray" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="08e41-575">或</span><span class="sxs-lookup"><span data-stu-id="08e41-575">-or-</span></span> 
 <span data-ttu-id="08e41-576"><paramref name="destinationArray" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-576"><paramref name="destinationArray" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="08e41-577"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 具有不同的秩。</span><span class="sxs-lookup"><span data-stu-id="08e41-577"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</span></span></exception>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="08e41-578"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 属于不兼容的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-578"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> are of incompatible types.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="08e41-579"><paramref name="sourceArray" /> 中至少有一个元素无法转换为 <paramref name="destinationArray" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-579">At least one element in <paramref name="sourceArray" /> cannot be cast to the type of <paramref name="destinationArray" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-580"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-580"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-581"><paramref name="length" /> 大于 <paramref name="sourceArray" /> 中的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-581"><paramref name="length" /> is greater than the number of elements in <paramref name="sourceArray" />.</span></span>  
  
<span data-ttu-id="08e41-582">或</span><span class="sxs-lookup"><span data-stu-id="08e41-582">-or-</span></span> 
 <span data-ttu-id="08e41-583"><paramref name="length" /> 大于 <paramref name="destinationArray" /> 中的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-583"><paramref name="length" /> is greater than the number of elements in <paramref name="destinationArray" />.</span></span></exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="destinationArray" Type="System.Array" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="sourceArray"><span data-ttu-id="08e41-584">包含要复制的数据的 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-584">The <see cref="T:System.Array" /> that contains the data to copy.</span></span></param>
        <param name="destinationArray"><span data-ttu-id="08e41-585">接收数据的 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-585">The <see cref="T:System.Array" /> that receives the data.</span></span></param>
        <param name="length"><span data-ttu-id="08e41-586">一个 64 位整数，它表示要复制的元素数目。</span><span class="sxs-lookup"><span data-stu-id="08e41-586">A 64-bit integer that represents the number of elements to copy.</span></span> <span data-ttu-id="08e41-587">该整数必须介于零和 <see cref="F:System.Int32.MaxValue" /> 之间（包括这两个值）。</span><span class="sxs-lookup"><span data-stu-id="08e41-587">The integer must be between zero and <see cref="F:System.Int32.MaxValue" />, inclusive.</span></span></param>
        <summary><span data-ttu-id="08e41-588">从第一个元素开始复制 <see cref="T:System.Array" /> 中的一系列元素，将它们粘贴到另一 <see cref="T:System.Array" /> 中（从第一个元素开始）。</span><span class="sxs-lookup"><span data-stu-id="08e41-588">Copies a range of elements from an <see cref="T:System.Array" /> starting at the first element and pastes them into another <see cref="T:System.Array" /> starting at the first element.</span></span> <span data-ttu-id="08e41-589">长度指定为 64 位整数。</span><span class="sxs-lookup"><span data-stu-id="08e41-589">The length is specified as a 64-bit integer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-590">`sourceArray` 和 `destinationArray` 参数必须具有相同的维数。</span><span class="sxs-lookup"><span data-stu-id="08e41-590">The `sourceArray` and `destinationArray` parameters must have the same number of dimensions.</span></span> <span data-ttu-id="08e41-591">此外，`destinationArray` 必须已设置了维度，并且必须具有足够数量的元素来容纳所复制的数据。</span><span class="sxs-lookup"><span data-stu-id="08e41-591">In addition, `destinationArray` must already have been dimensioned and must have a sufficient number of elements to accommodate the copied data.</span></span>  
  
 <span data-ttu-id="08e41-592">在多维数组之间复制时，数组的行为类似于一维数组，其中的行（或列）在概念上是端到端的布局。</span><span class="sxs-lookup"><span data-stu-id="08e41-592">When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end to end.</span></span> <span data-ttu-id="08e41-593">例如，如果一个数组有三行（或两列），其中每个行都有四个元素，则从该数组的开头复制六个元素将复制第一行（或列）的所有四个元素和第二行（或列）的前两个元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-593">For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</span></span>  
  
 <span data-ttu-id="08e41-594">如果 `sourceArray` 和 `destinationArray` 重叠，此方法的行为就像在覆盖 `destinationArray` 之前，在临时位置保留 `sourceArray` 的原始值。</span><span class="sxs-lookup"><span data-stu-id="08e41-594">If `sourceArray` and `destinationArray` overlap, this method behaves as if the original values of `sourceArray` were preserved in a temporary location before `destinationArray` is overwritten.</span></span>  
  
 <span data-ttu-id="08e41-595">[C++]</span><span class="sxs-lookup"><span data-stu-id="08e41-595">[C++]</span></span>  
  
 <span data-ttu-id="08e41-596">此方法等效于标准 C/C++函数 `memmove`，而不是 `memcpy`。</span><span class="sxs-lookup"><span data-stu-id="08e41-596">This method is equivalent to the standard C/C++ function `memmove`, not `memcpy`.</span></span>  
  
 <span data-ttu-id="08e41-597">数组可以是引用类型的数组或值类型数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-597">The arrays can be reference-type arrays or value-type arrays.</span></span> <span data-ttu-id="08e41-598">根据需要执行类型 downcasting。</span><span class="sxs-lookup"><span data-stu-id="08e41-598">Type downcasting is performed, as required.</span></span>  
  
-   <span data-ttu-id="08e41-599">从引用类型数组复制到值类型数组时，每个元素都将取消装箱，然后复制。</span><span class="sxs-lookup"><span data-stu-id="08e41-599">When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</span></span> <span data-ttu-id="08e41-600">从值类型的数组复制到引用类型的数组时，每个元素都进行装箱，然后复制。</span><span class="sxs-lookup"><span data-stu-id="08e41-600">When copying from a value-type array to a reference-type array, each element is boxed and then copied.</span></span>  
  
-   <span data-ttu-id="08e41-601">从引用类型或值类型数组复制到 <xref:System.Object> 数组时，将创建一个 <xref:System.Object> 来保存每个值或引用，然后将其复制。</span><span class="sxs-lookup"><span data-stu-id="08e41-601">When copying from a reference-type or value-type array to an <xref:System.Object> array, an <xref:System.Object> is created to hold each value or reference and then copied.</span></span> <span data-ttu-id="08e41-602">在从 <xref:System.Object> 数组复制到引用类型或值类型数组时，如果不可能进行赋值，则会引发 <xref:System.InvalidCastException>。</span><span class="sxs-lookup"><span data-stu-id="08e41-602">When copying from an <xref:System.Object> array to a reference-type or value-type array and the assignment is not possible, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
-   <span data-ttu-id="08e41-603">如果 `sourceArray` 和 `destinationArray` 均为引用类型数组，或是 <xref:System.Object>类型的数组，则执行浅表复制。</span><span class="sxs-lookup"><span data-stu-id="08e41-603">If `sourceArray` and `destinationArray` are both reference-type arrays or are both arrays of type <xref:System.Object>, a shallow copy is performed.</span></span> <span data-ttu-id="08e41-604"><xref:System.Array> 的浅表副本是新 <xref:System.Array>，它包含对与原始 <xref:System.Array>相同的元素的引用。</span><span class="sxs-lookup"><span data-stu-id="08e41-604">A shallow copy of an <xref:System.Array> is a new <xref:System.Array> containing references to the same elements as the original <xref:System.Array>.</span></span> <span data-ttu-id="08e41-605">不复制元素本身或元素所引用的任何内容。</span><span class="sxs-lookup"><span data-stu-id="08e41-605">The elements themselves or anything referenced by the elements are not copied.</span></span> <span data-ttu-id="08e41-606">与此相反，<xref:System.Array> 的深层副本会复制元素以及元素直接或间接引用的所有内容。</span><span class="sxs-lookup"><span data-stu-id="08e41-606">In contrast, a deep copy of an <xref:System.Array> copies the elements and everything directly or indirectly referenced by the elements.</span></span>  
  
 <span data-ttu-id="08e41-607">如果数组的类型不兼容，则会引发 <xref:System.ArrayTypeMismatchException>。</span><span class="sxs-lookup"><span data-stu-id="08e41-607">An <xref:System.ArrayTypeMismatchException> is thrown if the arrays are of incompatible types.</span></span> <span data-ttu-id="08e41-608">类型兼容性定义如下：</span><span class="sxs-lookup"><span data-stu-id="08e41-608">Type compatibility is defined as follows:</span></span>  
  
-   <span data-ttu-id="08e41-609">类型与自身兼容。</span><span class="sxs-lookup"><span data-stu-id="08e41-609">A type is compatible with itself.</span></span>  
  
-   <span data-ttu-id="08e41-610">值类型与 <xref:System.Object> 和具有该值类型实现的接口类型兼容。</span><span class="sxs-lookup"><span data-stu-id="08e41-610">A value type is compatible with <xref:System.Object> and with an interface type implemented by that value type.</span></span> <span data-ttu-id="08e41-611">仅当某个值类型直接实现该接口时，才会将该值类型视为已连接。</span><span class="sxs-lookup"><span data-stu-id="08e41-611">A value type is considered connected to an interface only if it implements that interface directly.</span></span> <span data-ttu-id="08e41-612">断开连接的类型不兼容。</span><span class="sxs-lookup"><span data-stu-id="08e41-612">Disconnected types are not compatible.</span></span>  
  
-   <span data-ttu-id="08e41-613">如果从源类型到目标类型的复制是扩大转换，则两个内部（预定义）值类型是兼容的。</span><span class="sxs-lookup"><span data-stu-id="08e41-613">Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</span></span> <span data-ttu-id="08e41-614">扩大转换从不会丢失信息，而收缩转换可能会丢失信息。</span><span class="sxs-lookup"><span data-stu-id="08e41-614">A widening conversion never loses information, whereas a narrowing conversion can lose information.</span></span> <span data-ttu-id="08e41-615">例如，将32位有符号整数转换为64位有符号整数是扩大转换，将64位有符号整数转换为32位带符号整数是收缩转换。</span><span class="sxs-lookup"><span data-stu-id="08e41-615">For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</span></span> <span data-ttu-id="08e41-616">有关转换的详细信息，请参阅 <xref:System.Convert>。</span><span class="sxs-lookup"><span data-stu-id="08e41-616">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
-   <span data-ttu-id="08e41-617">Nonintrinsic （用户定义）值类型仅与自身兼容。</span><span class="sxs-lookup"><span data-stu-id="08e41-617">A nonintrinsic (user-defined) value type is compatible only with itself.</span></span>  
  
-   <span data-ttu-id="08e41-618">枚举具有到 <xref:System.Enum> 及其基础类型的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="08e41-618">Enumerations have an implicit conversion to <xref:System.Enum> and to their underlying type.</span></span>  
  
 <span data-ttu-id="08e41-619">如果 `sourceArray` 中的每个元素都需要向下转换（例如，从基类到派生类或从接口到对象），并且不能将一个或多个元素强制转换为 `destinationArray`中的相应类型，则会引发 <xref:System.InvalidCastException>。</span><span class="sxs-lookup"><span data-stu-id="08e41-619">If every element in `sourceArray` requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in `destinationArray`, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
 <span data-ttu-id="08e41-620">如果此方法在复制时引发异常，则 `destinationArray` 的状态为 undefined。</span><span class="sxs-lookup"><span data-stu-id="08e41-620">If this method throws an exception while copying, the state of `destinationArray` is undefined.</span></span>  
  
 <span data-ttu-id="08e41-621">此方法是一个 O （`n`）操作，其中 `n` 是 `length`的。</span><span class="sxs-lookup"><span data-stu-id="08e41-621">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-622"><paramref name="sourceArray" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-622"><paramref name="sourceArray" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="08e41-623">或</span><span class="sxs-lookup"><span data-stu-id="08e41-623">-or-</span></span> 
 <span data-ttu-id="08e41-624"><paramref name="destinationArray" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-624"><paramref name="destinationArray" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="08e41-625"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 具有不同的秩。</span><span class="sxs-lookup"><span data-stu-id="08e41-625"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</span></span></exception>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="08e41-626"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 属于不兼容的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-626"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> are of incompatible types.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="08e41-627"><paramref name="sourceArray" /> 中至少有一个元素无法转换为 <paramref name="destinationArray" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-627">At least one element in <paramref name="sourceArray" /> cannot be cast to the type of <paramref name="destinationArray" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-628"><paramref name="length" /> 小于 0 或大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-628"><paramref name="length" /> is less than 0 or greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-629"><paramref name="length" /> 大于 <paramref name="sourceArray" /> 中的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-629"><paramref name="length" /> is greater than the number of elements in <paramref name="sourceArray" />.</span></span>  
  
<span data-ttu-id="08e41-630">或</span><span class="sxs-lookup"><span data-stu-id="08e41-630">-or-</span></span> 
 <span data-ttu-id="08e41-631"><paramref name="length" /> 大于 <paramref name="destinationArray" /> 中的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-631"><paramref name="length" /> is greater than the number of elements in <paramref name="destinationArray" />.</span></span></exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray"><span data-ttu-id="08e41-632">包含要复制的数据的 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-632">The <see cref="T:System.Array" /> that contains the data to copy.</span></span></param>
        <param name="sourceIndex"><span data-ttu-id="08e41-633">一个 32 位整数，它表示 <paramref name="sourceArray" /> 中复制开始处的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-633">A 32-bit integer that represents the index in the <paramref name="sourceArray" /> at which copying begins.</span></span></param>
        <param name="destinationArray"><span data-ttu-id="08e41-634">接收数据的 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-634">The <see cref="T:System.Array" /> that receives the data.</span></span></param>
        <param name="destinationIndex"><span data-ttu-id="08e41-635">一个 32 位整数，它表示 <paramref name="destinationArray" /> 中存储开始处的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-635">A 32-bit integer that represents the index in the <paramref name="destinationArray" /> at which storing begins.</span></span></param>
        <param name="length"><span data-ttu-id="08e41-636">一个 32 位整数，它表示要复制的元素数目。</span><span class="sxs-lookup"><span data-stu-id="08e41-636">A 32-bit integer that represents the number of elements to copy.</span></span></param>
        <summary><span data-ttu-id="08e41-637">复制 <see cref="T:System.Array" /> 中的一系列元素（从指定的源索引开始），并将它们粘贴到另一 <see cref="T:System.Array" /> 中（从指定的目标索引开始）。</span><span class="sxs-lookup"><span data-stu-id="08e41-637">Copies a range of elements from an <see cref="T:System.Array" /> starting at the specified source index and pastes them to another <see cref="T:System.Array" /> starting at the specified destination index.</span></span> <span data-ttu-id="08e41-638">长度和索引指定为 32 位整数。</span><span class="sxs-lookup"><span data-stu-id="08e41-638">The length and the indexes are specified as 32-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-639">`sourceArray` 和 `destinationArray` 参数必须具有相同的维数。</span><span class="sxs-lookup"><span data-stu-id="08e41-639">The `sourceArray` and `destinationArray` parameters must have the same number of dimensions.</span></span> <span data-ttu-id="08e41-640">此外，`destinationArray` 必须已设置了维度，并且必须从 `destinationIndex` 位置开始有足够数量的元素，才能容纳复制的数据。</span><span class="sxs-lookup"><span data-stu-id="08e41-640">In addition, `destinationArray` must already have been dimensioned and must have a sufficient number of elements starting from the `destinationIndex` position to accommodate the copied data.</span></span>  
  
 <span data-ttu-id="08e41-641">在多维数组之间复制时，数组的行为类似于一维数组，其中的行（或列）在概念上是端到端的布局。</span><span class="sxs-lookup"><span data-stu-id="08e41-641">When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end.</span></span> <span data-ttu-id="08e41-642">例如，如果一个数组有三行（或两列），其中每个行都有四个元素，则从该数组的开头复制六个元素将复制第一行（或列）的所有四个元素和第二行（或列）的前两个元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-642">For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</span></span> <span data-ttu-id="08e41-643">若要从第三行（或列）的第二个元素开始复制，`sourceIndex` 必须是第一行（或列）加上第二行（或列）加两行的上限。</span><span class="sxs-lookup"><span data-stu-id="08e41-643">To start copying from the second element of the third row (or column), `sourceIndex` must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</span></span>  
  
 <span data-ttu-id="08e41-644">如果 `sourceArray` 和 `destinationArray` 重叠，此方法的行为就像在覆盖 `destinationArray` 之前，在临时位置保留 `sourceArray` 的原始值。</span><span class="sxs-lookup"><span data-stu-id="08e41-644">If `sourceArray` and `destinationArray` overlap, this method behaves as if the original values of `sourceArray` were preserved in a temporary location before `destinationArray` is overwritten.</span></span>  
  
 <span data-ttu-id="08e41-645">[C++]</span><span class="sxs-lookup"><span data-stu-id="08e41-645">[C++]</span></span>  
  
 <span data-ttu-id="08e41-646">此方法等效于标准 C/C++函数 `memmove`，而不是 `memcpy`。</span><span class="sxs-lookup"><span data-stu-id="08e41-646">This method is equivalent to the standard C/C++ function `memmove`, not `memcpy`.</span></span>  
  
 <span data-ttu-id="08e41-647">数组可以是引用类型的数组或值类型数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-647">The arrays can be reference-type arrays or value-type arrays.</span></span> <span data-ttu-id="08e41-648">根据需要执行类型 downcasting。</span><span class="sxs-lookup"><span data-stu-id="08e41-648">Type downcasting is performed, as required.</span></span>  
  
-   <span data-ttu-id="08e41-649">从引用类型数组复制到值类型数组时，每个元素都将取消装箱，然后复制。</span><span class="sxs-lookup"><span data-stu-id="08e41-649">When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</span></span> <span data-ttu-id="08e41-650">从值类型的数组复制到引用类型的数组时，每个元素都进行装箱，然后复制。</span><span class="sxs-lookup"><span data-stu-id="08e41-650">When copying from a value-type array to a reference-type array, each element is boxed and then copied.</span></span>  
  
-   <span data-ttu-id="08e41-651">从引用类型或值类型数组复制到 <xref:System.Object> 数组时，将创建一个 <xref:System.Object> 来保存每个值或引用，然后将其复制。</span><span class="sxs-lookup"><span data-stu-id="08e41-651">When copying from a reference-type or value-type array to an <xref:System.Object> array, an <xref:System.Object> is created to hold each value or reference and then copied.</span></span> <span data-ttu-id="08e41-652">在从 <xref:System.Object> 数组复制到引用类型或值类型数组时，如果不可能进行赋值，则会引发 <xref:System.InvalidCastException>。</span><span class="sxs-lookup"><span data-stu-id="08e41-652">When copying from an <xref:System.Object> array to a reference-type or value-type array and the assignment is not possible, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
-   <span data-ttu-id="08e41-653">如果 `sourceArray` 和 `destinationArray` 均为引用类型数组，或是 <xref:System.Object>类型的数组，则执行浅表复制。</span><span class="sxs-lookup"><span data-stu-id="08e41-653">If `sourceArray` and `destinationArray` are both reference-type arrays or are both arrays of type <xref:System.Object>, a shallow copy is performed.</span></span> <span data-ttu-id="08e41-654"><xref:System.Array> 的浅表副本是新 <xref:System.Array>，它包含对与原始 <xref:System.Array>相同的元素的引用。</span><span class="sxs-lookup"><span data-stu-id="08e41-654">A shallow copy of an <xref:System.Array> is a new <xref:System.Array> containing references to the same elements as the original <xref:System.Array>.</span></span> <span data-ttu-id="08e41-655">不复制元素本身或元素所引用的任何内容。</span><span class="sxs-lookup"><span data-stu-id="08e41-655">The elements themselves or anything referenced by the elements are not copied.</span></span> <span data-ttu-id="08e41-656">与此相反，<xref:System.Array> 的深层副本会复制元素以及元素直接或间接引用的所有内容。</span><span class="sxs-lookup"><span data-stu-id="08e41-656">In contrast, a deep copy of an <xref:System.Array> copies the elements and everything directly or indirectly referenced by the elements.</span></span>  
  
 <span data-ttu-id="08e41-657">如果数组的类型不兼容，则会引发 <xref:System.ArrayTypeMismatchException>。</span><span class="sxs-lookup"><span data-stu-id="08e41-657">An <xref:System.ArrayTypeMismatchException> is thrown if the arrays are of incompatible types.</span></span> <span data-ttu-id="08e41-658">类型兼容性定义如下：</span><span class="sxs-lookup"><span data-stu-id="08e41-658">Type compatibility is defined as follows:</span></span>  
  
-   <span data-ttu-id="08e41-659">类型与自身兼容。</span><span class="sxs-lookup"><span data-stu-id="08e41-659">A type is compatible with itself.</span></span>  
  
-   <span data-ttu-id="08e41-660">值类型与 <xref:System.Object> 和具有该值类型实现的接口类型兼容。</span><span class="sxs-lookup"><span data-stu-id="08e41-660">A value type is compatible with <xref:System.Object> and with an interface type implemented by that value type.</span></span> <span data-ttu-id="08e41-661">仅当某个值类型直接实现该接口时，才会将该值类型视为已连接。</span><span class="sxs-lookup"><span data-stu-id="08e41-661">A value type is considered connected to an interface only if it implements that interface directly.</span></span> <span data-ttu-id="08e41-662">断开连接的类型不兼容。</span><span class="sxs-lookup"><span data-stu-id="08e41-662">Disconnected types are not compatible.</span></span>  
  
-   <span data-ttu-id="08e41-663">如果从源类型到目标类型的复制是扩大转换，则两个内部（预定义）值类型是兼容的。</span><span class="sxs-lookup"><span data-stu-id="08e41-663">Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</span></span> <span data-ttu-id="08e41-664">扩大转换从不会丢失信息，而收缩转换可能会丢失信息。</span><span class="sxs-lookup"><span data-stu-id="08e41-664">A widening conversion never loses information, whereas a narrowing conversion can lose information.</span></span> <span data-ttu-id="08e41-665">例如，将32位有符号整数转换为64位有符号整数是扩大转换，将64位有符号整数转换为32位带符号整数是收缩转换。</span><span class="sxs-lookup"><span data-stu-id="08e41-665">For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</span></span> <span data-ttu-id="08e41-666">有关转换的详细信息，请参阅 <xref:System.Convert>。</span><span class="sxs-lookup"><span data-stu-id="08e41-666">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
-   <span data-ttu-id="08e41-667">Nonintrinsic （用户定义）值类型仅与自身兼容。</span><span class="sxs-lookup"><span data-stu-id="08e41-667">A nonintrinsic (user-defined) value type is compatible only with itself.</span></span>  
  
-   <span data-ttu-id="08e41-668">枚举具有到 <xref:System.Enum> 及其基础类型的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="08e41-668">Enumerations have an implicit conversion to <xref:System.Enum> and to their underlying type.</span></span>  
  
 <span data-ttu-id="08e41-669">如果 `sourceArray` 中的每个元素都需要向下转换（例如，从基类到派生类或从接口到对象），并且不能将一个或多个元素强制转换为 `destinationArray`中的相应类型，则会引发 <xref:System.InvalidCastException>。</span><span class="sxs-lookup"><span data-stu-id="08e41-669">If every element in `sourceArray` requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in `destinationArray`, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
 <span data-ttu-id="08e41-670">如果此方法在复制时引发异常，则 `destinationArray` 的状态为 undefined。</span><span class="sxs-lookup"><span data-stu-id="08e41-670">If this method throws an exception while copying, the state of `destinationArray` is undefined.</span></span>  
  
 <span data-ttu-id="08e41-671">此方法是一个 O （`n`）操作，其中 `n` 是 `length`的。</span><span class="sxs-lookup"><span data-stu-id="08e41-671">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-672">下面的代码示例演示如何将类型 <xref:System.Object> 的一 <xref:System.Array> 复制到整数类型的另一个 <xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="08e41-672">The following code example shows how to copy from one <xref:System.Array> of type <xref:System.Object> to another <xref:System.Array> of type integer.</span></span>  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-673"><paramref name="sourceArray" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-673"><paramref name="sourceArray" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="08e41-674">或</span><span class="sxs-lookup"><span data-stu-id="08e41-674">-or-</span></span> 
 <span data-ttu-id="08e41-675"><paramref name="destinationArray" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-675"><paramref name="destinationArray" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="08e41-676"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 具有不同的秩。</span><span class="sxs-lookup"><span data-stu-id="08e41-676"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</span></span></exception>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="08e41-677"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 属于不兼容的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-677"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> are of incompatible types.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="08e41-678"><paramref name="sourceArray" /> 中至少有一个元素无法转换为 <paramref name="destinationArray" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-678">At least one element in <paramref name="sourceArray" /> cannot be cast to the type of <paramref name="destinationArray" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-679"><paramref name="sourceIndex" /> 少于 <paramref name="sourceArray" /> 的第一个维度的下限。</span><span class="sxs-lookup"><span data-stu-id="08e41-679"><paramref name="sourceIndex" /> is less than the lower bound of the first dimension of <paramref name="sourceArray" />.</span></span>  
  
<span data-ttu-id="08e41-680">或</span><span class="sxs-lookup"><span data-stu-id="08e41-680">-or-</span></span> 
 <span data-ttu-id="08e41-681"><paramref name="destinationIndex" /> 少于 <paramref name="destinationArray" /> 的第一个维度的下限。</span><span class="sxs-lookup"><span data-stu-id="08e41-681"><paramref name="destinationIndex" /> is less than the lower bound of the first dimension of <paramref name="destinationArray" />.</span></span>  
  
<span data-ttu-id="08e41-682">或</span><span class="sxs-lookup"><span data-stu-id="08e41-682">-or-</span></span> 
 <span data-ttu-id="08e41-683"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-683"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-684"><paramref name="length" /> 大于从 <paramref name="sourceIndex" /> 到 <paramref name="sourceArray" /> 末尾的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-684"><paramref name="length" /> is greater than the number of elements from <paramref name="sourceIndex" /> to the end of <paramref name="sourceArray" />.</span></span>  
  
<span data-ttu-id="08e41-685">或</span><span class="sxs-lookup"><span data-stu-id="08e41-685">-or-</span></span> 
 <span data-ttu-id="08e41-686"><paramref name="length" /> 大于从 <paramref name="destinationIndex" /> 到 <paramref name="destinationArray" /> 末尾的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-686"><paramref name="length" /> is greater than the number of elements from <paramref name="destinationIndex" /> to the end of <paramref name="destinationArray" />.</span></span></exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int64 sourceIndex, class System.Array destinationArray, int64 destinationIndex, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Long, destinationArray As Array, destinationIndex As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, long sourceIndex, Array ^ destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int64 * Array * int64 * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="sourceIndex" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="destinationArray" Type="System.Array" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="destinationIndex" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int64" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="sourceArray"><span data-ttu-id="08e41-687">包含要复制的数据的 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-687">The <see cref="T:System.Array" /> that contains the data to copy.</span></span></param>
        <param name="sourceIndex"><span data-ttu-id="08e41-688">一个 64 位整数，它表示复制开始处的 <paramref name="sourceArray" /> 中的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-688">A 64-bit integer that represents the index in the <paramref name="sourceArray" /> at which copying begins.</span></span></param>
        <param name="destinationArray"><span data-ttu-id="08e41-689">接收数据的 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-689">The <see cref="T:System.Array" /> that receives the data.</span></span></param>
        <param name="destinationIndex"><span data-ttu-id="08e41-690">一个 64 位整数，它表示存储开始处的 <paramref name="destinationArray" /> 中的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-690">A 64-bit integer that represents the index in the <paramref name="destinationArray" /> at which storing begins.</span></span></param>
        <param name="length"><span data-ttu-id="08e41-691">一个 64 位整数，它表示要复制的元素数目。</span><span class="sxs-lookup"><span data-stu-id="08e41-691">A 64-bit integer that represents the number of elements to copy.</span></span> <span data-ttu-id="08e41-692">该整数必须介于零和 <see cref="F:System.Int32.MaxValue" /> 之间（包括这两个值）。</span><span class="sxs-lookup"><span data-stu-id="08e41-692">The integer must be between zero and <see cref="F:System.Int32.MaxValue" />, inclusive.</span></span></param>
        <summary><span data-ttu-id="08e41-693">复制 <see cref="T:System.Array" /> 中的一系列元素（从指定的源索引开始），并将它们粘贴到另一 <see cref="T:System.Array" /> 中（从指定的目标索引开始）。</span><span class="sxs-lookup"><span data-stu-id="08e41-693">Copies a range of elements from an <see cref="T:System.Array" /> starting at the specified source index and pastes them to another <see cref="T:System.Array" /> starting at the specified destination index.</span></span> <span data-ttu-id="08e41-694">长度和索引指定为 64 位整数。</span><span class="sxs-lookup"><span data-stu-id="08e41-694">The length and the indexes are specified as 64-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-695">`sourceArray` 和 `destinationArray` 参数必须具有相同的维数。</span><span class="sxs-lookup"><span data-stu-id="08e41-695">The `sourceArray` and `destinationArray` parameters must have the same number of dimensions.</span></span> <span data-ttu-id="08e41-696">此外，`destinationArray` 必须已设置了维度，并且必须从 `destinationIndex` 位置开始有足够数量的元素，才能容纳复制的数据。</span><span class="sxs-lookup"><span data-stu-id="08e41-696">In addition, `destinationArray` must already have been dimensioned and must have a sufficient number of elements starting from the `destinationIndex` position to accommodate the copied data.</span></span>  
  
 <span data-ttu-id="08e41-697">在多维数组之间复制时，数组的行为类似于一维数组，其中的行（或列）在概念上是端到端的布局。</span><span class="sxs-lookup"><span data-stu-id="08e41-697">When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end.</span></span> <span data-ttu-id="08e41-698">例如，如果一个数组有三行（或两列），其中每个行都有四个元素，则从该数组的开头复制六个元素将复制第一行（或列）的所有四个元素和第二行（或列）的前两个元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-698">For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</span></span> <span data-ttu-id="08e41-699">若要从第三行（或列）的第二个元素开始复制，`sourceIndex` 必须是第一行（或列）加上第二行（或列）加两行的上限。</span><span class="sxs-lookup"><span data-stu-id="08e41-699">To start copying from the second element of the third row (or column), `sourceIndex` must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</span></span>  
  
 <span data-ttu-id="08e41-700">如果 `sourceArray` 和 `destinationArray` 重叠，此方法的行为就像在覆盖 `destinationArray` 之前，在临时位置保留 `sourceArray` 的原始值。</span><span class="sxs-lookup"><span data-stu-id="08e41-700">If `sourceArray` and `destinationArray` overlap, this method behaves as if the original values of `sourceArray` were preserved in a temporary location before `destinationArray` is overwritten.</span></span>  
  
 <span data-ttu-id="08e41-701">[C++]</span><span class="sxs-lookup"><span data-stu-id="08e41-701">[C++]</span></span>  
  
 <span data-ttu-id="08e41-702">此方法等效于标准 C/C++函数 `memmove`，而不是 `memcpy`。</span><span class="sxs-lookup"><span data-stu-id="08e41-702">This method is equivalent to the standard C/C++ function `memmove`, not `memcpy`.</span></span>  
  
 <span data-ttu-id="08e41-703">数组可以是引用类型的数组或值类型数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-703">The arrays can be reference-type arrays or value-type arrays.</span></span> <span data-ttu-id="08e41-704">根据需要执行类型 downcasting。</span><span class="sxs-lookup"><span data-stu-id="08e41-704">Type downcasting is performed, as required.</span></span>  
  
-   <span data-ttu-id="08e41-705">从引用类型数组复制到值类型数组时，每个元素都将取消装箱，然后复制。</span><span class="sxs-lookup"><span data-stu-id="08e41-705">When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</span></span> <span data-ttu-id="08e41-706">从值类型的数组复制到引用类型的数组时，每个元素都进行装箱，然后复制。</span><span class="sxs-lookup"><span data-stu-id="08e41-706">When copying from a value-type array to a reference-type array, each element is boxed and then copied.</span></span>  
  
-   <span data-ttu-id="08e41-707">从引用类型或值类型数组复制到 <xref:System.Object> 数组时，将创建一个 <xref:System.Object> 来保存每个值或引用，然后将其复制。</span><span class="sxs-lookup"><span data-stu-id="08e41-707">When copying from a reference-type or value-type array to an <xref:System.Object> array, an <xref:System.Object> is created to hold each value or reference and then copied.</span></span> <span data-ttu-id="08e41-708">在从 <xref:System.Object> 数组复制到引用类型或值类型数组时，如果不可能进行赋值，则会引发 <xref:System.InvalidCastException>。</span><span class="sxs-lookup"><span data-stu-id="08e41-708">When copying from an <xref:System.Object> array to a reference-type or value-type array and the assignment is not possible, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
-   <span data-ttu-id="08e41-709">如果 `sourceArray` 和 `destinationArray` 均为引用类型数组，或是 <xref:System.Object>类型的数组，则执行浅表复制。</span><span class="sxs-lookup"><span data-stu-id="08e41-709">If `sourceArray` and `destinationArray` are both reference-type arrays or are both arrays of type <xref:System.Object>, a shallow copy is performed.</span></span> <span data-ttu-id="08e41-710"><xref:System.Array> 的浅表副本是新 <xref:System.Array>，它包含对与原始 <xref:System.Array>相同的元素的引用。</span><span class="sxs-lookup"><span data-stu-id="08e41-710">A shallow copy of an <xref:System.Array> is a new <xref:System.Array> containing references to the same elements as the original <xref:System.Array>.</span></span> <span data-ttu-id="08e41-711">不复制元素本身或元素所引用的任何内容。</span><span class="sxs-lookup"><span data-stu-id="08e41-711">The elements themselves or anything referenced by the elements are not copied.</span></span> <span data-ttu-id="08e41-712">与此相反，<xref:System.Array> 的深层副本会复制元素以及元素直接或间接引用的所有内容。</span><span class="sxs-lookup"><span data-stu-id="08e41-712">In contrast, a deep copy of an <xref:System.Array> copies the elements and everything directly or indirectly referenced by the elements.</span></span>  
  
 <span data-ttu-id="08e41-713">如果数组的类型不兼容，则会引发 <xref:System.ArrayTypeMismatchException>。</span><span class="sxs-lookup"><span data-stu-id="08e41-713">An <xref:System.ArrayTypeMismatchException> is thrown if the arrays are of incompatible types.</span></span> <span data-ttu-id="08e41-714">类型兼容性定义如下：</span><span class="sxs-lookup"><span data-stu-id="08e41-714">Type compatibility is defined as follows:</span></span>  
  
-   <span data-ttu-id="08e41-715">类型与自身兼容。</span><span class="sxs-lookup"><span data-stu-id="08e41-715">A type is compatible with itself.</span></span>  
  
-   <span data-ttu-id="08e41-716">值类型与 <xref:System.Object> 和具有该值类型实现的接口类型兼容。</span><span class="sxs-lookup"><span data-stu-id="08e41-716">A value type is compatible with <xref:System.Object> and with an interface type implemented by that value type.</span></span> <span data-ttu-id="08e41-717">仅当某个值类型直接实现该接口时，才会将该值类型视为已连接。</span><span class="sxs-lookup"><span data-stu-id="08e41-717">A value type is considered connected to an interface only if it implements that interface directly.</span></span> <span data-ttu-id="08e41-718">断开连接的类型不兼容。</span><span class="sxs-lookup"><span data-stu-id="08e41-718">Disconnected types are not compatible.</span></span>  
  
-   <span data-ttu-id="08e41-719">如果从源类型到目标类型的复制是扩大转换，则两个内部（预定义）值类型是兼容的。</span><span class="sxs-lookup"><span data-stu-id="08e41-719">Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</span></span> <span data-ttu-id="08e41-720">扩大转换从不会丢失信息，而收缩转换可能会丢失信息。</span><span class="sxs-lookup"><span data-stu-id="08e41-720">A widening conversion never loses information, whereas a narrowing conversion can lose information.</span></span> <span data-ttu-id="08e41-721">例如，将32位有符号整数转换为64位有符号整数是扩大转换，将64位有符号整数转换为32位带符号整数是收缩转换。</span><span class="sxs-lookup"><span data-stu-id="08e41-721">For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</span></span> <span data-ttu-id="08e41-722">有关转换的详细信息，请参阅 <xref:System.Convert>。</span><span class="sxs-lookup"><span data-stu-id="08e41-722">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
-   <span data-ttu-id="08e41-723">Nonintrinsic （用户定义）值类型仅与自身兼容。</span><span class="sxs-lookup"><span data-stu-id="08e41-723">A nonintrinsic (user-defined) value type is compatible only with itself.</span></span>  
  
-   <span data-ttu-id="08e41-724">枚举具有到 <xref:System.Enum> 及其基础类型的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="08e41-724">Enumerations have an implicit conversion to <xref:System.Enum> and to their underlying type.</span></span>  
  
 <span data-ttu-id="08e41-725">如果 `sourceArray` 中的每个元素都需要向下转换（例如，从基类到派生类或从接口到对象），并且不能将一个或多个元素强制转换为 `destinationArray`中的相应类型，则会引发 <xref:System.InvalidCastException>。</span><span class="sxs-lookup"><span data-stu-id="08e41-725">If every element in `sourceArray` requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in `destinationArray`, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
 <span data-ttu-id="08e41-726">如果此方法在复制时引发异常，则 `destinationArray` 的状态为 undefined。</span><span class="sxs-lookup"><span data-stu-id="08e41-726">If this method throws an exception while copying, the state of `destinationArray` is undefined.</span></span>  
  
 <span data-ttu-id="08e41-727">此方法是一个 O （`n`）操作，其中 `n` 是 `length`的。</span><span class="sxs-lookup"><span data-stu-id="08e41-727">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-728">下面的代码示例演示如何将类型 <xref:System.Object> 的一 <xref:System.Array> 复制到整数类型的另一个 <xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="08e41-728">The following code example shows how to copy from one <xref:System.Array> of type <xref:System.Object> to another <xref:System.Array> of type integer.</span></span>  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-729"><paramref name="sourceArray" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-729"><paramref name="sourceArray" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="08e41-730">或</span><span class="sxs-lookup"><span data-stu-id="08e41-730">-or-</span></span> 
 <span data-ttu-id="08e41-731"><paramref name="destinationArray" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-731"><paramref name="destinationArray" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="08e41-732"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 具有不同的秩。</span><span class="sxs-lookup"><span data-stu-id="08e41-732"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</span></span></exception>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="08e41-733"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 属于不兼容的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-733"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> are of incompatible types.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="08e41-734"><paramref name="sourceArray" /> 中至少有一个元素无法转换为 <paramref name="destinationArray" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-734">At least one element in <paramref name="sourceArray" /> cannot be cast to the type of <paramref name="destinationArray" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-735"><paramref name="sourceIndex" /> 超出了 <paramref name="sourceArray" /> 的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-735"><paramref name="sourceIndex" /> is outside the range of valid indexes for the <paramref name="sourceArray" />.</span></span>  
  
<span data-ttu-id="08e41-736">或</span><span class="sxs-lookup"><span data-stu-id="08e41-736">-or-</span></span> 
 <span data-ttu-id="08e41-737"><paramref name="destinationIndex" /> 超出了 <paramref name="destinationArray" /> 的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-737"><paramref name="destinationIndex" /> is outside the range of valid indexes for the <paramref name="destinationArray" />.</span></span>  
  
<span data-ttu-id="08e41-738">或</span><span class="sxs-lookup"><span data-stu-id="08e41-738">-or-</span></span> 
 <span data-ttu-id="08e41-739"><paramref name="length" /> 小于 0 或大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-739"><paramref name="length" /> is less than 0 or greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-740"><paramref name="length" /> 大于从 <paramref name="sourceIndex" /> 到 <paramref name="sourceArray" />末尾的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-740"><paramref name="length" /> is greater than the number of elements from <paramref name="sourceIndex" /> to the end of <paramref name="sourceArray" />.</span></span>  
  
<span data-ttu-id="08e41-741">或</span><span class="sxs-lookup"><span data-stu-id="08e41-741">-or-</span></span> 
 <span data-ttu-id="08e41-742"><paramref name="length" /> 大于从 <paramref name="destinationIndex" /> 到 <paramref name="destinationArray" /> 末尾的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-742"><paramref name="length" /> is greater than the number of elements from <paramref name="destinationIndex" /> to the end of <paramref name="destinationArray" />.</span></span></exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="08e41-743">将当前一维数组的所有元素复制到指定的一维数组中。</span><span class="sxs-lookup"><span data-stu-id="08e41-743">Copies all the elements of the current one-dimensional array to the specified one-dimensional array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int index);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="08e41-744">一维数组，它是从当前数组复制的元素的目标。</span><span class="sxs-lookup"><span data-stu-id="08e41-744">The one-dimensional array that is the destination of the elements copied from the current array.</span></span></param>
        <param name="index"><span data-ttu-id="08e41-745">一个 32 位整数，它表示 <paramref name="array" /> 中复制开始处的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-745">A 32-bit integer that represents the index in <paramref name="array" /> at which copying begins.</span></span></param>
        <summary><span data-ttu-id="08e41-746">从指定的目标数组索引处开始，将当前一维数组的所有元素复制到指定的一维数组中。</span><span class="sxs-lookup"><span data-stu-id="08e41-746">Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index.</span></span> <span data-ttu-id="08e41-747">索引指定为 32 位整数。</span><span class="sxs-lookup"><span data-stu-id="08e41-747">The index is specified as a 32-bit integer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-748">此方法将当前数组实例的所有元素复制到 `array` 目标数组，从索引 `index`开始。</span><span class="sxs-lookup"><span data-stu-id="08e41-748">This method copies all the elements of the current array instance to the `array` destination array, starting at index `index`.</span></span> <span data-ttu-id="08e41-749">`array` 目标数组必须已设置了维度，并且必须具有足够数量的元素来容纳复制的元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-749">The `array` destination array must already have been dimensioned and must have a sufficient number of elements to accommodate the copied elements.</span></span> <span data-ttu-id="08e41-750">否则，该方法将引发异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-750">Otherwise, the method throws an exception.</span></span>  
  
 <span data-ttu-id="08e41-751">此方法支持 <xref:System.Collections.ICollection?displayProperty=nameWithType> 接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-751">This method supports the <xref:System.Collections.ICollection?displayProperty=nameWithType> interface.</span></span> <span data-ttu-id="08e41-752">如果不显式要求实现 <xref:System.Collections.ICollection?displayProperty=nameWithType>，请使用 <xref:System.Array.Copy%2A> 以避免额外的间接寻址。</span><span class="sxs-lookup"><span data-stu-id="08e41-752">If implementing <xref:System.Collections.ICollection?displayProperty=nameWithType> is not explicitly required, use <xref:System.Array.Copy%2A> to avoid an extra indirection.</span></span>  
  
 <span data-ttu-id="08e41-753">如果此方法在复制时引发异常，则 `array` 的状态为 undefined。</span><span class="sxs-lookup"><span data-stu-id="08e41-753">If this method throws an exception while copying, the state of `array` is undefined.</span></span>  
  
 <span data-ttu-id="08e41-754">此方法是一个 O （`n`）操作，其中 `n` 是 <xref:System.Array.Length%2A>的。它仅执行浅表复制。</span><span class="sxs-lookup"><span data-stu-id="08e41-754">This method is an O(`n`) operation, where `n` is <xref:System.Array.Length%2A>.It performs a shallow copy only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-755">下面的代码示例演示如何将 <xref:System.Array> 复制到其他 <xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="08e41-755">The following code example shows how to copy an <xref:System.Array> to another <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 <span data-ttu-id="08e41-756">下面的代码示例演示如何将 <xref:System.Array> 复制到具有非零下限的其他 <xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="08e41-756">The following code example shows how to copy an <xref:System.Array> to another <xref:System.Array> with a nonzero lower bound.</span></span> <span data-ttu-id="08e41-757">请注意，将复制整个源 <xref:System.Array>，包括覆盖目标 <xref:System.Array>中现有元素的空元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-757">Note that the entire source <xref:System.Array> is copied, including empty elements that overwrite existing elements in the target <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-758"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-758"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-759"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="08e41-759"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-760"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="08e41-760"><paramref name="array" /> is multidimensional.</span></span>  
  
<span data-ttu-id="08e41-761">或</span><span class="sxs-lookup"><span data-stu-id="08e41-761">-or-</span></span> 
<span data-ttu-id="08e41-762">源数组中的元素数大于从 <paramref name="index" /> 到目标 <paramref name="array" /> 的末尾之间的可用元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-762">The number of elements in the source array is greater than the available number of elements from <paramref name="index" /> to the end of the destination <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="08e41-763">无法自动将源 <see cref="T:System.Array" /> 的类型转换为目标 <paramref name="array" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-763">The type of the source <see cref="T:System.Array" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="08e41-764">源数组是多维数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-764">The source array is multidimensional.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="08e41-765">源 <see cref="T:System.Array" /> 中至少有一个元素无法转换为目标 <paramref name="array" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-765">At least one element in the source <see cref="T:System.Array" /> cannot be cast to the type of destination <paramref name="array" />.</span></span></exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, long index);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int64 index) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Array ^ array, long index);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Array * int64 -&gt; unit" Usage="array.CopyTo (array, index)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, long index);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int64 index) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, long index);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int64 -&gt; unit&#xA;override this.CopyTo : Array * int64 -&gt; unit" Usage="array.CopyTo (array, index)" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="08e41-766">一维数组，它是从当前数组复制的元素的目标。</span><span class="sxs-lookup"><span data-stu-id="08e41-766">The one-dimensional array that is the destination of the elements copied from the current array.</span></span></param>
        <param name="index"><span data-ttu-id="08e41-767">一个 64 位整数，它表示 <paramref name="array" /> 中复制开始处的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-767">A 64-bit integer that represents the index in <paramref name="array" /> at which copying begins.</span></span></param>
        <summary><span data-ttu-id="08e41-768">从指定的目标数组索引处开始，将当前一维数组的所有元素复制到指定的一维数组中。</span><span class="sxs-lookup"><span data-stu-id="08e41-768">Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index.</span></span> <span data-ttu-id="08e41-769">索引指定为 64 位整数。</span><span class="sxs-lookup"><span data-stu-id="08e41-769">The index is specified as a 64-bit integer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-770">此方法将当前数组实例的所有元素复制到 `array` 目标数组，从索引 `index`开始。</span><span class="sxs-lookup"><span data-stu-id="08e41-770">This method copies all the elements of the current array instance to the `array` destination array, starting at index `index`.</span></span> <span data-ttu-id="08e41-771">`array` 目标数组必须已设置了维度，并且必须具有足够数量的元素来容纳复制的元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-771">The `array` destination array must already have been dimensioned and must have a sufficient number of elements to accommodate the copied elements.</span></span> <span data-ttu-id="08e41-772">否则，该方法将引发异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-772">Otherwise, the method throws an exception.</span></span>  
  
 <span data-ttu-id="08e41-773">此方法支持 <xref:System.Collections.ICollection?displayProperty=nameWithType> 接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-773">This method supports the <xref:System.Collections.ICollection?displayProperty=nameWithType> interface.</span></span> <span data-ttu-id="08e41-774">如果不显式要求实现 <xref:System.Collections.ICollection?displayProperty=nameWithType>，请使用 <xref:System.Array.Copy%2A> 以避免额外的间接寻址。</span><span class="sxs-lookup"><span data-stu-id="08e41-774">If implementing <xref:System.Collections.ICollection?displayProperty=nameWithType> is not explicitly required, use <xref:System.Array.Copy%2A> to avoid an extra indirection.</span></span>  
  
 <span data-ttu-id="08e41-775">如果此方法在复制时引发异常，则 `array` 的状态为 undefined。</span><span class="sxs-lookup"><span data-stu-id="08e41-775">If this method throws an exception while copying, the state of `array` is undefined.</span></span>  
  
 <span data-ttu-id="08e41-776">此方法是一个 O （`n`）操作，其中 `n` 是 <xref:System.Array.Length%2A>的。它仅执行浅表复制。</span><span class="sxs-lookup"><span data-stu-id="08e41-776">This method is an O(`n`) operation, where `n` is <xref:System.Array.Length%2A>.It performs a shallow copy only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-777">下面的代码示例演示如何将 <xref:System.Array> 复制到其他 <xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="08e41-777">The following code example shows how to copy an <xref:System.Array> to another <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 <span data-ttu-id="08e41-778">下面的代码示例演示如何将 <xref:System.Array> 复制到具有非零下限的其他 <xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="08e41-778">The following code example shows how to copy an <xref:System.Array> to another <xref:System.Array> with a nonzero lower bound.</span></span> <span data-ttu-id="08e41-779">请注意，将复制整个源 <xref:System.Array>，包括覆盖目标 <xref:System.Array>中现有元素的空元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-779">Note that the entire source <xref:System.Array> is copied, including empty elements that overwrite existing elements in the target <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-780"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-780"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-781"><paramref name="index" /> 超出了 <paramref name="array" /> 的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-781"><paramref name="index" /> is outside the range of valid indexes for <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-782"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="08e41-782"><paramref name="array" /> is multidimensional.</span></span>  
  
<span data-ttu-id="08e41-783">或</span><span class="sxs-lookup"><span data-stu-id="08e41-783">-or-</span></span> 
<span data-ttu-id="08e41-784">源数组中的元素数大于从 <paramref name="index" /> 到目标 <paramref name="array" /> 的末尾之间的可用元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-784">The number of elements in the source array is greater than the available number of elements from <paramref name="index" /> to the end of the destination <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="08e41-785">无法自动将源 <see cref="T:System.Array" /> 的类型转换为目标 <paramref name="array" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-785">The type of the source <see cref="T:System.Array" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="08e41-786">源 <see cref="T:System.Array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="08e41-786">The source <see cref="T:System.Array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="08e41-787">源 <see cref="T:System.Array" /> 中至少有一个元素无法转换为目标 <paramref name="array" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-787">At least one element in the source <see cref="T:System.Array" /> cannot be cast to the type of destination <paramref name="array" />.</span></span></exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="08e41-788">初始化 <see cref="T:System.Array" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="08e41-788">Initializes a new instance of the <see cref="T:System.Array" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="elementType"><span data-ttu-id="08e41-789">要创建的 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-789">The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="length"><span data-ttu-id="08e41-790">要创建的 <see cref="T:System.Array" /> 的大小。</span><span class="sxs-lookup"><span data-stu-id="08e41-790">The size of the <see cref="T:System.Array" /> to create.</span></span></param>
        <summary><span data-ttu-id="08e41-791">创建使用从零开始的索引、具有指定 <see cref="T:System.Type" /> 和长度的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-791">Creates a one-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and length, with zero-based indexing.</span></span></summary>
        <returns><span data-ttu-id="08e41-792">使用从零开始的索引、具有指定 <see cref="T:System.Type" /> 和长度的新的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-792">A new one-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length, using zero-based indexing.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-793">与大多数类不同，<xref:System.Array> 提供 <xref:System.Array.CreateInstance%2A> 方法（而不是公共构造函数），以允许进行后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="08e41-793">Unlike most classes, <xref:System.Array> provides the <xref:System.Array.CreateInstance%2A> method, instead of public constructors, to allow for late bound access.</span></span>  
  
 <span data-ttu-id="08e41-794">引用类型元素初始化为 `null`。</span><span class="sxs-lookup"><span data-stu-id="08e41-794">Reference-type elements are initialized to `null`.</span></span> <span data-ttu-id="08e41-795">值类型元素初始化为零。</span><span class="sxs-lookup"><span data-stu-id="08e41-795">Value-type elements are initialized to zero.</span></span>  
  
 <span data-ttu-id="08e41-796">此方法是一个 O （`n`）操作，其中 `n` 是 `length`的。</span><span class="sxs-lookup"><span data-stu-id="08e41-796">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-797">下面的代码示例演示如何创建和初始化一维 <xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="08e41-797">The following code example shows how to create and initialize a one-dimensional <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CreateInstance Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-798"><paramref name="elementType" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-798"><paramref name="elementType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-799"><paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-799"><paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="08e41-800">不支持 <paramref name="elementType" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-800"><paramref name="elementType" /> is not supported.</span></span> <span data-ttu-id="08e41-801">例如，不支持 <see cref="T:System.Void" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-801">For example, <see cref="T:System.Void" /> is not supported.</span></span>  
  
<span data-ttu-id="08e41-802">或</span><span class="sxs-lookup"><span data-stu-id="08e41-802">-or-</span></span> 
 <span data-ttu-id="08e41-803"><paramref name="elementType" /> 为开放式泛型类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-803"><paramref name="elementType" /> is an open generic type.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-804"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-804"><paramref name="length" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params int[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;int&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType"><span data-ttu-id="08e41-805">要创建的 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-805">The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="lengths"><span data-ttu-id="08e41-806">一个 32 位整数数组，它表示要创建的 <see cref="T:System.Array" /> 中每个维度的大小。</span><span class="sxs-lookup"><span data-stu-id="08e41-806">An array of 32-bit integers that represent the size of each dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <summary><span data-ttu-id="08e41-807">创建索引从零开始、具有指定 <see cref="T:System.Type" /> 和维长的多维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-807">Creates a multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and dimension lengths, with zero-based indexing.</span></span> <span data-ttu-id="08e41-808">维的长度在一个 32 位整数数组中指定。</span><span class="sxs-lookup"><span data-stu-id="08e41-808">The dimension lengths are specified in an array of 32-bit integers.</span></span></summary>
        <returns><span data-ttu-id="08e41-809">指定 <see cref="T:System.Type" /> 的新多维 <see cref="T:System.Array" />，该数组每个维具有指定长度，且使用从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-809">A new multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length for each dimension, using zero-based indexing.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-810">与大多数类不同，<xref:System.Array> 提供 <xref:System.Array.CreateInstance%2A> 方法（而不是公共构造函数），以允许进行后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="08e41-810">Unlike most classes, <xref:System.Array> provides the <xref:System.Array.CreateInstance%2A> method, instead of public constructors, to allow for late bound access.</span></span>  
  
 <span data-ttu-id="08e41-811">`lengths` 数组中的元素数必须等于新 <xref:System.Array>中的维数。</span><span class="sxs-lookup"><span data-stu-id="08e41-811">The number of elements in the `lengths` array must equal the number of dimensions in the new <xref:System.Array>.</span></span> <span data-ttu-id="08e41-812">`lengths` 数组的每个元素都必须在新的 <xref:System.Array>中指定相应维度的长度。</span><span class="sxs-lookup"><span data-stu-id="08e41-812">Each element of the `lengths` array must specify the length of the corresponding dimension in the new <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="08e41-813">引用类型元素初始化为 `null`。</span><span class="sxs-lookup"><span data-stu-id="08e41-813">Reference-type elements are initialized to `null`.</span></span> <span data-ttu-id="08e41-814">值类型元素初始化为零。</span><span class="sxs-lookup"><span data-stu-id="08e41-814">Value-type elements are initialized to zero.</span></span>  
  
 <span data-ttu-id="08e41-815">此方法为 O （`n`）运算，其中 `n` 是 `lengths`中所有值的乘积。</span><span class="sxs-lookup"><span data-stu-id="08e41-815">This method is an O(`n`) operation, where `n` is the product of all values in `lengths`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-816">下面的代码示例演示如何创建和初始化多维 <xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="08e41-816">The following code example shows how to create and initialize a multidimensional <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-817"><paramref name="elementType" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-817"><paramref name="elementType" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="08e41-818">或</span><span class="sxs-lookup"><span data-stu-id="08e41-818">-or-</span></span> 
 <span data-ttu-id="08e41-819"><paramref name="lengths" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-819"><paramref name="lengths" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-820"><paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-820"><paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="08e41-821">或</span><span class="sxs-lookup"><span data-stu-id="08e41-821">-or-</span></span> 
<span data-ttu-id="08e41-822"><paramref name="lengths" /> 数组包含的元素少于一个。</span><span class="sxs-lookup"><span data-stu-id="08e41-822">The <paramref name="lengths" /> array contains less than one element.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="08e41-823">不支持 <paramref name="elementType" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-823"><paramref name="elementType" /> is not supported.</span></span> <span data-ttu-id="08e41-824">例如，不支持 <see cref="T:System.Void" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-824">For example, <see cref="T:System.Void" /> is not supported.</span></span>  
  
<span data-ttu-id="08e41-825">或</span><span class="sxs-lookup"><span data-stu-id="08e41-825">-or-</span></span> 
 <span data-ttu-id="08e41-826"><paramref name="elementType" /> 为开放式泛型类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-826"><paramref name="elementType" /> is an open generic type.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-827"><paramref name="lengths" /> 中的任何值都小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-827">Any value in <paramref name="lengths" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params long[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int64[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Long()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;long&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int64[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="lengths" Type="System.Int64[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType"><span data-ttu-id="08e41-828">要创建的 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-828">The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="lengths"><span data-ttu-id="08e41-829">一个 64 位整数数组，它表示要创建的 <see cref="T:System.Array" /> 中每个维度的大小。</span><span class="sxs-lookup"><span data-stu-id="08e41-829">An array of 64-bit integers that represent the size of each dimension of the <see cref="T:System.Array" /> to create.</span></span> <span data-ttu-id="08e41-830">数组中的每个整数都必须介于零和 <see cref="F:System.Int32.MaxValue" /> 之间，（包括零和 System.Int32.MaxValue）。</span><span class="sxs-lookup"><span data-stu-id="08e41-830">Each integer in the array must be between zero and <see cref="F:System.Int32.MaxValue" />, inclusive.</span></span></param>
        <summary><span data-ttu-id="08e41-831">创建索引从零开始、具有指定 <see cref="T:System.Type" /> 和维长的多维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-831">Creates a multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and dimension lengths, with zero-based indexing.</span></span> <span data-ttu-id="08e41-832">维度的长度在一个 64 位整数数组中指定。</span><span class="sxs-lookup"><span data-stu-id="08e41-832">The dimension lengths are specified in an array of 64-bit integers.</span></span></summary>
        <returns><span data-ttu-id="08e41-833">指定 <see cref="T:System.Type" /> 的新多维 <see cref="T:System.Array" />，该数组每个维具有指定长度，且使用从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-833">A new multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length for each dimension, using zero-based indexing.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-834">与大多数类不同，<xref:System.Array> 提供 <xref:System.Array.CreateInstance%2A> 方法（而不是公共构造函数），以允许进行后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="08e41-834">Unlike most classes, <xref:System.Array> provides the <xref:System.Array.CreateInstance%2A> method, instead of public constructors, to allow for late bound access.</span></span>  
  
 <span data-ttu-id="08e41-835">`lengths` 数组中的元素数必须等于新 <xref:System.Array>中的维数。</span><span class="sxs-lookup"><span data-stu-id="08e41-835">The number of elements in the `lengths` array must equal the number of dimensions in the new <xref:System.Array>.</span></span> <span data-ttu-id="08e41-836">`lengths` 数组的每个元素都必须在新的 <xref:System.Array>中指定相应维度的长度。</span><span class="sxs-lookup"><span data-stu-id="08e41-836">Each element of the `lengths` array must specify the length of the corresponding dimension in the new <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="08e41-837">引用类型元素初始化为 `null`。</span><span class="sxs-lookup"><span data-stu-id="08e41-837">Reference-type elements are initialized to `null`.</span></span> <span data-ttu-id="08e41-838">值类型元素初始化为零。</span><span class="sxs-lookup"><span data-stu-id="08e41-838">Value-type elements are initialized to zero.</span></span>  
  
 <span data-ttu-id="08e41-839">此方法为 O （`n`）运算，其中 `n` 是 `lengths`中所有值的乘积。</span><span class="sxs-lookup"><span data-stu-id="08e41-839">This method is an O(`n`) operation, where `n` is the product of all values in `lengths`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-840">下面的代码示例演示如何创建和初始化多维 <xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="08e41-840">The following code example shows how to create and initialize a multidimensional <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-841"><paramref name="elementType" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-841"><paramref name="elementType" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="08e41-842">或</span><span class="sxs-lookup"><span data-stu-id="08e41-842">-or-</span></span> 
 <span data-ttu-id="08e41-843"><paramref name="lengths" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-843"><paramref name="lengths" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-844"><paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-844"><paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="08e41-845">或</span><span class="sxs-lookup"><span data-stu-id="08e41-845">-or-</span></span> 
<span data-ttu-id="08e41-846"><paramref name="lengths" /> 数组包含的元素少于一个。</span><span class="sxs-lookup"><span data-stu-id="08e41-846">The <paramref name="lengths" /> array contains less than one element.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="08e41-847">不支持 <paramref name="elementType" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-847"><paramref name="elementType" /> is not supported.</span></span> <span data-ttu-id="08e41-848">例如，不支持 <see cref="T:System.Void" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-848">For example, <see cref="T:System.Void" /> is not supported.</span></span>  
  
<span data-ttu-id="08e41-849">或</span><span class="sxs-lookup"><span data-stu-id="08e41-849">-or-</span></span> 
 <span data-ttu-id="08e41-850"><paramref name="elementType" /> 为开放式泛型类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-850"><paramref name="elementType" /> is an open generic type.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-851"><paramref name="lengths" /> 中的任何值小于零或大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-851">Any value in <paramref name="lengths" /> is less than zero or greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="elementType"><span data-ttu-id="08e41-852">要创建的 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-852">The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="length1"><span data-ttu-id="08e41-853">要创建的 <see cref="T:System.Array" /> 的第一维的大小。</span><span class="sxs-lookup"><span data-stu-id="08e41-853">The size of the first dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="length2"><span data-ttu-id="08e41-854">要创建的 <see cref="T:System.Array" /> 的第二维的大小。</span><span class="sxs-lookup"><span data-stu-id="08e41-854">The size of the second dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <summary><span data-ttu-id="08e41-855">创建使用从零开始的索引、具有指定 <see cref="T:System.Array" /> 和维长的二维 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-855">Creates a two-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and dimension lengths, with zero-based indexing.</span></span></summary>
        <returns><span data-ttu-id="08e41-856">使用从零开始的索引、具有指定 <see cref="T:System.Type" /> 的新的二维 <see cref="T:System.Array" />，其每个维度都为指定的长度。</span><span class="sxs-lookup"><span data-stu-id="08e41-856">A new two-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length for each dimension, using zero-based indexing.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-857">与大多数类不同，<xref:System.Array> 提供 <xref:System.Array.CreateInstance%2A> 方法（而不是公共构造函数），以允许进行后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="08e41-857">Unlike most classes, <xref:System.Array> provides the <xref:System.Array.CreateInstance%2A> method, instead of public constructors, to allow for late bound access.</span></span>  
  
 <span data-ttu-id="08e41-858">引用类型元素初始化为 `null`。</span><span class="sxs-lookup"><span data-stu-id="08e41-858">Reference-type elements are initialized to `null`.</span></span> <span data-ttu-id="08e41-859">值类型元素初始化为零。</span><span class="sxs-lookup"><span data-stu-id="08e41-859">Value-type elements are initialized to zero.</span></span>  
  
 <span data-ttu-id="08e41-860">此方法是一个 O （`n`）操作，其中 `n` 是 `length1` 和 `length2`的产品。</span><span class="sxs-lookup"><span data-stu-id="08e41-860">This method is an O(`n`) operation, where `n` is the product of `length1` and `length2`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-861">下面的代码示例演示如何创建和初始化二维 <xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="08e41-861">The following code example shows how to create and initialize a two-dimensional <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-862"><paramref name="elementType" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-862"><paramref name="elementType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-863"><paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-863"><paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="08e41-864">不支持 <paramref name="elementType" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-864"><paramref name="elementType" /> is not supported.</span></span> <span data-ttu-id="08e41-865">例如，不支持 <see cref="T:System.Void" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-865">For example, <see cref="T:System.Void" /> is not supported.</span></span>  
  
<span data-ttu-id="08e41-866">或</span><span class="sxs-lookup"><span data-stu-id="08e41-866">-or-</span></span> 
 <span data-ttu-id="08e41-867"><paramref name="elementType" /> 为开放式泛型类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-867"><paramref name="elementType" /> is an open generic type.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-868"><paramref name="length1" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-868"><paramref name="length1" /> is less than zero.</span></span>  
  
<span data-ttu-id="08e41-869">或</span><span class="sxs-lookup"><span data-stu-id="08e41-869">-or-</span></span> 
 <span data-ttu-id="08e41-870"><paramref name="length2" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-870"><paramref name="length2" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths, int[] lowerBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths, int32[] lowerBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, lengths As Integer(), lowerBounds As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, cli::array &lt;int&gt; ^ lengths, cli::array &lt;int&gt; ^ lowerBounds);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths, lowerBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]" />
        <Parameter Name="lowerBounds" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="elementType"><span data-ttu-id="08e41-871">要创建的 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-871">The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="lengths"><span data-ttu-id="08e41-872">一维数组，它包含要创建的 <see cref="T:System.Array" /> 的每个维度的大小。</span><span class="sxs-lookup"><span data-stu-id="08e41-872">A one-dimensional array that contains the size of each dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="lowerBounds"><span data-ttu-id="08e41-873">一维数组，它包含要创建的 <see cref="T:System.Array" /> 的每个维度的下限（起始索引）。</span><span class="sxs-lookup"><span data-stu-id="08e41-873">A one-dimensional array that contains the lower bound (starting index) of each dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <summary><span data-ttu-id="08e41-874">创建具有指定下限、指定 <see cref="T:System.Array" /> 和维长的多维 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-874">Creates a multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and dimension lengths, with the specified lower bounds.</span></span></summary>
        <returns><span data-ttu-id="08e41-875">具有指定 <see cref="T:System.Type" /> 的新的多维 <see cref="T:System.Array" />，其每个维度都具有指定长度和下限。</span><span class="sxs-lookup"><span data-stu-id="08e41-875">A new multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length and lower bound for each dimension.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-876">与大多数类不同，<xref:System.Array> 提供 <xref:System.Array.CreateInstance%2A> 方法（而不是公共构造函数），以允许进行后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="08e41-876">Unlike most classes, <xref:System.Array> provides the <xref:System.Array.CreateInstance%2A> method, instead of public constructors, to allow for late bound access.</span></span>  
  
 <span data-ttu-id="08e41-877">`lengths` 和 `lowerBounds` 数组必须具有相同数量的元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-877">The `lengths` and `lowerBounds` arrays must have the same number of elements.</span></span> <span data-ttu-id="08e41-878">`lengths` 数组中的元素数必须等于新 <xref:System.Array>中的维数。</span><span class="sxs-lookup"><span data-stu-id="08e41-878">The number of elements in the `lengths` array must equal the number of dimensions in the new <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="08e41-879">`lengths` 数组的每个元素都必须在新的 <xref:System.Array>中指定相应维度的长度。</span><span class="sxs-lookup"><span data-stu-id="08e41-879">Each element of the `lengths` array must specify the length of the corresponding dimension in the new <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="08e41-880">`lowerBounds` 数组的每个元素都必须在新 <xref:System.Array>中指定相应维度的下限。</span><span class="sxs-lookup"><span data-stu-id="08e41-880">Each element of the `lowerBounds` array must specify the lower bound of the corresponding dimension in the new <xref:System.Array>.</span></span> <span data-ttu-id="08e41-881">通常，.NET Framework 类库和许多编程语言不处理非零的下限。</span><span class="sxs-lookup"><span data-stu-id="08e41-881">Generally, the .NET Framework class library and many programming languages do not handle nonzero lower bounds.</span></span>  
  
 <span data-ttu-id="08e41-882">引用类型元素初始化为 `null`。</span><span class="sxs-lookup"><span data-stu-id="08e41-882">Reference-type elements are initialized to `null`.</span></span> <span data-ttu-id="08e41-883">值类型元素初始化为零。</span><span class="sxs-lookup"><span data-stu-id="08e41-883">Value-type elements are initialized to zero.</span></span>  
  
 <span data-ttu-id="08e41-884">此方法为 O （`n`）运算，其中 `n` 是 `lengths`中所有值的乘积。</span><span class="sxs-lookup"><span data-stu-id="08e41-884">This method is an O(`n`) operation, where `n` is the product of all values in `lengths`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-885">下面的代码示例演示如何创建和初始化具有指定下限的多维 <xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="08e41-885">The following code example shows how to create and initialize a multidimensional <xref:System.Array> with specified lower bounds.</span></span>  
  
 [!code-cpp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-886"><paramref name="elementType" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-886"><paramref name="elementType" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="08e41-887">或</span><span class="sxs-lookup"><span data-stu-id="08e41-887">-or-</span></span> 
 <span data-ttu-id="08e41-888"><paramref name="lengths" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-888"><paramref name="lengths" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="08e41-889">或</span><span class="sxs-lookup"><span data-stu-id="08e41-889">-or-</span></span> 
 <span data-ttu-id="08e41-890"><paramref name="lowerBounds" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-890"><paramref name="lowerBounds" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-891"><paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-891"><paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="08e41-892">或</span><span class="sxs-lookup"><span data-stu-id="08e41-892">-or-</span></span> 
<span data-ttu-id="08e41-893"><paramref name="lengths" /> 数组包含的元素少于一个。</span><span class="sxs-lookup"><span data-stu-id="08e41-893">The <paramref name="lengths" /> array contains less than one element.</span></span>  
  
<span data-ttu-id="08e41-894">或</span><span class="sxs-lookup"><span data-stu-id="08e41-894">-or-</span></span> 
<span data-ttu-id="08e41-895"><paramref name="lengths" /> 和 <paramref name="lowerBounds" /> 数组包含的元素数不同。</span><span class="sxs-lookup"><span data-stu-id="08e41-895">The <paramref name="lengths" /> and <paramref name="lowerBounds" /> arrays do not contain the same number of elements.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="08e41-896">不支持 <paramref name="elementType" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-896"><paramref name="elementType" /> is not supported.</span></span> <span data-ttu-id="08e41-897">例如，不支持 <see cref="T:System.Void" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-897">For example, <see cref="T:System.Void" /> is not supported.</span></span>  
  
<span data-ttu-id="08e41-898">或</span><span class="sxs-lookup"><span data-stu-id="08e41-898">-or-</span></span> 
 <span data-ttu-id="08e41-899"><paramref name="elementType" /> 为开放式泛型类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-899"><paramref name="elementType" /> is an open generic type.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-900"><paramref name="lengths" /> 中的任何值都小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-900">Any value in <paramref name="lengths" /> is less than zero.</span></span>  
  
<span data-ttu-id="08e41-901">或</span><span class="sxs-lookup"><span data-stu-id="08e41-901">-or-</span></span> 
<span data-ttu-id="08e41-902"><paramref name="lowerBounds" /> 中的任意一个值都很大，因此，维的下限和长度的和大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-902">Any value in <paramref name="lowerBounds" /> is very large, such that the sum of a dimension's lower bound and length is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer, length3 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2, length3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length3" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="elementType"><span data-ttu-id="08e41-903">要创建的 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-903">The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="length1"><span data-ttu-id="08e41-904">要创建的 <see cref="T:System.Array" /> 的第一维的大小。</span><span class="sxs-lookup"><span data-stu-id="08e41-904">The size of the first dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="length2"><span data-ttu-id="08e41-905">要创建的 <see cref="T:System.Array" /> 的第二维的大小。</span><span class="sxs-lookup"><span data-stu-id="08e41-905">The size of the second dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="length3"><span data-ttu-id="08e41-906">要创建的 <see cref="T:System.Array" /> 的第三维的大小。</span><span class="sxs-lookup"><span data-stu-id="08e41-906">The size of the third dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <summary><span data-ttu-id="08e41-907">创建使用从零开始的索引、具有指定 <see cref="T:System.Type" /> 和维长的三维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-907">Creates a three-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and dimension lengths, with zero-based indexing.</span></span></summary>
        <returns><span data-ttu-id="08e41-908">每个维具有指定长度、使用从零开始的索引的指定 <see cref="T:System.Type" /> 的新三维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-908">A new three-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length for each dimension, using zero-based indexing.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-909">与大多数类不同，<xref:System.Array> 提供 <xref:System.Array.CreateInstance%2A> 方法（而不是公共构造函数），以允许进行后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="08e41-909">Unlike most classes, <xref:System.Array> provides the <xref:System.Array.CreateInstance%2A> method, instead of public constructors, to allow for late bound access.</span></span>  
  
 <span data-ttu-id="08e41-910">引用类型元素初始化为 `null`。</span><span class="sxs-lookup"><span data-stu-id="08e41-910">Reference-type elements are initialized to `null`.</span></span> <span data-ttu-id="08e41-911">值类型元素初始化为零。</span><span class="sxs-lookup"><span data-stu-id="08e41-911">Value-type elements are initialized to zero.</span></span>  
  
 <span data-ttu-id="08e41-912">此方法是一个 O （`n`）操作，其中 `n` 是 `length1`、`length2`和 `length3`的产品。</span><span class="sxs-lookup"><span data-stu-id="08e41-912">This method is an O(`n`) operation, where `n` is the product of `length1`, `length2`, and `length3`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-913">下面的代码示例演示如何创建和初始化三维 <xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="08e41-913">The following code example shows how to create and initialize a three-dimensional <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-914"><paramref name="elementType" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-914"><paramref name="elementType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-915"><paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-915"><paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="08e41-916">不支持 <paramref name="elementType" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-916"><paramref name="elementType" /> is not supported.</span></span> <span data-ttu-id="08e41-917">例如，不支持 <see cref="T:System.Void" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-917">For example, <see cref="T:System.Void" /> is not supported.</span></span>  
  
<span data-ttu-id="08e41-918">或</span><span class="sxs-lookup"><span data-stu-id="08e41-918">-or-</span></span> 
 <span data-ttu-id="08e41-919"><paramref name="elementType" /> 为开放式泛型类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-919"><paramref name="elementType" /> is an open generic type.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-920"><paramref name="length1" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-920"><paramref name="length1" /> is less than zero.</span></span>  
  
<span data-ttu-id="08e41-921">或</span><span class="sxs-lookup"><span data-stu-id="08e41-921">-or-</span></span> 
 <span data-ttu-id="08e41-922"><paramref name="length2" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-922"><paramref name="length2" /> is less than zero.</span></span>  
  
<span data-ttu-id="08e41-923">或</span><span class="sxs-lookup"><span data-stu-id="08e41-923">-or-</span></span> 
 <span data-ttu-id="08e41-924"><paramref name="length3" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-924"><paramref name="length3" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty(Of T) () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; 'T[]" Usage="System.Array.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-925">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-925">The type of the elements of the array.</span></span></typeparam>
        <summary><span data-ttu-id="08e41-926">返回一个空数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-926">Returns an empty array.</span></span></summary>
        <returns><span data-ttu-id="08e41-927">空数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-927">An empty array.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Exists : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.Exists (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-928">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-928">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-929">要搜索的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-929">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="match"><span data-ttu-id="08e41-930"><see cref="T:System.Predicate`1" />，定义要搜索的元素的条件。</span><span class="sxs-lookup"><span data-stu-id="08e41-930">The <see cref="T:System.Predicate`1" /> that defines the conditions of the elements to search for.</span></span></param>
        <summary><span data-ttu-id="08e41-931">确定指定数组包含的元素是否与指定谓词定义的条件匹配。</span><span class="sxs-lookup"><span data-stu-id="08e41-931">Determines whether the specified array contains elements that match the conditions defined by the specified predicate.</span></span></summary>
        <returns><span data-ttu-id="08e41-932">如果 <paramref name="array" /> 包含一个或多个与指定谓词所定义的条件相匹配的元素，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-932"><see langword="true" /> if <paramref name="array" /> contains one or more elements that match the conditions defined by the specified predicate; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-933"><xref:System.Predicate%601> 是一个方法委托，如果传递给它的对象与委托中定义的条件相匹配，则该方法将返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="08e41-933">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="08e41-934">`array` 的元素分别传递到 <xref:System.Predicate%601>中，当找到匹配项时，将停止处理。</span><span class="sxs-lookup"><span data-stu-id="08e41-934">The elements of `array` are individually passed to the <xref:System.Predicate%601>, and processing is stopped when a match is found.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-935">在C#和 Visual Basic 中，无需显式创建 <xref:System.Predicate%601> 委托。</span><span class="sxs-lookup"><span data-stu-id="08e41-935">In C# and Visual Basic, it is not necessary to create the <xref:System.Predicate%601> delegate explicitly.</span></span> <span data-ttu-id="08e41-936">这些语言从上下文推断正确的委托并自动创建它。</span><span class="sxs-lookup"><span data-stu-id="08e41-936">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="08e41-937">此方法是一个 O （`n`）操作，其中 `n` 是 `array`的 <xref:System.Array.Length%2A>。</span><span class="sxs-lookup"><span data-stu-id="08e41-937">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-938">下面的示例使用 lambda 表达式指定 <xref:System.Array.Exists%2A> 方法的匹配条件，以检查行星是否以给定的字母开头，或者是否在给定的数组中找到了行星。</span><span class="sxs-lookup"><span data-stu-id="08e41-938">The following example specifies the match conditions for the <xref:System.Array.Exists%2A> method using lambda expressions to check whether a planet starts with a given letter or whether the planet is found on the given array.</span></span>  
  
 [!code-csharp[System.Array.Exists#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists3.cs#3)]
 [!code-vb[System.Array.Exists#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists3.vb#3)]  
  
 <span data-ttu-id="08e41-939">下面的示例使用 <xref:System.Array.Exists%2A> 方法来指示字符串数组中的任何名称是否以指定字符开头。</span><span class="sxs-lookup"><span data-stu-id="08e41-939">The following example uses the <xref:System.Array.Exists%2A> method to indicate whether any names in a string array begin with a specified character.</span></span> <span data-ttu-id="08e41-940">该示例通过将要搜索的字符串传递到其类构造函数来实例化一个 `StringSearcher` 对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-940">The example instantiates a `StringSearcher` object by passing the string to search for to its class constructor.</span></span> <span data-ttu-id="08e41-941">`StringSearcher.StartsWith` 方法与 <xref:System.Predicate%601> 委托具有相同的签名。</span><span class="sxs-lookup"><span data-stu-id="08e41-941">The `StringSearcher.StartsWith` method has same signature as the <xref:System.Predicate%601> delegate.</span></span> <span data-ttu-id="08e41-942">调用 <xref:System.Array.Exists%2A> 方法时，会将数组的每个成员传递给委托，直到返回 `true` 或循环访问数组中的所有元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-942">When the <xref:System.Array.Exists%2A> method is called, each member of the array is passed to the delegate until it returns `true` or iterates all the elements in the array.</span></span>  
  
 [!code-csharp[System.Array.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists1.cs#1)]
 [!code-vb[System.Array.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists1.vb#1)]  
  
 <span data-ttu-id="08e41-943">你还可以使用 lambda 表达式，而不是显式定义其签名与委托的签名对应的方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-943">You can also use a lambda expression rather than explicitly define a method whose signature corresponds to that of the delegate.</span></span> <span data-ttu-id="08e41-944">下面的示例将 `StringSearcher` 类及其 `StartsWith` 方法替换为 lambda 表达式。</span><span class="sxs-lookup"><span data-stu-id="08e41-944">The following example replaces the `StringSearcher` class and its `StartsWith` method with a lambda expression.</span></span>  
  
 [!code-csharp[System.Array.Exists#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists2.cs#2)]
 [!code-vb[System.Array.Exists#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-945"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-945"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="08e41-946">或</span><span class="sxs-lookup"><span data-stu-id="08e41-946">-or-</span></span> 
 <span data-ttu-id="08e41-947"><paramref name="match" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-947"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
        <related type="Article" href="~/docs/csharp/programming-guide/statements-expressions-operators/lambda-expressions.md"><span data-ttu-id="08e41-948">Lambda 表达式（C# 编程指南）</span><span class="sxs-lookup"><span data-stu-id="08e41-948">Lambda Expressions (C# Programming Guide)</span></span></related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/procedures/lambda-expressions.md"><span data-ttu-id="08e41-949">Lambda 表达式 (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="08e41-949">Lambda Expressions (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T -&gt; unit" Usage="System.Array.Fill (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-950">数组中元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-950">The type of the elements in the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-951">要填充的数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-951">The array to be filled.</span></span></param>
        <param name="value"><span data-ttu-id="08e41-952">要分配给每个数组元素的值。</span><span class="sxs-lookup"><span data-stu-id="08e41-952">The value to assign to each array element.</span></span></param>
        <summary><span data-ttu-id="08e41-953">将类型为 <typeparamref name="T" /> 的给定 <paramref name="value" /> 分配给指定的 <paramref name="array" /> 的每个元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-953">Assigns the given <paramref name="value" /> of type <typeparamref name="T" /> to each element of the specified <paramref name="array" />.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T, startIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T * int * int -&gt; unit" Usage="System.Array.Fill (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-954">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-954">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-955">要填充的 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-955">The <see cref="T:System.Array" /> to be filled.</span></span></param>
        <param name="value"><span data-ttu-id="08e41-956">元素在指定范围中的新值。</span><span class="sxs-lookup"><span data-stu-id="08e41-956">The new value for the elements in the specified range.</span></span></param>
        <param name="startIndex"><span data-ttu-id="08e41-957">一个 32 位整数，它表示 <see cref="T:System.Array" /> 中填充开始位置的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-957">A 32-bit integer that represents the index in the <see cref="T:System.Array" /> at which filling begins.</span></span></param>
        <param name="count"><span data-ttu-id="08e41-958">要复制的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-958">The number of elements to copy.</span></span></param>
        <summary><span data-ttu-id="08e41-959">将类型为 <typeparamref name="T" /> 的给定 <paramref name="value" /> 分配给指定的 <paramref name="array" /> 的元素，其位于索引的 <paramref name="startIndex" />（含）到后续 <paramref name="count" /> 数的范围内。</span><span class="sxs-lookup"><span data-stu-id="08e41-959">Assigns the given <paramref name="value" /> of type <typeparamref name="T" /> to the elements of the specified <paramref name="array" /> which are within the range of <paramref name="startIndex" /> (inclusive) and the next <paramref name="count" /> number of indices.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Find&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Find(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Find(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Find : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.Find (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-960">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-960">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-961">要搜索的从零开始的一维数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-961">The one-dimensional, zero-based array to search.</span></span></param>
        <param name="match"><span data-ttu-id="08e41-962">用于定义要搜索的元素的条件的谓词。</span><span class="sxs-lookup"><span data-stu-id="08e41-962">The predicate that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="08e41-963">搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Array" /> 中的第一个匹配元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-963">Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="08e41-964">如果找到与指定谓词定义的条件匹配的第一个元素，则为该元素；否则为类型 <paramref name="T" /> 的默认值。</span><span class="sxs-lookup"><span data-stu-id="08e41-964">The first element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <paramref name="T" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-965"><xref:System.Predicate%601> 是方法或 lambda 表达式的委托，如果传递给它的对象与委托或 lambda 表达式中定义的条件相匹配，则返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="08e41-965">The <xref:System.Predicate%601> is a delegate to a method or a lambda expression that returns `true` if the object passed to it matches the conditions defined in the delegate or lambda expression.</span></span>  <span data-ttu-id="08e41-966">`array` 的元素分别传递到 <xref:System.Predicate%601>，从第一个元素开始，到最后一个元素结束。</span><span class="sxs-lookup"><span data-stu-id="08e41-966">The elements of `array` are individually passed to the <xref:System.Predicate%601>, starting with the first element and ending with the last element.</span></span>  <span data-ttu-id="08e41-967">找到匹配项时将停止处理。</span><span class="sxs-lookup"><span data-stu-id="08e41-967">Processing is stopped when a match is found.</span></span>  
  
 <span data-ttu-id="08e41-968">此方法是一个 O （`n`）操作，其中 `n` 是 `array`的 <xref:System.Array.Length%2A>。</span><span class="sxs-lookup"><span data-stu-id="08e41-968">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-969">下面的示例将 <xref:System.Predicate%601> 委托与 <xref:System.Array.Find%2A> 泛型方法一起使用以搜索 <xref:System.Drawing.Point> 结构的数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-969">The following example uses a <xref:System.Predicate%601> delegate with the <xref:System.Array.Find%2A> generic method to search an array of <xref:System.Drawing.Point> structures.</span></span> <span data-ttu-id="08e41-970">如果 X 和 Y 字段的乘积大于100000，则委托表示的方法 `ProductGT10`返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="08e41-970">The method the delegate represents, `ProductGT10`, returns `true` if the product of the X and Y fields is greater than 100,000.</span></span> <span data-ttu-id="08e41-971"><xref:System.Array.Find%2A> 方法为数组的每个元素调用委托，并返回满足测试条件的第一个点。</span><span class="sxs-lookup"><span data-stu-id="08e41-971">The <xref:System.Array.Find%2A> method calls the delegate for each element of the array, returning the first point that meets the test condition.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-972">Visual Basic 和C#用户不必显式创建委托或指定泛型方法的类型参数。</span><span class="sxs-lookup"><span data-stu-id="08e41-972">Visual Basic and C# users do not have to create the delegate explicitly or specify the type argument of the generic method.</span></span> <span data-ttu-id="08e41-973">编译器根据您提供的方法参数确定必要的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-973">The compilers determine the necessary types from the method arguments you supply.</span></span>  
  
 [!code-csharp[System.Array.Find#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/source.cs#1)]
 [!code-vb[System.Array.Find#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/source.vb#1)]  
  
 <span data-ttu-id="08e41-974">可以使用 lambda 表达式，而不是使用必需的签名显式定义方法，实例化 <xref:System.Predicate%601> 委托并将委托传递到 <xref:System.Array.Find%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-974">Rather than explicitly defining a method with the necessary signature, instantiating a <xref:System.Predicate%601> delegate, and passing the delegate to the <xref:System.Array.Find%2A> method, it is customary to use a lambda expression.</span></span> <span data-ttu-id="08e41-975">下面的示例与上一个示例相同，不同之处在于它使用 lambda 表达式作为 `match` 参数。</span><span class="sxs-lookup"><span data-stu-id="08e41-975">The following example is identical to the previous one, except that it uses a lambda expression as the `match` argument.</span></span>  
  
 [!code-csharp[System.Array.Find#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/lambda.cs#2)]
 [!code-vb[System.Array.Find#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/lambda.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-976"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-976"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="08e41-977">或</span><span class="sxs-lookup"><span data-stu-id="08e41-977">-or-</span></span> 
 <span data-ttu-id="08e41-978"><paramref name="match" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-978"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] FindAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] FindAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAll(Of T) (array As T(), match As Predicate(Of T)) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ FindAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindAll : 'T[] * Predicate&lt;'T&gt; -&gt; 'T[]" Usage="System.Array.FindAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-979">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-979">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-980">要搜索的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-980">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="match"><span data-ttu-id="08e41-981"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</span><span class="sxs-lookup"><span data-stu-id="08e41-981">The <see cref="T:System.Predicate`1" /> that defines the conditions of the elements to search for.</span></span></param>
        <summary><span data-ttu-id="08e41-982">检索与指定谓词定义的条件匹配的所有元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-982">Retrieves all the elements that match the conditions defined by the specified predicate.</span></span></summary>
        <returns><span data-ttu-id="08e41-983">如果找到一个 <see cref="T:System.Array" />，其中所有元素均与指定谓词定义的条件匹配，则为该数组；否则为一个空 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-983">An <see cref="T:System.Array" /> containing all the elements that match the conditions defined by the specified predicate, if found; otherwise, an empty <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-984"><xref:System.Predicate%601> 是一个方法委托，如果传递给它的对象与委托中定义的条件相匹配，则该方法将返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="08e41-984">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="08e41-985">`array` 的元素分别传递到 <xref:System.Predicate%601>，并且与条件相匹配的元素保存在返回的数组中。</span><span class="sxs-lookup"><span data-stu-id="08e41-985">The elements of `array` are individually passed to the <xref:System.Predicate%601>, and the elements that match the conditions are saved in the returned array.</span></span>  
  
 <span data-ttu-id="08e41-986">此方法是一个 O （`n`）操作，其中 `n` 是 `array`的 <xref:System.Array.Length%2A>。</span><span class="sxs-lookup"><span data-stu-id="08e41-986">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-987">下面的示例创建一个50随机数数组，其中的值的范围介于0到1000之间。</span><span class="sxs-lookup"><span data-stu-id="08e41-987">The following example creates an array of 50 random numbers with values that can range from 0 to 1,000.</span></span> <span data-ttu-id="08e41-988">然后，它使用返回从300到600范围内的值的 lambda 表达式调用 <xref:System.Array.FindAll%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-988">It then calls the <xref:System.Array.FindAll%2A> method with a lambda expression that returns the values that range from 300 to 600.</span></span> <span data-ttu-id="08e41-989">请注意，lambda 表达式被传递了一个名为 `x`的参数; 这表示传递到 <xref:System.Predicate%601>的单个数组成员。</span><span class="sxs-lookup"><span data-stu-id="08e41-989">Note that the lambda expression is passed a parameter named `x`;  this represents the individual array member that is passed to the <xref:System.Predicate%601>.</span></span> <span data-ttu-id="08e41-990">另请注意，本地 `lBound` 和 `uBound` 变量可在 lambda 表达式中访问。</span><span class="sxs-lookup"><span data-stu-id="08e41-990">Also note that the local `lBound` and `uBound` variables are accessible within the lambda expression.</span></span>  
  
 [!code-csharp[System.Array.FindAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.findall/cs/findall.cs#1)]
 [!code-vb[System.Array.FindAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.findall/vb/findall.vb#1)]  
  
 <span data-ttu-id="08e41-991">下面的代码示例演示 <xref:System.Array.Find%2A>、<xref:System.Array.FindLast%2A>和 <xref:System.Array.FindAll%2A> 泛型方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-991">The following code example demonstrates the <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, and <xref:System.Array.FindAll%2A> generic methods.</span></span> <span data-ttu-id="08e41-992">创建一个字符串数组，其中包含8个恐龙名称，其中两个名称（位置1和5）以 "saurus" 结尾。</span><span class="sxs-lookup"><span data-stu-id="08e41-992">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="08e41-993">此代码示例还定义了一个名为 `EndsWithSaurus`的搜索谓词方法，该方法接受一个字符串参数，并返回一个布尔值，指示输入字符串是否以 "saurus" 结尾。</span><span class="sxs-lookup"><span data-stu-id="08e41-993">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="08e41-994"><xref:System.Array.Find%2A> 泛型方法从开始处遍历数组，并将每个元素传递到 `EndsWithSaurus` 方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-994">The <xref:System.Array.Find%2A> generic method traverses the array from the beginning, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="08e41-995">当 `EndsWithSaurus` 方法返回元素 "Amargasaurus" 的 `true` 时，搜索将停止。</span><span class="sxs-lookup"><span data-stu-id="08e41-995">The search stops when the `EndsWithSaurus` method returns `true` for the element "Amargasaurus".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-996">在C#和 Visual Basic 中，无需显式创建 `Predicate<string>` 委托（`Predicate(Of String)` Visual Basic 中）。</span><span class="sxs-lookup"><span data-stu-id="08e41-996">In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="08e41-997">这些语言从上下文推断正确的委托并自动创建它。</span><span class="sxs-lookup"><span data-stu-id="08e41-997">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="08e41-998"><xref:System.Array.FindLast%2A> 泛型方法用于从末尾向后搜索数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-998">The <xref:System.Array.FindLast%2A> generic method is used to search the array backward from the end.</span></span> <span data-ttu-id="08e41-999">它在位置5找到元素 "Dilophosaurus"。</span><span class="sxs-lookup"><span data-stu-id="08e41-999">It finds the element "Dilophosaurus" at position 5.</span></span> <span data-ttu-id="08e41-1000"><xref:System.Array.FindAll%2A> 泛型方法用于返回数组，该数组包含以 "saurus" 结尾的所有元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1000">The <xref:System.Array.FindAll%2A> generic method is used to return an array containing all the elements that end in "saurus".</span></span> <span data-ttu-id="08e41-1001">显示元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1001">The elements are displayed.</span></span>  
  
 <span data-ttu-id="08e41-1002">此代码示例还演示了 <xref:System.Array.Exists%2A> 和 <xref:System.Array.TrueForAll%2A> 泛型方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1002">The code example also demonstrates the <xref:System.Array.Exists%2A> and <xref:System.Array.TrueForAll%2A> generic methods.</span></span>  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1003"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1003"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="08e41-1004">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1004">-or-</span></span> 
 <span data-ttu-id="08e41-1005"><paramref name="match" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1005"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="08e41-1006">在 <see cref="T:System.Array" /> 或其某个部分中搜索与指定谓词所定义的条件相匹配的元素，并返回第一个匹配项的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1006">Searches for an element that matches the conditions defined by a specified predicate, and returns the zero-based index of the first occurrence within an <see cref="T:System.Array" /> or a portion of it.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-1007">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-1007">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-1008">要搜索的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1008">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="match"><span data-ttu-id="08e41-1009"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</span><span class="sxs-lookup"><span data-stu-id="08e41-1009">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="08e41-1010">搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Array" /> 中第一个匹配元素的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1010">Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the entire <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="08e41-1011">如果找到与 <paramref name="match" /> 定义的条件相匹配的第一个元素，则为该元素的从零开始的索引；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="08e41-1011">The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1012">将从第一个元素开始向前搜索 <xref:System.Array>，并在最后一个元素结束。</span><span class="sxs-lookup"><span data-stu-id="08e41-1012">The <xref:System.Array> is searched forward starting at the first element and ending at the last element.</span></span>  
  
 <span data-ttu-id="08e41-1013"><xref:System.Predicate%601> 是一个方法委托，如果传递给它的对象与委托中定义的条件相匹配，则该方法将返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="08e41-1013">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="08e41-1014">`array` 的元素分别传递到 <xref:System.Predicate%601>中。</span><span class="sxs-lookup"><span data-stu-id="08e41-1014">The elements of `array` are individually passed to the <xref:System.Predicate%601>.</span></span>  
  
 <span data-ttu-id="08e41-1015">此方法是一个 O （`n`）操作，其中 `n` 是 `array`的 <xref:System.Array.Length%2A>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1015">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1016">下面的代码示例演示 <xref:System.Array.FindIndex%2A> 泛型方法的所有三个重载。</span><span class="sxs-lookup"><span data-stu-id="08e41-1016">The following code example demonstrates all three overloads of the <xref:System.Array.FindIndex%2A> generic method.</span></span> <span data-ttu-id="08e41-1017">创建一个字符串数组，其中包含8个恐龙名称，其中两个名称（位置1和5）以 "saurus" 结尾。</span><span class="sxs-lookup"><span data-stu-id="08e41-1017">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="08e41-1018">此代码示例还定义了一个名为 `EndsWithSaurus`的搜索谓词方法，该方法接受一个字符串参数，并返回一个布尔值，指示输入字符串是否以 "saurus" 结尾。</span><span class="sxs-lookup"><span data-stu-id="08e41-1018">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="08e41-1019"><xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> 方法重载从开始处遍历数组，并将每个元素传递到 `EndsWithSaurus` 方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1019">The <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> method overload traverses the array from the beginning, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="08e41-1020">当 `EndsWithSaurus` 方法返回位于位置1的元素 `true` 时，搜索将停止。</span><span class="sxs-lookup"><span data-stu-id="08e41-1020">The search stops when the `EndsWithSaurus` method returns `true` for the element at position 1.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-1021">在C#和 Visual Basic 中，无需显式创建 `Predicate<string>` 委托（`Predicate(Of String)` Visual Basic 中）。</span><span class="sxs-lookup"><span data-stu-id="08e41-1021">In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="08e41-1022">这些语言从上下文推断正确的委托并自动创建它。</span><span class="sxs-lookup"><span data-stu-id="08e41-1022">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="08e41-1023"><xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 方法重载用于从位置2开始搜索数组，并继续到数组末尾。</span><span class="sxs-lookup"><span data-stu-id="08e41-1023">The <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the array beginning at position 2 and continuing to the end of the array.</span></span> <span data-ttu-id="08e41-1024">它在位置5找到元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1024">It finds the element at position 5.</span></span> <span data-ttu-id="08e41-1025">最后，<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 方法重载用于搜索从位置2开始的三个元素的范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1025">Finally, the <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the range of three elements beginning at position 2.</span></span> <span data-ttu-id="08e41-1026">它将返回-1，因为该范围中没有以 "saurus" 结尾的恐龙名称。</span><span class="sxs-lookup"><span data-stu-id="08e41-1026">It returns -1 because there are no dinosaur names in that range that end with "saurus".</span></span>  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1027"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1027"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="08e41-1028">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1028">-or-</span></span> 
 <span data-ttu-id="08e41-1029"><paramref name="match" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1029"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-1030">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-1030">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-1031">要搜索的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1031">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="startIndex"><span data-ttu-id="08e41-1032">从零开始的搜索的起始索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1032">The zero-based starting index of the search.</span></span></param>
        <param name="match"><span data-ttu-id="08e41-1033"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</span><span class="sxs-lookup"><span data-stu-id="08e41-1033">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="08e41-1034">搜索与指定谓词所定义的条件相匹配的元素，并返回 <see cref="T:System.Array" /> 中从指定索引到最后一个元素的元素范围内第一个匹配项的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1034">Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <see cref="T:System.Array" /> that extends from the specified index to the last element.</span></span></summary>
        <returns><span data-ttu-id="08e41-1035">如果找到与 <paramref name="match" /> 定义的条件相匹配的第一个元素，则为该元素的从零开始的索引；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="08e41-1035">The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1036">将从 `startIndex` 开始向前搜索 <xref:System.Array>，并在最后一个元素结束。</span><span class="sxs-lookup"><span data-stu-id="08e41-1036">The <xref:System.Array> is searched forward starting at `startIndex` and ending at the last element.</span></span>  
  
 <span data-ttu-id="08e41-1037"><xref:System.Predicate%601> 是一个方法委托，如果传递给它的对象与委托中定义的条件相匹配，则该方法将返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="08e41-1037">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="08e41-1038">`array` 的元素分别传递到 <xref:System.Predicate%601>中。</span><span class="sxs-lookup"><span data-stu-id="08e41-1038">The elements of `array` are individually passed to the <xref:System.Predicate%601>.</span></span>  
  
 <span data-ttu-id="08e41-1039">此方法是 O （`n`）运算，其中 `n` 是 `startIndex` 到 `array`末尾的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1039">This method is an O(`n`) operation, where `n` is the number of elements from `startIndex` to the end of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1040">下面的代码示例演示 <xref:System.Array.FindIndex%2A> 泛型方法的所有三个重载。</span><span class="sxs-lookup"><span data-stu-id="08e41-1040">The following code example demonstrates all three overloads of the <xref:System.Array.FindIndex%2A> generic method.</span></span> <span data-ttu-id="08e41-1041">创建一个字符串数组，其中包含8个恐龙名称，其中两个名称（位置1和5）以 "saurus" 结尾。</span><span class="sxs-lookup"><span data-stu-id="08e41-1041">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="08e41-1042">此代码示例还定义了一个名为 `EndsWithSaurus`的搜索谓词方法，该方法接受一个字符串参数，并返回一个布尔值，指示输入字符串是否以 "saurus" 结尾。</span><span class="sxs-lookup"><span data-stu-id="08e41-1042">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="08e41-1043"><xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> 方法重载从开始处遍历数组，并将每个元素传递到 `EndsWithSaurus` 方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1043">The <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> method overload traverses the array from the beginning, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="08e41-1044">当 `EndsWithSaurus` 方法返回位于位置1的元素 `true` 时，搜索将停止。</span><span class="sxs-lookup"><span data-stu-id="08e41-1044">The search stops when the `EndsWithSaurus` method returns `true` for the element at position 1.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-1045">在C#和 Visual Basic 中，无需显式创建 `Predicate<string>` 委托（`Predicate(Of String)` Visual Basic 中）。</span><span class="sxs-lookup"><span data-stu-id="08e41-1045">In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="08e41-1046">这些语言从上下文推断正确的委托并自动创建它。</span><span class="sxs-lookup"><span data-stu-id="08e41-1046">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="08e41-1047"><xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 方法重载用于从位置2开始搜索数组，并继续到数组末尾。</span><span class="sxs-lookup"><span data-stu-id="08e41-1047">The <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the array beginning at position 2 and continuing to the end of the array.</span></span> <span data-ttu-id="08e41-1048">它在位置5找到元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1048">It finds the element at position 5.</span></span> <span data-ttu-id="08e41-1049">最后，<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 方法重载用于搜索从位置2开始的三个元素的范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1049">Finally, the <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the range of three elements beginning at position 2.</span></span> <span data-ttu-id="08e41-1050">它将返回-1，因为该范围中没有以 "saurus" 结尾的恐龙名称。</span><span class="sxs-lookup"><span data-stu-id="08e41-1050">It returns -1 because there are no dinosaur names in that range that end with "saurus".</span></span>  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1051"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1051"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="08e41-1052">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1052">-or-</span></span> 
 <span data-ttu-id="08e41-1053"><paramref name="match" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1053"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-1054"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1054"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-1055">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-1055">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-1056">要搜索的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1056">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="startIndex"><span data-ttu-id="08e41-1057">从零开始的搜索的起始索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1057">The zero-based starting index of the search.</span></span></param>
        <param name="count"><span data-ttu-id="08e41-1058">要搜索的部分中的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1058">The number of elements in the section to search.</span></span></param>
        <param name="match"><span data-ttu-id="08e41-1059"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</span><span class="sxs-lookup"><span data-stu-id="08e41-1059">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="08e41-1060">搜索与指定谓词所定义的条件相匹配的一个元素，并返回 <see cref="T:System.Array" /> 中从指定的索引开始、包含指定元素个数的元素范围内第一个匹配项的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1060">Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <see cref="T:System.Array" /> that starts at the specified index and contains the specified number of elements.</span></span></summary>
        <returns><span data-ttu-id="08e41-1061">如果找到与 <paramref name="match" /> 定义的条件相匹配的第一个元素，则为该元素的从零开始的索引；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="08e41-1061">The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1062">如果 `count` 大于0，则从 `startIndex` 开始向前搜索 <xref:System.Array>，在 `startIndex` `count` 减1处结束。</span><span class="sxs-lookup"><span data-stu-id="08e41-1062">The <xref:System.Array> is searched forward starting at `startIndex` and ending at `startIndex` plus `count` minus 1, if `count` is greater than 0.</span></span>  
  
 <span data-ttu-id="08e41-1063"><xref:System.Predicate%601> 是一个方法委托，如果传递给它的对象与委托中定义的条件相匹配，则该方法将返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="08e41-1063">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="08e41-1064">`array` 的元素分别传递到 <xref:System.Predicate%601>中。</span><span class="sxs-lookup"><span data-stu-id="08e41-1064">The elements of `array` are individually passed to the <xref:System.Predicate%601>.</span></span>  
  
 <span data-ttu-id="08e41-1065">此方法是一个 O （`n`）操作，其中 `n` 是 `count`的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1065">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1066">下面的代码示例演示 <xref:System.Array.FindIndex%2A> 泛型方法的所有三个重载。</span><span class="sxs-lookup"><span data-stu-id="08e41-1066">The following code example demonstrates all three overloads of the <xref:System.Array.FindIndex%2A> generic method.</span></span> <span data-ttu-id="08e41-1067">创建一个字符串数组，其中包含8个恐龙名称，其中两个名称（位置1和5）以 "saurus" 结尾。</span><span class="sxs-lookup"><span data-stu-id="08e41-1067">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="08e41-1068">此代码示例还定义了一个名为 `EndsWithSaurus`的搜索谓词方法，该方法接受一个字符串参数，并返回一个布尔值，指示输入字符串是否以 "saurus" 结尾。</span><span class="sxs-lookup"><span data-stu-id="08e41-1068">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="08e41-1069"><xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> 方法重载从开始处遍历数组，并将每个元素传递到 `EndsWithSaurus` 方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1069">The <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> method overload traverses the array from the beginning, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="08e41-1070">当 `EndsWithSaurus` 方法返回位于位置1的元素 `true` 时，搜索将停止。</span><span class="sxs-lookup"><span data-stu-id="08e41-1070">The search stops when the `EndsWithSaurus` method returns `true` for the element at position 1.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-1071">在C#和 Visual Basic 中，无需显式创建 `Predicate<string>` 委托（`Predicate(Of String)` Visual Basic 中）。</span><span class="sxs-lookup"><span data-stu-id="08e41-1071">In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="08e41-1072">这些语言从上下文推断正确的委托并自动创建它。</span><span class="sxs-lookup"><span data-stu-id="08e41-1072">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="08e41-1073"><xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 方法重载用于从位置2开始搜索数组，并继续到数组末尾。</span><span class="sxs-lookup"><span data-stu-id="08e41-1073">The <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the array beginning at position 2 and continuing to the end of the array.</span></span> <span data-ttu-id="08e41-1074">它在位置5找到元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1074">It finds the element at position 5.</span></span> <span data-ttu-id="08e41-1075">最后，<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 方法重载用于搜索从位置2开始的三个元素的范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1075">Finally, the <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the range of three elements beginning at position 2.</span></span> <span data-ttu-id="08e41-1076">它将返回-1，因为该范围中没有以 "saurus" 结尾的恐龙名称。</span><span class="sxs-lookup"><span data-stu-id="08e41-1076">It returns -1 because there are no dinosaur names in that range that end with "saurus".</span></span>  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1077"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1077"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="08e41-1078">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1078">-or-</span></span> 
 <span data-ttu-id="08e41-1079"><paramref name="match" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1079"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-1080"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1080"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span>  
  
<span data-ttu-id="08e41-1081">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1081">-or-</span></span> 
 <span data-ttu-id="08e41-1082"><paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-1082"><paramref name="count" /> is less than zero.</span></span>  
  
<span data-ttu-id="08e41-1083">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1083">-or-</span></span> 
 <span data-ttu-id="08e41-1084"><paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="array" /> 中指定有效部分。</span><span class="sxs-lookup"><span data-stu-id="08e41-1084"><paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindLast&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T FindLast&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLast(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T FindLast(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLast : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.FindLast (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-1085">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-1085">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-1086">要搜索的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1086">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="match"><span data-ttu-id="08e41-1087"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</span><span class="sxs-lookup"><span data-stu-id="08e41-1087">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="08e41-1088">搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Array" /> 中的最后一个匹配元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1088">Searches for an element that matches the conditions defined by the specified predicate, and returns the last occurrence within the entire <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="08e41-1089">如果找到，则为与指定谓词所定义的条件相匹配的最后一个元素；否则为类型 <paramref name="T" /> 的默认值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1089">The last element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <paramref name="T" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1090"><xref:System.Predicate%601> 是一个方法委托，如果传递给它的对象与委托中定义的条件相匹配，则该方法将返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="08e41-1090">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="08e41-1091">`array` 的元素分别传递到 <xref:System.Predicate%601>，在 <xref:System.Array>中向后移动，从最后一个元素开始，到第一个元素结束。</span><span class="sxs-lookup"><span data-stu-id="08e41-1091">The elements of `array` are individually passed to the <xref:System.Predicate%601>, moving backward in the <xref:System.Array>, starting with the last element and ending with the first element.</span></span>  <span data-ttu-id="08e41-1092">找到匹配项时将停止处理。</span><span class="sxs-lookup"><span data-stu-id="08e41-1092">Processing is stopped when a match is found.</span></span>  
  
 <span data-ttu-id="08e41-1093">此方法是一个 O （`n`）操作，其中 `n` 是 `array`的 <xref:System.Array.Length%2A>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1093">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1094">下面的代码示例演示 <xref:System.Array.Find%2A>、<xref:System.Array.FindLast%2A>和 <xref:System.Array.FindAll%2A> 泛型方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1094">The following code example demonstrates the <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, and <xref:System.Array.FindAll%2A> generic methods.</span></span> <span data-ttu-id="08e41-1095">创建一个字符串数组，其中包含8个恐龙名称，其中两个名称（位置1和5）以 "saurus" 结尾。</span><span class="sxs-lookup"><span data-stu-id="08e41-1095">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="08e41-1096">此代码示例还定义了一个名为 `EndsWithSaurus`的搜索谓词方法，该方法接受一个字符串参数，并返回一个布尔值，指示输入字符串是否以 "saurus" 结尾。</span><span class="sxs-lookup"><span data-stu-id="08e41-1096">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="08e41-1097"><xref:System.Array.Find%2A> 泛型方法从开始处遍历数组，并将每个元素传递到 `EndsWithSaurus` 方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1097">The <xref:System.Array.Find%2A> generic method traverses the array from the beginning, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="08e41-1098">当 `EndsWithSaurus` 方法返回元素 "Amargasaurus" 的 `true` 时，搜索将停止。</span><span class="sxs-lookup"><span data-stu-id="08e41-1098">The search stops when the `EndsWithSaurus` method returns `true` for the element "Amargasaurus".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-1099">在C#和 Visual Basic 中，无需显式创建`Predicate<string>` 委托（`Predicate(Of String)` Visual Basic 中）。</span><span class="sxs-lookup"><span data-stu-id="08e41-1099">In C# and Visual Basic, it is not necessary to create the`Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="08e41-1100">这些语言从上下文推断正确的委托并自动创建它。</span><span class="sxs-lookup"><span data-stu-id="08e41-1100">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="08e41-1101"><xref:System.Array.FindLast%2A> 泛型方法用于从末尾向后搜索数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-1101">The <xref:System.Array.FindLast%2A> generic method is used to search the array backward from the end.</span></span> <span data-ttu-id="08e41-1102">它在位置5找到元素 "Dilophosaurus"。</span><span class="sxs-lookup"><span data-stu-id="08e41-1102">It finds the element "Dilophosaurus" at position 5.</span></span> <span data-ttu-id="08e41-1103"><xref:System.Array.FindAll%2A> 泛型方法用于返回数组，该数组包含以 "saurus" 结尾的所有元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1103">The <xref:System.Array.FindAll%2A> generic method is used to return an array containing all the elements that end in "saurus".</span></span> <span data-ttu-id="08e41-1104">显示元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1104">The elements are displayed.</span></span>  
  
 <span data-ttu-id="08e41-1105">此代码示例还演示了 <xref:System.Array.Exists%2A> 和 <xref:System.Array.TrueForAll%2A> 泛型方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1105">The code example also demonstrates the <xref:System.Array.Exists%2A> and <xref:System.Array.TrueForAll%2A> generic methods.</span></span>  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1106"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1106"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="08e41-1107">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1107">-or-</span></span> 
 <span data-ttu-id="08e41-1108"><paramref name="match" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1108"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="08e41-1109">在 <see cref="T:System.Array" /> 或其某个部分中搜索与指定谓词所定义的条件相匹配的元素，并返回最后一个匹配项的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1109">Searches for an element that matches the conditions defined by a specified predicate, and returns the zero-based index of the last occurrence within an <see cref="T:System.Array" /> or a portion of it.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-1110">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-1110">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-1111">要搜索的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1111">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="match"><span data-ttu-id="08e41-1112"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</span><span class="sxs-lookup"><span data-stu-id="08e41-1112">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="08e41-1113">搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Array" /> 中最后一个匹配元素的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1113">Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the entire <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="08e41-1114">如果找到与 <paramref name="match" /> 定义的条件相匹配的最后一个元素，则为该元素的从零开始的索引；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="08e41-1114">The zero-based index of the last occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1115">从最后一个元素开始向后搜索 <xref:System.Array>，并在第一个元素处结束。</span><span class="sxs-lookup"><span data-stu-id="08e41-1115">The <xref:System.Array> is searched backward starting at the last element and ending at the first element.</span></span>  
  
 <span data-ttu-id="08e41-1116"><xref:System.Predicate%601> 是一个方法委托，如果传递给它的对象与委托中定义的条件相匹配，则该方法将返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="08e41-1116">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="08e41-1117">`array` 的元素分别传递到 <xref:System.Predicate%601>中。</span><span class="sxs-lookup"><span data-stu-id="08e41-1117">The elements of `array` are individually passed to the <xref:System.Predicate%601>.</span></span>  
  
 <span data-ttu-id="08e41-1118">此方法是一个 O （`n`）操作，其中 `n` 是 `array`的 <xref:System.Array.Length%2A>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1118">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1119">下面的代码示例演示 <xref:System.Array.FindLastIndex%2A> 泛型方法的所有三个重载。</span><span class="sxs-lookup"><span data-stu-id="08e41-1119">The following code example demonstrates all three overloads of the <xref:System.Array.FindLastIndex%2A> generic method.</span></span> <span data-ttu-id="08e41-1120">创建一个字符串数组，其中包含8个恐龙名称，其中两个名称（位置1和5）以 "saurus" 结尾。</span><span class="sxs-lookup"><span data-stu-id="08e41-1120">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="08e41-1121">此代码示例还定义了一个名为 `EndsWithSaurus`的搜索谓词方法，该方法接受一个字符串参数，并返回一个布尔值，指示输入字符串是否以 "saurus" 结尾。</span><span class="sxs-lookup"><span data-stu-id="08e41-1121">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="08e41-1122"><xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> 方法重载从末尾开始向后遍历数组，并将每个元素传递到 `EndsWithSaurus` 方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1122">The <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> method overload traverses the array backward from the end, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="08e41-1123">当 `EndsWithSaurus` 方法返回位于位置5的元素 `true` 时，搜索将停止。</span><span class="sxs-lookup"><span data-stu-id="08e41-1123">The search stops when the `EndsWithSaurus` method returns `true` for the element at position 5.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-1124">在C#和 Visual Basic 中，无需显式创建 `Predicate<string>` 委托（`Predicate(Of String)` Visual Basic 中）。</span><span class="sxs-lookup"><span data-stu-id="08e41-1124">In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="08e41-1125">这些语言从上下文推断正确的委托并自动创建它。</span><span class="sxs-lookup"><span data-stu-id="08e41-1125">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="08e41-1126"><xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 方法重载用于从位置4开始搜索数组，并向后移动到数组的开头。</span><span class="sxs-lookup"><span data-stu-id="08e41-1126">The <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the array beginning at position 4 and continuing backward to the beginning of the array.</span></span> <span data-ttu-id="08e41-1127">它在位置1找到元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1127">It finds the element at position 1.</span></span> <span data-ttu-id="08e41-1128">最后，<xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 方法重载用于搜索三个元素的范围，该范围从位置4开始并向后（即，元素为4、3和2）。</span><span class="sxs-lookup"><span data-stu-id="08e41-1128">Finally, the <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the range of three elements beginning at position 4 and working backward (that is, elements 4, 3, and 2).</span></span> <span data-ttu-id="08e41-1129">它将返回-1，因为该范围中没有以 "saurus" 结尾的恐龙名称。</span><span class="sxs-lookup"><span data-stu-id="08e41-1129">It returns -1 because there are no dinosaur names in that range that end with "saurus".</span></span>  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1130"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1130"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="08e41-1131">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1131">-or-</span></span> 
 <span data-ttu-id="08e41-1132"><paramref name="match" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1132"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-1133">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-1133">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-1134">要搜索的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1134">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="startIndex"><span data-ttu-id="08e41-1135">向后搜索的从零开始的起始索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1135">The zero-based starting index of the backward search.</span></span></param>
        <param name="match"><span data-ttu-id="08e41-1136"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</span><span class="sxs-lookup"><span data-stu-id="08e41-1136">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="08e41-1137">搜索与由指定谓词定义的条件相匹配的元素，并返回 <see cref="T:System.Array" /> 中从第一个元素到指定索引的元素范围内最后一个匹配项的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1137">Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <see cref="T:System.Array" /> that extends from the first element to the specified index.</span></span></summary>
        <returns><span data-ttu-id="08e41-1138">如果找到与 <paramref name="match" /> 定义的条件相匹配的最后一个元素，则为该元素的从零开始的索引；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="08e41-1138">The zero-based index of the last occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1139">从 `startIndex` 开始向后搜索 <xref:System.Array>，并在第一个元素处结束。</span><span class="sxs-lookup"><span data-stu-id="08e41-1139">The <xref:System.Array> is searched backward starting at `startIndex` and ending at the first element.</span></span>  
  
 <span data-ttu-id="08e41-1140"><xref:System.Predicate%601> 是一个方法委托，如果传递给它的对象与委托中定义的条件相匹配，则该方法将返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="08e41-1140">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="08e41-1141">`array` 的元素分别传递到 <xref:System.Predicate%601>中。</span><span class="sxs-lookup"><span data-stu-id="08e41-1141">The elements of `array` are individually passed to the <xref:System.Predicate%601>.</span></span>  
  
 <span data-ttu-id="08e41-1142">此方法为 O （`n`）运算，其中 `n` 是从 `array` 开始到 `startIndex`的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1142">This method is an O(`n`) operation, where `n` is the number of elements from the beginning of `array` to `startIndex`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1143">下面的代码示例演示 <xref:System.Array.FindLastIndex%2A> 泛型方法的所有三个重载。</span><span class="sxs-lookup"><span data-stu-id="08e41-1143">The following code example demonstrates all three overloads of the <xref:System.Array.FindLastIndex%2A> generic method.</span></span> <span data-ttu-id="08e41-1144">创建一个字符串数组，其中包含8个恐龙名称，其中两个名称（位置1和5）以 "saurus" 结尾。</span><span class="sxs-lookup"><span data-stu-id="08e41-1144">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="08e41-1145">此代码示例还定义了一个名为 `EndsWithSaurus`的搜索谓词方法，该方法接受一个字符串参数，并返回一个布尔值，指示输入字符串是否以 "saurus" 结尾。</span><span class="sxs-lookup"><span data-stu-id="08e41-1145">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="08e41-1146"><xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> 方法重载从末尾开始向后遍历数组，并将每个元素传递到 `EndsWithSaurus` 方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1146">The <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> method overload traverses the array backward from the end, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="08e41-1147">当 `EndsWithSaurus` 方法返回位于位置5的元素 `true` 时，搜索将停止。</span><span class="sxs-lookup"><span data-stu-id="08e41-1147">The search stops when the `EndsWithSaurus` method returns `true` for the element at position 5.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-1148">在C#和 Visual Basic 中，无需显式创建 `Predicate<string>` 委托（`Predicate(Of String)` Visual Basic 中）。</span><span class="sxs-lookup"><span data-stu-id="08e41-1148">In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="08e41-1149">这些语言从上下文推断正确的委托并自动创建它。</span><span class="sxs-lookup"><span data-stu-id="08e41-1149">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="08e41-1150"><xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 方法重载用于从位置4开始搜索数组，并向后移动到数组的开头。</span><span class="sxs-lookup"><span data-stu-id="08e41-1150">The <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the array beginning at position 4 and continuing backward to the beginning of the array.</span></span> <span data-ttu-id="08e41-1151">它在位置1找到元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1151">It finds the element at position 1.</span></span> <span data-ttu-id="08e41-1152">最后，<xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 方法重载用于搜索三个元素的范围，该范围从位置4开始并向后（即，元素为4、3和2）。</span><span class="sxs-lookup"><span data-stu-id="08e41-1152">Finally, the <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the range of three elements beginning at position 4 and working backward (that is, elements 4, 3, and 2).</span></span> <span data-ttu-id="08e41-1153">它将返回-1，因为该范围中没有以 "saurus" 结尾的恐龙名称。</span><span class="sxs-lookup"><span data-stu-id="08e41-1153">It returns -1 because there are no dinosaur names in that range that end with "saurus".</span></span>  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1154"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1154"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="08e41-1155">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1155">-or-</span></span> 
 <span data-ttu-id="08e41-1156"><paramref name="match" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1156"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-1157"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1157"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-1158">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-1158">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-1159">要搜索的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1159">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="startIndex"><span data-ttu-id="08e41-1160">向后搜索的从零开始的起始索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1160">The zero-based starting index of the backward search.</span></span></param>
        <param name="count"><span data-ttu-id="08e41-1161">要搜索的部分中的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1161">The number of elements in the section to search.</span></span></param>
        <param name="match"><span data-ttu-id="08e41-1162"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</span><span class="sxs-lookup"><span data-stu-id="08e41-1162">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="08e41-1163">搜索与指定谓词所定义的条件相匹配的元素，并返回 <see cref="T:System.Array" /> 中包含指定元素个数、到指定索引结束的元素范围内最后一个匹配项的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1163">Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <see cref="T:System.Array" /> that contains the specified number of elements and ends at the specified index.</span></span></summary>
        <returns><span data-ttu-id="08e41-1164">如果找到与 <paramref name="match" /> 定义的条件相匹配的最后一个元素，则为该元素的从零开始的索引；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="08e41-1164">The zero-based index of the last occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1165">将从 `startIndex` 开始向后 <xref:System.Array> 搜索，如果 `count` 大于0，则从 `startIndex` 减号开始，在 `count` 减号处结束。</span><span class="sxs-lookup"><span data-stu-id="08e41-1165">The <xref:System.Array> is searched backward starting at `startIndex` and ending at `startIndex` minus `count` plus 1, if `count` is greater than 0.</span></span>  
  
 <span data-ttu-id="08e41-1166"><xref:System.Predicate%601> 是一个方法委托，如果传递给它的对象与委托中定义的条件相匹配，则该方法将返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="08e41-1166">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="08e41-1167">`array` 的元素分别传递到 <xref:System.Predicate%601>中。</span><span class="sxs-lookup"><span data-stu-id="08e41-1167">The elements of `array` are individually passed to the <xref:System.Predicate%601>.</span></span>  
  
 <span data-ttu-id="08e41-1168">此方法是一个 O （`n`）操作，其中 `n` 是 `count`的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1168">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1169">下面的代码示例演示 <xref:System.Array.FindLastIndex%2A> 泛型方法的所有三个重载。</span><span class="sxs-lookup"><span data-stu-id="08e41-1169">The following code example demonstrates all three overloads of the <xref:System.Array.FindLastIndex%2A> generic method.</span></span> <span data-ttu-id="08e41-1170">创建一个字符串数组，其中包含8个恐龙名称，其中两个名称（位置1和5）以 "saurus" 结尾。</span><span class="sxs-lookup"><span data-stu-id="08e41-1170">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="08e41-1171">此代码示例还定义了一个名为 `EndsWithSaurus`的搜索谓词方法，该方法接受一个字符串参数，并返回一个布尔值，指示输入字符串是否以 "saurus" 结尾。</span><span class="sxs-lookup"><span data-stu-id="08e41-1171">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="08e41-1172"><xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> 方法重载从末尾开始向后遍历数组，并将每个元素传递到 `EndsWithSaurus` 方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1172">The <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> method overload traverses the array backward from the end, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="08e41-1173">当 `EndsWithSaurus` 方法返回位于位置5的元素 `true` 时，搜索将停止。</span><span class="sxs-lookup"><span data-stu-id="08e41-1173">The search stops when the `EndsWithSaurus` method returns `true` for the element at position 5.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-1174">在C#和 Visual Basic 中，无需显式创建 `Predicate<string>` 委托（`Predicate(Of String)` Visual Basic 中）。</span><span class="sxs-lookup"><span data-stu-id="08e41-1174">In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="08e41-1175">这些语言从上下文推断正确的委托并自动创建它。</span><span class="sxs-lookup"><span data-stu-id="08e41-1175">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="08e41-1176"><xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 方法重载用于从位置4开始搜索数组，并向后移动到数组的开头。</span><span class="sxs-lookup"><span data-stu-id="08e41-1176">The <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the array beginning at position 4 and continuing backward to the beginning of the array.</span></span> <span data-ttu-id="08e41-1177">它在位置1找到元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1177">It finds the element at position 1.</span></span> <span data-ttu-id="08e41-1178">最后，<xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 方法重载用于搜索三个元素的范围，该范围从位置4开始并向后（即，元素为4、3和2）。</span><span class="sxs-lookup"><span data-stu-id="08e41-1178">Finally, the <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the range of three elements beginning at position 4 and working backward (that is, elements 4, 3, and 2).</span></span> <span data-ttu-id="08e41-1179">它将返回-1，因为该范围中没有以 "saurus" 结尾的恐龙名称。</span><span class="sxs-lookup"><span data-stu-id="08e41-1179">It returns -1 because there are no dinosaur names in that range that end with "saurus".</span></span>  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1180"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1180"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="08e41-1181">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1181">-or-</span></span> 
 <span data-ttu-id="08e41-1182"><paramref name="match" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1182"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-1183"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1183"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span>  
  
<span data-ttu-id="08e41-1184">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1184">-or-</span></span> 
 <span data-ttu-id="08e41-1185"><paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-1185"><paramref name="count" /> is less than zero.</span></span>  
  
<span data-ttu-id="08e41-1186">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1186">-or-</span></span> 
 <span data-ttu-id="08e41-1187"><paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="array" /> 中指定有效部分。</span><span class="sxs-lookup"><span data-stu-id="08e41-1187"><paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEach&lt;T&gt;(!!T[] array, class System.Action`1&lt;!!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ForEach``1(``0[],System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ForEach(Of T) (array As T(), action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void ForEach(cli::array &lt;T&gt; ^ array, Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member ForEach : 'T[] * Action&lt;'T&gt; -&gt; unit" Usage="System.Array.ForEach (array, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-1188">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-1188">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-1189">从零开始的一维 <see cref="T:System.Array" />，要对其元素执行操作。</span><span class="sxs-lookup"><span data-stu-id="08e41-1189">The one-dimensional, zero-based <see cref="T:System.Array" /> on whose elements the action is to be performed.</span></span></param>
        <param name="action"><span data-ttu-id="08e41-1190">要对 <paramref name="array" /> 的每个元素执行的 <see cref="T:System.Action`1" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1190">The <see cref="T:System.Action`1" /> to perform on each element of <paramref name="array" />.</span></span></param>
        <summary><span data-ttu-id="08e41-1191">对指定数组的每个元素执行指定操作。</span><span class="sxs-lookup"><span data-stu-id="08e41-1191">Performs the specified action on each element of the specified array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1192"><xref:System.Action%601> 是对传递给它的对象执行操作的方法的委托。</span><span class="sxs-lookup"><span data-stu-id="08e41-1192">The <xref:System.Action%601> is a delegate to a method that performs an action on the object passed to it.</span></span>  <span data-ttu-id="08e41-1193">`array` 的元素分别传递到 <xref:System.Action%601>中。</span><span class="sxs-lookup"><span data-stu-id="08e41-1193">The elements of `array` are individually passed to the <xref:System.Action%601>.</span></span>  
  
 <span data-ttu-id="08e41-1194">此方法是一个 O （`n`）操作，其中 `n` 是 `array`的 <xref:System.Array.Length%2A>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1194">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1195">下面的示例演示如何使用 <xref:System.Array.ForEach%2A> 显示整数数组中每个元素的平方。</span><span class="sxs-lookup"><span data-stu-id="08e41-1195">The following example shows how to use <xref:System.Array.ForEach%2A> to display the squares of each element in an integer array.</span></span>  
  
 [!code-cpp[System.Array.ForEach#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.foreach/cpp/source.cpp#1)]
 [!code-csharp[System.Array.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.foreach/cs/source.cs#1)]
 [!code-vb[System.Array.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.foreach/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1196"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1196"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="08e41-1197">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1197">-or-</span></span> 
 <span data-ttu-id="08e41-1198"><paramref name="action" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1198"><paramref name="action" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="array.GetEnumerator " />
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerator GetEnumerator ();" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IEnumerator" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="08e41-1199">返回 <see cref="T:System.Collections.IEnumerator" /> 的 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1199">Returns an <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="08e41-1200"><see cref="T:System.Collections.IEnumerator" /> 的一个 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1200">An <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1201">[Visual Basic， C#]</span><span class="sxs-lookup"><span data-stu-id="08e41-1201">[Visual Basic, C#]</span></span>  
  
 <span data-ttu-id="08e41-1202">C#语言的 `foreach` 语句（`for each` 中C++`For Each` Visual Basic）隐藏了枚举器的复杂性。</span><span class="sxs-lookup"><span data-stu-id="08e41-1202">The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of the enumerators.</span></span> <span data-ttu-id="08e41-1203">因此，建议使用 `foreach`，而不是直接操作枚举数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1203">Therefore, using `foreach` is recommended, instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="08e41-1204">枚举器可用于读取集合中的数据，但不能用于修改基础集合。</span><span class="sxs-lookup"><span data-stu-id="08e41-1204">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="08e41-1205">最初，枚举数定位在集合中第一个元素的前面。</span><span class="sxs-lookup"><span data-stu-id="08e41-1205">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="08e41-1206"><xref:System.Collections.IEnumerator.Reset%2A> 也会将枚举器放回此位置。</span><span class="sxs-lookup"><span data-stu-id="08e41-1206"><xref:System.Collections.IEnumerator.Reset%2A> also brings the enumerator back to this position.</span></span>  <span data-ttu-id="08e41-1207">在此位置上，未定义 <xref:System.Collections.IEnumerator.Current%2A>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1207">At this position, <xref:System.Collections.IEnumerator.Current%2A> is undefined.</span></span> <span data-ttu-id="08e41-1208">因此，在读取 <xref:System.Collections.IEnumerator.MoveNext%2A> 的值之前，必须调用 <xref:System.Collections.IEnumerator.Current%2A> 将枚举器向前移动到集合的第一个元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1208">Therefore, you must call <xref:System.Collections.IEnumerator.MoveNext%2A> to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.IEnumerator.Current%2A>.</span></span>  
  
 <span data-ttu-id="08e41-1209">在调用 <xref:System.Collections.IEnumerator.Current%2A> 或 <xref:System.Collections.IEnumerator.MoveNext%2A> 之前，<xref:System.Collections.IEnumerator.Reset%2A> 返回同一对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-1209"><xref:System.Collections.IEnumerator.Current%2A> returns the same object until either <xref:System.Collections.IEnumerator.MoveNext%2A> or <xref:System.Collections.IEnumerator.Reset%2A> is called.</span></span> <span data-ttu-id="08e41-1210"><xref:System.Collections.IEnumerator.MoveNext%2A> 将 <xref:System.Collections.IEnumerator.Current%2A> 设置为下一个元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1210"><xref:System.Collections.IEnumerator.MoveNext%2A> sets <xref:System.Collections.IEnumerator.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="08e41-1211">如果 <xref:System.Collections.IEnumerator.MoveNext%2A> 越过集合的末尾，则枚举器将定位到集合中的最后一个元素之后，<xref:System.Collections.IEnumerator.MoveNext%2A> 返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="08e41-1211">If <xref:System.Collections.IEnumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.IEnumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="08e41-1212">当枚举器位于此位置时，对 <xref:System.Collections.IEnumerator.MoveNext%2A> 的后续调用也将返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="08e41-1212">When the enumerator is at this position, subsequent calls to <xref:System.Collections.IEnumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="08e41-1213">如果对的最后一个调用 <xref:System.Collections.IEnumerator.MoveNext%2A> 返回 `false`，则 <xref:System.Collections.IEnumerator.Current%2A> 未定义。</span><span class="sxs-lookup"><span data-stu-id="08e41-1213">If the last call to <xref:System.Collections.IEnumerator.MoveNext%2A> returned `false`, <xref:System.Collections.IEnumerator.Current%2A> is undefined.</span></span> <span data-ttu-id="08e41-1214">若要再次将 <xref:System.Collections.IEnumerator.Current%2A> 设置为集合的第一个元素，可以调用 <xref:System.Collections.IEnumerator.Reset%2A> 并接着调用 <xref:System.Collections.IEnumerator.MoveNext%2A>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1214">To set <xref:System.Collections.IEnumerator.Current%2A> to the first element of the collection again, you can call <xref:System.Collections.IEnumerator.Reset%2A> followed by <xref:System.Collections.IEnumerator.MoveNext%2A>.</span></span>  
  
 <span data-ttu-id="08e41-1215">只要集合保持不变，枚举数就保持有效。</span><span class="sxs-lookup"><span data-stu-id="08e41-1215">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="08e41-1216">如果对集合进行更改（如添加、修改或删除元素），则枚举数将失效且不可恢复，而且其行为是不确定的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1216">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</span></span>  
  
 <span data-ttu-id="08e41-1217">该枚举数不具有独占访问集合的权限；因此，枚举整个集合本质上不是一个线程安全的过程。</span><span class="sxs-lookup"><span data-stu-id="08e41-1217">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread safe procedure.</span></span>  <span data-ttu-id="08e41-1218">若要确保枚举过程中的线程安全性，可以在整个枚举过程中锁定集合。</span><span class="sxs-lookup"><span data-stu-id="08e41-1218">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="08e41-1219">若要允许多个线程访问集合以进行读写操作，则必须实现自己的同步。</span><span class="sxs-lookup"><span data-stu-id="08e41-1219">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="08e41-1220">此方法为 O （1）操作。</span><span class="sxs-lookup"><span data-stu-id="08e41-1220">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1221">下面的代码示例演示如何使用 <xref:System.Array.GetEnumerator%2A> 列出数组的元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1221">The following code example shows how to use <xref:System.Array.GetEnumerator%2A> to list the elements of an array.</span></span>  
  
 [!code-cpp[System.Array_GetEnumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CPP/array_getenumerator.cpp#1)]
 [!code-csharp[System.Array_GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CS/array_getenumerator.cs#1)]
 [!code-vb[System.Array_GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetEnumerator/VB/array_getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLength (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLength : int -&gt; int" Usage="array.GetLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension"><span data-ttu-id="08e41-1222"><see cref="T:System.Array" /> 的从零开始的维度，其长度需要确定。</span><span class="sxs-lookup"><span data-stu-id="08e41-1222">A zero-based dimension of the <see cref="T:System.Array" /> whose length needs to be determined.</span></span></param>
        <summary><span data-ttu-id="08e41-1223">获取一个 32 位整数，该整数表示 <see cref="T:System.Array" /> 的指定维中的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1223">Gets a 32-bit integer that represents the number of elements in the specified dimension of the <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="08e41-1224">一个 32 位整数，它表示指定维中的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1224">A 32-bit integer that represents the number of elements in the specified dimension.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1225">`GetLength(0)`<xref:System.Array.GetLength%2A> 的示例，该示例返回 <xref:System.Array>第一维中的元素数目。</span><span class="sxs-lookup"><span data-stu-id="08e41-1225">An example of <xref:System.Array.GetLength%2A> is `GetLength(0)`, which returns the number of elements in the first dimension of the <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="08e41-1226">此方法为 O （1）操作。</span><span class="sxs-lookup"><span data-stu-id="08e41-1226">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1227">下面的示例演示如何使用 <xref:System.Array.GetLength%2A> 显示具有不同秩的两个数组的尺寸。</span><span class="sxs-lookup"><span data-stu-id="08e41-1227">The following example shows how to use <xref:System.Array.GetLength%2A> to display the dimensions of two arrays with different ranks.</span></span>  
  
 [!code-cpp[System.Array.GetLength#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getlength/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetLength#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getlength/cs/source.cs#1)]
 [!code-vb[System.Array.GetLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getlength/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="08e41-1228"><paramref name="dimension" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-1228"><paramref name="dimension" /> is less than zero.</span></span>  
  
<span data-ttu-id="08e41-1229">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1229">-or-</span></span> 
 <span data-ttu-id="08e41-1230"><paramref name="dimension" /> 等于或大于 <see cref="P:System.Array.Rank" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1230"><paramref name="dimension" /> is equal to or greater than <see cref="P:System.Array.Rank" />.</span></span></exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLongLength">
      <MemberSignature Language="C#" Value="public long GetLongLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLongLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLongLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLongLength (dimension As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetLongLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLongLength : int -&gt; int64" Usage="array.GetLongLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="dimension"><span data-ttu-id="08e41-1231"><see cref="T:System.Array" /> 的从零开始的维度，其长度需要确定。</span><span class="sxs-lookup"><span data-stu-id="08e41-1231">A zero-based dimension of the <see cref="T:System.Array" /> whose length needs to be determined.</span></span></param>
        <summary><span data-ttu-id="08e41-1232">获取一个 64 位整数，该整数表示 <see cref="T:System.Array" /> 的指定维中的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1232">Gets a 64-bit integer that represents the number of elements in the specified dimension of the <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="08e41-1233">一个 64 位整数，它表示指定维度中的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1233">A 64-bit integer that represents the number of elements in the specified dimension.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1234">`GetLongLength(0)`<xref:System.Array.GetLongLength%2A> 的示例，该示例返回 <xref:System.Array>第一维中的元素数目。</span><span class="sxs-lookup"><span data-stu-id="08e41-1234">An example of <xref:System.Array.GetLongLength%2A> is `GetLongLength(0)`, which returns the number of elements in the first dimension of the <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="08e41-1235">此方法为 O （1）操作。</span><span class="sxs-lookup"><span data-stu-id="08e41-1235">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="08e41-1236"><paramref name="dimension" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-1236"><paramref name="dimension" /> is less than zero.</span></span>  
  
<span data-ttu-id="08e41-1237">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1237">-or-</span></span> 
 <span data-ttu-id="08e41-1238"><paramref name="dimension" /> 等于或大于 <see cref="P:System.Array.Rank" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1238"><paramref name="dimension" /> is equal to or greater than <see cref="P:System.Array.Rank" />.</span></span></exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLowerBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLowerBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLowerBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLowerBound : int -&gt; int" Usage="array.GetLowerBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension"><span data-ttu-id="08e41-1239">数组的从零开始的维度，其起始索引需要确定。</span><span class="sxs-lookup"><span data-stu-id="08e41-1239">A zero-based dimension of the array whose starting index needs to be determined.</span></span></param>
        <summary><span data-ttu-id="08e41-1240">获取数组中指定维度第一个元素的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1240">Gets the index of the first element of the specified dimension in the array.</span></span></summary>
        <returns><span data-ttu-id="08e41-1241">数组中指定维度第一个元素的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1241">The index of the first element of the specified dimension in the array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1242">`GetLowerBound(0)` 返回数组的第一个维度的起始索引，并且 `GetLowerBound(Rank - 1)` 返回数组最后一个维度的起始索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1242">`GetLowerBound(0)` returns the starting index of the first dimension of the array, and `GetLowerBound(Rank - 1)` returns the starting index of the last dimension of the array.</span></span>  
  
 <span data-ttu-id="08e41-1243"><xref:System.Array.GetLowerBound%2A> 方法始终返回一个值，该值指示数组下限的索引（即使数组为空）。</span><span class="sxs-lookup"><span data-stu-id="08e41-1243">The <xref:System.Array.GetLowerBound%2A> method always returns a value that indicates the index of the lower bound of the array, even if the array is empty.</span></span>  
  
 <span data-ttu-id="08e41-1244">请注意，尽管 .NET Framework 中的大多数数组都是从零开始的（也就是说，<xref:System.Array.GetLowerBound%2A> 方法对于数组的每个维度返回零），.NET Framework 确实支持不是从零开始的数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-1244">Note that, although most arrays in the .NET Framework are zero-based (that is, the <xref:System.Array.GetLowerBound%2A> method returns zero for each dimension of an array), the .NET Framework does support arrays that are not zero-based.</span></span> <span data-ttu-id="08e41-1245">此类数组可以用 <xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29> 方法创建，也可以从非托管代码返回。</span><span class="sxs-lookup"><span data-stu-id="08e41-1245">Such arrays can be created with the <xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29> method, and can also be returned from unmanaged code.</span></span>  
  
 <span data-ttu-id="08e41-1246">此方法为 O （1）操作。</span><span class="sxs-lookup"><span data-stu-id="08e41-1246">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1247">下面的示例使用 <xref:System.Array.GetLowerBound%2A> 和 <xref:System.Array.GetUpperBound%2A> 方法来显示一维数组和二维数组的边界，并显示其数组元素的值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1247">The following example uses the <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods to display the bounds of a one-dimensional and two-dimensional array and to display the values of their array elements.</span></span>  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="08e41-1248"><paramref name="dimension" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-1248"><paramref name="dimension" /> is less than zero.</span></span>  
  
<span data-ttu-id="08e41-1249">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1249">-or-</span></span> 
 <span data-ttu-id="08e41-1250"><paramref name="dimension" /> 等于或大于 <see cref="P:System.Array.Rank" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1250"><paramref name="dimension" /> is equal to or greater than <see cref="P:System.Array.Rank" />.</span></span></exception>
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetUpperBound">
      <MemberSignature Language="C#" Value="public int GetUpperBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetUpperBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUpperBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetUpperBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetUpperBound : int -&gt; int" Usage="array.GetUpperBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension"><span data-ttu-id="08e41-1251">数组的从零开始的维度，其上限需要确定。</span><span class="sxs-lookup"><span data-stu-id="08e41-1251">A zero-based dimension of the array whose upper bound needs to be determined.</span></span></param>
        <summary><span data-ttu-id="08e41-1252">获取数组中指定维度最后一个元素的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1252">Gets the index of the last element of the specified dimension in the array.</span></span></summary>
        <returns><span data-ttu-id="08e41-1253">数组中指定维度最后一个元素的索引，或 -1（如果指定维度为空）。</span><span class="sxs-lookup"><span data-stu-id="08e41-1253">The index of the last element of the specified dimension in the array, or -1 if the specified dimension is empty.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1254">`GetUpperBound(0)` 返回数组的第一个维中的最后一个索引，并且 `GetUpperBound(Rank - 1)` 返回数组最后一个维度的最后一个索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1254">`GetUpperBound(0)` returns the last index in the first dimension of the array, and `GetUpperBound(Rank - 1)` returns the last index of the last dimension of the array.</span></span>  
  
 <span data-ttu-id="08e41-1255">此方法为 O （1）操作。</span><span class="sxs-lookup"><span data-stu-id="08e41-1255">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1256">下面的示例使用 <xref:System.Array.GetLowerBound%2A> 和 <xref:System.Array.GetUpperBound%2A> 方法来显示一维数组和二维数组的边界，并显示其数组元素的值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1256">The following example uses the <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods to display the bounds of a one-dimensional and two-dimensional array and to display the values of their array elements.</span></span>  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="08e41-1257"><paramref name="dimension" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-1257"><paramref name="dimension" /> is less than zero.</span></span>  
  
<span data-ttu-id="08e41-1258">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1258">-or-</span></span> 
 <span data-ttu-id="08e41-1259"><paramref name="dimension" /> 等于或大于 <see cref="P:System.Array.Rank" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1259"><paramref name="dimension" /> is equal to or greater than <see cref="P:System.Array.Rank" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="08e41-1260">获取当前 <see cref="T:System.Array" /> 中指定元素的值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1260">Gets the value of the specified element in the current <see cref="T:System.Array" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="08e41-1261">一个 32 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的位置。</span><span class="sxs-lookup"><span data-stu-id="08e41-1261">A 32-bit integer that represents the position of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="08e41-1262">获取一维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1262">Gets the value at the specified position in the one-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="08e41-1263">索引指定为 32 位整数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1263">The index is specified as a 32-bit integer.</span></span></summary>
        <returns><span data-ttu-id="08e41-1264">一维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1264">The value at the specified position in the one-dimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1265"><xref:System.Array.GetLowerBound%2A> 和 <xref:System.Array.GetUpperBound%2A> 方法可确定 `index` 的值是否超出界限。</span><span class="sxs-lookup"><span data-stu-id="08e41-1265">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether the value of `index` is out of bounds.</span></span>  
  
 <span data-ttu-id="08e41-1266">此方法为 O （1）操作。</span><span class="sxs-lookup"><span data-stu-id="08e41-1266">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1267">下面的代码示例演示如何在一维或多维数组中设置和获取特定值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1267">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-1268">当前 <see cref="T:System.Array" /> 不是正好具有一个维度。</span><span class="sxs-lookup"><span data-stu-id="08e41-1268">The current <see cref="T:System.Array" /> does not have exactly one dimension.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="08e41-1269"><paramref name="index" /> 超出了当前 <see cref="T:System.Array" /> 的有效索引的范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1269"><paramref name="index" /> is outside the range of valid indexes for the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Integer()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices"><span data-ttu-id="08e41-1270">一个 32 位整数的一维数组，它表示指定要获取的 <see cref="T:System.Array" /> 元素的位置的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1270">A one-dimensional array of 32-bit integers that represent the indexes specifying the position of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="08e41-1271">获取多维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1271">Gets the value at the specified position in the multidimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="08e41-1272">索引指定为一个 32 位整数数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-1272">The indexes are specified as an array of 32-bit integers.</span></span></summary>
        <returns><span data-ttu-id="08e41-1273">多维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1273">The value at the specified position in the multidimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1274">`indices` 中的元素数必须等于 <xref:System.Array>中的维数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1274">The number of elements in `indices` must equal the number of dimensions in the <xref:System.Array>.</span></span> <span data-ttu-id="08e41-1275">`indices` 数组中的所有元素都必须共同指定所需元素在多维 <xref:System.Array>中的位置。</span><span class="sxs-lookup"><span data-stu-id="08e41-1275">All elements in the `indices` array must collectively specify the position of the desired element in the multidimensional <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="08e41-1276"><xref:System.Array.GetLowerBound%2A> 和 <xref:System.Array.GetUpperBound%2A> 方法可以确定任何索引是否超出界限。</span><span class="sxs-lookup"><span data-stu-id="08e41-1276">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="08e41-1277">此方法为 O （1）操作。</span><span class="sxs-lookup"><span data-stu-id="08e41-1277">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1278">下面的代码示例演示如何在一维或多维数组中设置和获取特定值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1278">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1279"><paramref name="indices" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1279"><paramref name="indices" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-1280">当前 <see cref="T:System.Array" /> 中的维数不等于 <paramref name="indices" /> 中的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1280">The number of dimensions in the current <see cref="T:System.Array" /> is not equal to the number of elements in <paramref name="indices" />.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="08e41-1281"><paramref name="indices" /> 中的任何元素都超出了当前 <see cref="T:System.Array" /> 的相应维度的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1281">Any element in <paramref name="indices" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="08e41-1282">一个 64 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的位置。</span><span class="sxs-lookup"><span data-stu-id="08e41-1282">A 64-bit integer that represents the position of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="08e41-1283">获取一维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1283">Gets the value at the specified position in the one-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="08e41-1284">索引指定为 64 位整数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1284">The index is specified as a 64-bit integer.</span></span></summary>
        <returns><span data-ttu-id="08e41-1285">一维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1285">The value at the specified position in the one-dimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1286"><xref:System.Array.GetLowerBound%2A> 和 <xref:System.Array.GetUpperBound%2A> 方法可确定 `index` 的值是否超出界限。</span><span class="sxs-lookup"><span data-stu-id="08e41-1286">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether the value of `index` is out of bounds.</span></span>  
  
 <span data-ttu-id="08e41-1287">此方法为 O （1）操作。</span><span class="sxs-lookup"><span data-stu-id="08e41-1287">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1288">下面的代码示例演示如何在一维或多维数组中设置和获取特定值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1288">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-1289">当前 <see cref="T:System.Array" /> 不是正好具有一个维度。</span><span class="sxs-lookup"><span data-stu-id="08e41-1289">The current <see cref="T:System.Array" /> does not have exactly one dimension.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-1290"><paramref name="index" /> 超出了当前 <see cref="T:System.Array" /> 的有效索引的范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1290"><paramref name="index" /> is outside the range of valid indexes for the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Long()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int64[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices"><span data-ttu-id="08e41-1291">一个 64 位整数的一维数组，它表示指定要获取的 <see cref="T:System.Array" /> 元素的位置的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1291">A one-dimensional array of 64-bit integers that represent the indexes specifying the position of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="08e41-1292">获取多维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1292">Gets the value at the specified position in the multidimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="08e41-1293">索引指定为一个 64 位整数数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-1293">The indexes are specified as an array of 64-bit integers.</span></span></summary>
        <returns><span data-ttu-id="08e41-1294">多维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1294">The value at the specified position in the multidimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1295">`indices` 中的元素数必须等于 <xref:System.Array>中的维数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1295">The number of elements in `indices` must equal the number of dimensions in the <xref:System.Array>.</span></span> <span data-ttu-id="08e41-1296">`indices` 数组中的所有元素都必须共同指定所需元素在多维 <xref:System.Array>中的位置。</span><span class="sxs-lookup"><span data-stu-id="08e41-1296">All elements in the `indices` array must collectively specify the position of the desired element in the multidimensional <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="08e41-1297"><xref:System.Array.GetLowerBound%2A> 和 <xref:System.Array.GetUpperBound%2A> 方法可以确定任何索引是否超出界限。</span><span class="sxs-lookup"><span data-stu-id="08e41-1297">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="08e41-1298">此方法为 O （1）操作。</span><span class="sxs-lookup"><span data-stu-id="08e41-1298">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1299">下面的代码示例演示如何在一维或多维数组中设置和获取特定值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1299">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1300"><paramref name="indices" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1300"><paramref name="indices" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-1301">当前 <see cref="T:System.Array" /> 中的维数不等于 <paramref name="indices" /> 中的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1301">The number of dimensions in the current <see cref="T:System.Array" /> is not equal to the number of elements in <paramref name="indices" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-1302"><paramref name="indices" /> 中的任何元素都超出了当前 <see cref="T:System.Array" /> 的相应维度的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1302">Any element in <paramref name="indices" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index1"><span data-ttu-id="08e41-1303">一个 32 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第一维索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1303">A 32-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <param name="index2"><span data-ttu-id="08e41-1304">一个 32 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第二维索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1304">A 32-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="08e41-1305">获取二维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1305">Gets the value at the specified position in the two-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="08e41-1306">索引指定为 32 位整数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1306">The indexes are specified as 32-bit integers.</span></span></summary>
        <returns><span data-ttu-id="08e41-1307">二维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1307">The value at the specified position in the two-dimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1308"><xref:System.Array.GetLowerBound%2A> 和 <xref:System.Array.GetUpperBound%2A> 方法可以确定任何索引是否超出界限。</span><span class="sxs-lookup"><span data-stu-id="08e41-1308">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="08e41-1309">此方法为 O （1）操作。</span><span class="sxs-lookup"><span data-stu-id="08e41-1309">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1310">下面的代码示例演示如何在一维或多维数组中设置和获取特定值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1310">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-1311">当前 <see cref="T:System.Array" /> 不是正好具有两个维度。</span><span class="sxs-lookup"><span data-stu-id="08e41-1311">The current <see cref="T:System.Array" /> does not have exactly two dimensions.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="08e41-1312"><paramref name="index1" /> 或 <paramref name="index2" /> 超出了当前 <see cref="T:System.Array" /> 的相应维度的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1312">Either <paramref name="index1" /> or <paramref name="index2" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index1"><span data-ttu-id="08e41-1313">一个 64 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第一维索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1313">A 64-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <param name="index2"><span data-ttu-id="08e41-1314">一个 64 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第二维索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1314">A 64-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="08e41-1315">获取二维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1315">Gets the value at the specified position in the two-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="08e41-1316">索引指定为 64 位整数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1316">The indexes are specified as 64-bit integers.</span></span></summary>
        <returns><span data-ttu-id="08e41-1317">二维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1317">The value at the specified position in the two-dimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1318"><xref:System.Array.GetLowerBound%2A> 和 <xref:System.Array.GetUpperBound%2A> 方法可以确定任何索引是否超出界限。</span><span class="sxs-lookup"><span data-stu-id="08e41-1318">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="08e41-1319">此方法为 O （1）操作。</span><span class="sxs-lookup"><span data-stu-id="08e41-1319">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1320">下面的代码示例演示如何在一维或多维数组中设置和获取特定值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1320">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-1321">当前 <see cref="T:System.Array" /> 不是正好具有两个维度。</span><span class="sxs-lookup"><span data-stu-id="08e41-1321">The current <see cref="T:System.Array" /> does not have exactly two dimensions.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-1322"><paramref name="index1" /> 或 <paramref name="index2" /> 超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1322">Either <paramref name="index1" /> or <paramref name="index2" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer, index3 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int * int -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index3" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index1"><span data-ttu-id="08e41-1323">一个 32 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第一维索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1323">A 32-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <param name="index2"><span data-ttu-id="08e41-1324">一个 32 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第二维索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1324">A 32-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <param name="index3"><span data-ttu-id="08e41-1325">一个 32 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第三维索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1325">A 32-bit integer that represents the third-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="08e41-1326">获取三维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1326">Gets the value at the specified position in the three-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="08e41-1327">索引指定为 32 位整数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1327">The indexes are specified as 32-bit integers.</span></span></summary>
        <returns><span data-ttu-id="08e41-1328">三维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1328">The value at the specified position in the three-dimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1329"><xref:System.Array.GetLowerBound%2A> 和 <xref:System.Array.GetUpperBound%2A> 方法可以确定任何索引是否超出界限。</span><span class="sxs-lookup"><span data-stu-id="08e41-1329">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="08e41-1330">此方法为 O （1）操作。</span><span class="sxs-lookup"><span data-stu-id="08e41-1330">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1331">下面的代码示例演示如何在一维或多维数组中设置和获取特定值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1331">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-1332">当前 <see cref="T:System.Array" /> 不是正好具有三个维度。</span><span class="sxs-lookup"><span data-stu-id="08e41-1332">The current <see cref="T:System.Array" /> does not have exactly three dimensions.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="08e41-1333"><paramref name="index1" /> 或 <paramref name="index2" /> 或 <paramref name="index3" /> 超出了当前 <see cref="T:System.Array" /> 的相应维度的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1333"><paramref name="index1" /> or <paramref name="index2" /> or <paramref name="index3" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long, index3 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index3" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index1"><span data-ttu-id="08e41-1334">一个 64 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第一维索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1334">A 64-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <param name="index2"><span data-ttu-id="08e41-1335">一个 64 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第二维索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1335">A 64-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <param name="index3"><span data-ttu-id="08e41-1336">一个 64 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第三维索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1336">A 64-bit integer that represents the third-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="08e41-1337">获取三维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1337">Gets the value at the specified position in the three-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="08e41-1338">索引指定为 64 位整数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1338">The indexes are specified as 64-bit integers.</span></span></summary>
        <returns><span data-ttu-id="08e41-1339">三维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1339">The value at the specified position in the three-dimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1340"><xref:System.Array.GetLowerBound%2A> 和 <xref:System.Array.GetUpperBound%2A> 方法可以确定任何索引是否超出界限。</span><span class="sxs-lookup"><span data-stu-id="08e41-1340">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="08e41-1341">此方法为 O （1）操作。</span><span class="sxs-lookup"><span data-stu-id="08e41-1341">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1342">下面的代码示例演示如何在一维或多维数组中设置和获取特定值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1342">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-1343">当前 <see cref="T:System.Array" /> 不是正好具有三个维度。</span><span class="sxs-lookup"><span data-stu-id="08e41-1343">The current <see cref="T:System.Array" /> does not have exactly three dimensions.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-1344"><paramref name="index1" /> 或 <paramref name="index2" /> 或 <paramref name="index3" /> 超出了当前 <see cref="T:System.Array" /> 的相应维度的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1344"><paramref name="index1" /> or <paramref name="index2" /> or <paramref name="index3" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="08e41-1345">在一个一维数组或该数组的一系列元素中搜索指定对象，并返回其首个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1345">Searches for the specified object and returns the index of its first occurrence in a one-dimensional array or in a range of elements in the array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="08e41-1346">要搜索的一维数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-1346">The one-dimensional array to search.</span></span></param>
        <param name="value"><span data-ttu-id="08e41-1347">要在 <paramref name="array" /> 中查找的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-1347">The object to locate in <paramref name="array" />.</span></span></param>
        <summary><span data-ttu-id="08e41-1348">在一个一维数组中搜索指定对象，并返回其首个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1348">Searches for the specified object and returns the index of its first occurrence in a one-dimensional array.</span></span></summary>
        <returns><span data-ttu-id="08e41-1349">如果找到，则为 <paramref name="array" /> 中 <paramref name="value" /> 的第一个匹配项的索引；否则为该数组的下限减 1。</span><span class="sxs-lookup"><span data-stu-id="08e41-1349">The index of the first occurrence of <paramref name="value" /> in <paramref name="array" />, if found; otherwise, the lower bound of the array minus 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1350">此方法将在一维数组的所有元素中搜索 `value`。</span><span class="sxs-lookup"><span data-stu-id="08e41-1350">This method searches all the elements of a one-dimensional array for `value`.</span></span> <span data-ttu-id="08e41-1351">若要确定 `value` 在 `array`中是否存在，方法会通过调用每个元素的 `Equals` 方法来执行相等比较，直到找到匹配项为止。</span><span class="sxs-lookup"><span data-stu-id="08e41-1351">To determine whether `value` exists in `array`, the method performs an equality comparison by calling each element's `Equals` method until it finds a match.</span></span> <span data-ttu-id="08e41-1352">这意味着，如果元素重写 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 方法，则调用该重写。</span><span class="sxs-lookup"><span data-stu-id="08e41-1352">This means that if the element overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, that override is called.</span></span>  
  
 <span data-ttu-id="08e41-1353">由于大多数数组的下限均为零，因此，如果找不到`value`，则此方法通常返回-1。</span><span class="sxs-lookup"><span data-stu-id="08e41-1353">Because most arrays have a lower bound of zero, this method generally returns -1 if`value` isn't found.</span></span> <span data-ttu-id="08e41-1354">在极少数情况下，数组的下限等于 <xref:System.Int32.MinValue?displayProperty=nameWithType>（0x80000000），并且找不到 `value`，则此方法返回 <xref:System.Int32.MaxValue?displayProperty=nameWithType> （0x7FFFFFFF）。</span><span class="sxs-lookup"><span data-stu-id="08e41-1354">In the rare case that the lower bound of the array is equal to <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) and `value` isn't found, this method returns <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).</span></span>  
  
 <span data-ttu-id="08e41-1355">此方法是一个 O （`n`）操作，其中 `n` 是 `array`的 <xref:System.Array.Length%2A>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1355">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1356">该示例调用 <xref:System.Array.IndexOf%2A> 方法的以下三个重载来查找字符串数组中字符串的索引：</span><span class="sxs-lookup"><span data-stu-id="08e41-1356">The example calls the following three overloads of the <xref:System.Array.IndexOf%2A> method to find the index of a string in a string array:</span></span>  
  
-   <span data-ttu-id="08e41-1357"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>，用于确定字符串数组中字符串 "the" 的第一个匹配项。</span><span class="sxs-lookup"><span data-stu-id="08e41-1357"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, to determine the first occurrence of the string "the" in a string array.</span></span>  
  
-   <span data-ttu-id="08e41-1358"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>，用于确定第四个字符串中的第一个匹配项到字符串数组的最后一个元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1358"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, to determine the first occurrence of the string "the" in the fourth to the last elements of a string array.</span></span>  
  
-   <span data-ttu-id="08e41-1359"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>，用于确定字符串数组中字符串 "the" 的第一个匹配项，该字符串是从最后一个成功匹配的元素到数组末尾的下一个元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1359"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, to determine the first occurrence of the string "the" in a string array from the element that follows the last successful match to the end of the array.</span></span>  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1360"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1360"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="08e41-1361"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1361"><paramref name="array" /> is multidimensional.</span></span></exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="08e41-1362">要搜索的一维数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-1362">The one-dimensional array to search.</span></span></param>
        <param name="value"><span data-ttu-id="08e41-1363">要在 <paramref name="array" /> 中查找的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-1363">The object to locate in <paramref name="array" />.</span></span></param>
        <param name="startIndex"><span data-ttu-id="08e41-1364">搜索的起始索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1364">The starting index of the search.</span></span> <span data-ttu-id="08e41-1365">空数组中 0（零）为有效值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1365">0 (zero) is valid in an empty array.</span></span></param>
        <summary><span data-ttu-id="08e41-1366">在一个一维数组的一系列元素中搜索指定对象，然后返回其首个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1366">Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of its first occurrence.</span></span> <span data-ttu-id="08e41-1367">范围从指定索引到该数组结尾。</span><span class="sxs-lookup"><span data-stu-id="08e41-1367">The range extends from a specified index to the end of the array.</span></span></summary>
        <returns><span data-ttu-id="08e41-1368">如果在从 <paramref name="startIndex" /> 到最后一个元素的 <paramref name="array" /> 中的元素范围中找到了 <paramref name="value" /> 的第一个匹配项的索引，则为该索引；否则为数组的下限减 1。</span><span class="sxs-lookup"><span data-stu-id="08e41-1368">The index of the first occurrence of <paramref name="value" />, if it's found, within the range of elements in <paramref name="array" /> that extends from <paramref name="startIndex" /> to the last element; otherwise, the lower bound of the array minus 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1369">此方法搜索一维数组，该数组从索引 `startIndex` 处的元素到最后一个元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1369">This method searches a one-dimensional array from the element at index `startIndex` to the last element.</span></span> <span data-ttu-id="08e41-1370">若要确定 `value` 在 `array`中是否存在，方法会通过调用每个元素的 `Equals` 方法来执行相等比较，直到找到匹配项为止。</span><span class="sxs-lookup"><span data-stu-id="08e41-1370">To determine whether `value` exists in `array`, the method performs an equality comparison by calling the `Equals` method of every element until it finds a match.</span></span> <span data-ttu-id="08e41-1371">这意味着，如果元素重写 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 方法，则调用该重写。</span><span class="sxs-lookup"><span data-stu-id="08e41-1371">This means that if the element overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, that override is called.</span></span>  
  
 <span data-ttu-id="08e41-1372">由于大多数数组的下限均为零，因此，如果找不到 `value`，则此方法通常返回-1。</span><span class="sxs-lookup"><span data-stu-id="08e41-1372">Because most arrays have a lower bound of zero, this method generally returns -1 if `value` isn't found.</span></span> <span data-ttu-id="08e41-1373">在极少数情况下，数组的下限等于 <xref:System.Int32.MinValue?displayProperty=nameWithType>（0x80000000），并且找不到 `value`，则此方法返回 <xref:System.Int32.MaxValue?displayProperty=nameWithType> （0x7FFFFFFF）。</span><span class="sxs-lookup"><span data-stu-id="08e41-1373">In the rare case that the lower bound of the array is equal to <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) and `value` isn't found, this method returns <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).</span></span>  
  
 <span data-ttu-id="08e41-1374">如果 `startIndex` 等于 <xref:System.Array.Length%2A?displayProperty=nameWithType>，则此方法返回-1。</span><span class="sxs-lookup"><span data-stu-id="08e41-1374">If `startIndex` equals <xref:System.Array.Length%2A?displayProperty=nameWithType>,the method returns -1.</span></span> <span data-ttu-id="08e41-1375">如果 `startIndex` 大于 <xref:System.Array.Length%2A?displayProperty=nameWithType>，则该方法将引发一个 <xref:System.ArgumentOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1375">If `startIndex` is greater than <xref:System.Array.Length%2A?displayProperty=nameWithType>, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span>  
  
 <span data-ttu-id="08e41-1376">此方法是 O （`n`）运算，其中 `n` 是 `startIndex` 到 `array`末尾的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1376">This method is an O(`n`) operation, where `n` is the number of elements from `startIndex` to the end of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1377">该示例调用 <xref:System.Array.IndexOf%2A> 方法的以下三个重载来查找字符串数组中字符串的索引：</span><span class="sxs-lookup"><span data-stu-id="08e41-1377">The example calls the following three overloads of the <xref:System.Array.IndexOf%2A> method to find the index of a string in a string array:</span></span>  
  
-   <span data-ttu-id="08e41-1378"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>，用于确定字符串数组中字符串 "the" 的第一个匹配项。</span><span class="sxs-lookup"><span data-stu-id="08e41-1378"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, to determine the first occurrence of the string "the" in a string array.</span></span>  
  
-   <span data-ttu-id="08e41-1379"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>，用于确定第四个字符串中的第一个匹配项到字符串数组的最后一个元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1379"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, to determine the first occurrence of the string "the" in the fourth to the last elements of a string array.</span></span>  
  
-   <span data-ttu-id="08e41-1380"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>，用于确定字符串数组中字符串 "the" 的第一个匹配项，该字符串是从最后一个成功匹配的元素到数组末尾的下一个元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1380"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, to determine the first occurrence of the string "the" in a string array from the element that follows the last successful match to the end of the array.</span></span>  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1381"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1381"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-1382"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1382"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="08e41-1383"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1383"><paramref name="array" /> is multidimensional.</span></span></exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-1384">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-1384">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="08e41-1385">要搜索的一维数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-1385">The one-dimensional array to search.</span></span></param>
        <param name="value"><span data-ttu-id="08e41-1386">要在 <paramref name="array" /> 中查找的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-1386">The object to locate in <paramref name="array" />.</span></span></param>
        <param name="startIndex"><span data-ttu-id="08e41-1387">搜索的起始索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1387">The starting index of the search.</span></span> <span data-ttu-id="08e41-1388">空数组中 0（零）为有效值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1388">0 (zero) is valid in an empty array.</span></span></param>
        <param name="count"><span data-ttu-id="08e41-1389">要搜索的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1389">The number of elements to search.</span></span></param>
        <summary><span data-ttu-id="08e41-1390">在一个一维数组的一系列元素中搜索指定对象，然后返回其首个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1390">Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of ifs first occurrence.</span></span> <span data-ttu-id="08e41-1391">该元素系列的范围从指定数量的元素的指定索引开始。</span><span class="sxs-lookup"><span data-stu-id="08e41-1391">The range extends from a specified index for a specified number of elements.</span></span></summary>
        <returns><span data-ttu-id="08e41-1392">如果在从索引 <paramref name="startIndex" /> 到 <paramref name="startIndex" /> + <paramref name="count" /> - 1 的 <paramref name="array" /> 中找到了 <paramref name="value" /> 的第一个匹配项的索引，则为该索引；否则为该数组的下限减 1。</span><span class="sxs-lookup"><span data-stu-id="08e41-1392">The index of the first occurrence of <paramref name="value" />, if it's found in the <paramref name="array" /> from index <paramref name="startIndex" /> to <paramref name="startIndex" /> + <paramref name="count" /> - 1; otherwise, the lower bound of the array minus 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1393">如果 `count` 大于0，则此方法会将一维数组的元素从 `startIndex` 搜索到 `startIndex` 加 `count` 减1。</span><span class="sxs-lookup"><span data-stu-id="08e41-1393">This method searches the elements of a one-dimensional array from `startIndex` to `startIndex` plus `count` minus 1, if `count` is greater than 0.</span></span> <span data-ttu-id="08e41-1394">若要确定 `value` 在 `array`中是否存在，方法会通过调用每个元素的 `Equals` 方法来执行相等比较，直到找到匹配项为止。</span><span class="sxs-lookup"><span data-stu-id="08e41-1394">To determine whether `value` exists in `array`, the method performs an equality comparison by calling the `Equals` method of every element until it finds a match.</span></span> <span data-ttu-id="08e41-1395">这意味着，如果元素重写 <xref:System.Object.Equals%2A?displayProperty=nameWithType> 方法，则调用该重写。</span><span class="sxs-lookup"><span data-stu-id="08e41-1395">This means that if the element overrides the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method, that override is called.</span></span>  
  
 <span data-ttu-id="08e41-1396">由于大多数数组的下限均为零，因此当找不到 `value` 时，此方法通常返回-1。</span><span class="sxs-lookup"><span data-stu-id="08e41-1396">Because most arrays have a lower bound of zero, this method generally returns -1 when `value` isn't found.</span></span> <span data-ttu-id="08e41-1397">在极少数情况下，数组的下限等于 <xref:System.Int32.MinValue?displayProperty=nameWithType> （0x80000000），并且找不到 `value`，则此方法返回 <xref:System.Int32.MaxValue?displayProperty=nameWithType> （0x7FFFFFFF）。</span><span class="sxs-lookup"><span data-stu-id="08e41-1397">In the rare case that the lower bound of the array is equal to <xref:System.Int32.MinValue?displayProperty=nameWithType> (0x80000000) and `value` isn't found, this method returns <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).</span></span>  
  
 <span data-ttu-id="08e41-1398">如果 `startindex` 等于 <xref:System.Array.Length%2A?displayProperty=nameWithType>，则此方法返回-1。</span><span class="sxs-lookup"><span data-stu-id="08e41-1398">If `startindex` equals <xref:System.Array.Length%2A?displayProperty=nameWithType>, the method returns -1.</span></span> <span data-ttu-id="08e41-1399">如果 `startIndex` 大于 <xref:System.Array.Length%2A?displayProperty=nameWithType>，则该方法将引发一个 <xref:System.ArgumentOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1399">If `startIndex` is greater than <xref:System.Array.Length%2A?displayProperty=nameWithType>, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span>  
  
 <span data-ttu-id="08e41-1400">此方法是一个 O （`n`）操作，其中 `n` 是 `count`的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1400">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1401">该示例调用 <xref:System.Array.IndexOf%2A> 方法的以下三个重载来查找字符串数组中字符串的索引：</span><span class="sxs-lookup"><span data-stu-id="08e41-1401">The example calls the following three overloads of the <xref:System.Array.IndexOf%2A> method to find the index of a string in a string array:</span></span>  
  
-   <span data-ttu-id="08e41-1402"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>，用于确定字符串数组中字符串 "the" 的第一个匹配项。</span><span class="sxs-lookup"><span data-stu-id="08e41-1402"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, to determine the first occurrence of the string "the" in a string array.</span></span>  
  
-   <span data-ttu-id="08e41-1403"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>，用于确定第四个字符串中的第一个匹配项到字符串数组的最后一个元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1403"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, to determine the first occurrence of the string "the" in the fourth to the last elements of a string array.</span></span>  
  
-   <span data-ttu-id="08e41-1404"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>，用于确定字符串数组中字符串 "the" 的第一个匹配项，该字符串是从最后一个成功匹配的元素到数组末尾的下一个元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1404"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, to determine the first occurrence of the string "the" in a string array from the element that follows the last successful match to the end of the array.</span></span> <span data-ttu-id="08e41-1405">若要确定 `count` 参数的值，它将从起始索引中减去数组的上限并添加一个。</span><span class="sxs-lookup"><span data-stu-id="08e41-1405">To determine the value of the `count` argument, it subtracts the upper bound of the array from the starting index and adds one.</span></span>  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1406"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1406"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-1407"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1407"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span>  
  
<span data-ttu-id="08e41-1408">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1408">-or-</span></span> 
 <span data-ttu-id="08e41-1409"><paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-1409"><paramref name="count" /> is less than zero.</span></span>  
  
<span data-ttu-id="08e41-1410">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1410">-or-</span></span> 
 <span data-ttu-id="08e41-1411"><paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="array" /> 中指定有效部分。</span><span class="sxs-lookup"><span data-stu-id="08e41-1411"><paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="08e41-1412"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1412"><paramref name="array" /> is multidimensional.</span></span></exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-1413">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-1413">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-1414">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-1414">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-1415">要搜索的从零开始的一维数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-1415">The one-dimensional, zero-based array to search.</span></span></param>
        <param name="value"><span data-ttu-id="08e41-1416">要在 <paramref name="array" /> 中查找的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-1416">The object to locate in <paramref name="array" />.</span></span></param>
        <summary><span data-ttu-id="08e41-1417">在一个一维数组中搜索指定对象，并返回其首个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1417">Searches for the specified object and returns the index of its first occurrence in a one-dimensional array.</span></span></summary>
        <returns><span data-ttu-id="08e41-1418">如果在整个 <paramref name="array" /> 中找到 <paramref name="value" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="08e41-1418">The zero-based index of the first occurrence of <paramref name="value" /> in the entire <paramref name="array" />, if found; otherwise, -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1419">此方法将在一维数组的所有元素中搜索 `value`。</span><span class="sxs-lookup"><span data-stu-id="08e41-1419">This method searches all the elements of a one-dimensional array for `value`.</span></span> <span data-ttu-id="08e41-1420">若要确定 `value` 在 `array`中是否存在，此方法将通过对每个元素调用 `T.Equals` 方法来执行相等比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-1420">To determine whether `value` exists in `array`, the method performs an equality comparison by calling the `T.Equals` method on every element.</span></span> <span data-ttu-id="08e41-1421">这意味着，如果 `T` 重写 <xref:System.Object.Equals%2A> 方法，则调用该重写。</span><span class="sxs-lookup"><span data-stu-id="08e41-1421">This means that if `T` overrides the <xref:System.Object.Equals%2A> method, that override is called.</span></span>  
  
 <span data-ttu-id="08e41-1422">此方法是一个 O （`n`）操作，其中 `n` 是 `array`的 <xref:System.Array.Length%2A>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1422">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1423">下面的示例演示 <xref:System.Array.IndexOf%2A> 方法的所有三个泛型重载。</span><span class="sxs-lookup"><span data-stu-id="08e41-1423">The following example demonstrates all three generic overloads of the <xref:System.Array.IndexOf%2A> method.</span></span> <span data-ttu-id="08e41-1424">创建一个字符串数组，其中有一个条目出现在索引位置0和索引位置5。</span><span class="sxs-lookup"><span data-stu-id="08e41-1424">An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</span></span> <span data-ttu-id="08e41-1425"><xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> 方法重载从开始处搜索数组，并查找字符串的第一个匹配项。</span><span class="sxs-lookup"><span data-stu-id="08e41-1425">The <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> method overload searches the array from the beginning, and finds the first occurrence of the string.</span></span> <span data-ttu-id="08e41-1426"><xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> 方法重载用于搜索从索引位置3开始的数组，并继续到数组末尾，并查找字符串的第二个匹配项。</span><span class="sxs-lookup"><span data-stu-id="08e41-1426">The <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> method overload is used to search the array beginning with index location 3 and continuing to the end of the array, and finds the second occurrence of the string.</span></span> <span data-ttu-id="08e41-1427">最后，<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> 方法重载用于搜索两个条目的范围，从第二个索引位置开始;它将返回-1，因为该范围内没有搜索字符串的实例。</span><span class="sxs-lookup"><span data-stu-id="08e41-1427">Finally, the <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> method overload is used to search a range of two entries, beginning at index location two; it returns -1 because there are no instances of the search string in that range.</span></span>  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1428"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1428"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-1429">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-1429">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-1430">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-1430">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-1431">要搜索的从零开始的一维数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-1431">The one-dimensional, zero-based array to search.</span></span></param>
        <param name="value"><span data-ttu-id="08e41-1432">要在 <paramref name="array" /> 中查找的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-1432">The object to locate in <paramref name="array" />.</span></span></param>
        <param name="startIndex"><span data-ttu-id="08e41-1433">从零开始的搜索的起始索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1433">The zero-based starting index of the search.</span></span> <span data-ttu-id="08e41-1434">空数组中 0（零）为有效值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1434">0 (zero) is valid in an empty array.</span></span></param>
        <summary><span data-ttu-id="08e41-1435">在一个一维数组的一系列元素中搜索指定对象，然后返回其首个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1435">Searches for the specified object in a range of elements of a one dimensional array, and returns the index of its first occurrence.</span></span> <span data-ttu-id="08e41-1436">范围从指定索引到该数组结尾。</span><span class="sxs-lookup"><span data-stu-id="08e41-1436">The range extends from a specified index to the end of the array.</span></span></summary>
        <returns><span data-ttu-id="08e41-1437">如果在 <paramref name="value" /> 中从 <paramref name="array" /> 到最后一个元素这部分元素中找到 <paramref name="startIndex" /> 的匹配项，则为第一个匹配项的从零开始的索引；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="08e41-1437">The zero-based index of the first occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that extends from <paramref name="startIndex" /> to the last element, if found; otherwise, -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1438">此方法从 `startIndex` 的元素搜索数组的一维数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-1438">This method searches a one-dimensional array from the element at `startIndex` to the end of the array.</span></span> <span data-ttu-id="08e41-1439">若要确定 `value` 在 `array`中是否存在，此方法将通过对每个元素调用 `T.Equals` 方法来执行相等比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-1439">To determine whether `value` exists in `array`, the method performs an equality comparison by calling the `T.Equals` method on every element.</span></span> <span data-ttu-id="08e41-1440">这意味着，如果 `T` 重写 <xref:System.Object.Equals%2A> 方法，则调用该重写。</span><span class="sxs-lookup"><span data-stu-id="08e41-1440">This means that if `T` overrides the <xref:System.Object.Equals%2A> method, that override is called.</span></span>  
  
 <span data-ttu-id="08e41-1441">如果 `startIndex` 等于 <xref:System.Array.Length%2A>，则该方法将返回-1。如果 `startIndex` 大于 <xref:System.Array.Length%2A?displayProperty=nameWithType>，则该方法将引发 <xref:System.ArgumentOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1441">If `startIndex` equals <xref:System.Array.Length%2A>,the method returns -1.If `startIndex` is greater than <xref:System.Array.Length%2A?displayProperty=nameWithType>, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span>  
  
 <span data-ttu-id="08e41-1442">此方法是 O （`n`）运算，其中 `n` 是 `startIndex` 到 `array`末尾的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1442">This method is an O(`n`) operation, where `n` is the number of elements from `startIndex` to the end of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1443">下面的示例演示 <xref:System.Array.IndexOf%2A> 方法的所有三个泛型重载。</span><span class="sxs-lookup"><span data-stu-id="08e41-1443">The following example demonstrates all three generic overloads of the <xref:System.Array.IndexOf%2A> method.</span></span> <span data-ttu-id="08e41-1444">创建一个字符串数组，其中有一个条目出现在索引位置0和索引位置5。</span><span class="sxs-lookup"><span data-stu-id="08e41-1444">An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</span></span> <span data-ttu-id="08e41-1445"><xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> 方法重载从开始处搜索数组，并查找字符串的第一个匹配项。</span><span class="sxs-lookup"><span data-stu-id="08e41-1445">The <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> method overload searches the array from the beginning, and finds the first occurrence of the string.</span></span> <span data-ttu-id="08e41-1446"><xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> 方法重载用于搜索从索引位置3开始的数组，并继续到数组末尾，并查找字符串的第二个匹配项。</span><span class="sxs-lookup"><span data-stu-id="08e41-1446">The <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> method overload is used to search the array beginning with index location 3 and continuing to the end of the array, and finds the second occurrence of the string.</span></span> <span data-ttu-id="08e41-1447">最后，<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> 方法重载用于搜索两个条目的范围，从第二个索引位置开始;它将返回-1，因为该范围内没有搜索字符串的实例。</span><span class="sxs-lookup"><span data-stu-id="08e41-1447">Finally, the <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> method overload is used to search a range of two entries, beginning at index location two; it returns -1 because there are no instances of the search string in that range.</span></span>  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1448"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1448"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-1449"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1449"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span></exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-1450">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-1450">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-1451">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-1451">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-1452">要搜索的从零开始的一维数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-1452">The one-dimensional, zero-based array to search.</span></span></param>
        <param name="value"><span data-ttu-id="08e41-1453">要在 <paramref name="array" /> 中查找的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-1453">The object to locate in <paramref name="array" />.</span></span></param>
        <param name="startIndex"><span data-ttu-id="08e41-1454">从零开始的搜索的起始索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1454">The zero-based starting index of the search.</span></span> <span data-ttu-id="08e41-1455">空数组中 0（零）为有效值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1455">0 (zero) is valid in an empty array.</span></span></param>
        <param name="count"><span data-ttu-id="08e41-1456">要搜索的部分中的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1456">The number of elements in the section to search.</span></span></param>
        <summary><span data-ttu-id="08e41-1457">在一个一维数组的一系列元素中搜索指定对象，然后返回其首个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1457">Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of its first occurrence.</span></span> <span data-ttu-id="08e41-1458">该元素系列的范围从指定数量的元素的指定索引开始。</span><span class="sxs-lookup"><span data-stu-id="08e41-1458">The range extends from a specified index for a specified number of elements.</span></span></summary>
        <returns><span data-ttu-id="08e41-1459">如果在从 <paramref name="count" /> 开始并且包含 <paramref name="startIndex" /> 中指定元素数量的 <paramref name="array" /> 元素范围中找到了 <paramref name="value" /> 第一个匹配项从零开始的索引，则为该索引；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="08e41-1459">The zero-based index of the first occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that starts at <paramref name="startIndex" /> and contains the number of elements specified in <paramref name="count" />, if found; otherwise, -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1460">如果 `count` 大于0，则此方法会将一维数组的元素从 `startIndex` 搜索到 `startIndex` 加 `count` 减1。</span><span class="sxs-lookup"><span data-stu-id="08e41-1460">This method searches the elements of a one-dimensional array from `startIndex` to `startIndex` plus `count` minus 1, if `count` is greater than 0.</span></span> <span data-ttu-id="08e41-1461">若要确定 `value` 在 `array`中是否存在，此方法将通过对每个元素调用 `T.Equals` 方法来执行相等比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-1461">To determine whether `value` exists in `array`, the method performs an equality comparison by calling the `T.Equals` method on every element.</span></span> <span data-ttu-id="08e41-1462">这意味着，如果 `T` 重写 <xref:System.Object.Equals%2A> 方法，则调用该重写。</span><span class="sxs-lookup"><span data-stu-id="08e41-1462">This means that if `T` overrides the <xref:System.Object.Equals%2A> method, that override is called.</span></span>  
  
 <span data-ttu-id="08e41-1463">如果 `startIndex` 等于 <xref:System.Array.Length%2A?displayProperty=nameWithType>，则此方法返回-1。</span><span class="sxs-lookup"><span data-stu-id="08e41-1463">If `startIndex` equals <xref:System.Array.Length%2A?displayProperty=nameWithType>, the method returns -1.</span></span>  <span data-ttu-id="08e41-1464">如果 `startIndex` 大于 <xref:System.Array.Length%2A?displayProperty=nameWithType>，则该方法将引发一个 <xref:System.ArgumentOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1464">If `startIndex` is greater than <xref:System.Array.Length%2A?displayProperty=nameWithType>, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span>  
  
 <span data-ttu-id="08e41-1465">此方法是一个 O （`n`）操作，其中 `n` 是 `count`的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1465">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1466">下面的示例演示 <xref:System.Array.IndexOf%2A> 方法的所有三个泛型重载。</span><span class="sxs-lookup"><span data-stu-id="08e41-1466">The following example demonstrates all three generic overloads of the <xref:System.Array.IndexOf%2A> method.</span></span> <span data-ttu-id="08e41-1467">创建一个字符串数组，其中有一个条目出现在索引位置0和索引位置5。</span><span class="sxs-lookup"><span data-stu-id="08e41-1467">An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</span></span> <span data-ttu-id="08e41-1468"><xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> 方法重载从开始处搜索数组，并查找字符串的第一个匹配项。</span><span class="sxs-lookup"><span data-stu-id="08e41-1468">The <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> method overload searches the array from the beginning, and finds the first occurrence of the string.</span></span> <span data-ttu-id="08e41-1469"><xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> 方法重载用于搜索从索引位置3开始的数组，并继续到数组末尾，并查找字符串的第二个匹配项。</span><span class="sxs-lookup"><span data-stu-id="08e41-1469">The <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> method overload is used to search the array beginning with index location 3 and continuing to the end of the array, and finds the second occurrence of the string.</span></span> <span data-ttu-id="08e41-1470">最后，<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> 方法重载用于搜索两个条目的范围，从第二个索引位置开始;它将返回-1，因为该范围内没有搜索字符串的实例。</span><span class="sxs-lookup"><span data-stu-id="08e41-1470">Finally, the <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> method overload is used to search a range of two entries, beginning at index location two; it returns -1 because there are no instances of the search string in that range.</span></span>  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1471"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1471"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-1472"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1472"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span>  
  
<span data-ttu-id="08e41-1473">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1473">-or-</span></span> 
 <span data-ttu-id="08e41-1474"><paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-1474"><paramref name="count" /> is less than zero.</span></span>  
  
<span data-ttu-id="08e41-1475">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1475">-or-</span></span> 
 <span data-ttu-id="08e41-1476"><paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="array" /> 中指定有效部分。</span><span class="sxs-lookup"><span data-stu-id="08e41-1476"><paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</span></span></exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-1477">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-1477">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Initialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize();" />
      <MemberSignature Language="F#" Value="member this.Initialize : unit -&gt; unit" Usage="array.Initialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="08e41-1478">通过调用值类型的无参数构造函数，初始化值类型 <see cref="T:System.Array" /> 的每一个元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1478">Initializes every element of the value-type <see cref="T:System.Array" /> by calling the parameterless constructor of the value type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1479">此方法旨在帮助编译器支持值类型数组;大多数用户不需要此方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1479">This method is designed to help compilers support value-type arrays; most users do not need this method.</span></span> <span data-ttu-id="08e41-1480">不能对引用类型数组使用。</span><span class="sxs-lookup"><span data-stu-id="08e41-1480">It must not be used on reference-type arrays.</span></span>  
  
 <span data-ttu-id="08e41-1481">如果 <xref:System.Array> 不是 <xref:System.Array> 值类型，或者如果值类型没有无参数的构造函数，则不会修改 <xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1481">If the <xref:System.Array> is not a value-type <xref:System.Array> or if the value type does not have a parameterless constructor, the <xref:System.Array> is not modified.</span></span>  
  
 <span data-ttu-id="08e41-1482">值类型 <xref:System.Array> 可以有任何下限和任意数量的维度。</span><span class="sxs-lookup"><span data-stu-id="08e41-1482">The value-type <xref:System.Array> can have any lower bound and any number of dimensions.</span></span>  
  
 <span data-ttu-id="08e41-1483">此方法是一个 O （`n`）操作，其中 `n` 是 <xref:System.Array.Length%2A>的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1483">This method is an O(`n`) operation, where `n` is <xref:System.Array.Length%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="08e41-1484">只能对具有构造函数的值类型使用此方法;但不具有构造函数的本机C#值类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-1484">You can use this method only on value types that have constructors; however, value types that are native to C# do not have constructors.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Array.IsFixedSize" />
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsFixedSize As Boolean" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsFixedSize { bool get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="08e41-1485">获取一个值，该值指示 <see cref="T:System.Array" /> 是否具有固定大小。</span><span class="sxs-lookup"><span data-stu-id="08e41-1485">Gets a value indicating whether the <see cref="T:System.Array" /> has a fixed size.</span></span></summary>
        <value><span data-ttu-id="08e41-1486">对于所有数组，此属性始终为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1486">This property is always <see langword="true" /> for all arrays.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1487"><xref:System.Array> 实现 <xref:System.Array.IsFixedSize%2A> 属性，因为 <xref:System.Collections.IList?displayProperty=nameWithType> 接口需要此属性。</span><span class="sxs-lookup"><span data-stu-id="08e41-1487"><xref:System.Array> implements the <xref:System.Array.IsFixedSize%2A> property because it is required by the <xref:System.Collections.IList?displayProperty=nameWithType> interface.</span></span>  
  
 <span data-ttu-id="08e41-1488">在创建数组后，具有固定大小的数组不允许添加或删除元素，但允许修改现有元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1488">An array with a fixed size does not allow the addition or removal of elements after the array is created, but it allows the modification of existing elements.</span></span>  
  
 <span data-ttu-id="08e41-1489">检索此属性的值的运算复杂度为 O(1)。</span><span class="sxs-lookup"><span data-stu-id="08e41-1489">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Array.IsReadOnly" />
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="08e41-1490">获取一个值，该值指示 <see cref="T:System.Array" /> 是否为只读。</span><span class="sxs-lookup"><span data-stu-id="08e41-1490">Gets a value indicating whether the <see cref="T:System.Array" /> is read-only.</span></span></summary>
        <value><span data-ttu-id="08e41-1491">对于所有数组，此属性始终为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1491">This property is always <see langword="false" /> for all arrays.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1492"><xref:System.Array> 实现 <xref:System.Array.IsReadOnly%2A> 属性，因为 <xref:System.Collections.IList?displayProperty=nameWithType> 接口需要此属性。</span><span class="sxs-lookup"><span data-stu-id="08e41-1492"><xref:System.Array> implements the <xref:System.Array.IsReadOnly%2A> property because it is required by the <xref:System.Collections.IList?displayProperty=nameWithType> interface.</span></span> <span data-ttu-id="08e41-1493">如果数组为只读，则在创建数组后，不允许添加、移除或修改元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1493">An array that is read-only does not allow the addition, removal, or modification of elements after the array is created.</span></span>  
  
 <span data-ttu-id="08e41-1494">如果需要只读集合，请使用实现 <xref:System.Collections.IList?displayProperty=nameWithType> 接口的 <xref:System.Collections> 类。</span><span class="sxs-lookup"><span data-stu-id="08e41-1494">If you require a read-only collection, use a <xref:System.Collections> class that implements the <xref:System.Collections.IList?displayProperty=nameWithType> interface.</span></span>  
  
 <span data-ttu-id="08e41-1495">如果将数组强制转换或转换为 <xref:System.Collections.IList> 接口对象，则 <xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType> 属性将返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="08e41-1495">If you cast or convert an array to an <xref:System.Collections.IList> interface object, the <xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType> property returns `false`.</span></span> <span data-ttu-id="08e41-1496">但是，如果将数组强制转换或转换为 <xref:System.Collections.Generic.IList%601> 接口，则 `IsReadOnly` 属性将返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="08e41-1496">However, if you cast or convert an array to a <xref:System.Collections.Generic.IList%601> interface, the `IsReadOnly` property returns `true`.</span></span>  
  
 <span data-ttu-id="08e41-1497">检索此属性的值的运算复杂度为 O(1)。</span><span class="sxs-lookup"><span data-stu-id="08e41-1497">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="N:System.Collections" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="N:System.Collections.Generic" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Array.IsSynchronized" />
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="08e41-1498">获取一个值，该值指示是否同步对 <see cref="T:System.Array" /> 的访问（线程安全）。</span><span class="sxs-lookup"><span data-stu-id="08e41-1498">Gets a value indicating whether access to the <see cref="T:System.Array" /> is synchronized (thread safe).</span></span></summary>
        <value><span data-ttu-id="08e41-1499">对于所有数组，此属性始终为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1499">This property is always <see langword="false" /> for all arrays.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1500"><xref:System.Array> 实现 <xref:System.Array.IsSynchronized%2A> 属性，因为 <xref:System.Collections.ICollection?displayProperty=nameWithType> 接口需要此属性。</span><span class="sxs-lookup"><span data-stu-id="08e41-1500"><xref:System.Array> implements the <xref:System.Array.IsSynchronized%2A> property because it is required by the <xref:System.Collections.ICollection?displayProperty=nameWithType> interface.</span></span>  
  
 <span data-ttu-id="08e41-1501">基于 <xref:System.Array> .NET Framework 类使用 <xref:System.Array.SyncRoot%2A> 属性提供其自己的同步版本的集合。</span><span class="sxs-lookup"><span data-stu-id="08e41-1501">.NET Framework classes based on <xref:System.Array> provide their own synchronized version of the collection using the <xref:System.Array.SyncRoot%2A> property.</span></span>  
  
 <span data-ttu-id="08e41-1502">使用数组的类也可以使用 <xref:System.Array.SyncRoot%2A> 属性实现其自己的同步。</span><span class="sxs-lookup"><span data-stu-id="08e41-1502">Classes that use arrays can also implement their own synchronization using the <xref:System.Array.SyncRoot%2A> property.</span></span> <span data-ttu-id="08e41-1503">同步代码必须对集合的 `SyncRoot` 执行操作，而不是直接对集合执行操作。</span><span class="sxs-lookup"><span data-stu-id="08e41-1503">The synchronizing code must perform operations on the `SyncRoot` of the collection, not directly on the collection.</span></span> <span data-ttu-id="08e41-1504">这样可确保对从其他对象派生的集合正确地执行操作。</span><span class="sxs-lookup"><span data-stu-id="08e41-1504">This ensures proper operation of collections that are derived from other objects.</span></span> <span data-ttu-id="08e41-1505">具体而言，它与可能同时修改集合的其他线程保持正确的同步。</span><span class="sxs-lookup"><span data-stu-id="08e41-1505">Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the collection.</span></span> <span data-ttu-id="08e41-1506">请注意，<xref:System.Array.SyncRoot%2A> 的某些实现可能会返回 <xref:System.Array> 本身。</span><span class="sxs-lookup"><span data-stu-id="08e41-1506">Note that some implementations of <xref:System.Array.SyncRoot%2A> might return the <xref:System.Array> itself.</span></span>  
  
 <span data-ttu-id="08e41-1507">枚举集合本质上不是线程安全的过程。</span><span class="sxs-lookup"><span data-stu-id="08e41-1507">Enumerating through a collection is intrinsically not a thread safe procedure.</span></span> <span data-ttu-id="08e41-1508">即使某个集合已同步，其他线程仍可以修改该集合，这会导致枚举数引发异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-1508">Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</span></span> <span data-ttu-id="08e41-1509">若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改所导致的异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-1509">To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</span></span>  
  
 <span data-ttu-id="08e41-1510">检索此属性的值的运算复杂度为 O(1)。</span><span class="sxs-lookup"><span data-stu-id="08e41-1510">Retrieving the value of this property is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1511">下面的代码示例演示如何使用 <xref:System.Array.SyncRoot%2A> 属性在整个枚举过程中锁定数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-1511">The following code example shows how to lock an array during the entire enumeration by using the <xref:System.Array.SyncRoot%2A> property.</span></span>  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.SyncRoot" />
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="08e41-1512">返回一维 <see cref="T:System.Array" /> 或 <see cref="T:System.Array" /> 的一部分中某个值的最后一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1512">Returns the index of the last occurrence of a value in a one-dimensional <see cref="T:System.Array" /> or in a portion of the <see cref="T:System.Array" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="08e41-1513">要搜索的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1513">The one-dimensional <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="08e41-1514">要在 <paramref name="array" /> 中查找的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-1514">The object to locate in <paramref name="array" />.</span></span></param>
        <summary><span data-ttu-id="08e41-1515">搜索指定的对象，并返回整个一维 <see cref="T:System.Array" /> 中最后一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1515">Searches for the specified object and returns the index of the last occurrence within the entire one-dimensional <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="08e41-1516">如果在整个 <paramref name="array" /> 中找到 <paramref name="value" /> 的最后一个匹配项的索引，则为该索引；否则为该数组的下限减 1。</span><span class="sxs-lookup"><span data-stu-id="08e41-1516">The index of the last occurrence of <paramref name="value" /> within the entire <paramref name="array" />, if found; otherwise, the lower bound of the array minus 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1517">从最后一个元素开始向后搜索一维 <xref:System.Array>，并在第一个元素处结束。</span><span class="sxs-lookup"><span data-stu-id="08e41-1517">The one-dimensional <xref:System.Array> is searched backward starting at the last element and ending at the first element.</span></span>  
  
 <span data-ttu-id="08e41-1518">使用 <xref:System.Object.Equals%2A?displayProperty=nameWithType> 方法将元素与指定的值进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-1518">The elements are compared to the specified value using the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="08e41-1519">如果元素类型为 nonintrinsic （用户定义）类型，则使用该类型的 `Equals` 实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-1519">If the element type is a nonintrinsic (user-defined) type, the `Equals` implementation of that type is used.</span></span>  
  
 <span data-ttu-id="08e41-1520">由于大多数数组的下限均为零，因此当找不到 `value` 时，此方法通常会返回-1。</span><span class="sxs-lookup"><span data-stu-id="08e41-1520">Since most arrays will have a lower bound of zero, this method would generally return -1 when `value` is not found.</span></span> <span data-ttu-id="08e41-1521">在极少数情况下，数组的下限等于 <xref:System.Int32.MinValue?displayProperty=nameWithType> 并且找不到 `value`，则此方法返回 <xref:System.Int32.MaxValue?displayProperty=nameWithType>，这 `System.Int32.MinValue - 1`。</span><span class="sxs-lookup"><span data-stu-id="08e41-1521">In the rare case that the lower bound of the array is equal to <xref:System.Int32.MinValue?displayProperty=nameWithType> and `value` is not found, this method returns <xref:System.Int32.MaxValue?displayProperty=nameWithType>, which is `System.Int32.MinValue - 1`.</span></span>  
  
 <span data-ttu-id="08e41-1522">此方法是一个 O （`n`）操作，其中 `n` 是 `array`的 <xref:System.Array.Length%2A>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1522">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
 <span data-ttu-id="08e41-1523">在 .NET Framework 版本2.0 中，此方法使用 <xref:System.Array> 的 <xref:System.Object.Equals%2A> 和 <xref:System.IComparable.CompareTo%2A> 方法来确定 <xref:System.Object> 参数指定的 `value` 是否存在。</span><span class="sxs-lookup"><span data-stu-id="08e41-1523">In the .NET Framework version 2.0, this method uses the <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods of the <xref:System.Array> to determine whether the <xref:System.Object> specified by the `value` parameter exists.</span></span> <span data-ttu-id="08e41-1524">在 .NET Framework 的早期版本中，此决定是使用 `value`<xref:System.Object> 本身的 <xref:System.Object.Equals%2A> 和 <xref:System.IComparable.CompareTo%2A> 方法进行的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1524">In the earlier versions of the .NET Framework, this determination was made by using the <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods of the `value`<xref:System.Object> itself.</span></span>  
  
 <span data-ttu-id="08e41-1525">集合中对象的 `item` 参数的 <xref:System.IComparable.CompareTo%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1525"><xref:System.IComparable.CompareTo%2A> methods of the `item` parameter on the objects in the collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1526">下面的代码示例演示如何确定指定元素在数组中的最后一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1526">The following code example shows how to determine the index of the last occurrence of a specified element in an array.</span></span>  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1527"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1527"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="08e41-1528"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1528"><paramref name="array" /> is multidimensional.</span></span></exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-1529">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-1529">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="08e41-1530">要搜索的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1530">The one-dimensional <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="08e41-1531">要在 <paramref name="array" /> 中查找的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-1531">The object to locate in <paramref name="array" />.</span></span></param>
        <param name="startIndex"><span data-ttu-id="08e41-1532">向后搜索的起始索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1532">The starting index of the backward search.</span></span></param>
        <summary><span data-ttu-id="08e41-1533">搜索指定的对象，并返回一维 <see cref="T:System.Array" /> 中从第一个元素到指定索引这部分元素中最后一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1533">Searches for the specified object and returns the index of the last occurrence within the range of elements in the one-dimensional <see cref="T:System.Array" /> that extends from the first element to the specified index.</span></span></summary>
        <returns><span data-ttu-id="08e41-1534">如果在 <paramref name="array" /> 中从第一个元素到 <paramref name="startIndex" /> 的元素范围内找到了 <paramref name="value" /> 的最后一个匹配项的索引，则为该索引；否则为该数组的下限减 1。</span><span class="sxs-lookup"><span data-stu-id="08e41-1534">The index of the last occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that extends from the first element to <paramref name="startIndex" />, if found; otherwise, the lower bound of the array minus 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1535">从 `startIndex` 开始向后搜索一维 <xref:System.Array>，并在第一个元素处结束。</span><span class="sxs-lookup"><span data-stu-id="08e41-1535">The one-dimensional <xref:System.Array> is searched backward starting at `startIndex` and ending at the first element.</span></span>  
  
 <span data-ttu-id="08e41-1536">使用 <xref:System.Object.Equals%2A?displayProperty=nameWithType> 方法将元素与指定的值进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-1536">The elements are compared to the specified value using the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="08e41-1537">如果元素类型为 nonintrinsic （用户定义）类型，则使用该类型的 `Equals` 实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-1537">If the element type is a nonintrinsic (user-defined) type, the `Equals` implementation of that type is used.</span></span>  
  
 <span data-ttu-id="08e41-1538">由于大多数数组的下限均为零，因此当找不到 `value` 时，此方法通常会返回-1。</span><span class="sxs-lookup"><span data-stu-id="08e41-1538">Since most arrays will have a lower bound of zero, this method would generally return -1 when `value` is not found.</span></span> <span data-ttu-id="08e41-1539">在极少数情况下，数组的下限等于 <xref:System.Int32.MinValue?displayProperty=nameWithType> 并且找不到 `value`，则此方法返回 <xref:System.Int32.MaxValue?displayProperty=nameWithType>，这 `System.Int32.MinValue - 1`。</span><span class="sxs-lookup"><span data-stu-id="08e41-1539">In the rare case that the lower bound of the array is equal to <xref:System.Int32.MinValue?displayProperty=nameWithType> and `value` is not found, this method returns <xref:System.Int32.MaxValue?displayProperty=nameWithType>, which is `System.Int32.MinValue - 1`.</span></span>  
  
 <span data-ttu-id="08e41-1540">此方法为 O （`n`）运算，其中 `n` 是从 `array` 开始到 `startIndex`的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1540">This method is an O(`n`) operation, where `n` is the number of elements from the beginning of `array` to `startIndex`.</span></span>  
  
 <span data-ttu-id="08e41-1541">在 .NET Framework 版本2.0 中，此方法使用 <xref:System.Array> 的 <xref:System.Object.Equals%2A> 和 <xref:System.IComparable.CompareTo%2A> 方法来确定 <xref:System.Object> 参数指定的 `value` 是否存在。</span><span class="sxs-lookup"><span data-stu-id="08e41-1541">In the .NET Framework version 2.0, this method uses the <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods of the <xref:System.Array> to determine whether the <xref:System.Object> specified by the `value` parameter exists.</span></span> <span data-ttu-id="08e41-1542">在 .NET Framework 的早期版本中，此决定是使用 `value`<xref:System.Object> 本身的 <xref:System.Object.Equals%2A> 和 <xref:System.IComparable.CompareTo%2A> 方法进行的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1542">In the earlier versions of the .NET Framework, this determination was made by using the <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods of the `value`<xref:System.Object> itself.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1543">下面的代码示例演示如何确定指定元素在数组中的最后一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1543">The following code example shows how to determine the index of the last occurrence of a specified element in an array.</span></span>  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1544"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1544"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-1545"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1545"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="08e41-1546"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1546"><paramref name="array" /> is multidimensional.</span></span></exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-1547">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-1547">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="08e41-1548">要搜索的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1548">The one-dimensional <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="08e41-1549">要在 <paramref name="array" /> 中查找的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-1549">The object to locate in <paramref name="array" />.</span></span></param>
        <param name="startIndex"><span data-ttu-id="08e41-1550">向后搜索的起始索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1550">The starting index of the backward search.</span></span></param>
        <param name="count"><span data-ttu-id="08e41-1551">要搜索的部分中的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1551">The number of elements in the section to search.</span></span></param>
        <summary><span data-ttu-id="08e41-1552">搜索指定的对象，并返回一维 <see cref="T:System.Array" /> 中到指定索引为止包含指定个元素的这部分元素中最后一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1552">Searches for the specified object and returns the index of the last occurrence within the range of elements in the one-dimensional <see cref="T:System.Array" /> that contains the specified number of elements and ends at the specified index.</span></span></summary>
        <returns><span data-ttu-id="08e41-1553">如果在包含 <paramref name="count" /> 中指定的元素数并且在 <paramref name="startIndex" /> 结尾的 <paramref name="array" /> 中的元素范围内找到了 <paramref name="value" /> 的最后一个匹配项的索引，则为该索引；否则为该数组的下限减 1。</span><span class="sxs-lookup"><span data-stu-id="08e41-1553">The index of the last occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that contains the number of elements specified in <paramref name="count" /> and ends at <paramref name="startIndex" />, if found; otherwise, the lower bound of the array minus 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1554">从 `startIndex` 开始向后搜索一维 <xref:System.Array>，在 `startIndex` 减号处结束，如果 `count` 大于0，则从 `count` 减号结束。</span><span class="sxs-lookup"><span data-stu-id="08e41-1554">The one-dimensional <xref:System.Array> is searched backward starting at `startIndex` and ending at `startIndex` minus `count` plus 1, if `count` is greater than 0.</span></span>  
  
 <span data-ttu-id="08e41-1555">使用 <xref:System.Object.Equals%2A?displayProperty=nameWithType> 方法将元素与指定的值进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-1555">The elements are compared to the specified value using the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="08e41-1556">如果元素类型为 nonintrinsic （用户定义）类型，则使用该类型的`Equals` 实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-1556">If the element type is a nonintrinsic (user-defined) type, the`Equals` implementation of that type is used.</span></span>  
  
 <span data-ttu-id="08e41-1557">由于大多数数组的下限均为零，因此当找不到 `value` 时，此方法通常会返回-1。</span><span class="sxs-lookup"><span data-stu-id="08e41-1557">Since most arrays will have a lower bound of zero, this method would generally return -1 when `value` is not found.</span></span> <span data-ttu-id="08e41-1558">在极少数情况下，数组的下限等于 <xref:System.Int32.MinValue?displayProperty=nameWithType> 并且找不到 `value`，则此方法返回 <xref:System.Int32.MaxValue?displayProperty=nameWithType>，这 `System.Int32.MinValue - 1`。</span><span class="sxs-lookup"><span data-stu-id="08e41-1558">In the rare case that the lower bound of the array is equal to <xref:System.Int32.MinValue?displayProperty=nameWithType> and `value` is not found, this method returns <xref:System.Int32.MaxValue?displayProperty=nameWithType>, which is `System.Int32.MinValue - 1`.</span></span>  
  
 <span data-ttu-id="08e41-1559">此方法是一个 O （`n`）操作，其中 `n` 是 `count`的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1559">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
 <span data-ttu-id="08e41-1560">在 .NET Framework 版本2.0 中，此方法使用 <xref:System.Array> 的 <xref:System.Object.Equals%2A> 和 <xref:System.IComparable.CompareTo%2A> 方法来确定 <xref:System.Object> 参数指定的 `value` 是否存在。</span><span class="sxs-lookup"><span data-stu-id="08e41-1560">In the .NET Framework version 2.0, this method uses the <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods of the <xref:System.Array> to determine whether the <xref:System.Object> specified by the `value` parameter exists.</span></span> <span data-ttu-id="08e41-1561">在 .NET Framework 的早期版本中，此决定是使用 `value`<xref:System.Object> 本身的 <xref:System.Object.Equals%2A> 和 <xref:System.IComparable.CompareTo%2A> 方法进行的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1561">In the earlier versions of the .NET Framework, this determination was made by using the <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods of the `value`<xref:System.Object> itself.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1562">下面的代码示例演示如何确定指定元素在数组中的最后一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1562">The following code example shows how to determine the index of the last occurrence of a specified element in an array.</span></span> <span data-ttu-id="08e41-1563">请注意，<xref:System.Array.LastIndexOf%2A> 方法是向后搜索;因此，`count` 必须小于或等于（`startIndex` 减去数组的下限加1）。</span><span class="sxs-lookup"><span data-stu-id="08e41-1563">Note that the <xref:System.Array.LastIndexOf%2A> method is a backward search; therefore, `count` must be less than or equal to (`startIndex` minus the lower bound of the array plus 1).</span></span>  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1564"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1564"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-1565"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1565"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span>  
  
<span data-ttu-id="08e41-1566">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1566">-or-</span></span> 
 <span data-ttu-id="08e41-1567"><paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-1567"><paramref name="count" /> is less than zero.</span></span>  
  
<span data-ttu-id="08e41-1568">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1568">-or-</span></span> 
 <span data-ttu-id="08e41-1569"><paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="array" /> 中指定有效部分。</span><span class="sxs-lookup"><span data-stu-id="08e41-1569"><paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="08e41-1570"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1570"><paramref name="array" /> is multidimensional.</span></span></exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-1571">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-1571">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-1572">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-1572">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-1573">要搜索的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1573">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="08e41-1574">要在 <paramref name="array" /> 中查找的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-1574">The object to locate in <paramref name="array" />.</span></span></param>
        <summary><span data-ttu-id="08e41-1575">搜索指定的对象，并返回整个 <see cref="T:System.Array" /> 中最后一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1575">Searches for the specified object and returns the index of the last occurrence within the entire <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="08e41-1576">如果在整个 <paramref name="array" /> 中找到 <paramref name="value" /> 的最后一个匹配项从零开始的索引，则为该索引；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="08e41-1576">The zero-based index of the last occurrence of <paramref name="value" /> within the entire <paramref name="array" />, if found; otherwise, -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1577">从最后一个元素开始向后搜索 <xref:System.Array>，并在第一个元素处结束。</span><span class="sxs-lookup"><span data-stu-id="08e41-1577">The <xref:System.Array> is searched backward starting at the last element and ending at the first element.</span></span>  
  
 <span data-ttu-id="08e41-1578">使用 <xref:System.Object.Equals%2A?displayProperty=nameWithType> 方法将元素与指定的值进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-1578">The elements are compared to the specified value using the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="08e41-1579">如果元素类型为 nonintrinsic （用户定义）类型，则使用该类型的 `Equals` 实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-1579">If the element type is a nonintrinsic (user-defined) type, the `Equals` implementation of that type is used.</span></span>  
  
 <span data-ttu-id="08e41-1580">此方法是一个 O （`n`）操作，其中 `n` 是 `array`的 <xref:System.Array.Length%2A>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1580">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1581">下面的代码示例演示 <xref:System.Array.LastIndexOf%2A> 方法的所有三个泛型重载。</span><span class="sxs-lookup"><span data-stu-id="08e41-1581">The following code example demonstrates all three generic overloads of the <xref:System.Array.LastIndexOf%2A> method.</span></span> <span data-ttu-id="08e41-1582">创建一个字符串数组，其中有一个条目出现在索引位置0和索引位置5。</span><span class="sxs-lookup"><span data-stu-id="08e41-1582">An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</span></span> <span data-ttu-id="08e41-1583"><xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> 方法重载从末尾搜索整个数组，并查找字符串的第二个匹配项。</span><span class="sxs-lookup"><span data-stu-id="08e41-1583">The <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> method overload searches the entire array from the end, and finds the second occurrence of the string.</span></span> <span data-ttu-id="08e41-1584"><xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> 方法重载用于从索引位置3开始向后搜索数组，并继续到数组的开头，并查找字符串的第一个匹配项。</span><span class="sxs-lookup"><span data-stu-id="08e41-1584">The <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> method overload is used to search the array backward beginning with index location 3 and continuing to the beginning of the array, and finds the first occurrence of the string.</span></span> <span data-ttu-id="08e41-1585">最后，<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> 方法重载用于搜索由四个条目组成的范围，从索引位置4开始并向后扩展（也就是说，它会搜索位于4、3、2和1位置的项）;此搜索将返回-1，因为该范围中没有搜索字符串的实例。</span><span class="sxs-lookup"><span data-stu-id="08e41-1585">Finally, the <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns -1 because there are no instances of the search string in that range.</span></span>  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1586"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1586"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-1587">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-1587">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-1588">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-1588">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-1589">要搜索的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1589">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="08e41-1590">要在 <paramref name="array" /> 中查找的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-1590">The object to locate in <paramref name="array" />.</span></span></param>
        <param name="startIndex"><span data-ttu-id="08e41-1591">向后搜索的从零开始的起始索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1591">The zero-based starting index of the backward search.</span></span></param>
        <summary><span data-ttu-id="08e41-1592">搜索指定的对象，并返回 <see cref="T:System.Array" /> 中从第一个元素到指定索引这部分元素中最后一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1592">Searches for the specified object and returns the index of the last occurrence within the range of elements in the <see cref="T:System.Array" /> that extends from the first element to the specified index.</span></span></summary>
        <returns><span data-ttu-id="08e41-1593">如果在 <paramref name="array" /> 中从第一个元素到 <paramref name="startIndex" /> 的元素范围中找到了该 <paramref name="value" /> 最后一个匹配项从零开始的索引，则为该索引；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="08e41-1593">The zero-based index of the last occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that extends from the first element to <paramref name="startIndex" />, if found; otherwise, -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1594">从 `startIndex` 开始向后搜索 <xref:System.Array>，并在第一个元素处结束。</span><span class="sxs-lookup"><span data-stu-id="08e41-1594">The <xref:System.Array> is searched backward starting at `startIndex` and ending at the first element.</span></span>  
  
 <span data-ttu-id="08e41-1595">使用 <xref:System.Object.Equals%2A?displayProperty=nameWithType> 方法将元素与指定的值进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-1595">The elements are compared to the specified value using the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="08e41-1596">如果元素类型为 nonintrinsic （用户定义）类型，则使用该类型的 `Equals` 实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-1596">If the element type is a nonintrinsic (user-defined) type, the `Equals` implementation of that type is used.</span></span>  
  
 <span data-ttu-id="08e41-1597">此方法为 O （`n`）运算，其中 `n` 是从 `array` 开始到 `startIndex`的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1597">This method is an O(`n`) operation, where `n` is the number of elements from the beginning of `array` to `startIndex`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1598">下面的代码示例演示 <xref:System.Array.LastIndexOf%2A> 方法的所有三个泛型重载。</span><span class="sxs-lookup"><span data-stu-id="08e41-1598">The following code example demonstrates all three generic overloads of the <xref:System.Array.LastIndexOf%2A> method.</span></span> <span data-ttu-id="08e41-1599">创建一个字符串数组，其中有一个条目出现在索引位置0和索引位置5。</span><span class="sxs-lookup"><span data-stu-id="08e41-1599">An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</span></span> <span data-ttu-id="08e41-1600"><xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> 方法重载从末尾搜索整个数组，并查找字符串的第二个匹配项。</span><span class="sxs-lookup"><span data-stu-id="08e41-1600">The <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> method overload searches the entire array from the end, and finds the second occurrence of the string.</span></span> <span data-ttu-id="08e41-1601"><xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> 方法重载用于从索引位置3开始向后搜索数组，并继续到数组的开头，并查找字符串的第一个匹配项。</span><span class="sxs-lookup"><span data-stu-id="08e41-1601">The <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> method overload is used to search the array backward beginning with index location 3 and continuing to the beginning of the array, and finds the first occurrence of the string.</span></span> <span data-ttu-id="08e41-1602">最后，<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> 方法重载用于搜索由四个条目组成的范围，从索引位置4开始并向后扩展（也就是说，它会搜索位于4、3、2和1位置的项）;此搜索将返回-1，因为该范围中没有搜索字符串的实例。</span><span class="sxs-lookup"><span data-stu-id="08e41-1602">Finally, the <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns -1 because there are no instances of the search string in that range.</span></span>  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1603"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1603"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-1604"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1604"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span></exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-1605">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-1605">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-1606">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-1606">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-1607">要搜索的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1607">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="08e41-1608">要在 <paramref name="array" /> 中查找的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-1608">The object to locate in <paramref name="array" />.</span></span></param>
        <param name="startIndex"><span data-ttu-id="08e41-1609">向后搜索的从零开始的起始索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1609">The zero-based starting index of the backward search.</span></span></param>
        <param name="count"><span data-ttu-id="08e41-1610">要搜索的部分中的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1610">The number of elements in the section to search.</span></span></param>
        <summary><span data-ttu-id="08e41-1611">搜索指定的对象，并返回 <see cref="T:System.Array" /> 中到指定索引为止包含指定个元素的这部分元素中最后一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1611">Searches for the specified object and returns the index of the last occurrence within the range of elements in the <see cref="T:System.Array" /> that contains the specified number of elements and ends at the specified index.</span></span></summary>
        <returns><span data-ttu-id="08e41-1612">如果在 <paramref name="startIndex" /> 中找到了包含 <paramref name="count" /> 中指定元素数并且到 <paramref name="array" /> 结尾的元素范围内的 <paramref name="value" /> 的最后一个匹配项的从零开始的索引，则为该索引；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="08e41-1612">The zero-based index of the last occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that contains the number of elements specified in <paramref name="count" /> and ends at <paramref name="startIndex" />, if found; otherwise, -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1613">将从 `startIndex` 开始向后 <xref:System.Array> 搜索，如果 `count` 大于0，则从 `startIndex` 减号开始，在 `count` 减号处结束。</span><span class="sxs-lookup"><span data-stu-id="08e41-1613">The <xref:System.Array> is searched backward starting at `startIndex` and ending at `startIndex` minus `count` plus 1, if `count` is greater than 0.</span></span>  
  
 <span data-ttu-id="08e41-1614">使用 <xref:System.Object.Equals%2A?displayProperty=nameWithType> 方法将元素与指定的值进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-1614">The elements are compared to the specified value using the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="08e41-1615">如果元素类型为 nonintrinsic （用户定义）类型，则使用该类型的 `Equals` 实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-1615">If the element type is a nonintrinsic (user-defined) type, the `Equals` implementation of that type is used.</span></span>  
  
 <span data-ttu-id="08e41-1616">此方法是一个 O （`n`）操作，其中 `n` 是 `count`的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1616">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1617">下面的代码示例演示 <xref:System.Array.LastIndexOf%2A> 方法的所有三个泛型重载。</span><span class="sxs-lookup"><span data-stu-id="08e41-1617">The following code example demonstrates all three generic overloads of the <xref:System.Array.LastIndexOf%2A> method.</span></span> <span data-ttu-id="08e41-1618">创建一个字符串数组，其中有一个条目出现在索引位置0和索引位置5。</span><span class="sxs-lookup"><span data-stu-id="08e41-1618">An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</span></span> <span data-ttu-id="08e41-1619"><xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> 方法重载从末尾搜索整个数组，并查找字符串的第二个匹配项。</span><span class="sxs-lookup"><span data-stu-id="08e41-1619">The <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> method overload searches the entire array from the end, and finds the second occurrence of the string.</span></span> <span data-ttu-id="08e41-1620"><xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> 方法重载用于从索引位置3开始向后搜索数组，并继续到数组的开头，并查找字符串的第一个匹配项。</span><span class="sxs-lookup"><span data-stu-id="08e41-1620">The <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> method overload is used to search the array backward beginning with index location 3 and continuing to the beginning of the array, and finds the first occurrence of the string.</span></span> <span data-ttu-id="08e41-1621">最后，<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> 方法重载用于搜索由四个条目组成的范围，从索引位置4开始并向后扩展（也就是说，它会搜索位于4、3、2和1位置的项）;此搜索将返回-1，因为该范围中没有搜索字符串的实例。</span><span class="sxs-lookup"><span data-stu-id="08e41-1621">Finally, the <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns -1 because there are no instances of the search string in that range.</span></span>  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1622"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1622"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-1623"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1623"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span>  
  
<span data-ttu-id="08e41-1624">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1624">-or-</span></span> 
 <span data-ttu-id="08e41-1625"><paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-1625"><paramref name="count" /> is less than zero.</span></span>  
  
<span data-ttu-id="08e41-1626">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1626">-or-</span></span> 
 <span data-ttu-id="08e41-1627"><paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="array" /> 中指定有效部分。</span><span class="sxs-lookup"><span data-stu-id="08e41-1627"><paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</span></span></exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-1628">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-1628">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Array.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Array.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="08e41-1629">获取 <see cref="T:System.Array" /> 的所有维度中的元素总数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1629">Gets the total number of elements in all the dimensions of the <see cref="T:System.Array" />.</span></span></summary>
        <value><span data-ttu-id="08e41-1630"><see cref="T:System.Array" /> 的所有维度中的元素总数；如果数组中无元素，则为零。</span><span class="sxs-lookup"><span data-stu-id="08e41-1630">The total number of elements in all the dimensions of the <see cref="T:System.Array" />; zero if there are no elements in the array.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1631">检索此属性的值的运算复杂度为 O(1)。</span><span class="sxs-lookup"><span data-stu-id="08e41-1631">Retrieving the value of this property is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1632">下面的示例使用 <xref:System.Array.Length%2A> 属性来获取数组中的元素总数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1632">The following example uses the <xref:System.Array.Length%2A> property to get the total number of elements in an array.</span></span> <span data-ttu-id="08e41-1633">它还使用 <xref:System.Array.GetUpperBound%2A> 方法来确定多维数组的每个维度中的元素数目。</span><span class="sxs-lookup"><span data-stu-id="08e41-1633">It also uses the <xref:System.Array.GetUpperBound%2A> method to determine the number of elements in each dimension of a multidimensional array.</span></span>  
  
 [!code-csharp[System.Array.Length#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.length/cs/length1.cs#1)]
 [!code-vb[System.Array.Length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.length/vb/length1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="08e41-1634">数组是多维数组并且包含多个 <see cref="F:System.Int32.MaxValue" /> 元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1634">The array is multidimensional and contains more than <see cref="F:System.Int32.MaxValue" /> elements.</span></span></exception>
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="LongLength">
      <MemberSignature Language="C#" Value="public long LongLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LongLength" />
      <MemberSignature Language="DocId" Value="P:System.Array.LongLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LongLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LongLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LongLength : int64" Usage="System.Array.LongLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="08e41-1635">获取一个 64 位整数，该整数表示 <see cref="T:System.Array" /> 的所有维数中元素的总数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1635">Gets a 64-bit integer that represents the total number of elements in all the dimensions of the <see cref="T:System.Array" />.</span></span></summary>
        <value><span data-ttu-id="08e41-1636">一个 64 位整数，表示 <see cref="T:System.Array" /> 的所有维数中元素的总数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1636">A 64-bit integer that represents the total number of elements in all the dimensions of the <see cref="T:System.Array" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1637">检索此属性的值的运算复杂度为 O(1)。</span><span class="sxs-lookup"><span data-stu-id="08e41-1637">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Array.Length" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Array.Rank" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rank As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Rank { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Rank : int" Usage="System.Array.Rank" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="08e41-1638">获取 <see cref="T:System.Array" /> 的秩（维数）。</span><span class="sxs-lookup"><span data-stu-id="08e41-1638">Gets the rank (number of dimensions) of the <see cref="T:System.Array" />.</span></span> <span data-ttu-id="08e41-1639">例如，一维数组返回 1，二维数组返回 2，依次类推。</span><span class="sxs-lookup"><span data-stu-id="08e41-1639">For example, a one-dimensional array returns 1, a two-dimensional array returns 2, and so on.</span></span></summary>
        <value><span data-ttu-id="08e41-1640"><see cref="T:System.Array" /> 的秩（维数）。</span><span class="sxs-lookup"><span data-stu-id="08e41-1640">The rank (number of dimensions) of the <see cref="T:System.Array" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1641">例如，Visual Basic 代码</span><span class="sxs-lookup"><span data-stu-id="08e41-1641">For example, the Visual Basic code</span></span>  
  
```vb  
Dim TDArray(0,0,0) As Integer  
```  
  
 <span data-ttu-id="08e41-1642">和C#代码</span><span class="sxs-lookup"><span data-stu-id="08e41-1642">and the C# code</span></span>  
  
```csharp  
int[,,] TDArray = new int[1,1,1];  
```  
  
 <span data-ttu-id="08e41-1643">创建具有一个值为3的 <xref:System.Array.Rank%2A> 属性的三个维度的数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-1643">create an array of three dimensions with a <xref:System.Array.Rank%2A> property whose value is 3.</span></span>  
  
 <span data-ttu-id="08e41-1644">交错数组（数组的数组）为一维数组;其 <xref:System.Array.Rank%2A> 属性的值为1。</span><span class="sxs-lookup"><span data-stu-id="08e41-1644">A jagged array (an array of arrays) is a one-dimensional array; the value of its <xref:System.Array.Rank%2A> property is 1.</span></span>  
  
 <span data-ttu-id="08e41-1645">检索此属性的值的运算复杂度为 O(1)。</span><span class="sxs-lookup"><span data-stu-id="08e41-1645">Retrieving the value of this property is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1646">下面的示例初始化一维数组、二维数组和交错数组，并检索每个数组的 <xref:System.Array.Rank%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="08e41-1646">The following example initializes a one-dimensional array, a two-dimensional array, and a jagged array, and retrieves the <xref:System.Array.Rank%2A> property of each.</span></span>  
  
 [!code-csharp[System.Array.Rank#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.rank/cs/rank1.cs#1)]
 [!code-vb[System.Array.Rank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.rank/vb/rank1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[] array, int newSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Resize&lt;T&gt;(!!T[]&amp; array, int32 newSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Resize``1(``0[]@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Resize(Of T) (ByRef array As T(), newSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Resize(cli::array &lt;T&gt; ^ % array, int newSize);" />
      <MemberSignature Language="F#" Value="static member Resize : T[] * int -&gt; unit" Usage="System.Array.Resize (array, newSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="newSize" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-1647">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-1647">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-1648">要调整大小的一维数组，该数组从零开始；如果为 <see langword="null" />，则新建具有指定大小的数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-1648">The one-dimensional, zero-based array to resize, or <see langword="null" /> to create a new array with the specified size.</span></span></param>
        <param name="newSize"><span data-ttu-id="08e41-1649">新数组的大小。</span><span class="sxs-lookup"><span data-stu-id="08e41-1649">The size of the new array.</span></span></param>
        <summary><span data-ttu-id="08e41-1650">将一维数组的元素数更改为指定的新大小。</span><span class="sxs-lookup"><span data-stu-id="08e41-1650">Changes the number of elements of a one-dimensional array to the specified new size.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1651">此方法分配一个具有指定大小的新数组，将元素从旧数组复制到新数组，然后将旧数组替换为新数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-1651">This method allocates a new array with the specified size, copies elements from the old array to the new one, and then replaces the old array with the new one.</span></span> <span data-ttu-id="08e41-1652">`array` 必须为一维数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-1652">`array` must be a one-dimensional array.</span></span>  
  
 <span data-ttu-id="08e41-1653">如果 `null``array`，则此方法将创建具有指定大小的新数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-1653">If `array` is `null`, this method creates a new array with the specified size.</span></span>  
  
 <span data-ttu-id="08e41-1654">如果 `newSize` 大于旧数组的 <xref:System.Array.Length%2A>，则分配一个新数组，并将所有元素从旧数组复制到新数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-1654">If `newSize` is greater than the <xref:System.Array.Length%2A> of the old array, a new array is allocated and all the elements are copied from the old array to the new one.</span></span>  <span data-ttu-id="08e41-1655">如果 `newSize` 小于旧数组的 <xref:System.Array.Length%2A>，则将分配新的数组，并将元素从旧数组复制到新数组，直到填充新数组;旧数组中元素的其余部分将被忽略。</span><span class="sxs-lookup"><span data-stu-id="08e41-1655">If `newSize` is less than the <xref:System.Array.Length%2A> of the old array, a new array is allocated and elements are copied from the old array to the new one until the new one is filled; the rest of the elements in the old array are ignored.</span></span>  <span data-ttu-id="08e41-1656">如果 `newSize` 等于旧数组的 <xref:System.Array.Length%2A>，则此方法不执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="08e41-1656">If `newSize` is equal to the <xref:System.Array.Length%2A> of the old array, this method does nothing.</span></span>  
  
 <span data-ttu-id="08e41-1657">此方法是一个 O （`n`）操作，其中 `n` 是 `newSize`的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1657">This method is an O(`n`) operation, where `n` is `newSize`.</span></span>  
  
 <span data-ttu-id="08e41-1658"><xref:System.Array.Resize%2A> 方法仅调整一维数组的大小。</span><span class="sxs-lookup"><span data-stu-id="08e41-1658">The <xref:System.Array.Resize%2A> method resizes a one-dimensional array only.</span></span> <span data-ttu-id="08e41-1659"><xref:System.Array> 类不包含用于调整多维数组大小的方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1659">The <xref:System.Array> class does not include a method for resizing multi-dimensional arrays.</span></span> <span data-ttu-id="08e41-1660">为此，你必须提供自己的代码或在第三方库中调用专用方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1660">To do this, you must either provide your own code or call a special-purpose method in a third-party library.</span></span> <span data-ttu-id="08e41-1661">下面的代码演示了一种可能的实现，该方法用于调整*n*维数组的大小。</span><span class="sxs-lookup"><span data-stu-id="08e41-1661">The following code illustrates one possible implementation for a method that resizes an array of *n* dimensions.</span></span>  
  
 [!code-csharp[System.Array.Resize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/resizexd.cs#2)]
 [!code-vb[System.Array.Resize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/resizexd.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1662">下面的示例演示调整大小如何影响数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-1662">The following example shows how resizing affects the array.</span></span>  
  
 [!code-cpp[System.Array.Resize#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Resize/CPP/System.Array.Resize.cpp#1)]
 [!code-csharp[System.Array.Resize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/arrayresize.cs#1)]
 [!code-vb[System.Array.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/arrayresize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-1663"><paramref name="newSize" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-1663"><paramref name="newSize" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="08e41-1664">反转一维 <see cref="T:System.Array" /> 或部分 <see cref="T:System.Array" /> 中元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1664">Reverses the order of the elements in a one-dimensional <see cref="T:System.Array" /> or in a portion of the <see cref="T:System.Array" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="08e41-1665">要反转的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1665">The one-dimensional <see cref="T:System.Array" /> to reverse.</span></span></param>
        <summary><span data-ttu-id="08e41-1666">反转整个一维 <see cref="T:System.Array" /> 中元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1666">Reverses the sequence of the elements in the entire one-dimensional <see cref="T:System.Array" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1667">调用此方法后，`myArray[i]`中的元素（其中 `i` 是数组中的任何索引），则移动到 `myArray[j]`，其中 `j` 等于 `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`。</span><span class="sxs-lookup"><span data-stu-id="08e41-1667">After a call to this method, the element at `myArray[i]`, where `i` is any index in the array, moves to `myArray[j]`, where `j` equals `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.</span></span>  
  
 <span data-ttu-id="08e41-1668">此方法是一个 O （`n`）操作，其中 `n` 是 `array`的 <xref:System.Array.Length%2A>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1668">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
 <span data-ttu-id="08e41-1669">如下面的示例所示，可以使用 <xref:System.Array.Reverse%2A> 方法来反转交错数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-1669">As the following example shows, the <xref:System.Array.Reverse%2A> method can be used to reverse a jagged array.</span></span> <span data-ttu-id="08e41-1670">它将使用当前区域性的日历中当前年份的每个月的一个元素来初始化交错数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-1670">It initializes a jagged array with one element for each month of the current year in the current culture's calendar.</span></span> <span data-ttu-id="08e41-1671">每个元素都包含一个数组，该数组包含的元素数量与该月份的天数相同。</span><span class="sxs-lookup"><span data-stu-id="08e41-1671">Each element contains an array with as many elements as that month has days.</span></span> <span data-ttu-id="08e41-1672">该示例显示数组的内容，调用 <xref:System.Array.Reverse%2A> 方法，然后显示反向数组的内容。</span><span class="sxs-lookup"><span data-stu-id="08e41-1672">The example displays the contents of the array, calls the <xref:System.Array.Reverse%2A> method, and then displays the contents of the reversed array.</span></span>  
  
 [!code-csharp[System.Array.Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.reverse/cs/reversejagged.cs#1)]
 [!code-vb[System.Array.Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.reverse/vb/reversejagged.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1673">下面的代码示例演示如何对 <xref:System.Array>中的值进行反向排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1673">The following code example shows how to reverse the sort of the values in an <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1674"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1674"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="08e41-1675"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1675"><paramref name="array" /> is multidimensional.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="08e41-1676">要反转的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1676">The one-dimensional <see cref="T:System.Array" /> to reverse.</span></span></param>
        <param name="index"><span data-ttu-id="08e41-1677">要反转的部分的起始索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1677">The starting index of the section to reverse.</span></span></param>
        <param name="length"><span data-ttu-id="08e41-1678">要反转的部分中的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1678">The number of elements in the section to reverse.</span></span></param>
        <summary><span data-ttu-id="08e41-1679">反转一维 <see cref="T:System.Array" /> 中元素子集的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1679">Reverses the sequence of a subset of the elements in the one-dimensional <see cref="T:System.Array" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1680">调用此方法后，`myArray[i]`中的元素（其中 `i` 是数组中的任何索引），则移动到 `myArray[j]`，其中 `j` 等于 `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`。</span><span class="sxs-lookup"><span data-stu-id="08e41-1680">After a call to this method, the element at `myArray[i]`, where `i` is any index in the array, moves to `myArray[j]`, where `j` equals `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.</span></span>  
  
 <span data-ttu-id="08e41-1681"><xref:System.Array.Reverse%2A> 方法可用于反转交错数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-1681">The <xref:System.Array.Reverse%2A> method can be used to reverse a jagged array.</span></span>  
  
 <span data-ttu-id="08e41-1682">此方法是一个 O （`n`）操作，其中 `n` 是 `length`的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1682">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1683">下面的代码示例演示如何对 <xref:System.Array>中的一系列元素中的值进行反向排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1683">The following code example shows how to reverse the sort of the values in a range of elements in an <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1684"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1684"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="08e41-1685"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1685"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-1686"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="08e41-1686"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
<span data-ttu-id="08e41-1687">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1687">-or-</span></span> 
 <span data-ttu-id="08e41-1688"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-1688"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-1689"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1689"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-1690"><paramref name="array" /> 中的元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-1690">The type of the elements in <paramref name="array" />.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-1691">要反转的元素的一维数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-1691">The one-dimensional array of elements to reverse.</span></span></param>
        <summary><span data-ttu-id="08e41-1692">反转一维泛型数组中元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1692">Reverses the sequence of the elements in the one-dimensional generic array.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1693"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1693"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="08e41-1694"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1694"><paramref name="array" /> is multidimensional.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-1695"><paramref name="array" /> 中的元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-1695">The type of the elements in <paramref name="array" />.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-1696">要反转的元素的一维数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-1696">The one-dimensional array of elements to reverse.</span></span></param>
        <param name="index"><span data-ttu-id="08e41-1697">要反转的部分的起始索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1697">The starting index of the section to reverse.</span></span></param>
        <param name="length"><span data-ttu-id="08e41-1698">要反转的部分中的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1698">The number of elements in the section to reverse.</span></span></param>
        <summary><span data-ttu-id="08e41-1699">反转一维泛型数组中元素子集的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1699">Reverses the sequence of a subset of the elements in the one-dimensional generic array.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1700"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1700"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="08e41-1701"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1701"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-1702"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="08e41-1702"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
<span data-ttu-id="08e41-1703">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1703">-or-</span></span> 
 <span data-ttu-id="08e41-1704"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-1704"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-1705"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1705"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="08e41-1706">将当前 <see cref="T:System.Array" /> 中的指定元素设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1706">Sets the specified element in the current <see cref="T:System.Array" /> to the specified value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="08e41-1707">指定元素的新值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1707">The new value for the specified element.</span></span></param>
        <param name="index"><span data-ttu-id="08e41-1708">一个 32 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的位置。</span><span class="sxs-lookup"><span data-stu-id="08e41-1708">A 32-bit integer that represents the position of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <summary><span data-ttu-id="08e41-1709">将某值设置给一维 <see cref="T:System.Array" /> 中指定位置的元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1709">Sets a value to the element at the specified position in the one-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="08e41-1710">索引指定为 32 位整数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1710">The index is specified as a 32-bit integer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1711"><xref:System.Array.GetLowerBound%2A> 和 <xref:System.Array.GetUpperBound%2A> 方法可确定 `index` 的值是否超出界限。</span><span class="sxs-lookup"><span data-stu-id="08e41-1711">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether the value of `index` is out of bounds.</span></span>  
  
 <span data-ttu-id="08e41-1712">有关转换的详细信息，请参阅 <xref:System.Convert>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1712">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="08e41-1713">此方法为 O （1）操作。</span><span class="sxs-lookup"><span data-stu-id="08e41-1713">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-1714">如果 <xref:System.Array.SetValue%2A> 用于将 `null` 分配到值类型数组的元素，则该元素的所有字段都将初始化为零。</span><span class="sxs-lookup"><span data-stu-id="08e41-1714">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="08e41-1715">元素的值不是空引用，并且无法通过搜索空引用来找到。</span><span class="sxs-lookup"><span data-stu-id="08e41-1715">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1716">下面的代码示例演示如何在一维或多维数组中设置和获取特定值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1716">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-1717">当前 <see cref="T:System.Array" /> 不是正好具有一个维度。</span><span class="sxs-lookup"><span data-stu-id="08e41-1717">The current <see cref="T:System.Array" /> does not have exactly one dimension.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="08e41-1718"><paramref name="value" /> 不能转换为当前 <see cref="T:System.Array" />的元素类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-1718"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="08e41-1719"><paramref name="index" /> 超出了当前 <see cref="T:System.Array" /> 的有效索引的范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1719"><paramref name="index" /> is outside the range of valid indexes for the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="08e41-1720">指定元素的新值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1720">The new value for the specified element.</span></span></param>
        <param name="indices"><span data-ttu-id="08e41-1721">32 位整数的一维数组，它表示用于指定要设置的元素的位置的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1721">A one-dimensional array of 32-bit integers that represent the indexes specifying the position of the element to set.</span></span></param>
        <summary><span data-ttu-id="08e41-1722">将某值设置给多维 <see cref="T:System.Array" /> 中指定位置的元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1722">Sets a value to the element at the specified position in the multidimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="08e41-1723">索引指定为一个 32 位整数数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-1723">The indexes are specified as an array of 32-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1724">`indices` 中的元素数必须等于 <xref:System.Array>中的维数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1724">The number of elements in `indices` must equal the number of dimensions in the <xref:System.Array>.</span></span> <span data-ttu-id="08e41-1725">`indices` 数组中的所有元素都必须共同指定所需元素在多维 <xref:System.Array>中的位置。</span><span class="sxs-lookup"><span data-stu-id="08e41-1725">All elements in the `indices` array must collectively specify the position of the desired element in the multidimensional <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="08e41-1726"><xref:System.Array.GetLowerBound%2A> 和 <xref:System.Array.GetUpperBound%2A> 方法可以确定 `indices` 数组中是否有任何值超出界限。</span><span class="sxs-lookup"><span data-stu-id="08e41-1726">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the values in the `indices` array is out of bounds.</span></span>  
  
 <span data-ttu-id="08e41-1727">有关转换的详细信息，请参阅 <xref:System.Convert>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1727">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="08e41-1728">此方法为 O （1）操作。</span><span class="sxs-lookup"><span data-stu-id="08e41-1728">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-1729">如果 <xref:System.Array.SetValue%2A> 用于将 `null` 分配到值类型数组的元素，则该元素的所有字段都将初始化为零。</span><span class="sxs-lookup"><span data-stu-id="08e41-1729">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="08e41-1730">元素的值不是空引用，并且无法通过搜索空引用来找到。</span><span class="sxs-lookup"><span data-stu-id="08e41-1730">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1731">下面的代码示例演示如何在一维或多维数组中设置和获取特定值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1731">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1732"><paramref name="indices" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1732"><paramref name="indices" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-1733">当前 <see cref="T:System.Array" /> 中的维数不等于 <paramref name="indices" /> 中的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1733">The number of dimensions in the current <see cref="T:System.Array" /> is not equal to the number of elements in <paramref name="indices" />.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="08e41-1734"><paramref name="value" /> 不能转换为当前 <see cref="T:System.Array" /> 的元素类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-1734"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="08e41-1735"><paramref name="indices" /> 中的任何元素都超出了当前 <see cref="T:System.Array" /> 的相应维度的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1735">Any element in <paramref name="indices" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="08e41-1736">指定元素的新值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1736">The new value for the specified element.</span></span></param>
        <param name="index"><span data-ttu-id="08e41-1737">一个 64 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的位置。</span><span class="sxs-lookup"><span data-stu-id="08e41-1737">A 64-bit integer that represents the position of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <summary><span data-ttu-id="08e41-1738">将值设置为一维 <see cref="T:System.Array" /> 中指定位置的元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1738">Sets a value to the element at the specified position in the one-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="08e41-1739">索引指定为 64 位整数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1739">The index is specified as a 64-bit integer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1740"><xref:System.Array.GetLowerBound%2A> 和 <xref:System.Array.GetUpperBound%2A> 方法可确定 `index` 的值是否超出界限。</span><span class="sxs-lookup"><span data-stu-id="08e41-1740">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether the value of `index` is out of bounds.</span></span>  
  
 <span data-ttu-id="08e41-1741">有关转换的详细信息，请参阅 <xref:System.Convert>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1741">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="08e41-1742">此方法为 O （1）操作。</span><span class="sxs-lookup"><span data-stu-id="08e41-1742">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-1743">如果 <xref:System.Array.SetValue%2A> 用于将 `null` 分配到值类型数组的元素，则该元素的所有字段都将初始化为零。</span><span class="sxs-lookup"><span data-stu-id="08e41-1743">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="08e41-1744">元素的值不是空引用，并且无法通过搜索空引用来找到。</span><span class="sxs-lookup"><span data-stu-id="08e41-1744">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1745">下面的代码示例演示如何在一维或多维数组中设置和获取特定值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1745">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-1746">当前 <see cref="T:System.Array" /> 不是正好具有一个维度。</span><span class="sxs-lookup"><span data-stu-id="08e41-1746">The current <see cref="T:System.Array" /> does not have exactly one dimension.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="08e41-1747"><paramref name="value" /> 不能转换为当前 <see cref="T:System.Array" />的元素类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-1747"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-1748"><paramref name="index" /> 超出了当前 <see cref="T:System.Array" /> 的有效索引的范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1748"><paramref name="index" /> is outside the range of valid indexes for the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Long())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indices" Type="System.Int64[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="08e41-1749">指定元素的新值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1749">The new value for the specified element.</span></span></param>
        <param name="indices"><span data-ttu-id="08e41-1750">64 位整数的一维数组，它表示用于指定要设置元素的位置索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1750">A one-dimensional array of 64-bit integers that represent the indexes specifying the position of the element to set.</span></span></param>
        <summary><span data-ttu-id="08e41-1751">将值设置为多维 <see cref="T:System.Array" /> 中指定位置的元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1751">Sets a value to the element at the specified position in the multidimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="08e41-1752">索引指定为一个 64 位整数数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-1752">The indexes are specified as an array of 64-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1753">`indices` 中的元素数必须等于 <xref:System.Array>中的维数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1753">The number of elements in `indices` must equal the number of dimensions in the <xref:System.Array>.</span></span> <span data-ttu-id="08e41-1754">`indices` 数组中的所有元素都必须共同指定所需元素在多维 <xref:System.Array>中的位置。</span><span class="sxs-lookup"><span data-stu-id="08e41-1754">All elements in the `indices` array must collectively specify the position of the desired element in the multidimensional <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="08e41-1755"><xref:System.Array.GetLowerBound%2A> 和 <xref:System.Array.GetUpperBound%2A> 方法可以确定 `indices` 数组中是否有任何值超出界限。</span><span class="sxs-lookup"><span data-stu-id="08e41-1755">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the values in the `indices` array is out of bounds.</span></span>  
  
 <span data-ttu-id="08e41-1756">有关转换的详细信息，请参阅 <xref:System.Convert>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1756">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="08e41-1757">此方法为 O （1）操作。</span><span class="sxs-lookup"><span data-stu-id="08e41-1757">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-1758">如果 <xref:System.Array.SetValue%2A> 用于将 `null` 分配到值类型数组的元素，则该元素的所有字段都将初始化为零。</span><span class="sxs-lookup"><span data-stu-id="08e41-1758">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="08e41-1759">元素的值不是空引用，并且无法通过搜索空引用来找到。</span><span class="sxs-lookup"><span data-stu-id="08e41-1759">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1760">下面的代码示例演示如何在一维或多维数组中设置和获取特定值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1760">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1761"><paramref name="indices" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1761"><paramref name="indices" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-1762">当前 <see cref="T:System.Array" /> 中的维数不等于 <paramref name="indices" /> 中的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1762">The number of dimensions in the current <see cref="T:System.Array" /> is not equal to the number of elements in <paramref name="indices" />.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="08e41-1763"><paramref name="value" /> 不能转换为当前 <see cref="T:System.Array" /> 的元素类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-1763"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-1764"><paramref name="indices" /> 中的任何元素都超出了当前 <see cref="T:System.Array" /> 的相应维度的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1764">Any element in <paramref name="indices" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="08e41-1765">指定元素的新值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1765">The new value for the specified element.</span></span></param>
        <param name="index1"><span data-ttu-id="08e41-1766">一个 32 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第一维索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1766">A 32-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <param name="index2"><span data-ttu-id="08e41-1767">一个 32 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第二维索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1767">A 32-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <summary><span data-ttu-id="08e41-1768">将某值设置给二维 <see cref="T:System.Array" /> 中指定位置的元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1768">Sets a value to the element at the specified position in the two-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="08e41-1769">索引指定为 32 位整数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1769">The indexes are specified as 32-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1770"><xref:System.Array.GetLowerBound%2A> 和 <xref:System.Array.GetUpperBound%2A> 方法可以确定任何索引是否超出界限。</span><span class="sxs-lookup"><span data-stu-id="08e41-1770">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="08e41-1771">有关转换的详细信息，请参阅 <xref:System.Convert>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1771">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="08e41-1772">此方法为 O （1）操作。</span><span class="sxs-lookup"><span data-stu-id="08e41-1772">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-1773">如果 <xref:System.Array.SetValue%2A> 用于将 `null` 分配到值类型数组的元素，则该元素的所有字段都将初始化为零。</span><span class="sxs-lookup"><span data-stu-id="08e41-1773">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="08e41-1774">元素的值不是空引用，并且无法通过搜索空引用来找到。</span><span class="sxs-lookup"><span data-stu-id="08e41-1774">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1775">下面的代码示例演示如何在一维或多维数组中设置和获取特定值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1775">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-1776">当前 <see cref="T:System.Array" /> 不是正好具有两个维度。</span><span class="sxs-lookup"><span data-stu-id="08e41-1776">The current <see cref="T:System.Array" /> does not have exactly two dimensions.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="08e41-1777"><paramref name="value" /> 不能转换为当前 <see cref="T:System.Array" /> 的元素类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-1777"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="08e41-1778"><paramref name="index1" /> 或 <paramref name="index2" /> 超出了当前 <see cref="T:System.Array" /> 的相应维度的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1778">Either <paramref name="index1" /> or <paramref name="index2" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index1" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="08e41-1779">指定元素的新值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1779">The new value for the specified element.</span></span></param>
        <param name="index1"><span data-ttu-id="08e41-1780">一个 64 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第一维索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1780">A 64-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <param name="index2"><span data-ttu-id="08e41-1781">一个 64 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第二维索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1781">A 64-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <summary><span data-ttu-id="08e41-1782">将某值设置给二维 <see cref="T:System.Array" /> 中指定位置的元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1782">Sets a value to the element at the specified position in the two-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="08e41-1783">索引指定为 64 位整数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1783">The indexes are specified as 64-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1784"><xref:System.Array.GetLowerBound%2A> 和 <xref:System.Array.GetUpperBound%2A> 方法可以确定任何索引是否超出界限。</span><span class="sxs-lookup"><span data-stu-id="08e41-1784">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="08e41-1785">有关转换的详细信息，请参阅 <xref:System.Convert>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1785">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="08e41-1786">此方法为 O （1）操作。</span><span class="sxs-lookup"><span data-stu-id="08e41-1786">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-1787">如果 <xref:System.Array.SetValue%2A> 用于将 `null` 分配到值类型数组的元素，则该元素的所有字段都将初始化为零。</span><span class="sxs-lookup"><span data-stu-id="08e41-1787">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="08e41-1788">元素的值不是空引用，并且无法通过搜索空引用来找到。</span><span class="sxs-lookup"><span data-stu-id="08e41-1788">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1789">下面的代码示例演示如何在一维或多维数组中设置和获取特定值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1789">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-1790">当前 <see cref="T:System.Array" /> 不是正好具有两个维度。</span><span class="sxs-lookup"><span data-stu-id="08e41-1790">The current <see cref="T:System.Array" /> does not have exactly two dimensions.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="08e41-1791"><paramref name="value" /> 不能转换为当前 <see cref="T:System.Array" /> 的元素类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-1791"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-1792"><paramref name="index1" /> 或 <paramref name="index2" /> 超出了当前 <see cref="T:System.Array" /> 的相应维度的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1792">Either <paramref name="index1" /> or <paramref name="index2" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer, index3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index3" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="08e41-1793">指定元素的新值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1793">The new value for the specified element.</span></span></param>
        <param name="index1"><span data-ttu-id="08e41-1794">一个 32 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第一维索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1794">A 32-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <param name="index2"><span data-ttu-id="08e41-1795">一个 32 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第二维索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1795">A 32-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <param name="index3"><span data-ttu-id="08e41-1796">一个 32 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第三维索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1796">A 32-bit integer that represents the third-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <summary><span data-ttu-id="08e41-1797">将值设置为三维 <see cref="T:System.Array" /> 中指定位置的元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1797">Sets a value to the element at the specified position in the three-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="08e41-1798">索引指定为 32 位整数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1798">The indexes are specified as 32-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1799"><xref:System.Array.GetLowerBound%2A> 和 <xref:System.Array.GetUpperBound%2A> 方法可以确定任何索引是否超出界限。</span><span class="sxs-lookup"><span data-stu-id="08e41-1799">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="08e41-1800">有关转换的详细信息，请参阅 <xref:System.Convert>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1800">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="08e41-1801">此方法为 O （1）操作。</span><span class="sxs-lookup"><span data-stu-id="08e41-1801">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-1802">如果 <xref:System.Array.SetValue%2A> 用于将 `null` 分配到值类型数组的元素，则该元素的所有字段都将初始化为零。</span><span class="sxs-lookup"><span data-stu-id="08e41-1802">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="08e41-1803">元素的值不是空引用，并且无法通过搜索空引用来找到。</span><span class="sxs-lookup"><span data-stu-id="08e41-1803">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1804">下面的代码示例演示如何在一维或多维数组中设置和获取特定值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1804">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-1805">当前 <see cref="T:System.Array" /> 不是正好具有三个维度。</span><span class="sxs-lookup"><span data-stu-id="08e41-1805">The current <see cref="T:System.Array" /> does not have exactly three dimensions.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="08e41-1806"><paramref name="value" /> 不能转换为当前 <see cref="T:System.Array" /> 的元素类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-1806"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="08e41-1807"><paramref name="index1" /> 或 <paramref name="index2" /> 或 <paramref name="index3" /> 超出了当前 <see cref="T:System.Array" /> 的相应维度的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1807"><paramref name="index1" /> or <paramref name="index2" /> or <paramref name="index3" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long, index3 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index1" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index3" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="08e41-1808">指定元素的新值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1808">The new value for the specified element.</span></span></param>
        <param name="index1"><span data-ttu-id="08e41-1809">一个 64 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第一维索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1809">A 64-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <param name="index2"><span data-ttu-id="08e41-1810">一个 64 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第二维索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1810">A 64-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <param name="index3"><span data-ttu-id="08e41-1811">一个 64 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第三维索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1811">A 64-bit integer that represents the third-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <summary><span data-ttu-id="08e41-1812">将某值设置给三维 <see cref="T:System.Array" /> 中指定位置的元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-1812">Sets a value to the element at the specified position in the three-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="08e41-1813">索引指定为 64 位整数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1813">The indexes are specified as 64-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1814"><xref:System.Array.GetLowerBound%2A> 和 <xref:System.Array.GetUpperBound%2A> 方法可以确定任何索引是否超出界限。</span><span class="sxs-lookup"><span data-stu-id="08e41-1814">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="08e41-1815">有关转换的详细信息，请参阅 <xref:System.Convert>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1815">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="08e41-1816">此方法为 O （1）操作。</span><span class="sxs-lookup"><span data-stu-id="08e41-1816">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-1817">如果 <xref:System.Array.SetValue%2A> 用于将 `null` 分配到值类型数组的元素，则该元素的所有字段都将初始化为零。</span><span class="sxs-lookup"><span data-stu-id="08e41-1817">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="08e41-1818">元素的值不是空引用，并且无法通过搜索空引用来找到。</span><span class="sxs-lookup"><span data-stu-id="08e41-1818">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1819">下面的代码示例演示如何在一维或多维数组中设置和获取特定值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1819">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-1820">当前 <see cref="T:System.Array" /> 不是正好具有三个维度。</span><span class="sxs-lookup"><span data-stu-id="08e41-1820">The current <see cref="T:System.Array" /> does not have exactly three dimensions.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="08e41-1821"><paramref name="value" /> 不能转换为当前 <see cref="T:System.Array" /> 的元素类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-1821"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-1822"><paramref name="index1" /> 或 <paramref name="index2" /> 或 <paramref name="index3" /> 超出了当前 <see cref="T:System.Array" /> 的相应维度的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1822"><paramref name="index1" /> or <paramref name="index2" /> or <paramref name="index3" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="08e41-1823">对一维数组中的元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1823">Sorts the elements in a one-dimensional array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : Array -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="08e41-1824">要排序的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1824">The one-dimensional <see cref="T:System.Array" /> to sort.</span></span></param>
        <summary><span data-ttu-id="08e41-1825">使用 <see cref="T:System.Array" /> 中每个元素的 <see cref="T:System.IComparable" /> 实现，对整个一维 <see cref="T:System.Array" /> 中的元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1825">Sorts the elements in an entire one-dimensional <see cref="T:System.Array" /> using the <see cref="T:System.IComparable" /> implementation of each element of the <see cref="T:System.Array" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1826">`array` 的每个元素都必须实现 <xref:System.IComparable> 接口，才能与 `array`中的其他每个元素进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-1826">Each element of `array` must implement the <xref:System.IComparable> interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="08e41-1827">如果排序未成功完成，则结果是不确定的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1827">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="08e41-1828">此方法使用反省 sort （introsort）算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="08e41-1828">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="08e41-1829">如果分区大小小于或等于16个元素，则它将使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1829">If the partition size is less than or equal to 16 elements, it uses an [insertion sort](https://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-1830">如果分区数超过 2 \* Log<sup>N</sup>，其中*N*为输入数组的范围，则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1830">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where *N* is the range of the input array, it uses a [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-1831">否则，它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1831">Otherwise, it uses a [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="08e41-1832">此实现执行不稳定的排序;也就是说，如果两个元素相等，则可能不会保留它们的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1832">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="08e41-1833">相反，稳定排序会保留相等元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1833">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="08e41-1834">对于使用 Heapsort 和快速排序算法排序的数组，在最坏的情况下，此方法为 O （`n` log `n`）操作，其中 `n` 是 `array`的 <xref:System.Array.Length%2A>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1834">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1835">下面的代码示例演示如何使用默认比较器和反向排序顺序的自定义比较器对 <xref:System.Array> 中的值进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1835">The following code example shows how to sort the values in an <xref:System.Array> using the default comparer and a custom comparer that reverses the sort order.</span></span> <span data-ttu-id="08e41-1836">请注意，结果根据当前 <xref:System.Globalization.CultureInfo>的不同而异。</span><span class="sxs-lookup"><span data-stu-id="08e41-1836">Note that the result might vary depending on the current <xref:System.Globalization.CultureInfo>.</span></span>  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1837"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1837"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="08e41-1838"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1838"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="08e41-1839"><paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-1839">One or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-1840">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-1840">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys"><span data-ttu-id="08e41-1841">一维 <see cref="T:System.Array" />，其中包含要排序的关键字。</span><span class="sxs-lookup"><span data-stu-id="08e41-1841">The one-dimensional <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="08e41-1842">一维 <see cref="T:System.Array" />，其中包含与 <paramref name="keys" /><see cref="T:System.Array" /> 中每个关键字对应的项。</span><span class="sxs-lookup"><span data-stu-id="08e41-1842">The one-dimensional <see cref="T:System.Array" /> that contains the items that correspond to each of the keys in the <paramref name="keys" /><see cref="T:System.Array" />.</span></span>  
  
<span data-ttu-id="08e41-1843">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1843">-or-</span></span> 
 <span data-ttu-id="08e41-1844">如果为 <see langword="null" />，则只对 <paramref name="keys" /><see cref="T:System.Array" /> 进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1844"><see langword="null" /> to sort only the <paramref name="keys" /><see cref="T:System.Array" />.</span></span></param>
        <summary><span data-ttu-id="08e41-1845">基于第一个 <see cref="T:System.Array" /> 中的关键字，使用每个关键字的 <see cref="T:System.IComparable" /> 实现，对两个一维 <see cref="T:System.Array" /> 对象（一个包含关键字，另一个包含对应的项）进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1845">Sorts a pair of one-dimensional <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the <see cref="T:System.IComparable" /> implementation of each key.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1846">`keys`<xref:System.Array> 中的每个键在 `items`<xref:System.Array>中都有相应的项。</span><span class="sxs-lookup"><span data-stu-id="08e41-1846">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="08e41-1847">当在排序过程中重定位某个键时，`items`<xref:System.Array> 中的相应项同样会重新定位。</span><span class="sxs-lookup"><span data-stu-id="08e41-1847">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="08e41-1848">因此，`items`<xref:System.Array> 根据 `keys`<xref:System.Array>中对应键的排列方式进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1848">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="08e41-1849">`keys`<xref:System.Array> 中的每个键都必须实现 <xref:System.IComparable> 接口，才能与其他每个键进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-1849">Each key in the `keys`<xref:System.Array> must implement the <xref:System.IComparable> interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="08e41-1850">您可以排序是否有多个项大于键，但不会对没有对应键的项进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1850">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="08e41-1851">如果键比项多，则无法排序;这样做会引发 <xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1851">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="08e41-1852">如果排序未成功完成，则结果是不确定的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1852">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="08e41-1853">此方法使用反省 sort （introsort）算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="08e41-1853">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="08e41-1854">如果分区大小小于或等于16个元素，则它将使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1854">If the partition size is less than or equal to 16 elements, it uses an [insertion sort](https://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-1855">如果分区数超过 2 \* Log<sup>N</sup>，其中*N*为输入数组的范围，则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1855">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where *N* is the range of the input array, it uses a [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-1856">否则，它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1856">Otherwise, it uses a [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="08e41-1857">此实现执行不稳定的排序;也就是说，如果两个元素相等，则可能不会保留它们的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1857">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="08e41-1858">相反，稳定排序会保留相等元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1858">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="08e41-1859">对于使用 Heapsort 和快速排序算法排序的数组，在最坏的情况下，此方法为 O （`n` log `n`）操作，其中 `n` 是 `keys`的 <xref:System.Array.Length%2A>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1859">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `keys`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1860">下面的示例演示如何对两个关联的数组（其中第一个数组包含键，第二个数组包含值）进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1860">The following example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</span></span> <span data-ttu-id="08e41-1861">排序是使用默认比较器和反向排序顺序的自定义比较器来完成的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1861">Sorts are done using the default comparer and a custom comparer that reverses the sort order.</span></span> <span data-ttu-id="08e41-1862">请注意，结果根据当前 <xref:System.Globalization.CultureInfo>的不同而异。</span><span class="sxs-lookup"><span data-stu-id="08e41-1862">Note that the result might vary depending on the current <xref:System.Globalization.CultureInfo>.</span></span>  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1863"><paramref name="keys" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1863"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="08e41-1864"><paramref name="keys" /><see cref="T:System.Array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1864">The <paramref name="keys" /><see cref="T:System.Array" /> is multidimensional.</span></span>  
  
<span data-ttu-id="08e41-1865">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1865">-or-</span></span> 
<span data-ttu-id="08e41-1866"><paramref name="items" /><see cref="T:System.Array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1866">The <paramref name="items" /><see cref="T:System.Array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-1867"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="08e41-1867"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="08e41-1868"><paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-1868">One or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.IDictionary" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-1869">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-1869">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="08e41-1870">要排序的一维数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-1870">The one-dimensional array to sort.</span></span></param>
        <param name="comparer"><span data-ttu-id="08e41-1871">比较元素时要使用的实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-1871">The implementation to use when comparing elements.</span></span>  
  
<span data-ttu-id="08e41-1872">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1872">-or-</span></span> 
 <span data-ttu-id="08e41-1873">若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-1873"><see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="08e41-1874">使用指定的 <see cref="T:System.Collections.IComparer" />，对一维 <see cref="T:System.Array" /> 中的元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1874">Sorts the elements in a one-dimensional <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.IComparer" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1875">如果 `null``comparer`，则 `array` 的每个元素都必须实现 <xref:System.IComparable> 接口，才能与 `array`中的其他每个元素进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-1875">If `comparer` is `null`, each element of `array` must implement the <xref:System.IComparable> interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="08e41-1876">如果排序未成功完成，则结果是不确定的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1876">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="08e41-1877">此方法使用反省 sort （introsort）算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="08e41-1877">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="08e41-1878">如果分区大小小于或等于16个元素，则它将使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1878">If the partition size is less than or equal to 16 elements, it uses an [insertion sort](https://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-1879">如果分区数超过 2 \* Log<sup>N</sup>，其中*N*为输入数组的范围，则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1879">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-1880">否则，它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1880">Otherwise, it uses a [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="08e41-1881">此实现执行不稳定的排序;也就是说，如果两个元素相等，则可能不会保留它们的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1881">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="08e41-1882">相反，稳定排序会保留相等元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1882">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="08e41-1883">对于使用 Heapsort 和快速排序算法排序的数组，在最坏的情况下，此方法为 O （`n` log `n`）操作，其中 `n` 是 `array`的 <xref:System.Array.Length%2A>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1883">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
 <span data-ttu-id="08e41-1884">.NET Framework 包括下表中列出的预定义 <xref:System.Collections.IComparer> 实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-1884">The .NET Framework includes predefined <xref:System.Collections.IComparer> implementations listed in the following table.</span></span>  
  
|<span data-ttu-id="08e41-1885">实现</span><span class="sxs-lookup"><span data-stu-id="08e41-1885">Implementation</span></span>|<span data-ttu-id="08e41-1886">说明</span><span class="sxs-lookup"><span data-stu-id="08e41-1886">Description</span></span>|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|<span data-ttu-id="08e41-1887">比较两个对象，但执行字符串的不区分大小写的比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-1887">Compares any two objects, but performs a case-insensitive comparison of strings.</span></span>|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|<span data-ttu-id="08e41-1888">使用当前区域性的排序约定来比较任意两个对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-1888">Compares any two objects by using the sorting conventions of the current culture.</span></span>|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|<span data-ttu-id="08e41-1889">使用固定区域性的排序约定来比较两个对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-1889">Compares any two objects by using the sorting conventions of the invariant culture.</span></span>|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|<span data-ttu-id="08e41-1890">使用类型的默认排序顺序比较 `T` 类型的两个对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-1890">Compares two objects of type `T` by using the type's default sort order.</span></span>|  
  
 <span data-ttu-id="08e41-1891">您还可以通过向 `comparer` 参数提供自己 <xref:System.Collections.IComparer> 实现的实例，支持自定义比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-1891">You can also support custom comparisons by providing an instance of your own <xref:System.Collections.IComparer> implementation to the `comparer` parameter.</span></span> <span data-ttu-id="08e41-1892">该示例通过定义一个 `ReverseComparer` 类来实现此目的，此类反转类型实例的默认排序顺序并执行不区分大小写的字符串比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-1892">The example does this by defining a `ReverseComparer` class that reverses the default sort order for instances of a type and performs case-insensitive string comparison.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1893">下面的示例使用默认比较器对字符串数组中的值进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1893">The following example sorts the values in a string array by using the default comparer.</span></span> <span data-ttu-id="08e41-1894">它还定义了一个名为 `ReverseComparer` 的自定义 <xref:System.Collections.IComparer> 实现，它在执行不区分大小写的字符串比较时反转对象的默认排序顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1894">It also defines a custom <xref:System.Collections.IComparer> implementation named `ReverseComparer` that reverses an object's default sort order while performing a case-insensitive string comparison.</span></span> <span data-ttu-id="08e41-1895">请注意，输出可能因当前区域性而异。</span><span class="sxs-lookup"><span data-stu-id="08e41-1895">Note that the output might vary depending on the current culture.</span></span>  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1896"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1896"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="08e41-1897"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1897"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="08e41-1898"><paramref name="comparer" /> 为 <see langword="null" />，且 <paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-1898"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-1899"><paramref name="comparer" /> 的实现导致排序时出现错误。</span><span class="sxs-lookup"><span data-stu-id="08e41-1899">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="08e41-1900">例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</span><span class="sxs-lookup"><span data-stu-id="08e41-1900">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="08e41-1901">.NET Framework 4 及更早版本仅使用快速排序算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1901">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="08e41-1902">快速排序在某些情况下标识无效的比较器，在这种情况下，排序操作引发 <see cref="T:System.IndexOutOfRangeException" /> 异常，并向调用方引发 <see cref="T:System.ArgumentException" /> 异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-1902">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="08e41-1903">从 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]开始，先前引发 <see cref="T:System.ArgumentException" /> 的排序操作可能不会引发异常，因为插入排序和 heapsort 算法未检测到无效的比较器。</span><span class="sxs-lookup"><span data-stu-id="08e41-1903">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="08e41-1904">大多数情况下，这适用于具有小于或等于16个元素的数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-1904">For the most part, this applies to arrays with less than or equal to 16 elements.</span></span></para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-1905">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-1905">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys"><span data-ttu-id="08e41-1906">一维 <see cref="T:System.Array" />，其中包含要排序的关键字。</span><span class="sxs-lookup"><span data-stu-id="08e41-1906">The one-dimensional <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="08e41-1907">一维 <see cref="T:System.Array" />，其中包含与 <paramref name="keys" /><see cref="T:System.Array" /> 中每个关键字对应的项。</span><span class="sxs-lookup"><span data-stu-id="08e41-1907">The one-dimensional <see cref="T:System.Array" /> that contains the items that correspond to each of the keys in the <paramref name="keys" /><see cref="T:System.Array" />.</span></span>  
  
<span data-ttu-id="08e41-1908">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1908">-or-</span></span> 
 <span data-ttu-id="08e41-1909">如果为 <see langword="null" />，则只对 <paramref name="keys" /><see cref="T:System.Array" /> 进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1909"><see langword="null" /> to sort only the <paramref name="keys" /><see cref="T:System.Array" />.</span></span></param>
        <param name="comparer"><span data-ttu-id="08e41-1910">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-1910">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.</span></span>  
  
<span data-ttu-id="08e41-1911">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1911">-or-</span></span> 
 <span data-ttu-id="08e41-1912">若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-1912"><see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="08e41-1913">基于第一个 <see cref="T:System.Array" /> 中的关键字，使用指定的 <see cref="T:System.Collections.IComparer" />，对两个一维 <see cref="T:System.Array" /> 对象（一个包含关键字，另一个包含对应的项）进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1913">Sorts a pair of one-dimensional <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.IComparer" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1914">`keys`<xref:System.Array> 中的每个键在 `items`<xref:System.Array>中都有相应的项。</span><span class="sxs-lookup"><span data-stu-id="08e41-1914">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="08e41-1915">当在排序过程中重定位某个键时，`items`<xref:System.Array> 中的相应项同样会重新定位。</span><span class="sxs-lookup"><span data-stu-id="08e41-1915">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="08e41-1916">因此，`items`<xref:System.Array> 根据 `keys`<xref:System.Array>中对应键的排列方式进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1916">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="08e41-1917">如果 `null``comparer`，则 `keys`<xref:System.Array> 中的每个键都必须实现 <xref:System.IComparable> 接口，才能与其他每个键进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-1917">If `comparer` is `null`, each key in the `keys`<xref:System.Array> must implement the <xref:System.IComparable> interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="08e41-1918">您可以排序是否有多个项大于键，但不会对没有对应键的项进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1918">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="08e41-1919">如果键比项多，则无法排序;这样做会引发 <xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1919">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="08e41-1920">如果排序未成功完成，则结果是不确定的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1920">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="08e41-1921">.NET Framework 包括下表中列出的预定义 <xref:System.Collections.IComparer> 实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-1921">The .NET Framework includes predefined <xref:System.Collections.IComparer> implementations listed in the following table.</span></span>  
  
|<span data-ttu-id="08e41-1922">实现</span><span class="sxs-lookup"><span data-stu-id="08e41-1922">Implementation</span></span>|<span data-ttu-id="08e41-1923">说明</span><span class="sxs-lookup"><span data-stu-id="08e41-1923">Description</span></span>|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|<span data-ttu-id="08e41-1924">比较两个对象，但执行字符串的不区分大小写的比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-1924">Compares any two objects, but performs a case-insensitive comparison of strings.</span></span>|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|<span data-ttu-id="08e41-1925">使用当前区域性的排序约定来比较任意两个对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-1925">Compares any two objects by using the sorting conventions of the current culture.</span></span>|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|<span data-ttu-id="08e41-1926">使用固定区域性的排序约定来比较两个对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-1926">Compares any two objects by using the sorting conventions of the invariant culture.</span></span>|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|<span data-ttu-id="08e41-1927">使用类型的默认排序顺序比较 `T` 类型的两个对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-1927">Compares two objects of type `T` by using the type's default sort order.</span></span>|  
  
 <span data-ttu-id="08e41-1928">您还可以通过向 `comparer` 参数提供自己 <xref:System.Collections.IComparer> 实现的实例，支持自定义比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-1928">You can also support custom comparisons by providing an instance of your own <xref:System.Collections.IComparer> implementation to the `comparer` parameter.</span></span> <span data-ttu-id="08e41-1929">该示例通过定义一个 <xref:System.Collections.IComparer> 实现实现此目的，该实现将反转默认排序顺序并执行不区分大小写的字符串比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-1929">The example does this by defining an <xref:System.Collections.IComparer> implementation that reverses the default sort order and performs case-insensitive string comparison.</span></span>  
  
 <span data-ttu-id="08e41-1930">此方法使用反省 sort （introsort）算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="08e41-1930">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="08e41-1931">如果分区大小小于或等于16个元素，则它将使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1931">If the partition size is less than or equal to 16 elements, it uses an [insertion sort](https://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-1932">如果分区数超过 2 \* Log<sup>N</sup>，其中*N*为输入数组的范围，则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1932">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-1933">否则，它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1933">Otherwise, it uses a [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="08e41-1934">此实现执行不稳定的排序;也就是说，如果两个元素相等，则可能不会保留它们的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1934">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="08e41-1935">相反，稳定排序会保留相等元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1935">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="08e41-1936">对于使用 Heapsort 和快速排序算法排序的数组，在最坏的情况下，此方法为 O （`n` log `n`）操作，其中 `n` 是 `keys`的 <xref:System.Array.Length%2A>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1936">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `keys`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1937">下面的示例演示如何对两个关联的数组（其中第一个数组包含键，第二个数组包含值）进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1937">The following example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</span></span> <span data-ttu-id="08e41-1938">排序是使用默认比较器和反向排序顺序的自定义比较器来完成的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1938">Sorts are done using the default comparer and a custom comparer that reverses the sort order.</span></span> <span data-ttu-id="08e41-1939">请注意，结果根据当前 <xref:System.Globalization.CultureInfo>的不同而异。</span><span class="sxs-lookup"><span data-stu-id="08e41-1939">Note that the result might vary depending on the current <xref:System.Globalization.CultureInfo>.</span></span>  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1940"><paramref name="keys" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1940"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="08e41-1941"><paramref name="keys" /><see cref="T:System.Array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1941">The <paramref name="keys" /><see cref="T:System.Array" /> is multidimensional.</span></span>  
  
<span data-ttu-id="08e41-1942">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1942">-or-</span></span> 
<span data-ttu-id="08e41-1943"><paramref name="items" /><see cref="T:System.Array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1943">The <paramref name="items" /><see cref="T:System.Array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-1944"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="08e41-1944"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span>  
  
<span data-ttu-id="08e41-1945">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1945">-or-</span></span> 
<span data-ttu-id="08e41-1946"><paramref name="comparer" /> 的实现导致排序时出现错误。</span><span class="sxs-lookup"><span data-stu-id="08e41-1946">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="08e41-1947">例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</span><span class="sxs-lookup"><span data-stu-id="08e41-1947">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="08e41-1948"><paramref name="comparer" /> 为 <see langword="null" />，且 <paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-1948"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="08e41-1949">.NET Framework 4 及更早版本仅使用快速排序算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1949">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="08e41-1950">快速排序在某些情况下标识无效的比较器，在这种情况下，排序操作引发 <see cref="T:System.IndexOutOfRangeException" /> 异常，并向调用方引发 <see cref="T:System.ArgumentException" /> 异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-1950">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="08e41-1951">从 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]开始，先前引发 <see cref="T:System.ArgumentException" /> 的排序操作可能不会引发异常，因为插入排序和 heapsort 算法未检测到无效的比较器。</span><span class="sxs-lookup"><span data-stu-id="08e41-1951">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="08e41-1952">大多数情况下，这适用于具有小于或等于16个元素的数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-1952">For the most part, this applies to arrays with less than or equal to 16 elements.</span></span></para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-1953">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-1953">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="08e41-1954">要排序的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1954">The one-dimensional <see cref="T:System.Array" /> to sort.</span></span></param>
        <param name="index"><span data-ttu-id="08e41-1955">排序范围的起始索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1955">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="08e41-1956">排序范围内的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1956">The number of elements in the range to sort.</span></span></param>
        <summary><span data-ttu-id="08e41-1957">使用 <see cref="T:System.Array" /> 中每个元素的 <see cref="T:System.IComparable" /> 实现，对一维 <see cref="T:System.Array" /> 中的部分元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1957">Sorts the elements in a range of elements in a one-dimensional <see cref="T:System.Array" /> using the <see cref="T:System.IComparable" /> implementation of each element of the <see cref="T:System.Array" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1958">`array` 中指定范围内的元素中的每个元素都必须实现 <xref:System.IComparable> 接口，才能与 `array`中的每个其他元素进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-1958">Each element within the specified range of elements in `array` must implement the <xref:System.IComparable> interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="08e41-1959">如果排序未成功完成，则结果是不确定的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1959">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="08e41-1960">此方法使用反省 sort （introsort）算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="08e41-1960">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="08e41-1961">如果分区大小小于或等于16个元素，则它将使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1961">If the partition size is less than or equal to 16 elements, it uses an [insertion sort](https://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-1962">如果分区数超过 2 \* Log<sup>N</sup>，其中*N*为输入数组的范围，则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1962">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-1963">否则，它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1963">Otherwise, it uses a [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="08e41-1964">此实现执行不稳定的排序;也就是说，如果两个元素相等，则可能不会保留它们的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1964">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="08e41-1965">相反，稳定排序会保留相等元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1965">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="08e41-1966">对于使用 Heapsort 和快速排序算法排序的数组，在最坏的情况下，此方法为 O （`n` log `n`）操作，其中 `n` 是 `length`的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1966">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1967">下面的代码示例演示如何使用默认比较器和反向排序顺序的自定义比较器对 <xref:System.Array> 中的值进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1967">The following code example shows how to sort the values in an <xref:System.Array> using the default comparer and a custom comparer that reverses the sort order.</span></span> <span data-ttu-id="08e41-1968">请注意，结果根据当前 <xref:System.Globalization.CultureInfo>的不同而异。</span><span class="sxs-lookup"><span data-stu-id="08e41-1968">Note that the result might vary depending on the current <xref:System.Globalization.CultureInfo>.</span></span>  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-1969"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-1969"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="08e41-1970"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1970"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-1971"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="08e41-1971"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
<span data-ttu-id="08e41-1972">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1972">-or-</span></span> 
 <span data-ttu-id="08e41-1973"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-1973"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-1974"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-1974"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="08e41-1975"><paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-1975">One or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-1976">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-1976">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys"><span data-ttu-id="08e41-1977">一维 <see cref="T:System.Array" />，其中包含要排序的关键字。</span><span class="sxs-lookup"><span data-stu-id="08e41-1977">The one-dimensional <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="08e41-1978">一维 <see cref="T:System.Array" />，其中包含与 <paramref name="keys" /><see cref="T:System.Array" /> 中每个关键字对应的项。</span><span class="sxs-lookup"><span data-stu-id="08e41-1978">The one-dimensional <see cref="T:System.Array" /> that contains the items that correspond to each of the keys in the <paramref name="keys" /><see cref="T:System.Array" />.</span></span>  
  
<span data-ttu-id="08e41-1979">或</span><span class="sxs-lookup"><span data-stu-id="08e41-1979">-or-</span></span> 
 <span data-ttu-id="08e41-1980">如果为 <see langword="null" />，则只对 <paramref name="keys" /><see cref="T:System.Array" /> 进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1980"><see langword="null" /> to sort only the <paramref name="keys" /><see cref="T:System.Array" />.</span></span></param>
        <param name="index"><span data-ttu-id="08e41-1981">排序范围的起始索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-1981">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="08e41-1982">排序范围内的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-1982">The number of elements in the range to sort.</span></span></param>
        <summary><span data-ttu-id="08e41-1983">基于第一个 <see cref="T:System.Array" /> 中的关键字，使用每个关键字的 <see cref="T:System.IComparable" /> 实现，对两个一维 <see cref="T:System.Array" /> 对象（一个包含关键字，另一个包含对应的项）的部分元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1983">Sorts a range of elements in a pair of one-dimensional <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the <see cref="T:System.IComparable" /> implementation of each key.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-1984">`keys`<xref:System.Array> 中的每个键在 `items`<xref:System.Array>中都有相应的项。</span><span class="sxs-lookup"><span data-stu-id="08e41-1984">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="08e41-1985">当在排序过程中重定位某个键时，`items`<xref:System.Array> 中的相应项同样会重新定位。</span><span class="sxs-lookup"><span data-stu-id="08e41-1985">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="08e41-1986">因此，`items`<xref:System.Array> 根据 `keys`<xref:System.Array>中对应键的排列方式进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1986">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="08e41-1987">`keys`<xref:System.Array> 中指定范围内的元素中的每个键都必须实现 <xref:System.IComparable> 接口，才能与其他每个键进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-1987">Each key within the specified range of elements in the `keys`<xref:System.Array> must implement the <xref:System.IComparable> interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="08e41-1988">您可以排序是否有多个项大于键，但不会对没有对应键的项进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1988">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="08e41-1989">如果键比项多，则无法排序;这样做会引发 <xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="08e41-1989">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="08e41-1990">如果排序未成功完成，则结果是不确定的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1990">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="08e41-1991">此方法使用反省 sort （introsort）算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="08e41-1991">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="08e41-1992">如果分区大小小于或等于16个元素，则它将使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1992">If the partition size is less than or equal to 16 elements, it uses an [insertion sort](https://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-1993">如果分区数超过 2 \* Log<sup>N</sup>，其中*N*为输入数组的范围，则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1993">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where *N* is the range of the input array, it uses a [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-1994">否则，它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-1994">Otherwise, it uses a [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="08e41-1995">此实现执行不稳定的排序;也就是说，如果两个元素相等，则可能不会保留它们的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1995">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="08e41-1996">相反，稳定排序会保留相等元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-1996">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="08e41-1997">对于使用 Heapsort 和快速排序算法排序的数组，在最坏的情况下，此方法为 O （`n` log `n`）操作，其中 `n` 是 `length`的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1997">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-1998">下面的代码示例演示如何对两个关联的数组进行排序，其中第一个数组包含键，第二个数组包含值。</span><span class="sxs-lookup"><span data-stu-id="08e41-1998">The following code example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</span></span> <span data-ttu-id="08e41-1999">排序是使用默认比较器和反向排序顺序的自定义比较器来完成的。</span><span class="sxs-lookup"><span data-stu-id="08e41-1999">Sorts are done using the default comparer and a custom comparer that reverses the sort order.</span></span> <span data-ttu-id="08e41-2000">请注意，结果根据当前 <xref:System.Globalization.CultureInfo>的不同而异。</span><span class="sxs-lookup"><span data-stu-id="08e41-2000">Note that the result might vary depending on the current <xref:System.Globalization.CultureInfo>.</span></span>  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-2001"><paramref name="keys" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-2001"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="08e41-2002"><paramref name="keys" /><see cref="T:System.Array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="08e41-2002">The <paramref name="keys" /><see cref="T:System.Array" /> is multidimensional.</span></span>  
  
<span data-ttu-id="08e41-2003">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2003">-or-</span></span> 
<span data-ttu-id="08e41-2004"><paramref name="items" /><see cref="T:System.Array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="08e41-2004">The <paramref name="items" /><see cref="T:System.Array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-2005"><paramref name="index" /> 小于 <paramref name="keys" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="08e41-2005"><paramref name="index" /> is less than the lower bound of <paramref name="keys" />.</span></span>  
  
<span data-ttu-id="08e41-2006">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2006">-or-</span></span> 
 <span data-ttu-id="08e41-2007"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-2007"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-2008"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的长度大于 <paramref name="items" />的长度。</span><span class="sxs-lookup"><span data-stu-id="08e41-2008"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span>  
  
<span data-ttu-id="08e41-2009">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2009">-or-</span></span> 
 <span data-ttu-id="08e41-2010"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="keys" /><see cref="T:System.Array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-2010"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="keys" /><see cref="T:System.Array" />.</span></span>  
  
<span data-ttu-id="08e41-2011">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2011">-or-</span></span> 
 <span data-ttu-id="08e41-2012"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="items" /><see cref="T:System.Array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-2012"><paramref name="items" /> is not <see langword="null" />, and <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="items" /><see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="08e41-2013"><paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-2013">One or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-2014">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-2014">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="08e41-2015">要排序的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-2015">The one-dimensional <see cref="T:System.Array" /> to sort.</span></span></param>
        <param name="index"><span data-ttu-id="08e41-2016">排序范围的起始索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-2016">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="08e41-2017">排序范围内的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-2017">The number of elements in the range to sort.</span></span></param>
        <param name="comparer"><span data-ttu-id="08e41-2018">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-2018">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.</span></span>  
  
<span data-ttu-id="08e41-2019">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2019">-or-</span></span> 
 <span data-ttu-id="08e41-2020">若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-2020"><see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="08e41-2021">使用指定的 <see cref="T:System.Collections.IComparer" />，对一维 <see cref="T:System.Array" /> 中的部分元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2021">Sorts the elements in a range of elements in a one-dimensional <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.IComparer" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-2022">如果 `null``comparer`，则 `array` 中指定范围内的元素内的每个元素都必须实现 <xref:System.IComparable> 接口，才能与 `array`中的其他每个元素进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-2022">If `comparer` is `null`, each element within the specified range of elements in `array` must implement the <xref:System.IComparable> interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="08e41-2023">如果排序未成功完成，则结果是不确定的。</span><span class="sxs-lookup"><span data-stu-id="08e41-2023">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="08e41-2024">.NET Framework 包括下表中列出的预定义 <xref:System.Collections.IComparer> 实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-2024">The .NET Framework includes predefined <xref:System.Collections.IComparer> implementations listed in the following table.</span></span>  
  
|<span data-ttu-id="08e41-2025">实现</span><span class="sxs-lookup"><span data-stu-id="08e41-2025">Implementation</span></span>|<span data-ttu-id="08e41-2026">说明</span><span class="sxs-lookup"><span data-stu-id="08e41-2026">Description</span></span>|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|<span data-ttu-id="08e41-2027">比较两个对象，但执行字符串的不区分大小写的比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-2027">Compares any two objects, but performs a case-insensitive comparison of strings.</span></span>|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|<span data-ttu-id="08e41-2028">使用当前区域性的排序约定来比较任意两个对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-2028">Compares any two objects by using the sorting conventions of the current culture.</span></span>|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|<span data-ttu-id="08e41-2029">使用固定区域性的排序约定来比较两个对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-2029">Compares any two objects by using the sorting conventions of the invariant culture.</span></span>|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|<span data-ttu-id="08e41-2030">使用类型的默认排序顺序比较 `T` 类型的两个对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-2030">Compares two objects of type `T` by using the type's default sort order.</span></span>|  
  
 <span data-ttu-id="08e41-2031">您还可以通过向 `comparer` 参数提供自己 <xref:System.Collections.IComparer> 实现的实例，支持自定义比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-2031">You can also support custom comparisons by providing an instance of your own <xref:System.Collections.IComparer> implementation to the `comparer` parameter.</span></span> <span data-ttu-id="08e41-2032">该示例通过定义一个 `ReverseComparer` 类来实现此目的，此类反转类型实例的默认排序顺序并执行不区分大小写的字符串比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-2032">The example does this by defining a `ReverseComparer` class that reverses the default sort order for instances of a type and performs case-insensitive string comparison.</span></span>  
  
 <span data-ttu-id="08e41-2033">此方法使用反省 sort （introsort）算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="08e41-2033">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="08e41-2034">如果分区大小小于或等于16个元素，则它将使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2034">If the partition size is less than or equal to 16 elements, it uses an [insertion sort](https://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-2035">如果分区数超过 2 \* Log<sup>N</sup>，其中*N*为输入数组的范围，则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2035">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-2036">否则，它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2036">Otherwise, it uses a [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="08e41-2037">此实现执行不稳定的排序;也就是说，如果两个元素相等，则可能不会保留它们的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2037">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="08e41-2038">相反，稳定排序会保留相等元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2038">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="08e41-2039">对于使用 Heapsort 和快速排序算法排序的数组，在最坏的情况下，此方法为 O （`n` log `n`）操作，其中 `n` 是 `length`的。</span><span class="sxs-lookup"><span data-stu-id="08e41-2039">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-2040">下面的代码示例演示如何使用默认比较器和反向排序顺序的自定义比较器对 <xref:System.Array> 中的值进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2040">The following code example shows how to sort the values in an <xref:System.Array> using the default comparer and a custom comparer that reverses the sort order.</span></span> <span data-ttu-id="08e41-2041">请注意，结果根据当前 <xref:System.Globalization.CultureInfo>的不同而异。</span><span class="sxs-lookup"><span data-stu-id="08e41-2041">Note that the result might vary depending on the current <xref:System.Globalization.CultureInfo>.</span></span>  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-2042"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-2042"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="08e41-2043"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="08e41-2043"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-2044"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="08e41-2044"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
<span data-ttu-id="08e41-2045">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2045">-or-</span></span> 
 <span data-ttu-id="08e41-2046"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-2046"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-2047"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-2047"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span>  
  
<span data-ttu-id="08e41-2048">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2048">-or-</span></span> 
<span data-ttu-id="08e41-2049"><paramref name="comparer" /> 的实现导致排序时出现错误。</span><span class="sxs-lookup"><span data-stu-id="08e41-2049">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="08e41-2050">例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</span><span class="sxs-lookup"><span data-stu-id="08e41-2050">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="08e41-2051"><paramref name="comparer" /> 为 <see langword="null" />，且 <paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-2051"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="08e41-2052">.NET Framework 4 及更早版本仅使用快速排序算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2052">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="08e41-2053">快速排序在某些情况下标识无效的比较器，在这种情况下，排序操作引发 <see cref="T:System.IndexOutOfRangeException" /> 异常，并向调用方引发 <see cref="T:System.ArgumentException" /> 异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-2053">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="08e41-2054">从 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]开始，先前引发 <see cref="T:System.ArgumentException" /> 的排序操作可能不会引发异常，因为插入排序和 heapsort 算法未检测到无效的比较器。</span><span class="sxs-lookup"><span data-stu-id="08e41-2054">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="08e41-2055">大多数情况下，这适用于具有小于或等于16个元素的数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-2055">For the most part, this applies to arrays with less than or equal to 16 elements.</span></span></para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-2056">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-2056">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys"><span data-ttu-id="08e41-2057">一维 <see cref="T:System.Array" />，其中包含要排序的关键字。</span><span class="sxs-lookup"><span data-stu-id="08e41-2057">The one-dimensional <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="08e41-2058">一维 <see cref="T:System.Array" />，其中包含与 <paramref name="keys" /><see cref="T:System.Array" /> 中每个关键字对应的项。</span><span class="sxs-lookup"><span data-stu-id="08e41-2058">The one-dimensional <see cref="T:System.Array" /> that contains the items that correspond to each of the keys in the <paramref name="keys" /><see cref="T:System.Array" />.</span></span>  
  
<span data-ttu-id="08e41-2059">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2059">-or-</span></span> 
 <span data-ttu-id="08e41-2060">如果为 <see langword="null" />，则只对 <paramref name="keys" /><see cref="T:System.Array" /> 进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2060"><see langword="null" /> to sort only the <paramref name="keys" /><see cref="T:System.Array" />.</span></span></param>
        <param name="index"><span data-ttu-id="08e41-2061">排序范围的起始索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-2061">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="08e41-2062">排序范围内的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-2062">The number of elements in the range to sort.</span></span></param>
        <param name="comparer"><span data-ttu-id="08e41-2063">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-2063">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.</span></span>  
  
<span data-ttu-id="08e41-2064">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2064">-or-</span></span> 
 <span data-ttu-id="08e41-2065">若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-2065"><see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="08e41-2066">基于第一个 <see cref="T:System.Array" /> 中的关键字，使用指定的 <see cref="T:System.Collections.IComparer" />，对两个一维 <see cref="T:System.Array" /> 对象（一个包含关键字，另一个包含对应的项）的部分元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2066">Sorts a range of elements in a pair of one-dimensional <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.IComparer" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-2067">`keys`<xref:System.Array> 中的每个键在 `items`<xref:System.Array>中都有相应的项。</span><span class="sxs-lookup"><span data-stu-id="08e41-2067">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="08e41-2068">当在排序过程中重定位某个键时，`items`<xref:System.Array> 中的相应项同样会重新定位。</span><span class="sxs-lookup"><span data-stu-id="08e41-2068">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="08e41-2069">因此，`items`<xref:System.Array> 根据 `keys`<xref:System.Array>中对应键的排列方式进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2069">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="08e41-2070">如果 `null``comparer`，则 `keys`<xref:System.Array> 中指定范围内的元素中的每个键都必须实现 <xref:System.IComparable> 接口，才能与其他每个键进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-2070">If `comparer` is `null`, each key within the specified range of elements in the `keys`<xref:System.Array> must implement the <xref:System.IComparable> interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="08e41-2071">您可以排序是否有多个项大于键，但不会对没有对应键的项进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2071">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="08e41-2072">如果键比项多，则无法排序;这样做会引发 <xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="08e41-2072">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="08e41-2073">如果排序未成功完成，则结果是不确定的。</span><span class="sxs-lookup"><span data-stu-id="08e41-2073">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="08e41-2074">.NET Framework 包括下表中列出的预定义 <xref:System.Collections.IComparer> 实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-2074">The .NET Framework includes predefined <xref:System.Collections.IComparer> implementations listed in the following table.</span></span>  
  
|<span data-ttu-id="08e41-2075">实现</span><span class="sxs-lookup"><span data-stu-id="08e41-2075">Implementation</span></span>|<span data-ttu-id="08e41-2076">说明</span><span class="sxs-lookup"><span data-stu-id="08e41-2076">Description</span></span>|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|<span data-ttu-id="08e41-2077">比较两个对象，但执行字符串的不区分大小写的比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-2077">Compares any two objects, but performs a case-insensitive comparison of strings.</span></span>|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|<span data-ttu-id="08e41-2078">使用当前区域性的排序约定来比较任意两个对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-2078">Compares any two objects by using the sorting conventions of the current culture.</span></span>|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|<span data-ttu-id="08e41-2079">使用固定区域性的排序约定来比较两个对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-2079">Compares any two objects by using the sorting conventions of the invariant culture.</span></span>|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|<span data-ttu-id="08e41-2080">使用类型的默认排序顺序比较 `T` 类型的两个对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-2080">Compares two objects of type `T` by using the type's default sort order.</span></span>|  
  
 <span data-ttu-id="08e41-2081">您还可以通过向 `comparer` 参数提供自己 <xref:System.Collections.IComparer> 实现的实例，支持自定义比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-2081">You can also support custom comparisons by providing an instance of your own <xref:System.Collections.IComparer> implementation to the `comparer` parameter.</span></span> <span data-ttu-id="08e41-2082">该示例通过定义一个反向默认排序顺序并执行不区分大小写的字符串比较的自定义 <xref:System.Collections.IComparer> 实现来实现此目的。</span><span class="sxs-lookup"><span data-stu-id="08e41-2082">The example does this by defining a custom <xref:System.Collections.IComparer> implementation that reverses the default sort order and performs case-insensitive string comparison.</span></span>  
  
 <span data-ttu-id="08e41-2083">此方法使用反省 sort （introsort）算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="08e41-2083">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="08e41-2084">如果分区大小小于或等于16个元素，则它将使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2084">If the partition size is less than or equal to 16 elements, it uses an [insertion sort](https://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-2085">如果分区数超过 2 \* Log<sup>N</sup>，其中*N*为输入数组的范围，则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2085">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where *N* is the range of the input array, it uses a [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-2086">否则，它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2086">Otherwise, it uses a [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="08e41-2087">此实现执行不稳定的排序;也就是说，如果两个元素相等，则可能不会保留它们的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2087">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="08e41-2088">相反，稳定排序会保留相等元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2088">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="08e41-2089">对于使用 Heapsort 和快速排序算法排序的数组，在最坏的情况下，此方法为 O （`n` log `n`）操作，其中 `n` 是 `length`的。</span><span class="sxs-lookup"><span data-stu-id="08e41-2089">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-2090">下面的代码示例演示如何对两个关联的数组进行排序，其中第一个数组包含键，第二个数组包含值。</span><span class="sxs-lookup"><span data-stu-id="08e41-2090">The following code example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</span></span> <span data-ttu-id="08e41-2091">排序是使用默认比较器和反向排序顺序的自定义比较器来完成的。</span><span class="sxs-lookup"><span data-stu-id="08e41-2091">Sorts are done using the default comparer and a custom comparer that reverses the sort order.</span></span> <span data-ttu-id="08e41-2092">请注意，结果根据当前 <xref:System.Globalization.CultureInfo>的不同而异。</span><span class="sxs-lookup"><span data-stu-id="08e41-2092">Note that the result might vary depending on the current <xref:System.Globalization.CultureInfo>.</span></span>  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-2093"><paramref name="keys" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-2093"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="08e41-2094"><paramref name="keys" /><see cref="T:System.Array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="08e41-2094">The <paramref name="keys" /><see cref="T:System.Array" /> is multidimensional.</span></span>  
  
<span data-ttu-id="08e41-2095">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2095">-or-</span></span> 
<span data-ttu-id="08e41-2096"><paramref name="items" /><see cref="T:System.Array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="08e41-2096">The <paramref name="items" /><see cref="T:System.Array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-2097"><paramref name="index" /> 小于 <paramref name="keys" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="08e41-2097"><paramref name="index" /> is less than the lower bound of <paramref name="keys" />.</span></span>  
  
<span data-ttu-id="08e41-2098">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2098">-or-</span></span> 
 <span data-ttu-id="08e41-2099"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-2099"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-2100"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的下限与 <paramref name="items" /> 的下限不匹配。</span><span class="sxs-lookup"><span data-stu-id="08e41-2100"><paramref name="items" /> is not <see langword="null" />, and the lower bound of <paramref name="keys" /> does not match the lower bound of <paramref name="items" />.</span></span>  
  
<span data-ttu-id="08e41-2101">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2101">-or-</span></span> 
 <span data-ttu-id="08e41-2102"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="08e41-2102"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span>  
  
<span data-ttu-id="08e41-2103">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2103">-or-</span></span> 
 <span data-ttu-id="08e41-2104"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="keys" /><see cref="T:System.Array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-2104"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="keys" /><see cref="T:System.Array" />.</span></span>  
  
<span data-ttu-id="08e41-2105">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2105">-or-</span></span> 
 <span data-ttu-id="08e41-2106"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="items" /><see cref="T:System.Array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-2106"><paramref name="items" /> is not <see langword="null" />, and <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="items" /><see cref="T:System.Array" />.</span></span>  
  
<span data-ttu-id="08e41-2107">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2107">-or-</span></span> 
<span data-ttu-id="08e41-2108"><paramref name="comparer" /> 的实现导致排序时出现错误。</span><span class="sxs-lookup"><span data-stu-id="08e41-2108">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="08e41-2109">例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</span><span class="sxs-lookup"><span data-stu-id="08e41-2109">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="08e41-2110"><paramref name="comparer" /> 为 <see langword="null" />，且 <paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-2110"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="08e41-2111">.NET Framework 4 及更早版本仅使用快速排序算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2111">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="08e41-2112">快速排序在某些情况下标识无效的比较器，在这种情况下，排序操作引发 <see cref="T:System.IndexOutOfRangeException" /> 异常，并向调用方引发 <see cref="T:System.ArgumentException" /> 异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-2112">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="08e41-2113">从 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]开始，先前引发 <see cref="T:System.ArgumentException" /> 的排序操作可能不会引发异常，因为插入排序和 heapsort 算法未检测到无效的比较器。</span><span class="sxs-lookup"><span data-stu-id="08e41-2113">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="08e41-2114">大多数情况下，这适用于具有小于或等于16个元素的数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-2114">For the most part, this applies to arrays with less than or equal to 16 elements.</span></span></para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-2115">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-2115">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-2116">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-2116">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-2117">要排序的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-2117">The one-dimensional, zero-based <see cref="T:System.Array" /> to sort.</span></span></param>
        <summary><span data-ttu-id="08e41-2118">使用 <see cref="T:System.Array" /> 中每个元素的 <see cref="T:System.IComparable`1" /> 泛型接口实现，对整个 <see cref="T:System.Array" /> 中的元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2118">Sorts the elements in an entire <see cref="T:System.Array" /> using the <see cref="T:System.IComparable`1" /> generic interface implementation of each element of the <see cref="T:System.Array" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-2119">`array` 的每个元素必须实现 <xref:System.IComparable%601> 泛型接口，才能与 `array`中的每个其他元素进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-2119">Each element of `array` must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="08e41-2120">如果排序未成功完成，则结果是不确定的。</span><span class="sxs-lookup"><span data-stu-id="08e41-2120">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="08e41-2121">此方法使用反省 sort （introsort）算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="08e41-2121">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="08e41-2122">如果分区大小小于或等于16个元素，则它将使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2122">If the partition size is less than or equal to 16 elements, it uses an [insertion sort](https://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-2123">如果分区数超过 2 \* Log<sup>N</sup>，其中*N*为输入数组的范围，则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2123">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-2124">否则，它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2124">Otherwise, it uses a [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="08e41-2125">此实现执行不稳定的排序;也就是说，如果两个元素相等，则可能不会保留它们的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2125">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="08e41-2126">相反，稳定排序会保留相等元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2126">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="08e41-2127">对于使用 Heapsort 和快速排序算法排序的数组，在最坏的情况下，此方法为 O （`n` log `n`）操作，其中 `n` 是 `array`的 <xref:System.Array.Length%2A>。</span><span class="sxs-lookup"><span data-stu-id="08e41-2127">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-2128">下面的代码示例演示 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> 泛型方法重载和 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> 泛型方法重载。</span><span class="sxs-lookup"><span data-stu-id="08e41-2128">The following code example demonstrates the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> generic method overload and the <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> generic method overload.</span></span> <span data-ttu-id="08e41-2129">创建一个字符串数组，无特定顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2129">An array of strings is created, in no particular order.</span></span>  
  
 <span data-ttu-id="08e41-2130">显示、排序并再次显示数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-2130">The array is displayed, sorted, and displayed again.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-2131">对 <xref:System.Array.Sort%2A> 和 <xref:System.Array.BinarySearch%2A> 泛型方法的调用与对其非泛型方法的调用没有任何区别，因为 Visual Basic、 C#和C++从第一个参数的类型推断泛型类型参数的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-2131">The calls to the <xref:System.Array.Sort%2A> and <xref:System.Array.BinarySearch%2A> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</span></span> <span data-ttu-id="08e41-2132">如果使用[Ildasm （IL 拆装器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)检查 Microsoft 中间语言（MSIL），可以看到正在调用泛型方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2132">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 <span data-ttu-id="08e41-2133">然后，使用 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> 泛型方法重载搜索两个字符串，一个字符串不在数组中，另一个是。</span><span class="sxs-lookup"><span data-stu-id="08e41-2133">The <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> generic method overload is then used to search for two strings, one that is not in the array and one that is.</span></span> <span data-ttu-id="08e41-2134"><xref:System.Array.BinarySearch%2A> 方法的数组和返回值将传递给 `ShowWhere` 泛型方法，该方法显示索引值（如果找到该字符串），否则在搜索字符串位于数组中的元素之间将会出现该方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2134">The array and the return value of the <xref:System.Array.BinarySearch%2A> method are passed to the `ShowWhere` generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</span></span> <span data-ttu-id="08e41-2135">如果字符串不是 n 数组，则索引为负; 因此 `ShowWhere` 方法采用按位求补（ C#和中的 ~ 运算符C++，在 Visual Basic 中 `Xor`-1）来获取列表中大于搜索字符串的第一个元素的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-2135">The index is negative if the string is not n the array, so the `ShowWhere` method takes the bitwise complement (the ~ operator in C# and Visual C++, `Xor` -1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</span></span>  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-2136"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-2136"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="08e41-2137"><paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable`1" /> 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-2137">One or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-2138">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-2138">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-2139">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-2139">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-2140">要排序的从零开始的一维 <see cref="T:System.Array" /></span><span class="sxs-lookup"><span data-stu-id="08e41-2140">The one-dimensional, zero-base <see cref="T:System.Array" /> to sort</span></span></param>
        <param name="comparer"><span data-ttu-id="08e41-2141">比较元素时使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口实现；如果为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable`1" /> 泛型接口实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-2141">The <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface implementation to use when comparing elements, or <see langword="null" /> to use the <see cref="T:System.IComparable`1" /> generic interface implementation of each element.</span></span></param>
        <summary><span data-ttu-id="08e41-2142">使用指定的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口，对 <see cref="T:System.Array" /> 中的元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2142">Sorts the elements in an <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-2143">如果 `null``comparer`，则 `array` 的每个元素都必须实现 <xref:System.IComparable%601> 泛型接口，才能与 `array`中的其他每个元素进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-2143">If `comparer` is `null`, each element of `array` must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="08e41-2144">如果排序未成功完成，则结果是不确定的。</span><span class="sxs-lookup"><span data-stu-id="08e41-2144">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="08e41-2145">此方法使用反省 sort （introsort）算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="08e41-2145">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="08e41-2146">如果分区大小小于或等于16个元素，则它将使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2146">If the partition size is less than or equal to 16 elements, it uses an [insertion sort](https://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-2147">如果分区数超过 2 \* Log<sup>N</sup>，其中*N*为输入数组的范围，则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2147">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-2148">否则，它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2148">Otherwise, it uses a [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="08e41-2149">此实现执行不稳定的排序;也就是说，如果两个元素相等，则可能不会保留它们的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2149">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="08e41-2150">相反，稳定排序会保留相等元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2150">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="08e41-2151">对于使用 Heapsort 和快速排序算法排序的数组，在最坏的情况下，此方法为 O （`n` log `n`）操作，其中 `n` 是 `array`的 <xref:System.Array.Length%2A>。</span><span class="sxs-lookup"><span data-stu-id="08e41-2151">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-2152">下面的代码示例演示 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 泛型方法重载和 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 泛型方法重载。</span><span class="sxs-lookup"><span data-stu-id="08e41-2152">The following code example demonstrates the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload and the <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload.</span></span>  
  
 <span data-ttu-id="08e41-2153">此代码示例定义了一个名为 `ReverseCompare`的字符串的替代比较器，该比较器实现了 `IComparer<string>` （`IComparer(Of String)` Visual Basic C++，`IComparer<String^>` Visual）泛型接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-2153">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="08e41-2154">比较器调用 <xref:System.String.CompareTo%28System.String%29> 方法，并反转比较数的顺序，以便字符串排序为高到低而不是低到高。</span><span class="sxs-lookup"><span data-stu-id="08e41-2154">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="08e41-2155">显示、排序并再次显示数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-2155">The array is displayed, sorted, and displayed again.</span></span> <span data-ttu-id="08e41-2156">必须对数组进行排序才能使用 <xref:System.Array.BinarySearch%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2156">Arrays must be sorted in order to use the <xref:System.Array.BinarySearch%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-2157">对 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 和 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 泛型方法的调用与对其非泛型方法的调用没有任何区别，因为 Visual Basic、 C#和C++从第一个参数的类型推断泛型类型参数的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-2157">The calls to the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> and <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</span></span> <span data-ttu-id="08e41-2158">如果使用[Ildasm （IL 拆装器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)检查 Microsoft 中间语言（MSIL），可以看到正在调用泛型方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2158">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 <span data-ttu-id="08e41-2159">然后，使用 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 泛型方法重载搜索两个字符串，一个字符串不在数组中，另一个是。</span><span class="sxs-lookup"><span data-stu-id="08e41-2159">The <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload is then used to search for two strings, one that is not in the array and one that is.</span></span> <span data-ttu-id="08e41-2160"><xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 方法的数组和返回值将传递给 `ShowWhere` 泛型方法，该方法显示索引值（如果找到该字符串），否则在搜索字符串位于数组中的元素之间将会出现该方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2160">The array and the return value of the <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> method are passed to the `ShowWhere` generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</span></span> <span data-ttu-id="08e41-2161">如果字符串不是 n 数组，则索引为负; 因此 `ShowWhere` 方法采用按位求补（ C#和中的 ~ 运算符C++，在 Visual Basic 中 `Xor`-1）来获取列表中大于搜索字符串的第一个元素的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-2161">The index is negative if the string is not n the array, so the `ShowWhere` method takes the bitwise complement (the ~ operator in C# and Visual C++, `Xor` -1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</span></span>  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-2162"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-2162"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="08e41-2163"><paramref name="comparer" /> 为 <see langword="null" />，且 <paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable`1" /> 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-2163"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-2164"><paramref name="comparer" /> 的实现导致排序时出现错误。</span><span class="sxs-lookup"><span data-stu-id="08e41-2164">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="08e41-2165">例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</span><span class="sxs-lookup"><span data-stu-id="08e41-2165">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="08e41-2166">.NET Framework 4 及更早版本仅使用快速排序算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2166">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="08e41-2167">快速排序在某些情况下标识无效的比较器，在这种情况下，排序操作引发 <see cref="T:System.IndexOutOfRangeException" /> 异常，并向调用方引发 <see cref="T:System.ArgumentException" /> 异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-2167">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="08e41-2168">从 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]开始，先前引发 <see cref="T:System.ArgumentException" /> 的排序操作可能不会引发异常，因为插入排序和 heapsort 算法未检测到无效的比较器。</span><span class="sxs-lookup"><span data-stu-id="08e41-2168">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="08e41-2169">大多数情况下，这适用于具有小于或等于16个元素的数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-2169">For the most part, this applies to arrays with less than or equal to 16 elements.</span></span></para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-2170">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-2170">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Comparison{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * Comparison&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-2171">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-2171">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-2172">要排序的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-2172">The one-dimensional, zero-based <see cref="T:System.Array" /> to sort</span></span></param>
        <param name="comparison"><span data-ttu-id="08e41-2173">比较元素时要使用的 <see cref="T:System.Comparison`1" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-2173">The <see cref="T:System.Comparison`1" /> to use when comparing elements.</span></span></param>
        <summary><span data-ttu-id="08e41-2174">使用指定的 <see cref="T:System.Comparison`1" />，对 <see cref="T:System.Array" /> 中的元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2174">Sorts the elements in an <see cref="T:System.Array" /> using the specified <see cref="T:System.Comparison`1" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-2175">如果排序未成功完成，则结果是不确定的。</span><span class="sxs-lookup"><span data-stu-id="08e41-2175">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="08e41-2176">此方法使用反省 sort （introsort）算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="08e41-2176">This method uses introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="08e41-2177">如果分区大小小于或等于16个元素，则它将使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2177">If the partition size is less than or equal to 16 elements, it uses an [insertion sort](https://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-2178">如果分区数超过 2 \* Log<sup>N</sup>，其中*N*为输入数组的范围，则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2178">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-2179">否则，它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2179">Otherwise, it uses a [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="08e41-2180">此实现执行不稳定的排序;也就是说，如果两个元素相等，则可能不会保留它们的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2180">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="08e41-2181">相反，稳定排序会保留相等元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2181">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="08e41-2182">对于使用 Heapsort 和快速排序算法排序的数组，在最坏的情况下，此方法为 O （`n` log `n`）操作，其中 `n` 是 `array`的 <xref:System.Array.Length%2A>。</span><span class="sxs-lookup"><span data-stu-id="08e41-2182">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-2183">下面的代码示例演示 <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> 方法重载。</span><span class="sxs-lookup"><span data-stu-id="08e41-2183">The following code example demonstrates the <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> method overload.</span></span>  
  
 <span data-ttu-id="08e41-2184">此代码示例定义了一个名为 `CompareDinosByLength`的字符串的替代比较方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2184">The code example defines an alternative comparison method for strings, named `CompareDinosByLength`.</span></span> <span data-ttu-id="08e41-2185">此方法的工作方式如下：首先，为`null`测试比较规则，并将 null 引用视为小于非空引用。</span><span class="sxs-lookup"><span data-stu-id="08e41-2185">This method works as follows: First, the comparands are tested for`null`, and a null reference is treated as less than a non-null.</span></span> <span data-ttu-id="08e41-2186">其次，比较字符串长度，较长的字符串被认为更大。</span><span class="sxs-lookup"><span data-stu-id="08e41-2186">Second, the string lengths are compared, and the longer string is deemed to be greater.</span></span> <span data-ttu-id="08e41-2187">第三，如果长度相等，则使用普通字符串比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-2187">Third, if the lengths are equal, ordinary string comparison is used.</span></span>  
  
 <span data-ttu-id="08e41-2188">创建一个字符串数组，并以无特定顺序填充四个字符串。</span><span class="sxs-lookup"><span data-stu-id="08e41-2188">A array of strings is created and populated with four strings, in no particular order.</span></span> <span data-ttu-id="08e41-2189">此列表还包括一个空字符串和一个空引用。</span><span class="sxs-lookup"><span data-stu-id="08e41-2189">The list also includes an empty string and a null reference.</span></span> <span data-ttu-id="08e41-2190">随即显示列表，该列表使用表示 `CompareDinosByLength` 方法的 <xref:System.Comparison%601> 泛型委托进行排序，并再次显示。</span><span class="sxs-lookup"><span data-stu-id="08e41-2190">The list is displayed, sorted using a <xref:System.Comparison%601> generic delegate representing the `CompareDinosByLength` method, and displayed again.</span></span>  
  
 [!code-cpp[Array_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[Array_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortComparison/cs/source.cs#1)]
 [!code-vb[Array_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-2191"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-2191"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="08e41-2192">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2192">-or-</span></span> 
 <span data-ttu-id="08e41-2193"><paramref name="comparison" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-2193"><paramref name="comparison" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-2194"><paramref name="comparison" /> 的实现导致排序时出现错误。</span><span class="sxs-lookup"><span data-stu-id="08e41-2194">The implementation of <paramref name="comparison" /> caused an error during the sort.</span></span> <span data-ttu-id="08e41-2195">例如，将某个项与其自身比较时，<paramref name="comparison" /> 可能不返回 0。</span><span class="sxs-lookup"><span data-stu-id="08e41-2195">For example, <paramref name="comparison" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="08e41-2196">.NET Framework 4 及更早版本仅使用快速排序算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2196">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="08e41-2197">快速排序在某些情况下标识无效的比较器，在这种情况下，排序操作引发 <see cref="T:System.IndexOutOfRangeException" /> 异常，并向调用方引发 <see cref="T:System.ArgumentException" /> 异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-2197">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="08e41-2198">从 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]开始，先前引发 <see cref="T:System.ArgumentException" /> 的排序操作可能不会引发异常，因为插入排序和 heapsort 算法未检测到无效的比较器。</span><span class="sxs-lookup"><span data-stu-id="08e41-2198">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="08e41-2199">大多数情况下，这适用于具有小于或等于6个元素的数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-2199">For the most part, this applies to arrays with less than or equal to 6 elements.</span></span></para></block>
        <altmember cref="T:System.Comparison`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-2200">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-2200">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-2201">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-2201">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-2202">要排序的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-2202">The one-dimensional, zero-based <see cref="T:System.Array" /> to sort</span></span></param>
        <param name="index"><span data-ttu-id="08e41-2203">排序范围的起始索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-2203">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="08e41-2204">排序范围内的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-2204">The number of elements in the range to sort.</span></span></param>
        <summary><span data-ttu-id="08e41-2205">使用 <see cref="T:System.Array" /> 中每个元素的 <see cref="T:System.IComparable`1" /> 泛型接口实现，对 <see cref="T:System.Array" /> 中元素范围内的元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2205">Sorts the elements in a range of elements in an <see cref="T:System.Array" /> using the <see cref="T:System.IComparable`1" /> generic interface implementation of each element of the <see cref="T:System.Array" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-2206">`array` 中指定范围内的元素中的每个元素都必须实现 <xref:System.IComparable%601> 泛型接口，才能与 `array`中的每个其他元素进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-2206">Each element within the specified range of elements in `array` must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="08e41-2207">如果排序未成功完成，则结果是不确定的。</span><span class="sxs-lookup"><span data-stu-id="08e41-2207">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="08e41-2208">此方法使用反省 sort （introsort）算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="08e41-2208">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="08e41-2209">如果分区大小小于或等于16个元素，则它将使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2209">If the partition size is less than or equal to 16 elements, it uses an [insertion sort](https://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-2210">如果分区数超过 2 \* Log<sup>N</sup>，其中*N*为输入数组的范围，则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2210">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-2211">否则，它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2211">Otherwise, it uses a [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="08e41-2212">此实现执行不稳定的排序;也就是说，如果两个元素相等，则可能不会保留它们的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2212">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="08e41-2213">相反，稳定排序会保留相等元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2213">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="08e41-2214">对于使用 Heapsort 和快速排序算法排序的数组，在最坏的情况下，此方法为 O （`n` log `n`）操作，其中 `n` 是 `length`的。</span><span class="sxs-lookup"><span data-stu-id="08e41-2214">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-2215">下面的代码示例演示 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 泛型方法重载，以及用于对数组中的范围进行排序的 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 泛型方法重载。</span><span class="sxs-lookup"><span data-stu-id="08e41-2215">The following code example demonstrates the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> generic method overload and the <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload for sorting a range in an array.</span></span>  
  
 <span data-ttu-id="08e41-2216">此代码示例定义了一个名为 `ReverseCompare`的字符串的替代比较器，该比较器实现了 `IComparer<string>` （`IComparer(Of String)` Visual Basic C++，`IComparer<String^>` Visual）泛型接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-2216">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="08e41-2217">比较器调用 <xref:System.String.CompareTo%28System.String%29> 方法，并反转比较数的顺序，以便字符串排序为高到低而不是低到高。</span><span class="sxs-lookup"><span data-stu-id="08e41-2217">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="08e41-2218">此代码示例创建并显示一个恐龙名称数组，其中包含三个 herbivores，后跟三个 carnivores （tyrannosaurids）。</span><span class="sxs-lookup"><span data-stu-id="08e41-2218">The code example creates and displays an array of dinosaur names, consisting of three herbivores followed by three carnivores (tyrannosaurids, to be precise).</span></span> <span data-ttu-id="08e41-2219"><xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 泛型方法重载用于对数组的最后三个元素进行排序，然后将显示该元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-2219">The <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> generic method overload is used to sort the last three elements of the array, which is then displayed.</span></span> <span data-ttu-id="08e41-2220"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 泛型方法重载与 `ReverseCompare` 一起使用，以便按相反的顺序对最后三个元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2220">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload is used with `ReverseCompare` to sort the last three elements in reverse order.</span></span> <span data-ttu-id="08e41-2221">将再次显示完全混淆的恐龙。</span><span class="sxs-lookup"><span data-stu-id="08e41-2221">The thoroughly confused dinosaurs are displayed again.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-2222">对 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 和 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 泛型方法的调用与对其非泛型方法的调用没有任何区别，因为 Visual Basic、 C#和C++从第一个参数的类型推断泛型类型参数的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-2222">The calls to the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> and <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</span></span> <span data-ttu-id="08e41-2223">如果使用[Ildasm （IL 拆装器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)检查 Microsoft 中间语言（MSIL），可以看到正在调用泛型方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2223">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-2224"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-2224"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-2225"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="08e41-2225"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
<span data-ttu-id="08e41-2226">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2226">-or-</span></span> 
 <span data-ttu-id="08e41-2227"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-2227"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-2228"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-2228"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="08e41-2229"><paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable`1" /> 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-2229">One or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-2230">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-2230">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-2231">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-2231">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-2232">要排序的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-2232">The one-dimensional, zero-based <see cref="T:System.Array" /> to sort.</span></span></param>
        <param name="index"><span data-ttu-id="08e41-2233">排序范围的起始索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-2233">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="08e41-2234">排序范围内的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-2234">The number of elements in the range to sort.</span></span></param>
        <param name="comparer"><span data-ttu-id="08e41-2235">比较元素时使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口实现；如果为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable`1" /> 泛型接口实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-2235">The <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface implementation to use when comparing elements, or <see langword="null" /> to use the <see cref="T:System.IComparable`1" /> generic interface implementation of each element.</span></span></param>
        <summary><span data-ttu-id="08e41-2236">使用指定的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口，对 <see cref="T:System.Array" /> 中的部分元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2236">Sorts the elements in a range of elements in an <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-2237">如果 `null``comparer`，则 `array` 中指定范围内的元素内的每个元素都必须实现 <xref:System.IComparable%601> 泛型接口，才能与 `array`中的其他每个元素进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-2237">If `comparer` is `null`, each element within the specified range of elements in `array` must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="08e41-2238">如果排序未成功完成，则结果是不确定的。</span><span class="sxs-lookup"><span data-stu-id="08e41-2238">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="08e41-2239">此方法使用反省 sort （introsort）算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="08e41-2239">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="08e41-2240">如果分区大小小于或等于16个元素，则它将使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2240">If the partition size is less than or equal to 16 elements, it uses an [insertion sort](https://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-2241">如果分区数超过 2 \* Log<sup>N</sup>，其中*N*为输入数组的范围，则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2241">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-2242">否则，它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2242">Otherwise, it uses a [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="08e41-2243">此实现执行不稳定的排序;也就是说，如果两个元素相等，则可能不会保留它们的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2243">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="08e41-2244">相反，稳定排序会保留相等元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2244">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="08e41-2245">对于使用 Heapsort 和快速排序算法排序的数组，在最坏的情况下，此方法为 O （`n` log `n`）操作，其中 `n` 是 `length`的。</span><span class="sxs-lookup"><span data-stu-id="08e41-2245">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-2246">下面的代码示例演示 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 泛型方法重载，以及用于对数组中的范围进行排序的 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 泛型方法重载。</span><span class="sxs-lookup"><span data-stu-id="08e41-2246">The following code example demonstrates the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> generic method overload and the <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload for sorting a range in an array.</span></span>  
  
 <span data-ttu-id="08e41-2247">此代码示例定义了一个名为 `ReverseCompare`的字符串的替代比较器，该比较器实现了 `IComparer<string>` （`IComparer(Of String)` Visual Basic C++，`IComparer<String^>` Visual）泛型接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-2247">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="08e41-2248">比较器调用 <xref:System.String.CompareTo%28System.String%29> 方法，并反转比较数的顺序，以便字符串排序为高到低而不是低到高。</span><span class="sxs-lookup"><span data-stu-id="08e41-2248">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="08e41-2249">此代码示例创建并显示一个恐龙名称数组，其中包含三个 herbivores，后跟三个 carnivores （tyrannosaurids）。</span><span class="sxs-lookup"><span data-stu-id="08e41-2249">The code example creates and displays an array of dinosaur names, consisting of three herbivores followed by three carnivores (tyrannosaurids, to be precise).</span></span> <span data-ttu-id="08e41-2250"><xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 泛型方法重载用于对数组的最后三个元素进行排序，然后将显示该元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-2250">The <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> generic method overload is used to sort the last three elements of the array, which is then displayed.</span></span> <span data-ttu-id="08e41-2251"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 泛型方法重载与 `ReverseCompare` 一起使用，以便按相反的顺序对最后三个元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2251">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload is used with `ReverseCompare` to sort the last three elements in reverse order.</span></span> <span data-ttu-id="08e41-2252">将再次显示完全混淆的恐龙。</span><span class="sxs-lookup"><span data-stu-id="08e41-2252">The thoroughly confused dinosaurs are displayed again.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-2253">对 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 和 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 泛型方法的调用与对其非泛型方法的调用没有任何区别，因为 Visual Basic、 C#和C++从第一个参数的类型推断泛型类型参数的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-2253">The calls to the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> and <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</span></span> <span data-ttu-id="08e41-2254">如果使用[Ildasm （IL 拆装器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)检查 Microsoft 中间语言（MSIL），可以看到正在调用泛型方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2254">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-2255"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-2255"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-2256"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="08e41-2256"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
<span data-ttu-id="08e41-2257">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2257">-or-</span></span> 
 <span data-ttu-id="08e41-2258"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-2258"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-2259"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-2259"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span>  
  
<span data-ttu-id="08e41-2260">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2260">-or-</span></span> 
<span data-ttu-id="08e41-2261"><paramref name="comparer" /> 的实现导致排序时出现错误。</span><span class="sxs-lookup"><span data-stu-id="08e41-2261">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="08e41-2262">例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</span><span class="sxs-lookup"><span data-stu-id="08e41-2262">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="08e41-2263"><paramref name="comparer" /> 为 <see langword="null" />，且 <paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable`1" /> 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-2263"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="08e41-2264">.NET Framework 4 及更早版本仅使用快速排序算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2264">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="08e41-2265">快速排序在某些情况下标识无效的比较器，在这种情况下，排序操作引发 <see cref="T:System.IndexOutOfRangeException" /> 异常，并向调用方引发 <see cref="T:System.ArgumentException" /> 异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-2265">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="08e41-2266">从 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]开始，先前引发 <see cref="T:System.ArgumentException" /> 的排序操作可能不会引发异常，因为插入排序和 heapsort 算法未检测到无效的比较器。</span><span class="sxs-lookup"><span data-stu-id="08e41-2266">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="08e41-2267">大多数情况下，这适用于具有小于或等于16个元素的数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-2267">For the most part, this applies to arrays with less than or equal to 16 elements.</span></span></para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-2268">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-2268">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey"><span data-ttu-id="08e41-2269">关键字数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-2269">The type of the elements of the key array.</span></span></typeparam>
        <typeparam name="TValue"><span data-ttu-id="08e41-2270">项数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-2270">The type of the elements of the items array.</span></span></typeparam>
        <param name="keys"><span data-ttu-id="08e41-2271">从零开始的一维 <see cref="T:System.Array" />，它包含要排序的关键字。</span><span class="sxs-lookup"><span data-stu-id="08e41-2271">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="08e41-2272">从零开始的一维 <see cref="T:System.Array" />，其中包含与 <paramref name="keys" /> 中的关键字对应的项；如果为 <see langword="null" />，则只对 <paramref name="keys" /> 进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2272">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the items that correspond to the keys in <paramref name="keys" />, or <see langword="null" /> to sort only <paramref name="keys" />.</span></span></param>
        <summary><span data-ttu-id="08e41-2273">基于第一个 <see cref="T:System.Array" /> 中的键，使用每个键的 <see cref="T:System.IComparable`1" /> 泛型接口实现，对一对 <see cref="T:System.Array" /> 对象（一个包含键，另一个包含对应的项）进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2273">Sorts a pair of <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the <see cref="T:System.IComparable`1" /> generic interface implementation of each key.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-2274">`keys`<xref:System.Array> 中的每个键在 `items`<xref:System.Array>中都有相应的项。</span><span class="sxs-lookup"><span data-stu-id="08e41-2274">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="08e41-2275">当在排序过程中重定位某个键时，`items`<xref:System.Array> 中的相应项同样会重新定位。</span><span class="sxs-lookup"><span data-stu-id="08e41-2275">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="08e41-2276">因此，`items`<xref:System.Array> 根据 `keys`<xref:System.Array>中对应键的排列方式进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2276">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="08e41-2277">`keys`<xref:System.Array> 中的每个键都必须实现 <xref:System.IComparable%601> 泛型接口，才能与其他每个键进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-2277">Each key in the `keys`<xref:System.Array> must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="08e41-2278">您可以排序是否有多个项大于键，但不会对没有对应键的项进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2278">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="08e41-2279">如果键比项多，则无法排序;这样做会引发 <xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="08e41-2279">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="08e41-2280">如果排序未成功完成，则结果是不确定的。</span><span class="sxs-lookup"><span data-stu-id="08e41-2280">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="08e41-2281">此方法使用反省 sort （introsort）算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="08e41-2281">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="08e41-2282">如果分区大小小于或等于16个元素，则它将使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2282">If the partition size is less than or equal 16 elements, it uses an [insertion sort](https://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-2283">如果分区数超过 2 \* Log<sup>N</sup>，其中*N*为输入数组的范围，则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2283">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-2284">否则，它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2284">Otherwise, it uses a [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="08e41-2285">此实现执行不稳定的排序;也就是说，如果两个元素相等，则可能不会保留它们的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2285">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="08e41-2286">相反，稳定排序会保留相等元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2286">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="08e41-2287">对于使用 Heapsort 和快速排序算法排序的数组，在最坏的情况下，此方法为 O （`n` log `n`）操作，其中 `n` 是 `array`的 <xref:System.Array.Length%2A>。</span><span class="sxs-lookup"><span data-stu-id="08e41-2287">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-2288">下面的代码示例演示 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>、<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>、<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>和 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 泛型方法重载，用于对表示键和值的数组对进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2288">The following code example demonstrates the <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, and <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overloads, for sorting pairs of arrays that represent keys and values.</span></span>  
  
 <span data-ttu-id="08e41-2289">此代码示例定义了一个名为 `ReverseCompare`的字符串的替代比较器，该比较器实现了 `IComparer<string>` （`IComparer(Of String)` Visual Basic C++，`IComparer<String^>` Visual）泛型接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-2289">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="08e41-2290">比较器调用 <xref:System.String.CompareTo%28System.String%29> 方法，并反转比较数的顺序，以便字符串排序为高到低而不是低到高。</span><span class="sxs-lookup"><span data-stu-id="08e41-2290">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="08e41-2291">此代码示例创建并显示一个恐龙名称数组（密钥）和一个整数数组，表示每个恐龙的最大长度（值）。</span><span class="sxs-lookup"><span data-stu-id="08e41-2291">The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</span></span> <span data-ttu-id="08e41-2292">然后，将数组排序并显示多次：</span><span class="sxs-lookup"><span data-stu-id="08e41-2292">The arrays are then sorted and displayed several times:</span></span>  
  
-   <span data-ttu-id="08e41-2293"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> 重载用于按照第一个数组中的恐龙名称顺序对这两个数组进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2293">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> overload is used to sort both arrays in order of the dinosaur names in the first array.</span></span>  
  
-   <span data-ttu-id="08e41-2294"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 重载和 `ReverseCompare` 实例用于反转成对数组的排序顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2294">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload and an instance of `ReverseCompare` are used to reverse the sort order of the paired arrays.</span></span>  
  
-   <span data-ttu-id="08e41-2295"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 重载用于对这两个数组的最后三个元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2295">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload is used to sort the last three elements of both arrays.</span></span>  
  
-   <span data-ttu-id="08e41-2296"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 重载用于按相反的顺序对两个数组中的最后三个元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2296">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload is used to sort the last three elements of both arrays in reverse order.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-2297">对泛型方法的调用与对它们的非泛型方法的调用没有任何不同之处，因为C#Visual Basic、 C++和从前两个自变量的类型推断泛型类型参数的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-2297">The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</span></span> <span data-ttu-id="08e41-2298">如果使用[Ildasm （IL 拆装器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)检查 Microsoft 中间语言（MSIL），可以看到正在调用泛型方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2298">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-2299"><paramref name="keys" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-2299"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-2300"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的下限与 <paramref name="items" />的下限不匹配。</span><span class="sxs-lookup"><span data-stu-id="08e41-2300"><paramref name="items" /> is not <see langword="null" />, and the lower bound of <paramref name="keys" /> does not match the lower bound of <paramref name="items" />.</span></span>  
  
<span data-ttu-id="08e41-2301">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2301">-or-</span></span> 
 <span data-ttu-id="08e41-2302"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="08e41-2302"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="08e41-2303"><paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素不实现 <see cref="T:System.IComparable`1" /> 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-2303">One or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-2304">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-2304">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey"><span data-ttu-id="08e41-2305">关键字数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-2305">The type of the elements of the key array.</span></span></typeparam>
        <typeparam name="TValue"><span data-ttu-id="08e41-2306">项数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-2306">The type of the elements of the items array.</span></span></typeparam>
        <param name="keys"><span data-ttu-id="08e41-2307">从零开始的一维 <see cref="T:System.Array" />，它包含要排序的关键字。</span><span class="sxs-lookup"><span data-stu-id="08e41-2307">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="08e41-2308">从零开始的一维 <see cref="T:System.Array" />，其中包含与 <paramref name="keys" /> 中的关键字对应的项；如果为 <see langword="null" />，则只对 <paramref name="keys" /> 进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2308">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the items that correspond to the keys in <paramref name="keys" />, or <see langword="null" /> to sort only <paramref name="keys" />.</span></span></param>
        <param name="comparer"><span data-ttu-id="08e41-2309">比较元素时使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口实现；如果为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable`1" /> 泛型接口实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-2309">The <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface implementation to use when comparing elements, or <see langword="null" /> to use the <see cref="T:System.IComparable`1" /> generic interface implementation of each element.</span></span></param>
        <summary><span data-ttu-id="08e41-2310">基于第一个 <see cref="T:System.Array" /> 中的关键字，使用指定的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口，对两个 <see cref="T:System.Array" /> 对象（一个包含关键字，另一个包含对应的项）进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2310">Sorts a pair of <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-2311">`keys`<xref:System.Array> 中的每个键在 `items`<xref:System.Array>中都有相应的项。</span><span class="sxs-lookup"><span data-stu-id="08e41-2311">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="08e41-2312">当在排序过程中重定位某个键时，`items`<xref:System.Array> 中的相应项同样会重新定位。</span><span class="sxs-lookup"><span data-stu-id="08e41-2312">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="08e41-2313">因此，`items`<xref:System.Array> 根据 `keys`<xref:System.Array>中对应键的排列方式进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2313">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="08e41-2314">如果 `null``comparer`，则 `keys`<xref:System.Array> 中的每个键都必须实现 <xref:System.IComparable%601> 泛型接口，才能与其他每个键进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-2314">If `comparer` is `null`, each key in the `keys`<xref:System.Array> must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="08e41-2315">您可以排序是否有多个项大于键，但不会对没有对应键的项进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2315">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="08e41-2316">如果键比项多，则无法排序;这样做会引发 <xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="08e41-2316">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="08e41-2317">如果排序未成功完成，则结果是不确定的。</span><span class="sxs-lookup"><span data-stu-id="08e41-2317">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="08e41-2318">此方法使用反省 sort （introsort）算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="08e41-2318">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="08e41-2319">如果分区大小小于或等于16个元素，则它将使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2319">If the partition size is less than or equal to 16 elements, it uses an [insertion sort](https://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-2320">如果分区数超过 2 \* Log<sup>N</sup>，其中*N*为输入数组的范围，则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2320">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-2321">否则，它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2321">Otherwise, it uses a [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="08e41-2322">此实现执行不稳定的排序;也就是说，如果两个元素相等，则可能不会保留它们的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2322">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="08e41-2323">相反，稳定排序会保留相等元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2323">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="08e41-2324">对于使用 Heapsort 和快速排序算法排序的数组，在最坏的情况下，此方法为 O （`n` log `n`）操作，其中 `n` 是 `array`的 <xref:System.Array.Length%2A>。</span><span class="sxs-lookup"><span data-stu-id="08e41-2324">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-2325">下面的代码示例演示了 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>，[\]，TValue\<x： IComparer %60 %602 %28 %60 %600% 5B% 5D% 2C %60 %601% 5B% 5D% 2Csystem.string，% 7B %60 %600% 7D %29 >、<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>和 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 泛型方法重载，用于对表示键和值的数组对进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2325">The following code example demonstrates the <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>,<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, and <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overloads, for sorting pairs of arrays that represent keys and values.</span></span>  
  
 <span data-ttu-id="08e41-2326">此代码示例定义了一个名为 `ReverseCompare`的字符串的替代比较器，该比较器实现了 `IComparer<string>` （`IComparer(Of String)` Visual Basic C++，`IComparer<String^>` Visual）泛型接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-2326">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="08e41-2327">比较器调用 <xref:System.String.CompareTo%28System.String%29> 方法，并反转比较数的顺序，以便字符串排序为高到低而不是低到高。</span><span class="sxs-lookup"><span data-stu-id="08e41-2327">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="08e41-2328">此代码示例创建并显示一个恐龙名称数组（密钥）和一个整数数组，表示每个恐龙的最大长度（值）。</span><span class="sxs-lookup"><span data-stu-id="08e41-2328">The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</span></span> <span data-ttu-id="08e41-2329">然后，将数组排序并显示多次：</span><span class="sxs-lookup"><span data-stu-id="08e41-2329">The arrays are then sorted and displayed several times:</span></span>  
  
-   <span data-ttu-id="08e41-2330"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> 重载用于按照第一个数组中的恐龙名称顺序对这两个数组进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2330">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> overload is used to sort both arrays in order of the dinosaur names in the first array.</span></span>  
  
-   <span data-ttu-id="08e41-2331">[\]，TValue\<x： IComparer %60 %7 %28 %60 %600% 5B% 5D% 2C %60 %601% 5B% 5D% 2Csystem.string，% 7B %60 %600% 7D %29 > 重载，并使用 `ReverseCompare` 的实例反转配对数组的排序顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2331">The [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload and an instance of `ReverseCompare` are used to reverse the sort order of the paired arrays.</span></span>  
  
-   <span data-ttu-id="08e41-2332"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 重载用于对这两个数组的最后三个元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2332">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload is used to sort the last three elements of both arrays.</span></span>  
  
-   <span data-ttu-id="08e41-2333"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 重载用于按相反的顺序对两个数组中的最后三个元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2333">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload is used to sort the last three elements of both arrays in reverse order.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-2334">对泛型方法的调用与对它们的非泛型方法的调用没有任何不同之处，因为C#Visual Basic、 C++和从前两个自变量的类型推断泛型类型参数的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-2334">The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</span></span> <span data-ttu-id="08e41-2335">如果使用[Ildasm （IL 拆装器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)检查 Microsoft 中间语言（MSIL），可以看到正在调用泛型方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2335">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-2336"><paramref name="keys" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-2336"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-2337"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的下限与 <paramref name="items" />的下限不匹配。</span><span class="sxs-lookup"><span data-stu-id="08e41-2337"><paramref name="items" /> is not <see langword="null" />, and the lower bound of <paramref name="keys" /> does not match the lower bound of <paramref name="items" />.</span></span>  
  
<span data-ttu-id="08e41-2338">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2338">-or-</span></span> 
 <span data-ttu-id="08e41-2339"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="08e41-2339"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span>  
  
<span data-ttu-id="08e41-2340">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2340">-or-</span></span> 
<span data-ttu-id="08e41-2341"><paramref name="comparer" /> 的实现导致排序时出现错误。</span><span class="sxs-lookup"><span data-stu-id="08e41-2341">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="08e41-2342">例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</span><span class="sxs-lookup"><span data-stu-id="08e41-2342">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="08e41-2343"><paramref name="comparer" /> 为 <see langword="null" />，且 <paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable`1" /> 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-2343"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="08e41-2344">.NET Framework 4 及更早版本仅使用快速排序算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2344">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="08e41-2345">快速排序在某些情况下标识无效的比较器，在这种情况下，排序操作引发 <see cref="T:System.IndexOutOfRangeException" /> 异常，并向调用方引发 <see cref="T:System.ArgumentException" /> 异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-2345">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="08e41-2346">从 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]开始，先前引发 <see cref="T:System.ArgumentException" /> 的排序操作可能不会引发异常，因为插入排序和 heapsort 算法未检测到无效的比较器。</span><span class="sxs-lookup"><span data-stu-id="08e41-2346">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="08e41-2347">大多数情况下，这适用于具有小于或等于16个元素的数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-2347">For the most part, this applies to arrays with less than or equal to 16 elements.</span></span></para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-2348">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-2348">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey"><span data-ttu-id="08e41-2349">关键字数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-2349">The type of the elements of the key array.</span></span></typeparam>
        <typeparam name="TValue"><span data-ttu-id="08e41-2350">项数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-2350">The type of the elements of the items array.</span></span></typeparam>
        <param name="keys"><span data-ttu-id="08e41-2351">从零开始的一维 <see cref="T:System.Array" />，它包含要排序的关键字。</span><span class="sxs-lookup"><span data-stu-id="08e41-2351">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="08e41-2352">从零开始的一维 <see cref="T:System.Array" />，其中包含与 <paramref name="keys" /> 中的关键字对应的项；如果为 <see langword="null" />，则只对 <paramref name="keys" /> 进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2352">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the items that correspond to the keys in <paramref name="keys" />, or <see langword="null" /> to sort only <paramref name="keys" />.</span></span></param>
        <param name="index"><span data-ttu-id="08e41-2353">排序范围的起始索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-2353">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="08e41-2354">排序范围内的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-2354">The number of elements in the range to sort.</span></span></param>
        <summary><span data-ttu-id="08e41-2355">基于第一个 <see cref="T:System.Array" /> 中的键，使用每个键的 <see cref="T:System.IComparable`1" /> 泛型接口实现，对两个 <see cref="T:System.Array" /> 对象（一个包含键，另一个包含对应的项）的部分元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2355">Sorts a range of elements in a pair of <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the <see cref="T:System.IComparable`1" /> generic interface implementation of each key.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-2356">`keys`<xref:System.Array> 中的每个键在 `items`<xref:System.Array>中都有相应的项。</span><span class="sxs-lookup"><span data-stu-id="08e41-2356">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="08e41-2357">当在排序过程中重定位某个键时，`items`<xref:System.Array> 中的相应项同样会重新定位。</span><span class="sxs-lookup"><span data-stu-id="08e41-2357">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="08e41-2358">因此，`items`<xref:System.Array> 根据 `keys`<xref:System.Array>中对应键的排列方式进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2358">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="08e41-2359">`keys`<xref:System.Array> 中指定范围内的元素中的每个键都必须实现 <xref:System.IComparable%601> 泛型接口，才能与其他每个键进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-2359">Each key within the specified range of elements in the `keys`<xref:System.Array> must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="08e41-2360">您可以排序是否有多个项大于键，但不会对没有对应键的项进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2360">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="08e41-2361">如果键比项多，则无法排序;这样做会引发 <xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="08e41-2361">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="08e41-2362">如果排序未成功完成，则结果是不确定的。</span><span class="sxs-lookup"><span data-stu-id="08e41-2362">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="08e41-2363">此方法使用反省 sort （introsort）算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="08e41-2363">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="08e41-2364">如果分区大小小于或等于16个元素，则它将使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2364">If the partition size is less than or equal to 16 elements, it uses an [insertion sort](https://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-2365">如果分区数超过 2 \* Log<sup>N</sup>，其中*N*为输入数组的范围，则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2365">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-2366">否则，它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2366">Otherwise, it uses a [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="08e41-2367">此实现执行不稳定的排序;也就是说，如果两个元素相等，则可能不会保留它们的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2367">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="08e41-2368">相反，稳定排序会保留相等元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2368">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="08e41-2369">对于使用 Heapsort 和快速排序算法排序的数组，在最坏的情况下，此方法为 O （`n` log `n`）操作，其中 `n` 是 `length`的。</span><span class="sxs-lookup"><span data-stu-id="08e41-2369">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-2370">下面的代码示例演示了 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>、<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>、[\]、TValue\<x： %60 %602 %28 %60 %600% 5B% 5D% 2C %60 %601% 5B% 5D% 2Csystem.string% 2Csystem.string %29 > 和 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 泛型方法重载，用于对表示键和值的数组对进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2370">The following code example demonstrates the <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, and <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overloads, for sorting pairs of arrays that represent keys and values.</span></span>  
  
 <span data-ttu-id="08e41-2371">此代码示例定义了一个名为 `ReverseCompare`的字符串的替代比较器，该比较器实现了 `IComparer<string>` （`IComparer(Of String)` Visual Basic C++，`IComparer<String^>` Visual）泛型接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-2371">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="08e41-2372">比较器调用 <xref:System.String.CompareTo%28System.String%29> 方法，并反转比较数的顺序，以便字符串排序为高到低而不是低到高。</span><span class="sxs-lookup"><span data-stu-id="08e41-2372">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="08e41-2373">此代码示例创建并显示一个恐龙名称数组（密钥）和一个整数数组，表示每个恐龙的最大长度（值）。</span><span class="sxs-lookup"><span data-stu-id="08e41-2373">The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</span></span> <span data-ttu-id="08e41-2374">然后，将数组排序并显示多次：</span><span class="sxs-lookup"><span data-stu-id="08e41-2374">The arrays are then sorted and displayed several times:</span></span>  
  
-   <span data-ttu-id="08e41-2375"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> 重载用于按照第一个数组中的恐龙名称顺序对这两个数组进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2375">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> overload is used to sort both arrays in order of the dinosaur names in the first array.</span></span>  
  
-   <span data-ttu-id="08e41-2376"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 重载和 `ReverseCompare` 实例用于反转成对数组的排序顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2376">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload and an instance of `ReverseCompare` are used to reverse the sort order of the paired arrays.</span></span>  
  
-   <span data-ttu-id="08e41-2377">[\]，TValue\<x：% %28 %60 %600% 5B% 5D% 2C %60 %601% 5B% 5D% 2Csystem.string% 2Csystem.string %29 > 重载用于对这两个数组的最后三个元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2377">The [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload is used to sort the last three elements of both arrays.</span></span>  
  
-   <span data-ttu-id="08e41-2378"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 重载用于按相反的顺序对两个数组中的最后三个元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2378">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload is used to sort the last three elements of both arrays in reverse order.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-2379">对泛型方法的调用与对它们的非泛型方法的调用没有任何不同之处，因为C#Visual Basic、 C++和从前两个自变量的类型推断泛型类型参数的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-2379">The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</span></span> <span data-ttu-id="08e41-2380">如果使用[Ildasm （IL 拆装器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)检查 Microsoft 中间语言（MSIL），可以看到正在调用泛型方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2380">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-2381"><paramref name="keys" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-2381"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-2382"><paramref name="index" /> 小于 <paramref name="keys" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="08e41-2382"><paramref name="index" /> is less than the lower bound of <paramref name="keys" />.</span></span>  
  
<span data-ttu-id="08e41-2383">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2383">-or-</span></span> 
 <span data-ttu-id="08e41-2384"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-2384"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-2385"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的下限与 <paramref name="items" /> 的下限不匹配。</span><span class="sxs-lookup"><span data-stu-id="08e41-2385"><paramref name="items" /> is not <see langword="null" />, and the lower bound of <paramref name="keys" /> does not match the lower bound of <paramref name="items" />.</span></span>  
  
<span data-ttu-id="08e41-2386">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2386">-or-</span></span> 
 <span data-ttu-id="08e41-2387"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="08e41-2387"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span>  
  
<span data-ttu-id="08e41-2388">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2388">-or-</span></span> 
 <span data-ttu-id="08e41-2389"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="keys" /><see cref="T:System.Array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-2389"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="keys" /><see cref="T:System.Array" />.</span></span>  
  
<span data-ttu-id="08e41-2390">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2390">-or-</span></span> 
 <span data-ttu-id="08e41-2391"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="items" /><see cref="T:System.Array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-2391"><paramref name="items" /> is not <see langword="null" />, and <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="items" /><see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="08e41-2392"><paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素不实现 <see cref="T:System.IComparable`1" /> 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-2392">One or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-2393">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-2393">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer, comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey"><span data-ttu-id="08e41-2394">关键字数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-2394">The type of the elements of the key array.</span></span></typeparam>
        <typeparam name="TValue"><span data-ttu-id="08e41-2395">项数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-2395">The type of the elements of the items array.</span></span></typeparam>
        <param name="keys"><span data-ttu-id="08e41-2396">从零开始的一维 <see cref="T:System.Array" />，它包含要排序的关键字。</span><span class="sxs-lookup"><span data-stu-id="08e41-2396">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="08e41-2397">从零开始的一维 <see cref="T:System.Array" />，其中包含与 <paramref name="keys" /> 中的关键字对应的项；如果为 <see langword="null" />，则只对 <paramref name="keys" /> 进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2397">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the items that correspond to the keys in <paramref name="keys" />, or <see langword="null" /> to sort only <paramref name="keys" />.</span></span></param>
        <param name="index"><span data-ttu-id="08e41-2398">排序范围的起始索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-2398">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="08e41-2399">排序范围内的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-2399">The number of elements in the range to sort.</span></span></param>
        <param name="comparer"><span data-ttu-id="08e41-2400">比较元素时使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口实现；如果为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable`1" /> 泛型接口实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-2400">The <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface implementation to use when comparing elements, or <see langword="null" /> to use the <see cref="T:System.IComparable`1" /> generic interface implementation of each element.</span></span></param>
        <summary><span data-ttu-id="08e41-2401">基于第一个 <see cref="T:System.Array" /> 中的关键字，使用指定的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口，对两个 <see cref="T:System.Array" /> 对象（一个包含关键字，另一个包含对应的项）的部分元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2401">Sorts a range of elements in a pair of <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-2402">`keys`<xref:System.Array> 中的每个键在 `items`<xref:System.Array>中都有相应的项。</span><span class="sxs-lookup"><span data-stu-id="08e41-2402">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="08e41-2403">当在排序过程中重定位某个键时，`items`<xref:System.Array> 中的相应项同样会重新定位。</span><span class="sxs-lookup"><span data-stu-id="08e41-2403">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="08e41-2404">因此，`items`<xref:System.Array> 根据 `keys`<xref:System.Array>中对应键的排列方式进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2404">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="08e41-2405">如果 `null``comparer`，则 `keys`<xref:System.Array> 中指定范围内的元素中的每个键都必须实现 <xref:System.IComparable%601> 泛型接口，才能与其他每个键进行比较。</span><span class="sxs-lookup"><span data-stu-id="08e41-2405">If `comparer` is `null`, each key within the specified range of elements in the `keys`<xref:System.Array> must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="08e41-2406">您可以排序是否有多个项大于键，但不会对没有对应键的项进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2406">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="08e41-2407">如果键比项多，则无法排序;这样做会引发 <xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="08e41-2407">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="08e41-2408">如果排序未成功完成，则结果是不确定的。</span><span class="sxs-lookup"><span data-stu-id="08e41-2408">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="08e41-2409">此方法使用反省 sort （introsort）算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="08e41-2409">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="08e41-2410">如果分区大小小于或等于16个元素，则它将使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2410">If the partition size is less than or equal to 16 elements, it uses an [insertion sort](https://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-2411">如果分区数超过 2 \* Log<sup>N</sup>，其中*N*为输入数组的范围，则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2411">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="08e41-2412">否则，它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2412">Otherwise, it uses a [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="08e41-2413">此实现执行不稳定的排序;也就是说，如果两个元素相等，则可能不会保留它们的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2413">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="08e41-2414">相反，稳定排序会保留相等元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2414">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="08e41-2415">对于使用 Heapsort 和快速排序算法排序的数组，在最坏的情况下，此方法为 O （`n` log `n`）操作，其中 `n` 是 `length`的。</span><span class="sxs-lookup"><span data-stu-id="08e41-2415">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-2416">下面的代码示例演示了 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>、<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>、<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>和 [\]，TValue\<x： 2Csystem.string %60 %602 %28 %60 %600% 5B% 5D% 2C %60 %601% 5B% 5D% 2Csystem.string%% 2Csystem.string%% 7B%% %600% 7D %29 > 泛型方法重载，用于对表示键和值的数组对进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2416">The following code example demonstrates the <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, and [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overloads, for sorting pairs of arrays that represent keys and values.</span></span>  
  
 <span data-ttu-id="08e41-2417">此代码示例定义了一个名为 `ReverseCompare`的字符串的替代比较器，该比较器实现了 `IComparer<string>`（`IComparer(Of String)` Visual Basic C++，`IComparer<String^>` Visual）泛型接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-2417">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>`(`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="08e41-2418">比较器调用 <xref:System.String.CompareTo%28System.String%29> 方法，并反转比较数的顺序，以便字符串排序为高到低而不是低到高。</span><span class="sxs-lookup"><span data-stu-id="08e41-2418">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="08e41-2419">此代码示例创建并显示一个恐龙名称数组（密钥）和一个整数数组，表示每个恐龙的最大长度（值）。</span><span class="sxs-lookup"><span data-stu-id="08e41-2419">The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</span></span> <span data-ttu-id="08e41-2420">然后，将数组排序并显示多次：</span><span class="sxs-lookup"><span data-stu-id="08e41-2420">The arrays are then sorted and displayed several times:</span></span>  
  
-   <span data-ttu-id="08e41-2421"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> 重载用于按照第一个数组中的恐龙名称顺序对这两个数组进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2421">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> overload is used to sort both arrays in order of the dinosaur names in the first array.</span></span>  
  
-   <span data-ttu-id="08e41-2422"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 重载和 `ReverseCompare` 实例用于反转成对数组的排序顺序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2422">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload and an instance of `ReverseCompare` are used to reverse the sort order of the paired arrays.</span></span>  
  
-   <span data-ttu-id="08e41-2423"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 重载用于对这两个数组的最后三个元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2423">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload is used to sort the last three elements of both arrays.</span></span>  
  
-   <span data-ttu-id="08e41-2424">[\]TValue\<x： 2Csystem.string %60 %602 %28 %60 %600% 5B% 5D% 2C %60 %601% 5B% 5D% 2Csystem.string%% 2Csystem.string %600% 7D %29 > 重载用于按相反顺序对这两个数组的最后三个元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="08e41-2424">The [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload is used to sort the last three elements of both arrays in reverse order.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-2425">对泛型方法的调用与对它们的非泛型方法的调用没有任何不同之处，因为C#Visual Basic、 C++和从前两个自变量的类型推断泛型类型参数的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-2425">The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</span></span> <span data-ttu-id="08e41-2426">如果使用[Ildasm （IL 拆装器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)检查 Microsoft 中间语言（MSIL），可以看到正在调用泛型方法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2426">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-2427"><paramref name="keys" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-2427"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-2428"><paramref name="index" /> 小于 <paramref name="keys" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="08e41-2428"><paramref name="index" /> is less than the lower bound of <paramref name="keys" />.</span></span>  
  
<span data-ttu-id="08e41-2429">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2429">-or-</span></span> 
 <span data-ttu-id="08e41-2430"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-2430"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-2431"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的下限与 <paramref name="items" /> 的下限不匹配。</span><span class="sxs-lookup"><span data-stu-id="08e41-2431"><paramref name="items" /> is not <see langword="null" />, and the lower bound of <paramref name="keys" /> does not match the lower bound of <paramref name="items" />.</span></span>  
  
<span data-ttu-id="08e41-2432">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2432">-or-</span></span> 
 <span data-ttu-id="08e41-2433"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="08e41-2433"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span>  
  
<span data-ttu-id="08e41-2434">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2434">-or-</span></span> 
 <span data-ttu-id="08e41-2435"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="keys" /><see cref="T:System.Array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-2435"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="keys" /><see cref="T:System.Array" />.</span></span>  
  
<span data-ttu-id="08e41-2436">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2436">-or-</span></span> 
 <span data-ttu-id="08e41-2437"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="items" /><see cref="T:System.Array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="08e41-2437"><paramref name="items" /> is not <see langword="null" />, and <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="items" /><see cref="T:System.Array" />.</span></span>  
  
<span data-ttu-id="08e41-2438">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2438">-or-</span></span> 
<span data-ttu-id="08e41-2439"><paramref name="comparer" /> 的实现导致排序时出现错误。</span><span class="sxs-lookup"><span data-stu-id="08e41-2439">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="08e41-2440">例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</span><span class="sxs-lookup"><span data-stu-id="08e41-2440">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="08e41-2441"><paramref name="comparer" /> 为 <see langword="null" />，且 <paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable`1" /> 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-2441"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="08e41-2442">.NET Framework 4 及更早版本仅使用快速排序算法。</span><span class="sxs-lookup"><span data-stu-id="08e41-2442">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="08e41-2443">快速排序在某些情况下标识无效的比较器，在这种情况下，排序操作引发 <see cref="T:System.IndexOutOfRangeException" /> 异常，并向调用方引发 <see cref="T:System.ArgumentException" /> 异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-2443">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="08e41-2444">从 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]开始，先前引发 <see cref="T:System.ArgumentException" /> 的排序操作可能不会引发异常，因为插入排序和 heapsort 算法未检测到无效的比较器。</span><span class="sxs-lookup"><span data-stu-id="08e41-2444">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="08e41-2445">大多数情况下，这适用于具有小于或等于16个元素的数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-2445">For the most part, this applies to arrays with less than or equal to 16 elements.</span></span></para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md"><span data-ttu-id="08e41-2446">在数组中执行不区分区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="08e41-2446">Performing Culture-Insensitive String Operations in Arrays</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Array.SyncRoot" />
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="08e41-2447">获取可用于同步对 <see cref="T:System.Array" /> 的访问的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-2447">Gets an object that can be used to synchronize access to the <see cref="T:System.Array" />.</span></span></summary>
        <value><span data-ttu-id="08e41-2448">可用于同步对 <see cref="T:System.Array" /> 的访问的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-2448">An object that can be used to synchronize access to the <see cref="T:System.Array" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-2449">此属性实现 <xref:System.Collections.ICollection?displayProperty=nameWithType> 接口。</span><span class="sxs-lookup"><span data-stu-id="08e41-2449">This property implements the <xref:System.Collections.ICollection?displayProperty=nameWithType> interface.</span></span>  
  
 <span data-ttu-id="08e41-2450">基于 <xref:System.Array> .NET Framework 类使用 <xref:System.Array.SyncRoot%2A> 属性提供其自己的同步版本的集合。</span><span class="sxs-lookup"><span data-stu-id="08e41-2450">.NET Framework classes based on <xref:System.Array> provide their own synchronized version of the collection using the <xref:System.Array.SyncRoot%2A> property.</span></span>  
  
 <span data-ttu-id="08e41-2451">使用数组的类也可以使用 <xref:System.Array.SyncRoot%2A> 属性实现其自己的同步。</span><span class="sxs-lookup"><span data-stu-id="08e41-2451">Classes that use arrays can also implement their own synchronization using the <xref:System.Array.SyncRoot%2A> property.</span></span> <span data-ttu-id="08e41-2452">同步代码必须对集合的 `SyncRoot` 执行操作，而不是直接对集合执行操作。</span><span class="sxs-lookup"><span data-stu-id="08e41-2452">The synchronizing code must perform operations on the `SyncRoot` of the collection, not directly on the collection.</span></span> <span data-ttu-id="08e41-2453">这样可确保对从其他对象派生的集合正确地执行操作。</span><span class="sxs-lookup"><span data-stu-id="08e41-2453">This ensures proper operation of collections that are derived from other objects.</span></span> <span data-ttu-id="08e41-2454">具体而言，它与可能同时修改集合的其他线程保持正确的同步。</span><span class="sxs-lookup"><span data-stu-id="08e41-2454">Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the collection.</span></span> <span data-ttu-id="08e41-2455">请注意，<xref:System.Array.SyncRoot%2A> 的某些实现可能会返回 <xref:System.Array> 本身。</span><span class="sxs-lookup"><span data-stu-id="08e41-2455">Note that some implementations of <xref:System.Array.SyncRoot%2A> might return the <xref:System.Array> itself.</span></span>  
  
 <span data-ttu-id="08e41-2456">枚举集合本质上不是线程安全的过程。</span><span class="sxs-lookup"><span data-stu-id="08e41-2456">Enumerating through a collection is intrinsically not a thread safe procedure.</span></span> <span data-ttu-id="08e41-2457">即使某个集合已同步，其他线程仍可以修改该集合，这会导致枚举数引发异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-2457">Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</span></span> <span data-ttu-id="08e41-2458">若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改所导致的异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-2458">To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</span></span>  
  
 <span data-ttu-id="08e41-2459">检索此属性的值的运算复杂度为 O(1)。</span><span class="sxs-lookup"><span data-stu-id="08e41-2459">Retrieving the value of this property is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-2460">下面的代码示例演示如何使用 <xref:System.Array.SyncRoot%2A> 属性在整个枚举过程中锁定数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-2460">The following code example shows how to lock an array during the entire enumeration by using the <xref:System.Array.SyncRoot%2A> property.</span></span>  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System::Collections::ICollection::Count { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="08e41-2461">获取 <see cref="T:System.Array" /> 中包含的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-2461">Gets the number of elements contained in the <see cref="T:System.Array" />.</span></span></summary>
        <value><span data-ttu-id="08e41-2462">集合中包含的元素数。</span><span class="sxs-lookup"><span data-stu-id="08e41-2462">The number of elements contained in the collection.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-2463">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-2463">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="08e41-2464">它只能在 <xref:System.Array> 实例被强制转换为 <xref:System.Collections.ICollection> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="08e41-2464">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.ICollection> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="08e41-2465">获取一个值，该值指示对 <see cref="T:System.Array" /> 的访问是否同步（线程安全）。</span><span class="sxs-lookup"><span data-stu-id="08e41-2465">Gets a value that indicates whether access to the <see cref="T:System.Array" /> is synchronized (thread safe).</span></span></summary>
        <value><span data-ttu-id="08e41-2466">如果对 <see cref="T:System.Array" /> 的访问是同步的（线程安全），则为 true；否则为 false。</span><span class="sxs-lookup"><span data-stu-id="08e41-2466">true if access to the <see cref="T:System.Array" /> is synchronized (thread safe); otherwise, false.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="08e41-2467">获取可用于同步对 <see cref="T:System.Array" /> 的访问的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-2467">Gets an object that can be used to synchronize access to the <see cref="T:System.Array" />.</span></span></summary>
        <value><span data-ttu-id="08e41-2468">可用于同步对 <see cref="T:System.Array" /> 的访问的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-2468">An object that can be used to synchronize access to the <see cref="T:System.Array" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="08e41-2469">要添加到 <see cref="T:System.Collections.IList" /> 的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-2469">The object to be added to the <see cref="T:System.Collections.IList" />.</span></span></param>
        <summary><span data-ttu-id="08e41-2470">调用此方法始终会引发 <see cref="T:System.NotSupportedException" /> 异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-2470">Calling this method always throws a <see cref="T:System.NotSupportedException" /> exception.</span></span></summary>
        <returns><span data-ttu-id="08e41-2471">不支持向数组添加值。</span><span class="sxs-lookup"><span data-stu-id="08e41-2471">Adding a value to an array is not supported.</span></span> <span data-ttu-id="08e41-2472">不返回任何值。</span><span class="sxs-lookup"><span data-stu-id="08e41-2472">No value is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-2473">通常，<xref:System.Collections.IList.Add%2A?displayProperty=nameWithType> 实现将成员添加到集合中。</span><span class="sxs-lookup"><span data-stu-id="08e41-2473">Ordinarily, an <xref:System.Collections.IList.Add%2A?displayProperty=nameWithType> implementation adds a member to a collection.</span></span> <span data-ttu-id="08e41-2474">但是，由于数组的大小是固定的（<xref:System.Array.IsFixedSize%2A> 属性总是返回 `true`），因此此方法始终引发 <xref:System.NotSupportedException> 异常。</span><span class="sxs-lookup"><span data-stu-id="08e41-2474">However, because arrays have a fixed size (the <xref:System.Array.IsFixedSize%2A> property always returns `true`), this method always throws a <xref:System.NotSupportedException> exception.</span></span>  
  
 <span data-ttu-id="08e41-2475">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-2475">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="08e41-2476">它只能在 <xref:System.Array> 实例被强制转换为 <xref:System.Collections.IList> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="08e41-2476">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="08e41-2477"><see cref="T:System.Collections.IList" /> 具有固定的大小。</span><span class="sxs-lookup"><span data-stu-id="08e41-2477">The <see cref="T:System.Collections.IList" /> has a fixed size.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Clear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="08e41-2478">从 <see cref="T:System.Collections.IList" /> 中移除所有项。</span><span class="sxs-lookup"><span data-stu-id="08e41-2478">Removes all items from the <see cref="T:System.Collections.IList" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-2479">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-2479">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="08e41-2480">它只能在 <xref:System.Array> 实例被强制转换为 <xref:System.Collections.IList> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="08e41-2480">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="08e41-2481"><see cref="T:System.Collections.IList" /> 为只读。</span><span class="sxs-lookup"><span data-stu-id="08e41-2481">The <see cref="T:System.Collections.IList" /> is read-only.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="08e41-2482">要在当前列表中定位的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-2482">The object to locate in the current list.</span></span> <span data-ttu-id="08e41-2483">要定位的元素对于引用类型可以是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-2483">The element to locate can be <see langword="null" /> for reference types.</span></span></param>
        <summary><span data-ttu-id="08e41-2484">确定某元素是否在 <see cref="T:System.Collections.IList" /> 中。</span><span class="sxs-lookup"><span data-stu-id="08e41-2484">Determines whether an element is in the <see cref="T:System.Collections.IList" />.</span></span></summary>
        <returns><span data-ttu-id="08e41-2485">如果在 <see langword="true" /> 中找到 <paramref name="value" />，则为 <see cref="T:System.Collections.IList" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-2485"><see langword="true" /> if <paramref name="value" /> is found in the <see cref="T:System.Collections.IList" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-2486">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-2486">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="08e41-2487">它只能在 <xref:System.Array> 实例被强制转换为 <xref:System.Collections.IList> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="08e41-2487">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="08e41-2488">要在当前列表中定位的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-2488">The object to locate in the current list.</span></span></param>
        <summary><span data-ttu-id="08e41-2489">确定 <see cref="T:System.Collections.IList" /> 中特定项的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-2489">Determines the index of a specific item in the <see cref="T:System.Collections.IList" />.</span></span></summary>
        <returns><span data-ttu-id="08e41-2490">如果在列表中找到，则为值的索引；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="08e41-2490">The index of value if found in the list; otherwise, -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-2491">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-2491">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="08e41-2492">它只能在 <xref:System.Array> 实例被强制转换为 <xref:System.Collections.IList> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="08e41-2492">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="08e41-2493">应插入 <paramref name="value" /> 的索引位置。</span><span class="sxs-lookup"><span data-stu-id="08e41-2493">The index at which <paramref name="value" /> should be inserted.</span></span></param>
        <param name="value"><span data-ttu-id="08e41-2494">要插入的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-2494">The object to insert.</span></span></param>
        <summary><span data-ttu-id="08e41-2495">在 <see cref="T:System.Collections.IList" /> 中的指定索引处插入一个项。</span><span class="sxs-lookup"><span data-stu-id="08e41-2495">Inserts an item to the <see cref="T:System.Collections.IList" /> at the specified index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-2496">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-2496">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="08e41-2497">它只能在 <xref:System.Array> 实例被强制转换为 <xref:System.Collections.IList> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="08e41-2497">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-2498"><paramref name="index" /> 不是 <see cref="T:System.Collections.IList" /> 中的有效索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-2498"><paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.IList" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="08e41-2499"><see cref="T:System.Collections.IList" /> 为只读。</span><span class="sxs-lookup"><span data-stu-id="08e41-2499">The <see cref="T:System.Collections.IList" /> is read-only.</span></span>  
  
<span data-ttu-id="08e41-2500">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2500">-or-</span></span> 
<span data-ttu-id="08e41-2501"><see cref="T:System.Collections.IList" /> 具有固定的大小。</span><span class="sxs-lookup"><span data-stu-id="08e41-2501">The <see cref="T:System.Collections.IList" /> has a fixed size.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="08e41-2502"><paramref name="value" /> 是 <see cref="T:System.Collections.IList" /> 中的 null 引用。</span><span class="sxs-lookup"><span data-stu-id="08e41-2502"><paramref name="value" /> is null reference in the <see cref="T:System.Collections.IList" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="08e41-2503">获取一个值，该值指示 <see cref="T:System.Array" /> 是否具有固定大小。</span><span class="sxs-lookup"><span data-stu-id="08e41-2503">Gets a value that indicates whether the <see cref="T:System.Array" /> has a fixed size.</span></span></summary>
        <value><span data-ttu-id="08e41-2504">如果 <see cref="T:System.Array" /> 具有固定大小，则为 true;否则为 false。</span><span class="sxs-lookup"><span data-stu-id="08e41-2504">true if the <see cref="T:System.Array" /> has a fixed size; otherwise, false.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="08e41-2505">获取一个值，该值指示 <see cref="T:System.Array" /> 是否为只读。</span><span class="sxs-lookup"><span data-stu-id="08e41-2505">Gets a value that indicates whether the <see cref="T:System.Array" /> is read-only.</span></span></summary>
        <value><span data-ttu-id="08e41-2506">如果 <see cref="T:System.Array" /> 是只读的，则为 true;否则为 false。</span><span class="sxs-lookup"><span data-stu-id="08e41-2506">true if the <see cref="T:System.Array" /> is read-only; otherwise, false.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="08e41-2507">要获取或设置的元素的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-2507">The index of the element to get or set.</span></span></param>
        <summary><span data-ttu-id="08e41-2508">获取或设置指定索引处的元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-2508">Gets or sets the element at the specified index.</span></span></summary>
        <value><span data-ttu-id="08e41-2509">指定索引处的元素。</span><span class="sxs-lookup"><span data-stu-id="08e41-2509">The element at the specified index.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-2510">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-2510">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="08e41-2511">它只能在 <xref:System.Array> 实例被强制转换为 <xref:System.Collections.IList> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="08e41-2511">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-2512"><paramref name="index" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="08e41-2512"><paramref name="index" /> is less than zero.</span></span>  
  
<span data-ttu-id="08e41-2513">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2513">-or-</span></span> 
 <span data-ttu-id="08e41-2514"><paramref name="index" /> 等于或大于 <see cref="P:System.Collections.ICollection.Count" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-2514"><paramref name="index" /> is equal to or greater than <see cref="P:System.Collections.ICollection.Count" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="08e41-2515">当前 <see cref="T:System.Array" /> 不是正好具有一个维度。</span><span class="sxs-lookup"><span data-stu-id="08e41-2515">The current <see cref="T:System.Array" /> does not have exactly one dimension.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="08e41-2516">要从 <see cref="T:System.Collections.IList" /> 中删除的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-2516">The object to remove from the <see cref="T:System.Collections.IList" />.</span></span></param>
        <summary><span data-ttu-id="08e41-2517">从 <see cref="T:System.Collections.IList" /> 中移除特定对象的第一个匹配项。</span><span class="sxs-lookup"><span data-stu-id="08e41-2517">Removes the first occurrence of a specific object from the <see cref="T:System.Collections.IList" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-2518">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-2518">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="08e41-2519">它只能在 <xref:System.Array> 实例被强制转换为 <xref:System.Collections.IList> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="08e41-2519">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="08e41-2520"><see cref="T:System.Collections.IList" /> 为只读。</span><span class="sxs-lookup"><span data-stu-id="08e41-2520">The <see cref="T:System.Collections.IList" /> is read-only.</span></span>  
  
<span data-ttu-id="08e41-2521">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2521">-or-</span></span> 
<span data-ttu-id="08e41-2522"><see cref="T:System.Collections.IList" /> 具有固定的大小。</span><span class="sxs-lookup"><span data-stu-id="08e41-2522">The <see cref="T:System.Collections.IList" /> has a fixed size.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.RemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="08e41-2523">要移除的元素的索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-2523">The index of the element to remove.</span></span></param>
        <summary><span data-ttu-id="08e41-2524">移除位于指定索引处的 <see cref="T:System.Collections.IList" /> 项。</span><span class="sxs-lookup"><span data-stu-id="08e41-2524">Removes the <see cref="T:System.Collections.IList" /> item at the specified index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-2525">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-2525">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="08e41-2526">它只能在 <xref:System.Array> 实例被强制转换为 <xref:System.Collections.IList> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="08e41-2526">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="08e41-2527">索引不是 <see cref="T:System.Collections.IList" /> 中的有效索引。</span><span class="sxs-lookup"><span data-stu-id="08e41-2527">index is not a valid index in the <see cref="T:System.Collections.IList" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="08e41-2528"><see cref="T:System.Collections.IList" /> 为只读。</span><span class="sxs-lookup"><span data-stu-id="08e41-2528">The <see cref="T:System.Collections.IList" /> is read-only.</span></span>  
  
<span data-ttu-id="08e41-2529">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2529">-or-</span></span> 
<span data-ttu-id="08e41-2530"><see cref="T:System.Collections.IList" /> 具有固定的大小。</span><span class="sxs-lookup"><span data-stu-id="08e41-2530">The <see cref="T:System.Collections.IList" /> has a fixed size.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="08e41-2531">要与当前实例进行比较的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-2531">The object to compare with the current instance.</span></span></param>
        <param name="comparer"><span data-ttu-id="08e41-2532">一个将当前对象与 <paramref name="other" /> 进行比较的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-2532">An object that compares the current object and <paramref name="other" />.</span></span></param>
        <summary><span data-ttu-id="08e41-2533">确定当前集合对象在排序顺序中的位置是位于另一个对象之前、之后还是与其位置相同。</span><span class="sxs-lookup"><span data-stu-id="08e41-2533">Determines whether the current collection object precedes, occurs in the same position as, or follows another object in the sort order.</span></span></summary>
        <returns><span data-ttu-id="08e41-2534">一个指示当前集合对象与其他对象的关系的整数，如下表所示。</span><span class="sxs-lookup"><span data-stu-id="08e41-2534">An integer that indicates the relationship of the current collection object to other, as shown in the following table.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="08e41-2535">返回值</span><span class="sxs-lookup"><span data-stu-id="08e41-2535">Return value</span></span> 
 </term><description> <span data-ttu-id="08e41-2536">说明</span><span class="sxs-lookup"><span data-stu-id="08e41-2536">Description</span></span> 
 </description></listheader><item><term> <span data-ttu-id="08e41-2537">-1</span><span class="sxs-lookup"><span data-stu-id="08e41-2537">-1</span></span> 
 </term><description> <span data-ttu-id="08e41-2538">当前实例位于 <paramref name="other" /> 之前。</span><span class="sxs-lookup"><span data-stu-id="08e41-2538">The current instance precedes <paramref name="other" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="08e41-2539">0</span><span class="sxs-lookup"><span data-stu-id="08e41-2539">0</span></span> 
 </term><description> <span data-ttu-id="08e41-2540">当前实例与 <paramref name="other" /> 位于同一位置。</span><span class="sxs-lookup"><span data-stu-id="08e41-2540">The current instance and <paramref name="other" /> are equal.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="08e41-2541">1</span><span class="sxs-lookup"><span data-stu-id="08e41-2541">1</span></span> 
 </term><description> <span data-ttu-id="08e41-2542">当前实例位于 <paramref name="other" /> 之后。</span><span class="sxs-lookup"><span data-stu-id="08e41-2542">The current instance follows <paramref name="other" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-2543">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-2543">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="08e41-2544">它只能在 <xref:System.Array> 实例被强制转换为 <xref:System.Collections.IStructuralComparable> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="08e41-2544">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IStructuralComparable> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="08e41-2545">要与当前实例进行比较的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-2545">The object to compare with the current instance.</span></span></param>
        <param name="comparer"><span data-ttu-id="08e41-2546">一个可确定当前实例与 <paramref name="other" /> 是否相等的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-2546">An object that determines whether the current instance and <paramref name="other" /> are equal.</span></span></param>
        <summary><span data-ttu-id="08e41-2547">确定某个对象与当前实例是否相等。</span><span class="sxs-lookup"><span data-stu-id="08e41-2547">Determines whether an object is equal to the current instance.</span></span></summary>
        <returns><span data-ttu-id="08e41-2548">如果两个对象相等，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-2548"><see langword="true" /> if the two objects are equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-2549">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-2549">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="08e41-2550">它只能在 <xref:System.Array> 实例被强制转换为 <xref:System.Collections.IStructuralEquatable> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="08e41-2550">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IStructuralEquatable> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="comparer"><span data-ttu-id="08e41-2551">一个计算当前对象的哈希代码的对象。</span><span class="sxs-lookup"><span data-stu-id="08e41-2551">An object that computes the hash code of the current object.</span></span></param>
        <summary><span data-ttu-id="08e41-2552">返回当前实例的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="08e41-2552">Returns a hash code for the current instance.</span></span></summary>
        <returns><span data-ttu-id="08e41-2553">当前实例的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="08e41-2553">The hash code for the current instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-2554">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="08e41-2554">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="08e41-2555">它只能在 <xref:System.Array> 实例被强制转换为 <xref:System.Collections.IStructuralEquatable> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="08e41-2555">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IStructuralEquatable> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TrueForAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TrueForAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrueForAll(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TrueForAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member TrueForAll : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.TrueForAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="08e41-2556">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="08e41-2556">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="08e41-2557">要对照条件进行检查的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-2557">The one-dimensional, zero-based <see cref="T:System.Array" /> to check against the conditions.</span></span></param>
        <param name="match"><span data-ttu-id="08e41-2558">用于定义检查元素时要对照的条件的谓词。</span><span class="sxs-lookup"><span data-stu-id="08e41-2558">The predicate that defines the conditions to check against the elements.</span></span></param>
        <summary><span data-ttu-id="08e41-2559">确定数组中的每个元素是否都与指定谓词定义的条件匹配。</span><span class="sxs-lookup"><span data-stu-id="08e41-2559">Determines whether every element in the array matches the conditions defined by the specified predicate.</span></span></summary>
        <returns><span data-ttu-id="08e41-2560">如果 <paramref name="array" /> 中的每个元素都与指定谓词定义的条件匹配，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-2560"><see langword="true" /> if every element in <paramref name="array" /> matches the conditions defined by the specified predicate; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="08e41-2561">如果数组中没有元素，则返回值为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-2561">If there are no elements in the array, the return value is <see langword="true" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="08e41-2562"><xref:System.Predicate%601> 是一个方法委托，如果传递给它的对象与委托中定义的条件相匹配，则该方法将返回`true`。</span><span class="sxs-lookup"><span data-stu-id="08e41-2562">The <xref:System.Predicate%601> is a delegate to a method that returns`true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="08e41-2563">`array` 的元素分别传递到 <xref:System.Predicate%601>，并且当委托为任何元素返回 `false` 时，将停止处理。</span><span class="sxs-lookup"><span data-stu-id="08e41-2563">The elements of `array` are individually passed to the <xref:System.Predicate%601>, and processing is stopped when the delegate returns `false` for any element.</span></span>  
  
 <span data-ttu-id="08e41-2564">此方法是一个 O （`n`）操作，其中 `n` 是 `array`的 <xref:System.Array.Length%2A>。</span><span class="sxs-lookup"><span data-stu-id="08e41-2564">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="08e41-2565">下面的示例确定字符串数组中每个元素的最后一个字符是否为数字。</span><span class="sxs-lookup"><span data-stu-id="08e41-2565">The following example determines whether the last character of each element in a string array is a number.</span></span> <span data-ttu-id="08e41-2566">它创建两个字符串数组。</span><span class="sxs-lookup"><span data-stu-id="08e41-2566">It creates two string arrays.</span></span> <span data-ttu-id="08e41-2567">第一个数组包含以字母字符结尾的字符串，以及以数字字符结尾的字符串。第二个数组仅包含以数字字符结尾的字符串。</span><span class="sxs-lookup"><span data-stu-id="08e41-2567">The first array includes both strings that end with alphabetic characters and strings that end with numeric characters.The second array consists only of strings that end with numeric characters.</span></span> <span data-ttu-id="08e41-2568">该示例还定义一个 `EndWithANumber` 方法，该方法的签名与 <xref:System.Predicate%601> 委托匹配。</span><span class="sxs-lookup"><span data-stu-id="08e41-2568">The example also defines an `EndWithANumber` method whose signature matches the <xref:System.Predicate%601> delegate.</span></span> <span data-ttu-id="08e41-2569">该示例将每个数组传递到 <xref:System.Array.TrueForAll%2A> 方法以及表示 `EndsWithANumber` 方法的委托。</span><span class="sxs-lookup"><span data-stu-id="08e41-2569">The example passes each array to the <xref:System.Array.TrueForAll%2A> method along with a delegate that represents the `EndsWithANumber` method.</span></span>  
  
 [!code-csharp[System.Array.TrueForAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall2.cs#2)]
 [!code-vb[System.Array.TrueForAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall2.vb#2)]  
  
 <span data-ttu-id="08e41-2570">下面的示例与第一个示例类似，不同之处在于，它将字符串数组传递到 <xref:System.Array.TrueForAll%2A> 方法，并使用 lambda 表达式来确定特定数组元素是否以数字的字符串表示形式结束。</span><span class="sxs-lookup"><span data-stu-id="08e41-2570">The following example is similar to the first, except that it passes the string array to the <xref:System.Array.TrueForAll%2A> method along with  a lambda expression that determines whether a particular array element ends with the string representation of a number.</span></span>  
  
 [!code-csharp[System.Array.TrueForAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall1.cs#1)]
 [!code-vb[System.Array.TrueForAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall1.vb#1)]  
  
 <span data-ttu-id="08e41-2571">在这两种情况下，只要遇到不以数字结尾的第一个数组元素，<xref:System.Array.TrueForAll%2A> 方法就会立即返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="08e41-2571">In both cases, the <xref:System.Array.TrueForAll%2A> method returns `false` as soon as it encounters the first array element that does not end in a number.</span></span> <span data-ttu-id="08e41-2572">否则，它将在循环访问数组中的所有元素后返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="08e41-2572">Otherwise, it returns `true` after iterating all the elements in the array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08e41-2573">由于两个示例都显示C# ，在和 Visual Basic 中，无需显式创建 `Predicate<string>` 委托（`Predicate(Of String)` Visual Basic）。</span><span class="sxs-lookup"><span data-stu-id="08e41-2573">As both examples show, in C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="08e41-2574">这些语言从上下文推断正确的委托并自动创建它。</span><span class="sxs-lookup"><span data-stu-id="08e41-2574">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="08e41-2575"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-2575"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="08e41-2576">或</span><span class="sxs-lookup"><span data-stu-id="08e41-2576">-or-</span></span> 
 <span data-ttu-id="08e41-2577"><paramref name="match" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="08e41-2577"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>
