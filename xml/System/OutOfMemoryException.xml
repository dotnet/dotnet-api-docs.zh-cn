<Type Name="OutOfMemoryException" FullName="System.OutOfMemoryException">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7685b8076d8e5170feac7c6bd842dbc50c1195a4" /><Meta Name="ms.sourcegitcommit" Value="9a0316374d19cc78674994106d073aa5ef1bd5f3" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="11/10/2020" /><Meta Name="ms.locfileid" Value="94456939" /></Metadata><TypeSignature Language="C#" Value="public class OutOfMemoryException : Exception" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OutOfMemoryException extends System.Exception" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="DocId" Value="T:System.OutOfMemoryException" />
  <TypeSignature Language="VB.NET" Value="Public Class OutOfMemoryException&#xA;Inherits Exception" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C++ CLI" Value="public ref class OutOfMemoryException : Exception" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="F#" Value="type OutOfMemoryException = class&#xA;    inherit Exception" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C#" Value="public class OutOfMemoryException : SystemException" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OutOfMemoryException extends System.SystemException" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="VB.NET" Value="Public Class OutOfMemoryException&#xA;Inherits SystemException" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class OutOfMemoryException : SystemException" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type OutOfMemoryException = class&#xA;    inherit SystemException" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit OutOfMemoryException extends System.SystemException" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Exception</BaseTypeName>
    <BaseTypeName FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">System.SystemException</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="46419-101">没有足够的内存继续执行程序时引发的异常。</span><span class="sxs-lookup"><span data-stu-id="46419-101">The exception that is thrown when there is not enough memory to continue the execution of a program.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="46419-102"><xref:System.OutOfMemoryException> 使用 `COR_E_OUTOFMEMORY` 具有值0x8007000E 的 HRESULT。</span><span class="sxs-lookup"><span data-stu-id="46419-102"><xref:System.OutOfMemoryException> uses the HRESULT `COR_E_OUTOFMEMORY`, which has the value 0x8007000E.</span></span>  
  
<span data-ttu-id="46419-103">有关实例的初始属性值的列表<xref:System.OutOfMemoryException>，请参阅<xref:System.OutOfMemoryException.%23ctor%2A>构造函数。</span><span class="sxs-lookup"><span data-stu-id="46419-103">For a list of initial property values for an instance of <xref:System.OutOfMemoryException>, see the <xref:System.OutOfMemoryException.%23ctor%2A> constructors.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="46419-104">继承属性的值 <xref:System.Exception.Data%2A> 始终为 `null` 。</span><span class="sxs-lookup"><span data-stu-id="46419-104">The value of the inherited <xref:System.Exception.Data%2A> property is always `null`.</span></span>  
  
<span data-ttu-id="46419-105"><xref:System.OutOfMemoryException>异常有两个主要原因：</span><span class="sxs-lookup"><span data-stu-id="46419-105">An <xref:System.OutOfMemoryException> exception has two major causes:</span></span>  
  
-   <span data-ttu-id="46419-106">你正试图展开一个 <xref:System.Text.StringBuilder> 超出其属性所定义的长度的对象 <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="46419-106">You are attempting to expand a <xref:System.Text.StringBuilder> object beyond the length defined by its <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType> property.</span></span>  
  
-   <span data-ttu-id="46419-107">公共语言运行时无法分配足够的连续内存来成功执行操作。</span><span class="sxs-lookup"><span data-stu-id="46419-107">The common language runtime cannot allocate enough contiguous memory to successfully perform an operation.</span></span> <span data-ttu-id="46419-108">需要内存分配的任何属性赋值或方法调用都可能引发此异常。</span><span class="sxs-lookup"><span data-stu-id="46419-108">This exception can be thrown by any property assignment or method call that requires a memory allocation.</span></span> <span data-ttu-id="46419-109">有关异常原因的详细信息 <xref:System.OutOfMemoryException> ，请参阅博客文章 ["内存不足" 不引用物理内存](https://docs.microsoft.com/archive/blogs/ericlippert/out-of-memory-does-not-refer-to-physical-memory)。</span><span class="sxs-lookup"><span data-stu-id="46419-109">For more information on the cause of the <xref:System.OutOfMemoryException> exception, see the blog post ["Out of Memory" Does Not Refer to Physical Memory](https://docs.microsoft.com/archive/blogs/ericlippert/out-of-memory-does-not-refer-to-physical-memory).</span></span>  
  
     <span data-ttu-id="46419-110">此类型的 <xref:System.OutOfMemoryException> 异常表示灾难性故障。</span><span class="sxs-lookup"><span data-stu-id="46419-110">This type of <xref:System.OutOfMemoryException> exception represents a catastrophic failure.</span></span> <span data-ttu-id="46419-111">如果选择处理异常，则应包括一个 `catch` 调用方法的块 <xref:System.Environment.FailFast%2A?displayProperty=nameWithType> 以终止应用程序，并向系统事件日志中添加一个条目，如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="46419-111">If you choose to handle the exception, you should include a `catch` block that calls the <xref:System.Environment.FailFast%2A?displayProperty=nameWithType> method to terminate your app and add an entry to the system event log, as the following example does.</span></span>  
  
     [!code-csharp[System.OutOfMemoryException#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.outofmemoryexception/cs/failfast1.cs#2)]
     [!code-vb[System.OutOfMemoryException#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.outofmemoryexception/vb/failfast1.vb#2)]  
  
 <span data-ttu-id="46419-112">引发异常的一些条件，以及可以采取哪些措施来消除异常，包括以下各项：</span><span class="sxs-lookup"><span data-stu-id="46419-112">Some of the conditions under which the exception is thrown and the actions you can take to eliminate it include the following:</span></span>  
  
<span data-ttu-id="46419-113">**正在调用 <xref:System.Text.StringBuilder.Insert%2A?displayProperty=nameWithType> 方法。**</span><span class="sxs-lookup"><span data-stu-id="46419-113">**You are calling the <xref:System.Text.StringBuilder.Insert%2A?displayProperty=nameWithType> method.**</span></span>  

<span data-ttu-id="46419-114">尝试增加对象的长度 <xref:System.Text.StringBuilder> 超出其属性指定的大小 <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="46419-114">You are attempting to increase the length of a <xref:System.Text.StringBuilder> object beyond the size specified by its <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="46419-115">下面的示例演示 <xref:System.OutOfMemoryException> <xref:System.Text.StringBuilder.Insert%28System.Int32%2CSystem.String%2CSystem.Int32%29?displayProperty=nameWithType> 当示例尝试插入将导致对象的 <xref:System.Text.StringBuilder.Length%2A> 属性超过其最大容量的字符串时，调用方法所引发的异常。</span><span class="sxs-lookup"><span data-stu-id="46419-115">The following example illustrates the <xref:System.OutOfMemoryException> exception thrown by a call to the <xref:System.Text.StringBuilder.Insert%28System.Int32%2CSystem.String%2CSystem.Int32%29?displayProperty=nameWithType> method when the example tries to insert a string that would cause the object's <xref:System.Text.StringBuilder.Length%2A> property to exceed its maximum capacity.</span></span>  
  
[!code-csharp[System.OutOfMemoryException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.outofmemoryexception/cs/sb_example1.cs#1)]
[!code-vb[System.OutOfMemoryException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.outofmemoryexception/vb/sb_example1.vb#1)]  
  
<span data-ttu-id="46419-116">可以执行以下任一操作来解决该错误：</span><span class="sxs-lookup"><span data-stu-id="46419-116">You can do either of the following to address the error:</span></span>  
  
-   <span data-ttu-id="46419-117">将对构造函数的调用替换为 <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 调用任何其他 <xref:System.Text.StringBuilder> 构造函数重载。</span><span class="sxs-lookup"><span data-stu-id="46419-117">Replace the call to the <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> constructor with a call any other <xref:System.Text.StringBuilder> constructor overload.</span></span> <span data-ttu-id="46419-118">对象的最大容量将 <xref:System.Text.StringBuilder> 设置为其默认值，即 <xref:System.Int32.MaxValue?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="46419-118">The maximum capacity of your <xref:System.Text.StringBuilder> object will be set to its default value, which is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  

-   <span data-ttu-id="46419-119"><xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType>使用足够大的值调用构造函数， `maxCapacity` 以容纳到对象的任何扩展 <xref:System.Text.StringBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="46419-119">Call the <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> constructor with a `maxCapacity` value that is large enough to accommodate any expansions to the <xref:System.Text.StringBuilder> object.</span></span>  
  
<span data-ttu-id="46419-120">**您的应用程序作为32位进程运行。**</span><span class="sxs-lookup"><span data-stu-id="46419-120">**Your app runs as a 32-bit process.**</span></span>

<span data-ttu-id="46419-121">32位进程最多可以在32位系统上分配2GB 的虚拟用户模式内存，在64位系统上分配4GB 的虚拟用户模式内存。</span><span class="sxs-lookup"><span data-stu-id="46419-121">32-bit processes can allocate a maximum of 2GB of virtual user-mode memory on 32-bit systems, and 4GB of virtual user-mode memory on 64-bit systems.</span></span> <span data-ttu-id="46419-122">这会使公共语言运行时在需要大量分配时更难分配足够的连续内存。</span><span class="sxs-lookup"><span data-stu-id="46419-122">This can make it more difficult for the common language runtime to allocate sufficient contiguous memory when a large allocation is needed.</span></span> <span data-ttu-id="46419-123">与此相反，64位进程最多可分配8TB 的虚拟内存。</span><span class="sxs-lookup"><span data-stu-id="46419-123">In contrast, 64-bit processes can allocate up to 8TB of virtual memory.</span></span> <span data-ttu-id="46419-124">若要解决此异常，请重新编译你的应用以面向64位平台。</span><span class="sxs-lookup"><span data-stu-id="46419-124">To address this exception, recompile your app to target a 64-bit platform.</span></span> <span data-ttu-id="46419-125">有关在 Visual Studio 中面向特定平台的信息，请参阅 [如何：配置项目以面向目标平台](/visualstudio/ide/how-to-configure-projects-to-target-platforms)。</span><span class="sxs-lookup"><span data-stu-id="46419-125">For information on targeting specific platforms in Visual Studio, see [How to: Configure Projects to Target Platforms](/visualstudio/ide/how-to-configure-projects-to-target-platforms).</span></span>  
  
<span data-ttu-id="46419-126">**应用正在泄漏非托管资源**</span><span class="sxs-lookup"><span data-stu-id="46419-126">**Your app is leaking unmanaged resources**</span></span> 

<span data-ttu-id="46419-127">虽然垃圾回收器能够释放分配给托管类型的内存，但它不管理分配给非托管资源（例如操作系统句柄）的内存， (包括文件、内存映射文件、管道、注册表项和等待句柄的句柄) 和由 Windows API 调用直接分配的内存块，或通过调用内存分配函数（如） `malloc` 。</span><span class="sxs-lookup"><span data-stu-id="46419-127">Although the garbage collector is able to free memory allocated to managed types, it does not manage memory allocated to unmanaged resources such as operating system handles (including handles to files, memory-mapped files, pipes, registry keys, and wait handles) and memory blocks allocated directly by Windows API calls or by calls to memory allocation functions such as `malloc`.</span></span> <span data-ttu-id="46419-128">使用非托管资源的类型实现 <xref:System.IDisposable> 接口。</span><span class="sxs-lookup"><span data-stu-id="46419-128">Types that consume unmanaged resources implement the <xref:System.IDisposable> interface.</span></span>  

<span data-ttu-id="46419-129">如果你使用的是使用非托管资源的类型，则应确保在使用完该类型后调用其 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="46419-129">If you are consuming a type that uses unmanaged resources, you should be sure to call its <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method when you have finished using it.</span></span> <span data-ttu-id="46419-130"> (某些类型还实现了 `Close` 在函数中与方法相同的方法 `Dispose` 。 ) 有关详细信息，请参阅 [使用实现 IDisposable 的对象](/dotnet/standard/garbage-collection/using-objects) 主题。</span><span class="sxs-lookup"><span data-stu-id="46419-130">(Some types also implement a `Close` method that is identical in function to a `Dispose` method.) For more information, see the [Using Objects That Implement IDisposable](/dotnet/standard/garbage-collection/using-objects) topic.</span></span>  

<span data-ttu-id="46419-131">如果已创建使用非托管资源的类型，请确保已实现 Dispose 模式，并在必要时提供终结器。</span><span class="sxs-lookup"><span data-stu-id="46419-131">If you have created a type that uses unmanaged resources, make sure that you have implemented the Dispose pattern and, if necessary, supplied a finalizer.</span></span> <span data-ttu-id="46419-132">有关详细信息，请参阅  [实现 Dispose 方法](/dotnet/standard/garbage-collection/implementing-dispose) 和 <xref:System.Object.Finalize%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="46419-132">For more information, see  [Implementing a Dispose method](/dotnet/standard/garbage-collection/implementing-dispose) and <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span>  
  
<span data-ttu-id="46419-133">**你正在尝试在64位进程中创建一个大型数组**</span><span class="sxs-lookup"><span data-stu-id="46419-133">**You are attempting to create a large array in a 64-bit process**</span></span>

<span data-ttu-id="46419-134">默认情况下，.NET Framework 中的公共语言运行时不允许大小超过2GB 的单个对象。</span><span class="sxs-lookup"><span data-stu-id="46419-134">By default, the common language runtime in .NET Framework does not allow single objects whose size exceeds 2GB.</span></span> <span data-ttu-id="46419-135">若要替代此默认值，可以使用 [\<gcAllowVeryLargeObjects>](/dotnet/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element) 配置文件设置来启用总计大小超过 2 GB 的数组。</span><span class="sxs-lookup"><span data-stu-id="46419-135">To override this default, you can use the [\<gcAllowVeryLargeObjects>](/dotnet/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element) configuration file setting to enable arrays whose total size exceeds 2 GB.</span></span> <span data-ttu-id="46419-136">在 .NET Core 中，默认情况下会启用支持大于 2 GB 的数组。</span><span class="sxs-lookup"><span data-stu-id="46419-136">On .NET Core, support for arrays of greater than 2 GB is enabled by default.</span></span> 
  
<span data-ttu-id="46419-137">**你使用的是大量的数据 (如) 内存中的数组、集合或数据库数据集。**</span><span class="sxs-lookup"><span data-stu-id="46419-137">**You are working with very large sets of data (such as arrays, collections, or database data sets) in memory.**</span></span>

<span data-ttu-id="46419-138">当内存中驻留的数据结构或数据集变得很大时，公共语言运行时无法为它们分配足够的连续内存时，会 <xref:System.OutOfMemoryException> 产生异常。</span><span class="sxs-lookup"><span data-stu-id="46419-138">When data structures or data sets that reside in memory become so large that the common language runtime is unable to allocate enough contiguous memory for them, an <xref:System.OutOfMemoryException> exception results.</span></span>  

<span data-ttu-id="46419-139">若要防止这些 <xref:System.OutOfMemoryException> 异常，必须修改应用程序，以便减少内存中驻留的数据，或将数据分成需要较小的内存分配的段。</span><span class="sxs-lookup"><span data-stu-id="46419-139">To prevent the <xref:System.OutOfMemoryException> exceptions, you must modify your application so that less data is resident in memory, or the data is divided into segments that require smaller memory allocations.</span></span> <span data-ttu-id="46419-140">例如：</span><span class="sxs-lookup"><span data-stu-id="46419-140">For example:</span></span>  

-   <span data-ttu-id="46419-141">如果要从数据库中检索所有数据，然后在应用程序中对其进行筛选，以最大程度地减少到服务器的往返，则应修改查询以仅返回应用程序所需的数据的子集。</span><span class="sxs-lookup"><span data-stu-id="46419-141">If you are retrieving all of the data from a database and then filtering it in your app to minimize trips to the server, you should modify your queries to return only the subset of data that your app needs.</span></span> <span data-ttu-id="46419-142">处理大型表时，多个查询几乎始终比检索单个表中的所有数据，然后对其进行操作的效率更高。</span><span class="sxs-lookup"><span data-stu-id="46419-142">When working with large tables, multiple queries are almost always more efficient than retrieving all of the data in a single table and then manipulating it.</span></span>  

-   <span data-ttu-id="46419-143">如果执行的是用户动态创建的查询，则应确保查询返回的记录数受到限制。</span><span class="sxs-lookup"><span data-stu-id="46419-143">If you are executing queries that users create dynamically, you should ensure that the number of records returned by the query is limited.</span></span>  

-   <span data-ttu-id="46419-144">如果你使用的大型数组或其他集合对象的大小会导致 <xref:System.OutOfMemoryException> 异常，则应该将应用程序修改为使用子集来处理数据，而不是一次处理所有数据。</span><span class="sxs-lookup"><span data-stu-id="46419-144">If you are using large arrays or other collection objects whose size results in an <xref:System.OutOfMemoryException> exception, you should modify your application to work the data in subsets rather than to work with it all at once.</span></span>  
  
<span data-ttu-id="46419-145">下面的示例获取一个包含200000000浮点值的数组，然后计算其平均值。</span><span class="sxs-lookup"><span data-stu-id="46419-145">The following example gets a array that consists of 200 million floating-point values and then calculates their mean.</span></span> <span data-ttu-id="46419-146">该示例的输出显示，因为该示例在计算平均值之前将整个数组存储在内存中，因此 <xref:System.OutOfMemoryException> 将引发。</span><span class="sxs-lookup"><span data-stu-id="46419-146">The output from the example shows that, because the example stores the entire array in memory before it calculates the mean, an <xref:System.OutOfMemoryException> is thrown.</span></span>  

[!code-csharp[System.OutOfMemoryException#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.outofmemoryexception/cs/data1.cs#3)]
[!code-vb[System.OutOfMemoryException#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.outofmemoryexception/vb/data1.vb#3)]  
  
<span data-ttu-id="46419-147">下面的示例 <xref:System.OutOfMemoryException> 通过处理传入的数据而无需将整个数据集存储在内存中，将数据序列化为文件（如有必要） (来消除异常，因为在此情况下，它们生成的文件的大小大于 1gb) ，并将计算出的平均值和事例数返回到调用例程。</span><span class="sxs-lookup"><span data-stu-id="46419-147">The following example eliminates the <xref:System.OutOfMemoryException> exception by processing the incoming data without storing the entire data set in memory, serializing the data to a file if necessary to permit further processing (these lines are commented out in the example, since in this case they produce a file whose size is greater than 1GB), and returning the calculated mean and the number of cases to the calling routine.</span></span>  

[!code-csharp[System.OutOfMemoryException#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.outofmemoryexception/cs/data2.cs#4)]
[!code-vb[System.OutOfMemoryException#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.outofmemoryexception/vb/data2.vb#4)]  
  
<span data-ttu-id="46419-148">**你要反复串联大型字符串。**</span><span class="sxs-lookup"><span data-stu-id="46419-148">**You are repeatedly concatenating large strings.**</span></span> 

<span data-ttu-id="46419-149">因为字符串是不可变的，所以每个字符串串联操作都会创建一个新字符串。</span><span class="sxs-lookup"><span data-stu-id="46419-149">Because strings are immutable, each string concatenation operation creates a new string.</span></span> <span data-ttu-id="46419-150">对于小字符串或少量串联操作的影响，可忽略不计。</span><span class="sxs-lookup"><span data-stu-id="46419-150">The impact for small strings, or for a small number of concatenation operations, is negligible.</span></span> <span data-ttu-id="46419-151">但对于大型字符串或大量串联操作，字符串连接可能会导致大量的内存分配和内存碎片，并导致性能不佳，还可能出现 <xref:System.OutOfMemoryException> 异常。</span><span class="sxs-lookup"><span data-stu-id="46419-151">But for large strings or a very large number of concatenation operations, string concatenation can lead to a large number of memory allocations and memory fragmentation, poor performance, and possibly <xref:System.OutOfMemoryException> exceptions.</span></span>  

<span data-ttu-id="46419-152">在连接大型字符串或执行大量串联操作时，应使用 <xref:System.Text.StringBuilder> 类，而不是 <xref:System.String> 类。</span><span class="sxs-lookup"><span data-stu-id="46419-152">When concatenating large strings or performing a large number of concatenation operations, you should use the <xref:System.Text.StringBuilder> class instead of the <xref:System.String> class.</span></span> <span data-ttu-id="46419-153">完成操作字符串后， <xref:System.Text.StringBuilder> 通过调用方法将实例转换为字符串 <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="46419-153">When you have finished manipulating the string, convert the <xref:System.Text.StringBuilder> instance to a string by calling the <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
<span data-ttu-id="46419-154">**将大量对象固定在内存中。**</span><span class="sxs-lookup"><span data-stu-id="46419-154">**You pin a large number of objects in memory.**</span></span>  
 
<span data-ttu-id="46419-155">长时间将大量对象固定在内存中可能会使垃圾回收器难以分配连续的内存块。</span><span class="sxs-lookup"><span data-stu-id="46419-155">Pinning a large number of objects in memory for long periods can make it difficult for the garbage collector to allocate contiguous blocks of memory.</span></span> <span data-ttu-id="46419-156">如果在内存中固定了大量对象（例如，使用 `fixed` c # 中的语句或通过使用的 <xref:System.Runtime.InteropServices.GCHandle.Alloc%28System.Object%2CSystem.Runtime.InteropServices.GCHandleType%29?displayProperty=nameWithType> 句柄类型调用方法 <xref:System.Runtime.InteropServices.GCHandleType.Pinned?displayProperty=nameWithType> ），则可以执行以下操作来解决 <xref:System.OutOfMemoryException> 异常。</span><span class="sxs-lookup"><span data-stu-id="46419-156">If you've pinned a large number of objects in memory, for example by using the `fixed` statement in C# or by calling the <xref:System.Runtime.InteropServices.GCHandle.Alloc%28System.Object%2CSystem.Runtime.InteropServices.GCHandleType%29?displayProperty=nameWithType> method with a handle type of <xref:System.Runtime.InteropServices.GCHandleType.Pinned?displayProperty=nameWithType>, you can do the following to address the <xref:System.OutOfMemoryException> exception.</span></span>  
  
-   <span data-ttu-id="46419-157">评估是否确实需要固定每个对象，</span><span class="sxs-lookup"><span data-stu-id="46419-157">Evaluate whether each object really needs to be pinned,</span></span>  

-   <span data-ttu-id="46419-158">确保每个对象尽快取消固定。</span><span class="sxs-lookup"><span data-stu-id="46419-158">Ensure that each object is unpinned as soon as possible.</span></span>  

-   <span data-ttu-id="46419-159">确保每次调用 <xref:System.Runtime.InteropServices.GCHandle.Alloc%28System.Object%2CSystem.Runtime.InteropServices.GCHandleType%29?displayProperty=nameWithType> 方法以固定内存时都有相应的 <xref:System.Runtime.InteropServices.GCHandle.Free%2A?displayProperty=nameWithType> 方法调用方法来取消固定该内存。</span><span class="sxs-lookup"><span data-stu-id="46419-159">Make sure that each call to the <xref:System.Runtime.InteropServices.GCHandle.Alloc%28System.Object%2CSystem.Runtime.InteropServices.GCHandleType%29?displayProperty=nameWithType> method to pin memory has a corresponding call to the <xref:System.Runtime.InteropServices.GCHandle.Free%2A?displayProperty=nameWithType> method to unpin that memory.</span></span>  

<span data-ttu-id="46419-160">以下 Microsoft 中间 (MSIL) 指令引发 <xref:System.OutOfMemoryException> 异常：</span><span class="sxs-lookup"><span data-stu-id="46419-160">The following Microsoft intermediate (MSIL) instructions throw an <xref:System.OutOfMemoryException> exception:</span></span>  
  
-   [<span data-ttu-id="46419-161">文本框</span><span class="sxs-lookup"><span data-stu-id="46419-161">box</span></span>](xref:System.Reflection.Emit.OpCodes.Box)  
-   [<span data-ttu-id="46419-162">newarr</span><span class="sxs-lookup"><span data-stu-id="46419-162">newarr</span></span>](xref:System.Reflection.Emit.OpCodes.Newarr)  
-   [<span data-ttu-id="46419-163">newobj</span><span class="sxs-lookup"><span data-stu-id="46419-163">newobj</span></span>](xref:System.Reflection.Emit.OpCodes.Newobj)  


 ]]></format>
    </remarks>
    <altmember cref="T:System.Exception" />
    <related type="Article" href="/dotnet/standard/exceptions/"><span data-ttu-id="46419-164">处理和引发异常</span><span class="sxs-lookup"><span data-stu-id="46419-164">Handling and Throwing Exceptions</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="46419-165">初始化 <see cref="T:System.OutOfMemoryException" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="46419-165">Initializes a new instance of the <see cref="T:System.OutOfMemoryException" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OutOfMemoryException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.OutOfMemoryException.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; OutOfMemoryException();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="46419-166">初始化 <see cref="T:System.OutOfMemoryException" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="46419-166">Initializes a new instance of the <see cref="T:System.OutOfMemoryException" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46419-167">此构造函数将 <xref:System.Exception.Message%2A> 新实例的属性初始化为系统提供的描述错误的消息，如 "没有足够的内存继续执行程序"。</span><span class="sxs-lookup"><span data-stu-id="46419-167">This constructor initializes the <xref:System.Exception.Message%2A> property of the new instance to a system-supplied message that describes the error, such as "There was not enough memory to continue the execution of the program."</span></span> <span data-ttu-id="46419-168">此消息会考虑当前系统区域性。</span><span class="sxs-lookup"><span data-stu-id="46419-168">This message takes into account the current system culture.</span></span>  
  
 <span data-ttu-id="46419-169">下表显示了 <xref:System.OutOfMemoryException> 实例的初始属性值。</span><span class="sxs-lookup"><span data-stu-id="46419-169">The following table shows the initial property values for an instance of <xref:System.OutOfMemoryException>.</span></span>  
  
|<span data-ttu-id="46419-170">properties</span><span class="sxs-lookup"><span data-stu-id="46419-170">Property</span></span>|<span data-ttu-id="46419-171">值</span><span class="sxs-lookup"><span data-stu-id="46419-171">Value</span></span>|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|<span data-ttu-id="46419-172">`null`.</span><span class="sxs-lookup"><span data-stu-id="46419-172">`null`.</span></span>|  
|<xref:System.Exception.Message%2A>|<span data-ttu-id="46419-173">本地化的错误消息字符串。</span><span class="sxs-lookup"><span data-stu-id="46419-173">The localized error message string.</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OutOfMemoryException (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.OutOfMemoryException.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; OutOfMemoryException(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new OutOfMemoryException : string -&gt; OutOfMemoryException" Usage="new System.OutOfMemoryException message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message"><span data-ttu-id="46419-174">描述错误的消息。</span><span class="sxs-lookup"><span data-stu-id="46419-174">The message that describes the error.</span></span></param>
        <summary><span data-ttu-id="46419-175">用指定的错误消息初始化 <see cref="T:System.OutOfMemoryException" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="46419-175">Initializes a new instance of the <see cref="T:System.OutOfMemoryException" /> class with a specified error message.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46419-176">`message` 参数的内容应为人所理解。</span><span class="sxs-lookup"><span data-stu-id="46419-176">The content of the `message` parameter is intended to be understood by humans.</span></span> <span data-ttu-id="46419-177">此构造函数的调用方需要确保此字符串已针对当前系统区域性进行了本地化。</span><span class="sxs-lookup"><span data-stu-id="46419-177">The caller of this constructor is required to ensure that this string has been localized for the current system culture.</span></span>  
  
 <span data-ttu-id="46419-178">下表显示了 <xref:System.OutOfMemoryException> 实例的初始属性值。</span><span class="sxs-lookup"><span data-stu-id="46419-178">The following table shows the initial property values for an instance of <xref:System.OutOfMemoryException>.</span></span>  
  
|<span data-ttu-id="46419-179">properties</span><span class="sxs-lookup"><span data-stu-id="46419-179">Property</span></span>|<span data-ttu-id="46419-180">值</span><span class="sxs-lookup"><span data-stu-id="46419-180">Value</span></span>|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|<span data-ttu-id="46419-181">空引用（在 Visual Basic 中为 `Nothing`）。</span><span class="sxs-lookup"><span data-stu-id="46419-181">A null reference (`Nothing` in Visual Basic).</span></span>|  
|<xref:System.Exception.Message%2A>|<span data-ttu-id="46419-182">错误消息字符串。</span><span class="sxs-lookup"><span data-stu-id="46419-182">The error message string.</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected OutOfMemoryException (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.OutOfMemoryException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; OutOfMemoryException(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new OutOfMemoryException : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; OutOfMemoryException" Usage="new System.OutOfMemoryException (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="46419-183">承载序列化对象数据的对象。</span><span class="sxs-lookup"><span data-stu-id="46419-183">The object that holds the serialized object data.</span></span></param>
        <param name="context"><span data-ttu-id="46419-184">关于来源和目标的上下文信息</span><span class="sxs-lookup"><span data-stu-id="46419-184">The contextual information about the source or destination.</span></span></param>
        <summary><span data-ttu-id="46419-185">用序列化数据初始化 <see cref="T:System.OutOfMemoryException" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="46419-185">Initializes a new instance of the <see cref="T:System.OutOfMemoryException" /> class with serialized data.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46419-186">在反序列化期间调用此构造函数以重新构造在流上传输的异常对象。</span><span class="sxs-lookup"><span data-stu-id="46419-186">This constructor is called during deserialization to reconstitute the exception object transmitted over a stream.</span></span> <span data-ttu-id="46419-187">有关详细信息，请参阅 [XML 和 SOAP 序列化](/dotnet/standard/serialization/xml-and-soap-serialization)。</span><span class="sxs-lookup"><span data-stu-id="46419-187">For more information, see [XML and SOAP Serialization](/dotnet/standard/serialization/xml-and-soap-serialization).</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/serialization/xml-and-soap-serialization"><span data-ttu-id="46419-188">XML 和 SOAP 序列化</span><span class="sxs-lookup"><span data-stu-id="46419-188">XML and SOAP Serialization</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OutOfMemoryException (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.OutOfMemoryException.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; OutOfMemoryException(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new OutOfMemoryException : string * Exception -&gt; OutOfMemoryException" Usage="new System.OutOfMemoryException (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message"><span data-ttu-id="46419-189">解释异常原因的错误消息。</span><span class="sxs-lookup"><span data-stu-id="46419-189">The error message that explains the reason for the exception.</span></span></param>
        <param name="innerException"><span data-ttu-id="46419-190">导致当前异常的异常。</span><span class="sxs-lookup"><span data-stu-id="46419-190">The exception that is the cause of the current exception.</span></span> <span data-ttu-id="46419-191">如果 <paramref name="innerException" /> 参数不是 null 引用（在 Visual Basic 中为 <see langword="Nothing" />），则在处理内部异常的 <see langword="catch" /> 块中引发当前异常。</span><span class="sxs-lookup"><span data-stu-id="46419-191">If the <paramref name="innerException" /> parameter is not a null reference (<see langword="Nothing" /> in Visual Basic), the current exception is raised in a <see langword="catch" /> block that handles the inner exception.</span></span></param>
        <summary><span data-ttu-id="46419-192">使用指定的错误消息和对作为此异常原因的内部异常的引用来初始化 <see cref="T:System.OutOfMemoryException" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="46419-192">Initializes a new instance of the <see cref="T:System.OutOfMemoryException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46419-193">因前一个异常而直接引发的异常可以在 <xref:System.Exception.InnerException%2A> 属性中包含对前一个异常的引用。</span><span class="sxs-lookup"><span data-stu-id="46419-193">An exception that is thrown as a direct result of a previous exception can include a reference to the previous exception in the <xref:System.Exception.InnerException%2A> property.</span></span> <span data-ttu-id="46419-194"><xref:System.Exception.InnerException%2A> 属性返回传递到构造函数中的相同值，或者如果 `Nothing` 属性不向构造函数提供内部异常值，则为空引用（在 Visual Basic 中为 <xref:System.Exception.InnerException%2A>）。</span><span class="sxs-lookup"><span data-stu-id="46419-194">The <xref:System.Exception.InnerException%2A> property returns the same value that is passed into the constructor, or a null reference (`Nothing` in Visual Basic) if the <xref:System.Exception.InnerException%2A> property does not supply the inner exception value to the constructor.</span></span>  
  
 <span data-ttu-id="46419-195">下表显示了 <xref:System.OutOfMemoryException> 实例的初始属性值。</span><span class="sxs-lookup"><span data-stu-id="46419-195">The following table shows the initial property values for an instance of <xref:System.OutOfMemoryException>.</span></span>  
  
|<span data-ttu-id="46419-196">properties</span><span class="sxs-lookup"><span data-stu-id="46419-196">Property</span></span>|<span data-ttu-id="46419-197">“值”</span><span class="sxs-lookup"><span data-stu-id="46419-197">Value</span></span>|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|<span data-ttu-id="46419-198">内部异常引用。</span><span class="sxs-lookup"><span data-stu-id="46419-198">The inner exception reference.</span></span>|  
|<xref:System.Exception.Message%2A>|<span data-ttu-id="46419-199">错误消息字符串。</span><span class="sxs-lookup"><span data-stu-id="46419-199">The error message string.</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Exception" />
        <related type="Article" href="/dotnet/standard/exceptions/"><span data-ttu-id="46419-200">处理和引发异常</span><span class="sxs-lookup"><span data-stu-id="46419-200">Handling and Throwing Exceptions</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
