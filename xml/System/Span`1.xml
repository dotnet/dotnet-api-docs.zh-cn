<Type Name="Span&lt;T&gt;" FullName="System.Span&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="453f4a5fae5c98cac6176b9ce24306be462dd954" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86686723" /></Metadata><TypeSignature Language="C#" Value="public struct Span&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Span`1&lt;T&gt; extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Span`1" />
  <TypeSignature Language="VB.NET" Value="Public Structure Span(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public value class Span" />
  <TypeSignature Language="F#" Value="type Span&lt;'T&gt; = struct" />
  <AssemblyInfo>
    <AssemblyName>System.Memory</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Memory" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Memory" FromVersion="4.1.0.0" To="System.Runtime" ToVersion="4.2.1.0" FrameworkAlternate="netcore-2.1;netcore-2.2" />
    <TypeForwarding From="System.Memory" FromVersion="4.2.0.0" To="System.Runtime" ToVersion="4.2.1.0" FrameworkAlternate="netcore-3.0" />
    <TypeForwarding From="System.Memory" FromVersion="4.2.1.0" To="System.Runtime" ToVersion="4.2.2.0" FrameworkAlternate="netcore-3.1" />
  </TypeForwardingChain>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
      <AttributeName Language="C#">[System.Runtime.CompilerServices.IsByRefLike]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsByRefLike&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
      <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T"><span data-ttu-id="80ea7-101">中项的类型 <see cref="T:System.Span`1" /> 。</span><span class="sxs-lookup"><span data-stu-id="80ea7-101">The type of items in the <see cref="T:System.Span`1" />.</span></span></typeparam>
    <summary><span data-ttu-id="80ea7-102">提供任意内存的连续区域的类型和内存安全表示。</span><span class="sxs-lookup"><span data-stu-id="80ea7-102">Provides a type- and memory-safe representation of a contiguous region of arbitrary memory.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  

<span data-ttu-id="80ea7-103">`Span<T>` 是在堆栈上分配的 [引用结构](/dotnet/csharp/language-reference/builtin-types/struct#ref-struct) ，而不是在托管堆上分配的。</span><span class="sxs-lookup"><span data-stu-id="80ea7-103">`Span<T>` is a [ref struct](/dotnet/csharp/language-reference/builtin-types/struct#ref-struct) that is allocated on the stack rather than on the managed heap.</span></span> <span data-ttu-id="80ea7-104">Ref 结构类型具有多个限制，可确保它们无法升级到托管堆，包括它们不能装箱、不能分配给类型的变量 <xref:System.Object> `dynamic` 或任何接口类型，它们不能是引用类型中的字段，并且不能跨 `await` 和 `yield` 边界使用。</span><span class="sxs-lookup"><span data-stu-id="80ea7-104">Ref struct types have a number of restrictions to ensure that they cannot be promoted to the managed heap, including that they can't be boxed, they can't be assigned to variables of type <xref:System.Object>, `dynamic` or to any interface type, they can't be fields in a reference type, and they can't be used across `await` and `yield` boundaries.</span></span> <span data-ttu-id="80ea7-105">此外，对两个方法 <xref:System.Span%601.Equals(System.Object)> 和的调用将 <xref:System.Span%601.GetHashCode%2A> 引发 <xref:System.NotSupportedException> 。</span><span class="sxs-lookup"><span data-stu-id="80ea7-105">In addition, calls to two methods, <xref:System.Span%601.Equals(System.Object)> and <xref:System.Span%601.GetHashCode%2A>, throw a <xref:System.NotSupportedException>.</span></span> 

> [!IMPORTANT]
> <span data-ttu-id="80ea7-106">由于它是仅堆栈类型，因此 `Span<T>` 对于需要在堆上存储缓冲区引用的多个方案是不合适的。</span><span class="sxs-lookup"><span data-stu-id="80ea7-106">Because it is a stack-only type, `Span<T>` is unsuitable for many scenarios that require storing references to buffers on the heap.</span></span> <span data-ttu-id="80ea7-107">例如，这是执行异步方法调用的例程。</span><span class="sxs-lookup"><span data-stu-id="80ea7-107">This is true, for example, of routines that make asynchronous method calls.</span></span> <span data-ttu-id="80ea7-108">对于这种情况，可以使用互补 <xref:System.Memory%601?displayProperty=nameWithType> 和 <xref:System.ReadOnlyMemory%601?displayProperty=nameWithType> 类型。</span><span class="sxs-lookup"><span data-stu-id="80ea7-108">For such scenarios, you can use the complementary <xref:System.Memory%601?displayProperty=nameWithType> and <xref:System.ReadOnlyMemory%601?displayProperty=nameWithType> types.</span></span>

<span data-ttu-id="80ea7-109">对于表示不可变或只读结构的范围，请使用 <xref:System.ReadOnlySpan%601?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="80ea7-109">For spans that represent immutable or read-only structures, use <xref:System.ReadOnlySpan%601?displayProperty=nameWithType>.</span></span>

## <a name="spant-and-memory"></a><span data-ttu-id="80ea7-110">范围 \<T> 和内存</span><span class="sxs-lookup"><span data-stu-id="80ea7-110">Span\<T> and memory</span></span>

<span data-ttu-id="80ea7-111">`Span<T>`表示任意内存的连续区域。</span><span class="sxs-lookup"><span data-stu-id="80ea7-111">A `Span<T>` represents a contiguous region of arbitrary memory.</span></span> <span data-ttu-id="80ea7-112">`Span<T>`实例通常用于保存数组或某个数组的一部分的元素。</span><span class="sxs-lookup"><span data-stu-id="80ea7-112">A `Span<T>` instance is often used to hold the elements of an array or a portion of an array.</span></span> <span data-ttu-id="80ea7-113">但与数组不同， `Span<T>` 实例可以指向托管内存、本机内存或在堆栈上管理的内存。</span><span class="sxs-lookup"><span data-stu-id="80ea7-113">Unlike an array, however, a `Span<T>` instance can point to managed memory, native memory, or memory managed on the stack.</span></span> <span data-ttu-id="80ea7-114">下面的示例 `Span<Byte>` 从数组创建：</span><span class="sxs-lookup"><span data-stu-id="80ea7-114">The following example creates a `Span<Byte>` from an array:</span></span>

[!code-csharp[Creating a Span\<Byte> from an array](~/samples/snippets/csharp/api/system/span/program.cs#1)]
     
<span data-ttu-id="80ea7-115">下面的示例创建一个 `Span<Byte>` 100 字节的本机内存：</span><span class="sxs-lookup"><span data-stu-id="80ea7-115">The following example creates a `Span<Byte>` from 100 bytes of native memory:</span></span>

[!code-csharp[Creating a Span\<Byte> from native memory](~/samples/snippets/csharp/api/system/span/program.cs#2)]

<span data-ttu-id="80ea7-116">下面的示例使用 c # [stackalloc](/dotnet/csharp/language-reference/keywords/stackalloc) 关键字在堆栈上分配100字节的内存：</span><span class="sxs-lookup"><span data-stu-id="80ea7-116">The following example uses the C# [stackalloc](/dotnet/csharp/language-reference/keywords/stackalloc) keyword to allocate 100 bytes of memory on the stack:</span></span>

[!code-csharp[Creating a Span\<Byte> from stack-allocated memory](~/samples/snippets/csharp/api/system/span/program.cs#3)]

<span data-ttu-id="80ea7-117">由于 `Span<T>` 是任意内存块的抽象，因此 `Span<T>` 具有参数的类和方法的方法将 `Span<T>` 在任何对象上操作， `Span<T>` 而不考虑它所封装的内存类型。</span><span class="sxs-lookup"><span data-stu-id="80ea7-117">Because `Span<T>` is an abstraction over an arbitrary block of memory, methods of the `Span<T>` class and methods with `Span<T>` parameters operate on any `Span<T>` object regardless of the kind of memory it encapsulates.</span></span> <span data-ttu-id="80ea7-118">例如，初始化范围并计算其元素的总和的代码的每个单独部分均可更改为单一初始化和计算方法，如以下示例所示：</span><span class="sxs-lookup"><span data-stu-id="80ea7-118">For example, each of the separate sections of code that initialize the span and calculate the sum of its elements can be changed into single initialization and calculation methods, as the following example illustrates:</span></span>

[!code-csharp[Creating a Span\<Byte> from stack-allocated memory](~/samples/snippets/csharp/api/system/span/program.cs#4)]

## <a name="spant-and-arrays"></a><span data-ttu-id="80ea7-119">范围 \<T> 和数组</span><span class="sxs-lookup"><span data-stu-id="80ea7-119">Span\<T> and arrays</span></span>

<span data-ttu-id="80ea7-120">包装数组时， `Span<T>` 可以包装整个数组，这与在 [Span \<T> 和 memory](#spant-and-memory) 部分的示例中所做的一样。</span><span class="sxs-lookup"><span data-stu-id="80ea7-120">When it wraps an array, `Span<T>` can wrap an entire array, as it did in the examples in the [Span\<T> and memory](#spant-and-memory) section.</span></span> <span data-ttu-id="80ea7-121">由于它支持切片，因此 `Span<T>` 还可以指向数组内的任何连续范围。</span><span class="sxs-lookup"><span data-stu-id="80ea7-121">Because it supports slicing, `Span<T>` can also point to any contiguous range within the array.</span></span>  

<span data-ttu-id="80ea7-122">下面的示例创建一个10元素整数数组中间5个元素的切片。</span><span class="sxs-lookup"><span data-stu-id="80ea7-122">The following example creates a slice of the middle five elements of a 10-element integer array.</span></span> <span data-ttu-id="80ea7-123">请注意，该代码会将切片中每个整数的值加倍。</span><span class="sxs-lookup"><span data-stu-id="80ea7-123">Note that the code doubles the values of each integer in the slice.</span></span> <span data-ttu-id="80ea7-124">正如输出所示，范围内的更改会反映在数组的值中。</span><span class="sxs-lookup"><span data-stu-id="80ea7-124">As the output shows, the changes made by the span are reflected in the values of the array.</span></span>

[!code-csharp[Creating a slice from a portion of a span](~/samples/snippets/csharp/api/system/span/slice/program.cs)]

## <a name="spant-and-slices"></a><span data-ttu-id="80ea7-125">跨度 \<T> 和切片</span><span class="sxs-lookup"><span data-stu-id="80ea7-125">Span\<T> and slices</span></span>

<span data-ttu-id="80ea7-126">`Span<T>` 包含方法的两个重载 <xref:System.Span%601.Slice%2A> ，该方法构成从指定索引处开始的当前范围的切片。</span><span class="sxs-lookup"><span data-stu-id="80ea7-126">`Span<T>` includes two overloads of the <xref:System.Span%601.Slice%2A> method that form a slice out of the current span that starts at a specified index.</span></span> <span data-ttu-id="80ea7-127">这样一来，就可以将中的数据 `Span<T>` 作为一组逻辑块进行处理，数据处理管道的部分可以按需处理这些数据块，并对性能的影响最小。</span><span class="sxs-lookup"><span data-stu-id="80ea7-127">This makes it possible to treat the data in a `Span<T>` as a set of logical chunks that can be processed as needed by portions of a data processing pipeline with minimal performance impact.</span></span> <span data-ttu-id="80ea7-128">例如，由于新式服务器协议通常基于文本，因此字符串和子字符串的操作非常重要。</span><span class="sxs-lookup"><span data-stu-id="80ea7-128">For example, since modern server protocols are often text-based, manipulation of strings and substrings is particularly important.</span></span> <span data-ttu-id="80ea7-129">在 <xref:System.String> 类中，提取子字符串的主要方法是 <xref:System.String.Substring%2A> 。</span><span class="sxs-lookup"><span data-stu-id="80ea7-129">In the <xref:System.String> class, the major method for extracting substrings is <xref:System.String.Substring%2A>.</span></span> <span data-ttu-id="80ea7-130">对于依赖于广泛的字符串操作的数据管道，其使用会带来一些性能损失，因为它：</span><span class="sxs-lookup"><span data-stu-id="80ea7-130">For data pipelines that rely on extensive string manipulation, its use offers some performance penalties, since it:</span></span>

1. <span data-ttu-id="80ea7-131">创建用于保存子字符串的新字符串。</span><span class="sxs-lookup"><span data-stu-id="80ea7-131">Creates a new string to hold the substring.</span></span>

2. <span data-ttu-id="80ea7-132">将原始字符串中的字符子集复制到新字符串中。</span><span class="sxs-lookup"><span data-stu-id="80ea7-132">Copies a subset of the characters from the original string to the new string.</span></span>

<span data-ttu-id="80ea7-133">可以使用或删除此分配和复制操作 `Span<T>` <xref:System.ReadOnlySpan%601> ，如下面的示例所示：</span><span class="sxs-lookup"><span data-stu-id="80ea7-133">This allocation and copy operation can be eliminated by using either `Span<T>` or <xref:System.ReadOnlySpan%601>, as the following example shows:</span></span>

[!code-csharp[Creating a slice from a substring](~/samples/snippets/csharp/api/system/span/slice2/program.cs)]


      ]]></format>
    </remarks>
    <related type="article" href="/dotnet/standard/memory-and-spans/"><span data-ttu-id="80ea7-134">内存和跨度相关类型</span><span class="sxs-lookup"><span data-stu-id="80ea7-134">Memory- and span-related types</span></span></related>
    <related type="article" href="/dotnet/standard/memory-and-spans/memory-t-usage-guidelines"><span data-ttu-id="80ea7-135">内存 &lt; t &gt; 和跨度 &lt; T &gt; 使用准则</span><span class="sxs-lookup"><span data-stu-id="80ea7-135">Memory&lt;T&gt; and Span&lt;T&gt; usage guidelines</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (T[]? array);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="new Span&lt;'T&gt; : 'T[] -&gt; Span&lt;'T&gt;" Usage="new System.Span&lt;'T&gt; array" />
      <MemberSignature Language="C#" Value="public Span (T[] array);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="80ea7-136">用来从中创建 <see cref="T:System.Span`1" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="80ea7-136">The array from which to create the <see cref="T:System.Span`1" /> object.</span></span></param>
        <summary><span data-ttu-id="80ea7-137">在整个指定数组上创建新的 <see cref="T:System.Span`1" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="80ea7-137">Creates a new <see cref="T:System.Span`1" /> object over the entirety of a specified array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="80ea7-138">如果 `array` 为 `null` ，则此构造函数返回 `null` `Span<T>` 。</span><span class="sxs-lookup"><span data-stu-id="80ea7-138">If `array` is `null`, this constructor returns a `null` `Span<T>`.</span></span>

      ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="80ea7-139"><paramref name="T" /> 为引用类型，并且 <paramref name="array" /> 不是 <paramref name="T" /> 类型的数组。</span><span class="sxs-lookup"><span data-stu-id="80ea7-139"><paramref name="T" /> is a reference type, and <paramref name="array" /> is not an array of type <paramref name="T" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (void* pointer, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(void* pointer, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(System.Void*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(void* pointer, int length);" />
      <MemberSignature Language="F#" Value="new Span&lt;'T&gt; : nativeptr&lt;unit&gt; * int -&gt; Span&lt;'T&gt;" Usage="new System.Span&lt;'T&gt; (pointer, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pointer" Type="System.Void*" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pointer"><span data-ttu-id="80ea7-140">指向内存中指定 <typeparamref name="T" /> 元素数的起始地址的指针。</span><span class="sxs-lookup"><span data-stu-id="80ea7-140">A pointer to the starting address of a specified number of <typeparamref name="T" /> elements in memory.</span></span></param>
        <param name="length"><span data-ttu-id="80ea7-141">要包含在 <see cref="T:System.Span`1" /> 中的 <typeparamref name="T" /> 元素数。</span><span class="sxs-lookup"><span data-stu-id="80ea7-141">The number of <typeparamref name="T" /> elements to be included in the <see cref="T:System.Span`1" />.</span></span></param>
        <summary><span data-ttu-id="80ea7-142">从指定的内存地址开始，从指定 <typeparamref name="T" /> 元素数创建新的 <see cref="T:System.Span`1" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="80ea7-142">Creates a new <see cref="T:System.Span`1" /> object  from a specified number of <typeparamref name="T" /> elements starting at a specified memory address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

        This constructor should be used with care, since it creates arbitrarily typed `T`s from a `void*`-typed block of memory, and `length` is not checked. However, if the constructor succeeds in creating a new <xref:System.Span%601> object, all subsequent uses are correct.        

      ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="80ea7-143"><paramref name="T" /> 是引用类型或包含指针，因此不能存储在非管理的内存中。</span><span class="sxs-lookup"><span data-stu-id="80ea7-143"><paramref name="T" /> is a reference type or contains pointers and therefore cannot be stored in unmanaged memory.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="80ea7-144"><paramref name="length" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="80ea7-144"><paramref name="length" /> is negative.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (T[]? array, int start, int length);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T(), start As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(cli::array &lt;T&gt; ^ array, int start, int length);" />
      <MemberSignature Language="F#" Value="new Span&lt;'T&gt; : 'T[] * int * int -&gt; Span&lt;'T&gt;" Usage="new System.Span&lt;'T&gt; (array, start, length)" />
      <MemberSignature Language="C#" Value="public Span (T[] array, int start, int length);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="80ea7-145">源数组。</span><span class="sxs-lookup"><span data-stu-id="80ea7-145">The source array.</span></span></param>
        <param name="start"><span data-ttu-id="80ea7-146">要包括在新的 <see cref="T:System.Span`1" /> 内的第一个元素的索引。</span><span class="sxs-lookup"><span data-stu-id="80ea7-146">The index of the first element to include in the new <see cref="T:System.Span`1" />.</span></span></param>
        <param name="length"><span data-ttu-id="80ea7-147">要包括在新的 <see cref="T:System.Span`1" /> 中的元素数。</span><span class="sxs-lookup"><span data-stu-id="80ea7-147">The number of elements to include in the new <see cref="T:System.Span`1" />.</span></span></param>
        <summary><span data-ttu-id="80ea7-148">从指定索引开始，创建包含数组的指定元素数的新 <see cref="T:System.Span`1" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="80ea7-148">Creates a new <see cref="T:System.Span`1" /> object that includes a specified number of elements of an array starting at a specified index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

### Remarks

<span data-ttu-id="80ea7-149">`default`当为时，此方法返回 `array` `null` 。</span><span class="sxs-lookup"><span data-stu-id="80ea7-149">This method returns `default` when `array` is `null`.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="80ea7-150"><paramref name="array" /> 是 <see langword="null" />，但 <paramref name="start" /> 或 <paramref name="length" /> 不为零。</span><span class="sxs-lookup"><span data-stu-id="80ea7-150"><paramref name="array" /> is <see langword="null" />, but <paramref name="start" /> or <paramref name="length" /> is non-zero.</span></span>

<span data-ttu-id="80ea7-151">- 或 -</span><span class="sxs-lookup"><span data-stu-id="80ea7-151">-or-</span></span>

<span data-ttu-id="80ea7-152"><paramref name="start" /> 在数组的界限外。</span><span class="sxs-lookup"><span data-stu-id="80ea7-152"><paramref name="start" /> is outside the bounds of the array.</span></span>

<span data-ttu-id="80ea7-153">- 或 -</span><span class="sxs-lookup"><span data-stu-id="80ea7-153">-or-</span></span>

<span data-ttu-id="80ea7-154"><paramref name="start" /> 和 <paramref name="length" /> 超过数组中的元素数。</span><span class="sxs-lookup"><span data-stu-id="80ea7-154"><paramref name="start" /> and <paramref name="length" /> exceeds the number of elements in the array.</span></span></exception>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="80ea7-155"><paramref name="T" /> 为引用类型，并且 <paramref name="array" /> 不是 <paramref name="T" /> 类型的数组。</span><span class="sxs-lookup"><span data-stu-id="80ea7-155"><paramref name="T" /> is a reference type, and <paramref name="array" /> is not an array of type <paramref name="T" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="span.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="80ea7-156">清除此 <see cref="T:System.Span`1" /> 对象的内容。</span><span class="sxs-lookup"><span data-stu-id="80ea7-156">Clears the contents of this <see cref="T:System.Span`1" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="80ea7-157">`Clear`方法将对象中的项设置 <xref:System.Span%601> 为其默认值。</span><span class="sxs-lookup"><span data-stu-id="80ea7-157">The `Clear` method sets the items in the <xref:System.Span%601> object to their default values.</span></span> <span data-ttu-id="80ea7-158">它不会从中删除项 <xref:System.Span%601> 。</span><span class="sxs-lookup"><span data-stu-id="80ea7-158">It does not remove items from the <xref:System.Span%601>.</span></span>  

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Span&lt;T&gt;? destination);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.CopyTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As Span(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Span&lt;T&gt; destination);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Span&lt;'T&gt; -&gt; unit" Usage="span.CopyTo destination" />
      <MemberSignature Language="C#" Value="public void CopyTo (Span&lt;T&gt; destination);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="80ea7-159">目标 <see cref="T:System.Span`1" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="80ea7-159">The destination <see cref="T:System.Span`1" /> object.</span></span></param>
        <summary><span data-ttu-id="80ea7-160">将此 <see cref="T:System.Span`1" /> 的内容复制到目标 <see cref="T:System.Span`1" />。</span><span class="sxs-lookup"><span data-stu-id="80ea7-160">Copies the contents of this <see cref="T:System.Span`1" /> into a destination <see cref="T:System.Span`1" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="80ea7-161">`source` `destination` 即使 `source` 和重叠，此方法也会将全部复制到 `destination` 。</span><span class="sxs-lookup"><span data-stu-id="80ea7-161">This method copies all of `source` to `destination` even if `source` and `destination` overlap.</span></span>

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="80ea7-162"><paramref name="destination" /> 短于源 <see cref="T:System.Span`1" />。</span><span class="sxs-lookup"><span data-stu-id="80ea7-162"><paramref name="destination" /> is shorter than the source <see cref="T:System.Span`1" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt;? Empty { get; }" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Span`1&lt;!T&gt; Empty" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Empty As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Span&lt;T&gt; Empty { Span&lt;T&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Empty : Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.Empty" />
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; Empty { get; }" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="80ea7-163">返回空的 <see cref="T:System.Span`1" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="80ea7-163">Returns an empty <see cref="T:System.Span`1" /> object.</span></span></summary>
        <value><span data-ttu-id="80ea7-164">空的 <see cref="T:System.Span`1" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="80ea7-164">An empty <see cref="T:System.Span`1" /> object.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="span.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.Obsolete("Equals() on Span will always throw an exception. Use == instead.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Equals() on Span will always throw an exception. Use == instead.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="80ea7-165">不支持。</span><span class="sxs-lookup"><span data-stu-id="80ea7-165">Not supported.</span></span></param>
        <summary><span data-ttu-id="80ea7-166">不支持对此方法的调用。</span><span class="sxs-lookup"><span data-stu-id="80ea7-166">Calls to this method are not supported.</span></span></summary>
        <returns><span data-ttu-id="80ea7-167">不支持对此方法的调用。</span><span class="sxs-lookup"><span data-stu-id="80ea7-167">Calls to this method are not supported.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
<span data-ttu-id="80ea7-168"><xref:System.Span%601.Equals%2A>不支持对方法的调用。</span><span class="sxs-lookup"><span data-stu-id="80ea7-168">Calls to the <xref:System.Span%601.Equals%2A> method are not supported.</span></span> <span data-ttu-id="80ea7-169">对方法的调用会 <xref:System.Span%601.Equals%2A> 产生两个结果：</span><span class="sxs-lookup"><span data-stu-id="80ea7-169">Calls to the <xref:System.Span%601.Equals%2A> methods produce either of two results:</span></span>

- <span data-ttu-id="80ea7-170">如果 `obj` 是 <xref:System.Span%601> ，则方法调用会生成编译器错误 CS1503： "无法从 ' system.object ' 转换为 ' object '。"这是因为 <xref:System.Span%601> 是一个不能装箱的 [ref 结构](/dotnet/csharp/language-reference/builtin-types/struct#ref-struct) ，因此无法将其转换为 <xref:System.Object> 。</span><span class="sxs-lookup"><span data-stu-id="80ea7-170">If `obj` is a <xref:System.Span%601>, the method call generates compiler error CS1503: "cannot convert from 'System.Span' to 'object'." This is because <xref:System.Span%601> is a [ref struct](/dotnet/csharp/language-reference/builtin-types/struct#ref-struct) that cannot be boxed and therefore cannot be converted to an <xref:System.Object>.</span></span>

- <span data-ttu-id="80ea7-171">如果的类型 `obj` 不是，则 <xref:System.Span%601> 方法调用将引发 <xref:System.NotSupportedException> 。</span><span class="sxs-lookup"><span data-stu-id="80ea7-171">If the type of `obj` is not a <xref:System.Span%601>, the method call throws a <xref:System.NotSupportedException>.</span></span> 

<span data-ttu-id="80ea7-172">若要比较两个 <xref:System.Span%601> 对象是否相等，请使用 <xref:System.Span%601.op_Equality%2A> 比较运算符。</span><span class="sxs-lookup"><span data-stu-id="80ea7-172">To compare two <xref:System.Span%601> objects for equality, use the <xref:System.Span%601.op_Equality%2A> comparison operator.</span></span>

        ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="80ea7-173">不支持对此方法的调用。</span><span class="sxs-lookup"><span data-stu-id="80ea7-173">Calls to this method are not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public void Fill (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Fill(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Fill(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Fill (value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Fill(T value);" />
      <MemberSignature Language="F#" Value="member this.Fill : 'T -&gt; unit" Usage="span.Fill value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="80ea7-174">要分配给范围的每个元素的值。</span><span class="sxs-lookup"><span data-stu-id="80ea7-174">The value to assign to each element of the span.</span></span></param>
        <summary><span data-ttu-id="80ea7-175">用指定的值填充此范围的元素。</span><span class="sxs-lookup"><span data-stu-id="80ea7-175">Fills the elements of this span with a specified value.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt;.Enumerator? GetEnumerator ();" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As Span(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; Span&lt;'T&gt;.Enumerator" Usage="span.GetEnumerator " />
      <MemberSignature Language="C#" Value="public Span&lt;T&gt;.Enumerator GetEnumerator ();" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="80ea7-176">返回用于此 <see cref="T:System.Span`1" /> 的枚举器。</span><span class="sxs-lookup"><span data-stu-id="80ea7-176">Returns an enumerator for this <see cref="T:System.Span`1" />.</span></span></summary>
        <returns><span data-ttu-id="80ea7-177">用于此范围的枚举器。</span><span class="sxs-lookup"><span data-stu-id="80ea7-177">An enumerator for this span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
<span data-ttu-id="80ea7-178"><xref:System.Span%601.GetEnumerator%2A>您可以使用 c # `foreach` 语句和 Visual Basic `For Each` ... `Next` 构造来枚举 <xref:System.Span%601> ，而不是直接调用方法。</span><span class="sxs-lookup"><span data-stu-id="80ea7-178">Instead of calling the <xref:System.Span%601.GetEnumerator%2A> method directly, you can use the C# `foreach` statement and the Visual Basic `For Each`...`Next` construct to enumerate a <xref:System.Span%601>.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="span.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.Obsolete("GetHashCode() on Span will always throw an exception.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("GetHashCode() on Span will always throw an exception.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="80ea7-179">引发 <see cref="T:System.NotSupportedException" />。</span><span class="sxs-lookup"><span data-stu-id="80ea7-179">Throws a <see cref="T:System.NotSupportedException" />.</span></span></summary>
        <returns><span data-ttu-id="80ea7-180">调用此方法始终引发 <see cref="T:System.NotSupportedException" />。</span><span class="sxs-lookup"><span data-stu-id="80ea7-180">Calls to this method always throw a <see cref="T:System.NotSupportedException" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="80ea7-181">不支持对此方法的调用。</span><span class="sxs-lookup"><span data-stu-id="80ea7-181">Calls to this method are not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetPinnableReference">
      <MemberSignature Language="C#" Value="public ref T GetPinnableReference ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T GetPinnableReference() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.GetPinnableReference" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPinnableReference () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T % GetPinnableReference();" />
      <MemberSignature Language="F#" Value="member this.GetPinnableReference : unit -&gt; 'T" Usage="span.GetPinnableReference " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="80ea7-182">返回对索引为零处 <see cref="T:System.Span`1" /> 元素的引用。</span><span class="sxs-lookup"><span data-stu-id="80ea7-182">Returns a reference to the element of the <see cref="T:System.Span`1" /> at index zero.</span></span></summary>
        <returns><span data-ttu-id="80ea7-183">返回对索引为零处 <see cref="T:System.Span`1" /> 元素的引用，或 <see langword="null" />，如果 <see cref="P:System.Span`1.IsEmpty" /> 为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="80ea7-183">A reference to the element of the <see cref="T:System.Span`1" /> at index zero, or <see langword="null" /> if <see cref="P:System.Span`1.IsEmpty" /> is  <see langword="true" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="80ea7-184">`GetPinnableReference`方法返回[ref 结构](/dotnet/csharp/language-reference/builtin-types/struct#ref-struct)。</span><span class="sxs-lookup"><span data-stu-id="80ea7-184">The `GetPinnableReference` method returns a [ref struct](/dotnet/csharp/language-reference/builtin-types/struct#ref-struct).</span></span> <span data-ttu-id="80ea7-185">它可用于 <xref:System.Span%601> 在内存中固定。</span><span class="sxs-lookup"><span data-stu-id="80ea7-185">It can be used for pinning a <xref:System.Span%601> in memory.</span></span> <span data-ttu-id="80ea7-186">需要在 <xref:System.Span%601> [fixed](/dotnet/csharp/language-reference/keywords/fixed-statement) 语句中支持的使用。</span><span class="sxs-lookup"><span data-stu-id="80ea7-186">It is required to support the use of a <xref:System.Span%601> within a [fixed](/dotnet/csharp/language-reference/keywords/fixed-statement) statement.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmpty : bool" Usage="System.Span&lt;'T&gt;.IsEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="80ea7-187">返回一个值，该值指示当前的 <see cref="T:System.Span`1" /> 是否为空。</span><span class="sxs-lookup"><span data-stu-id="80ea7-187">Returns a value that indicates whether the current <see cref="T:System.Span`1" /> is empty.</span></span></summary>
        <value><span data-ttu-id="80ea7-188"><see langword="true" /> 如果当前范围为空，则为; 否则为。否则为 <see langword="false" /> 。</span><span class="sxs-lookup"><span data-stu-id="80ea7-188"><see langword="true" /> if the current span is empty; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public ref T this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T % default[int] { T % get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : 'T" Usage="System.Span&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="80ea7-189">元素的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="80ea7-189">The zero-based index of the element.</span></span></param>
        <summary><span data-ttu-id="80ea7-190">获取指定基于零的索引处的元素。</span><span class="sxs-lookup"><span data-stu-id="80ea7-190">Gets the element at the specified zero-based index.</span></span></summary>
        <value><span data-ttu-id="80ea7-191">指定索引处的元素。</span><span class="sxs-lookup"><span data-stu-id="80ea7-191">The element at the specified index.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="80ea7-192"><paramref name="index" /> 小于零，或者大于或等于 <see cref="P:System.Span`1.Length" />。</span><span class="sxs-lookup"><span data-stu-id="80ea7-192"><paramref name="index" /> is less than zero or greater than or equal to <see cref="P:System.Span`1.Length" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Span&lt;'T&gt;.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="80ea7-193">返回当前范围的长度。</span><span class="sxs-lookup"><span data-stu-id="80ea7-193">Returns the length of the current span.</span></span></summary>
        <value><span data-ttu-id="80ea7-194">当前跨度的长度。</span><span class="sxs-lookup"><span data-stu-id="80ea7-194">The length of the current span.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Span&lt;T&gt;? left, Span&lt;T&gt;? right);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Span`1&lt;!T&gt; left, valuetype System.Span`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Equality(System.Span{`0},System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Span(Of T), right As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Span&lt;'T&gt; * Span&lt;'T&gt; -&gt; bool" Usage="left = right" />
      <MemberSignature Language="C#" Value="public static bool operator == (Span&lt;T&gt; left, Span&lt;T&gt; right);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Span&lt;T&gt;" />
        <Parameter Name="right" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="80ea7-195">要比较的第一个范围。</span><span class="sxs-lookup"><span data-stu-id="80ea7-195">The first span to compare.</span></span></param>
        <param name="right"><span data-ttu-id="80ea7-196">要比较的第二个范围。</span><span class="sxs-lookup"><span data-stu-id="80ea7-196">The second span to compare.</span></span></param>
        <summary><span data-ttu-id="80ea7-197">返回一个值，该值指示两个 <see cref="T:System.Span`1" /> 对象是否相等。</span><span class="sxs-lookup"><span data-stu-id="80ea7-197">Returns a value that indicates whether two <see cref="T:System.Span`1" /> objects are equal.</span></span></summary>
        <returns><span data-ttu-id="80ea7-198">如果两个 <see cref="T:System.Span`1" /> 对象相等，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="80ea7-198"><see langword="true" /> if the two <see cref="T:System.Span`1" /> objects are equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="80ea7-199">如果两个 <xref:System.Span%601> 对象具有相同的长度和对应的元素 `left` ，并且 `right` 指向相同的内存，则这两个对象相等。</span><span class="sxs-lookup"><span data-stu-id="80ea7-199">Two <xref:System.Span%601> objects are equal if they have the same length and the corresponding elements of `left` and `right` point to the same memory.</span></span> <span data-ttu-id="80ea7-200">请注意，相等性测试 *不* 会尝试确定内容是否相等。</span><span class="sxs-lookup"><span data-stu-id="80ea7-200">Note that the test for equality does *not* attempt to determine whether the contents are equal.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt;? (ArraySegment&lt;T&gt;? segment);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Span`1&lt;!T&gt; op_Implicit(valuetype System.ArraySegment`1&lt;!T&gt; segment) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Implicit(System.ArraySegment{`0})~System.Span{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (segment As ArraySegment(Of T)) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Span&lt;T&gt;(ArraySegment&lt;T&gt; segment);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : ArraySegment&lt;'T&gt; -&gt; Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.op_Implicit segment" />
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt; (ArraySegment&lt;T&gt; segment);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="segment"><span data-ttu-id="80ea7-201">要转换为 <see cref="T:System.Span`1" /> 的数组段。</span><span class="sxs-lookup"><span data-stu-id="80ea7-201">The array segment to be converted to a <see cref="T:System.Span`1" />.</span></span></param>
        <summary><span data-ttu-id="80ea7-202">定义 <see cref="T:System.ArraySegment`1" /> 到 <see cref="T:System.Span`1" /> 的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="80ea7-202">Defines an implicit conversion of an <see cref="T:System.ArraySegment`1" /> to a <see cref="T:System.Span`1" />.</span></span></summary>
        <returns><span data-ttu-id="80ea7-203">与数组段相对应的范围。</span><span class="sxs-lookup"><span data-stu-id="80ea7-203">A span that corresponds to the array segment.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;T&gt;? (Span&lt;T&gt;? span);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;!T&gt; op_Implicit(valuetype System.Span`1&lt;!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Implicit(System.Span{`0})~System.ReadOnlySpan{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (span As Span(Of T)) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;T&gt;(Span&lt;T&gt; span);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : Span&lt;'T&gt; -&gt; ReadOnlySpan&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.op_Implicit span" />
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;T&gt; (Span&lt;T&gt; span);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="80ea7-204">要转换为 <see cref="T:System.ReadOnlySpan`1" /> 的对象。</span><span class="sxs-lookup"><span data-stu-id="80ea7-204">The object to convert to a <see cref="T:System.ReadOnlySpan`1" />.</span></span></param>
        <summary><span data-ttu-id="80ea7-205">定义 <see cref="T:System.Span`1" /> 到 <see cref="T:System.ReadOnlySpan`1" /> 的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="80ea7-205">Defines an implicit conversion of a <see cref="T:System.Span`1" /> to a <see cref="T:System.ReadOnlySpan`1" />.</span></span></summary>
        <returns><span data-ttu-id="80ea7-206">与当前实例对应的只读范围。</span><span class="sxs-lookup"><span data-stu-id="80ea7-206">A read-only span that corresponds to the current instance.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt;? (T[]? array);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Span`1&lt;!T&gt; op_Implicit(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Implicit(`0[])~System.Span{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (array As T()) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Span&lt;T&gt;(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : 'T[] -&gt; Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.op_Implicit array" />
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt; (T[] array);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="80ea7-207">要转换为 <see cref="T:System.Span`1" /> 的数组。</span><span class="sxs-lookup"><span data-stu-id="80ea7-207">The array to convert to a <see cref="T:System.Span`1" />.</span></span></param>
        <summary><span data-ttu-id="80ea7-208">定义数组到 <see cref="T:System.Span`1" /> 的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="80ea7-208">Defines an implicit conversion of an array to a <see cref="T:System.Span`1" />.</span></span></summary>
        <returns><span data-ttu-id="80ea7-209">与 <paramref name="array" /> 对应的范围。</span><span class="sxs-lookup"><span data-stu-id="80ea7-209">The span that corresponds to <paramref name="array" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Span&lt;T&gt;? left, Span&lt;T&gt;? right);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Span`1&lt;!T&gt; left, valuetype System.Span`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Inequality(System.Span{`0},System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Span(Of T), right As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Span&lt;'T&gt; * Span&lt;'T&gt; -&gt; bool" Usage="System.Span&lt;'T&gt;.op_Inequality (left, right)" />
      <MemberSignature Language="C#" Value="public static bool operator != (Span&lt;T&gt; left, Span&lt;T&gt; right);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Span&lt;T&gt;" />
        <Parameter Name="right" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="80ea7-210">要比较的第一个范围。</span><span class="sxs-lookup"><span data-stu-id="80ea7-210">The first span to compare.</span></span></param>
        <param name="right"><span data-ttu-id="80ea7-211">要比较的第二个范围。</span><span class="sxs-lookup"><span data-stu-id="80ea7-211">The second span to compare.</span></span></param>
        <summary><span data-ttu-id="80ea7-212">返回一个值，该值指示两个 <see cref="T:System.Span`1" /> 对象是否不相等。</span><span class="sxs-lookup"><span data-stu-id="80ea7-212">Returns a value that indicates whether two <see cref="T:System.Span`1" /> objects are not equal.</span></span></summary>
        <returns><span data-ttu-id="80ea7-213">如果两个 <see cref="T:System.Span`1" /> 对象不相等，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="80ea7-213"><see langword="true" /> if the two <see cref="T:System.Span`1" /> objects are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="80ea7-214">如果两个 <xref:System.Span%601> 对象具有不同的长度，或者和的相应元素 `left` `right` 不指向相同的内存，则这两个对象相等。</span><span class="sxs-lookup"><span data-stu-id="80ea7-214">Two <xref:System.Span%601> objects are equal if they have different lengths or if the corresponding elements of `left` and `right` do not point to the same memory.</span></span> 

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt;? Slice (int start);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1&lt;!T&gt; Slice(int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Slice(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (start As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt; Slice(int start);" />
      <MemberSignature Language="F#" Value="member this.Slice : int -&gt; Span&lt;'T&gt;" Usage="span.Slice start" />
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; Slice (int start);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="80ea7-215">开始切片处的索引。</span><span class="sxs-lookup"><span data-stu-id="80ea7-215">The index at which to begin the slice.</span></span></param>
        <summary><span data-ttu-id="80ea7-216">从指定索引处开始的当前范围外形成切片。</span><span class="sxs-lookup"><span data-stu-id="80ea7-216">Forms a slice out of the current span that begins at a specified index.</span></span></summary>
        <returns><span data-ttu-id="80ea7-217">由当前范围（从 <paramref name="start" /> 到范围末尾）的所有元素组成的范围。</span><span class="sxs-lookup"><span data-stu-id="80ea7-217">A span that consists of all elements of the current span from <paramref name="start" /> to the end of the span.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="80ea7-218"><paramref name="start" /> 小于零或大于 <see cref="P:System.Span`1.Length" />。</span><span class="sxs-lookup"><span data-stu-id="80ea7-218"><paramref name="start" /> is less than zero or greater than <see cref="P:System.Span`1.Length" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt;? Slice (int start, int length);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1&lt;!T&gt; Slice(int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Slice(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (start As Integer, length As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt; Slice(int start, int length);" />
      <MemberSignature Language="F#" Value="member this.Slice : int * int -&gt; Span&lt;'T&gt;" Usage="span.Slice (start, length)" />
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; Slice (int start, int length);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="80ea7-219">开始切片处的索引。</span><span class="sxs-lookup"><span data-stu-id="80ea7-219">The index at which to begin this slice.</span></span></param>
        <param name="length"><span data-ttu-id="80ea7-220">切片所需的长度。</span><span class="sxs-lookup"><span data-stu-id="80ea7-220">The desired length for the slice.</span></span></param>
        <summary><span data-ttu-id="80ea7-221">从指定长度的指定索引处开始，在当前范围外形成切片。</span><span class="sxs-lookup"><span data-stu-id="80ea7-221">Forms a slice out of the current span starting at a specified index for a specified length.</span></span></summary>
        <returns><span data-ttu-id="80ea7-222">由当前范围（从 <paramref name="start" /> 开始）中 <paramref name="length" /> 元素组成的范围。</span><span class="sxs-lookup"><span data-stu-id="80ea7-222">A span that consists of <paramref name="length" /> elements from the current span starting at <paramref name="start" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="80ea7-223"><paramref name="start" /> 或 <paramref name="start" /> + <paramref name="length" /> 小于零或大于 <see cref="P:System.Span`1.Length" />。</span><span class="sxs-lookup"><span data-stu-id="80ea7-223"><paramref name="start" /> or <paramref name="start" /> + <paramref name="length" /> is less than zero or greater than <see cref="P:System.Span`1.Length" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="span.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="80ea7-224">将此范围的内容复制到新数组中。</span><span class="sxs-lookup"><span data-stu-id="80ea7-224">Copies the contents of this span into a new array.</span></span></summary>
        <returns><span data-ttu-id="80ea7-225">包含当前范围中数据的数组。</span><span class="sxs-lookup"><span data-stu-id="80ea7-225">An array containing the data in the current span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="80ea7-226">此方法执行堆分配，因此应尽可能避免使用。</span><span class="sxs-lookup"><span data-stu-id="80ea7-226">This method performs a heap allocation and therefore should be avoided if possible.</span></span> <span data-ttu-id="80ea7-227">有时，当支持对象的 Api <xref:System.Span%601> 不可用时，但使用数组的 api 是必需的。</span><span class="sxs-lookup"><span data-stu-id="80ea7-227">It it sometimes necessary when APIs that support <xref:System.Span%601> objects are not available but APIs that work with arrays are.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="span.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="80ea7-228">返回此 <see cref="T:System.Span`1" /> 对象的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="80ea7-228">Returns the string representation of this <see cref="T:System.Span`1" /> object.</span></span></summary>
        <returns><span data-ttu-id="80ea7-229">此 <see cref="T:System.Span`1" /> 对象的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="80ea7-229">The string representation of this <see cref="T:System.Span`1" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
<span data-ttu-id="80ea7-230">对于 `Span<Char>` ， `ToString` 方法返回一个 <xref:System.String> ，该字符串包含由指向的字符 <xref:System.Span%601> 。</span><span class="sxs-lookup"><span data-stu-id="80ea7-230">For a `Span<Char>`, the `ToString` method returns a <xref:System.String> that contains the characters pointed to by the <xref:System.Span%601>.</span></span> <span data-ttu-id="80ea7-231">否则，它将返回， <xref:System.String> 其中包含类型的名称和包含的元素的数目 <xref:System.Span%601> 。</span><span class="sxs-lookup"><span data-stu-id="80ea7-231">Otherwise, it returns a <xref:System.String> with the name of the type and the number of elements that the <xref:System.Span%601> contains.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCopyTo">
      <MemberSignature Language="C#" Value="public bool TryCopyTo (Span&lt;T&gt;? destination);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryCopyTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.TryCopyTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryCopyTo (destination As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryCopyTo(Span&lt;T&gt; destination);" />
      <MemberSignature Language="F#" Value="member this.TryCopyTo : Span&lt;'T&gt; -&gt; bool" Usage="span.TryCopyTo destination" />
      <MemberSignature Language="C#" Value="public bool TryCopyTo (Span&lt;T&gt; destination);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="80ea7-232">复制操作的目标。</span><span class="sxs-lookup"><span data-stu-id="80ea7-232">The target of the copy operation.</span></span></param>
        <summary><span data-ttu-id="80ea7-233">尝试将当前 <see cref="T:System.Span`1" /> 复制到目标 <see cref="T:System.Span`1" />，并返回一个指示复制操作是否成功的值。</span><span class="sxs-lookup"><span data-stu-id="80ea7-233">Attempts to copy the current <see cref="T:System.Span`1" /> to a destination <see cref="T:System.Span`1" /> and returns a value that indicates whether the copy operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="80ea7-234">如果复制操作已成功，则为 <see langword="true" />；否则，为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="80ea7-234"><see langword="true" /> if the copy operation succeeded; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="80ea7-235">`source` `destination` 即使 `source` 和重叠，此方法也会将全部复制到 `destination` 。</span><span class="sxs-lookup"><span data-stu-id="80ea7-235">This method copies all of `source` to `destination` even if `source` and `destination` overlap.</span></span>

<span data-ttu-id="80ea7-236">如果 `destination` 比源短，则 <xref:System.Span%601> 此方法将返回 `false` ，并且不写入任何数据 `destination` 。</span><span class="sxs-lookup"><span data-stu-id="80ea7-236">If `destination` is shorter than the source <xref:System.Span%601>, this method returns `false`, and no data is written to `destination`.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
