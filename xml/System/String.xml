<Type Name="String" FullName="System.String">
  <Metadata><Meta Name="ms.openlocfilehash" Value="926229698e9159a675616cb8c17271861345ac55" /><Meta Name="ms.sourcegitcommit" Value="a40c6a601bd45917c35e255d860c96b8b3853a79" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="01/05/2021" /><Meta Name="ms.locfileid" Value="97892306" /></Metadata><TypeSignature Language="C#" Value="public sealed class String : IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface seq&lt;char&gt;&#xA;    interface IEnumerable&#xA;    interface IComparable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface IConvertible&#xA;    interface IEquatable&lt;string&gt;" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface seq&lt;char&gt;&#xA;    interface IEnumerable&#xA;    interface ICloneable&#xA;    interface IComparable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface IConvertible&#xA;    interface IEquatable&lt;string&gt;" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface seq&lt;char&gt;&#xA;    interface IEnumerable&#xA;    interface IComparable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface IConvertible&#xA;    interface IEquatable&lt;string&gt;&#xA;    interface ICloneable" FrameworkAlternate="netcore-2.0" />
  <TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IConvertible, System.Collections.IEnumerable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IConvertible" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IConvertible, IEnumerable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IConvertible, System::Collections::IEnumerable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IEnumerable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IComparable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEnumerable&#xA;    interface IEquatable&lt;string&gt;" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IEnumerable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEquatable&lt;string&gt;" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C#" Value="public sealed class String : IComparable, IComparable&lt;string&gt;, IEquatable&lt;string&gt;, System.Collections.IEnumerable" FrameworkAlternate="netstandard-1.0;netstandard-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit string extends System.Object implements class System.Collections.IEnumerable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IEquatable`1&lt;string&gt;" FrameworkAlternate="netstandard-1.0;netstandard-1.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements IComparable, IComparable(Of String), IEnumerable, IEquatable(Of String)" FrameworkAlternate="netstandard-1.0;netstandard-1.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : IComparable, IComparable&lt;System::String ^&gt;, IEquatable&lt;System::String ^&gt;, System::Collections::IEnumerable" FrameworkAlternate="netstandard-1.0;netstandard-1.1" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IEnumerable&#xA;    interface IComparable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface IEquatable&lt;string&gt;" FrameworkAlternate="netstandard-1.0;netstandard-1.1" />
  <TypeSignature Language="C#" Value="public sealed class String : IComparable, IComparable&lt;string&gt;, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" FrameworkAlternate="netstandard-1.2" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IEquatable`1&lt;string&gt;" FrameworkAlternate="netstandard-1.2" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements IComparable, IComparable(Of String), IEnumerable(Of Char), IEquatable(Of String)" FrameworkAlternate="netstandard-1.2" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : IComparable, IComparable&lt;System::String ^&gt;, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" FrameworkAlternate="netstandard-1.2" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface IEquatable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEnumerable" FrameworkAlternate="netstandard-1.2" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>将文本表示为 UTF-16 代码单元的序列。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks

 字符串是用于表示文本的字符的有序集合。 <xref:System.String>对象是对象的有序集合 <xref:System.Char?displayProperty=nameWithType> ，表示字符串; <xref:System.Char?displayProperty=nameWithType> 对象对应于 utf-16 代码单元。 对象的值 <xref:System.String> 是对象的顺序集合的内容 <xref:System.Char?displayProperty=nameWithType> ，并且该值是不可变的 (也就是说，它是只读) 。 有关字符串不可变性的详细信息，请参阅 [永久性和 StringBuilder 类](#Immutability) 部分。 内存中对象的最大大小 <xref:System.String> 为 2 GB，即约1000000000个字符。

有关 Unicode、UTF-16、代码单位、代码点以及和类型的详细信息 <xref:System.Char> <xref:System.Text.Rune> ，请参阅 [.net 中的字符编码简介](/dotnet/standard/base-types/character-encoding-introduction)。

 本节内容：

 [实例化字符串对象](#Instantiation)\
 [Char 对象和 Unicode 字符](#Characters)\
 [字符串和 Unicode 标准](#Unicode)\
 [字符串和嵌入的 null 字符](#EmbeddedNulls)\
 [字符串和索引](#Indexes)\
 [空字符串和空字符串](#Nulls)\
 [永久性和 StringBuilder 类](#Immutability)\
 [序号与区分区域性的操作](#CultureSensitive)\
 [正](#Normalization)\
 [按类别列出的字符串操作](#ByCategory)

<a name="Instantiation"></a>
## <a name="instantiate-a-string-object"></a>实例化字符串对象
 可以 <xref:System.String> 通过以下方式实例化对象：

- 通过将字符串文本分配给 <xref:System.String> 变量。 这是创建字符串时最常用的方法。 下面的示例使用赋值创建几个字符串。 请注意，在 c # 中，因为反斜杠 (\\) 是转义字符，所以字符串中的文本反斜杠必须进行转义或整个字符串必须是 @-quoted 。

     [!code-cpp[System.String.Class.Instantiate#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp-interactive[System.String.Class.Instantiate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]

- 通过调用 <xref:System.String> 类构造函数。 下面的示例通过调用多个类构造函数来实例化字符串。 请注意，一些构造函数包含指向字符数组的指针或作为参数的带符号字节数组。 Visual Basic 不支持对这些构造函数的调用。 有关构造函数的详细信息 <xref:System.String> ，请参阅 <xref:System.String.%23ctor%2A> 构造函数摘要。

     [!code-cpp[System.String.Class.Instantiate#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp[System.String.Class.Instantiate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]

- 通过使用 c # 中的字符串串联运算符 (+，并 Visual Basic) 中的 & 或 + 来创建来自 <xref:System.String> 实例和字符串文本的任意组合的单个字符串。 下面的示例演示如何使用字符串连接运算符。

     [!code-cpp[System.String.Class.Instantiate#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp-interactive[System.String.Class.Instantiate#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]

- 通过检索属性或调用返回字符串的方法。 下面的示例使用类的方法 <xref:System.String> 从较大的字符串中提取子字符串。

     [!code-cpp[System.String.Class.Instantiate#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp-interactive[System.String.Class.Instantiate#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]

- 通过调用格式设置方法，将值或对象转换为其字符串表示形式。 下面的示例使用 [复合格式设置](/dotnet/standard/base-types/composite-formatting) 功能将两个对象的字符串表示形式嵌入到一个字符串中。

     [!code-cpp[System.String.Class.Instantiate#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp[System.String.Class.Instantiate#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]

<a name="Characters"></a>
## <a name="char-objects-and-unicode-characters"></a>Char 对象和 Unicode 字符
 字符串中的每个字符都是由 Unicode 标量值（也称为 Unicode 码位）或序号 (数字) Unicode 字符的值来定义的。 每个码位均使用 UTF-16 编码进行编码，并且编码的每个元素的数值均由一个 <xref:System.Char> 对象表示。

> [!NOTE]
> 请注意，由于 <xref:System.String> 实例包含 utf-16 代码单元的有序集合，因此，可以创建一个不是格式正确的 <xref:System.String> Unicode 字符串的对象。 例如，可以创建具有低代理项的字符串，而无需使用相应的高代理项。 尽管某些方法（例如，命名空间中的编码和解码对象的方法） <xref:System.Text> 可能会执行检查以确保字符串的格式正确，但 <xref:System.String> 类成员不确保字符串格式正确。

 单个 <xref:System.Char> 对象通常表示单个码位; 即，的数值 <xref:System.Char> 等于码位。 例如，字符 "a" 的码位为 U + 0061。 但是，码位可能要求多个编码元素 (多个 <xref:System.Char>) 的对象。 Unicode 标准定义两种类型的字符，它们对应于多个 <xref:System.Char> 对象： graphemes，以及与 unicode 辅助平面中的字符相对应的 unicode 补充码位。

- 字形由后跟一个或多个组合字符的基本字符表示。 例如，字符ä由 <xref:System.Char> 其码位为 u + 0061 的对象后跟 <xref:System.Char> 其码位为 u + 0308 的对象表示。 此字符也可由 <xref:System.Char> 其码位为 U + 00E4 的单个对象定义。 如下面的示例所示，区分大小写的相等比较表明这两个表示形式相等，不过普通序号比较不是这样。 但是，如果这两个字符串被规范化，则序号比较也指示它们相等。  (有关规范化字符串的详细信息，请参阅 [规范化](#Normalization) 部分。 ) 

     [!code-cpp[System.String.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]

- Unicode 补充码位 (代理项对) 由一个对象表示，该 <xref:System.Char> 对象的代码点为高代理项，后跟一个 <xref:System.Char> 其代码点为低代理项的对象。 高代理项的代码单位范围是从 U + D800 到 U + DBFF。 低代理项的代码单位范围是从 U + DC00 到 U + DFFF。 代理项对用于表示16个 Unicode 补充平面中的字符。 下面的示例创建一个代理项字符，并将其传递给 <xref:System.Char.IsSurrogatePair(System.Char%2CSystem.Char)?displayProperty=nameWithType> 方法，以确定它是否为代理项对。

     [!code-cpp[System.String.Class#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp-interactive[System.String.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]

<a name="Unicode"></a>
## <a name="strings-and-the-unicode-standard"></a>字符串和 Unicode 标准
 字符串中的字符由与值对应的 UTF-16 编码的代码单位表示 <xref:System.Char> 。

 字符串中的每个字符都具有关联的 Unicode 字符类别，该类别在 .NET 中由 <xref:System.Globalization.UnicodeCategory> 枚举表示。 可以通过调用方法来确定字符或代理项对的类别 <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> 。

[!INCLUDE[character-categories](~/includes/unicode-categories.md)]

 此外，.NET 还支持基于 Unicode 标准的字符串比较和排序。 .NET Framework 4 及早期版本维护其自己的字符串数据表。 这也适用于从 Windows 7 上运行的 .NET Framework 4.5 开始的 .NET Framework 版本。 从在 Windows 8 和更高版本的 Windows 操作系统上运行 .NET Framework 4.5 开始，运行时将字符串比较和排序操作委托给操作系统。 在 .NET Core 和 .NET 5 + 上，字符串比较和排序信息由 [Unicode 库的国际化组件](http://site.icu-project.org/) 提供 (但 windows 10 之前的 Windows 版本可能2019更新) 。 下表列出了 .NET 版本以及 Unicode 标准的版本，这些版本的字符比较和排序基于这些版本。

|.NET 版本|Unicode 标准版本|
|----------------------------|-------------------------------------|
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[Unicode 标准，版本 4.0.0](https://www.unicode.org/versions/Unicode4.0.0/)|
|.NET Framework 2.0|[Unicode 标准，版本 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[Unicode 标准，版本 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[Unicode 标准，版本 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] 和更高版本的 Windows 7|[Unicode 标准，版本 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] Windows 8 及更高版本的 Windows 操作系统上和更高版本|[Unicode 标准，版本 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|
|.NET Core 和 .NET 5+|取决于基础操作系统支持的 Unicode 标准版本。|

<a name="EmbeddedNulls"></a>
## <a name="strings-and-embedded-null-characters"></a>字符串和嵌入的 null 字符
 在 .NET 中， <xref:System.String> 对象可以包含嵌入的 null 字符，这些字符将作为字符串长度的一部分计数。 但是，在某些语言（如 C 和 c + +）中，空字符表示字符串的末尾;它不被视为字符串的一部分，并且不计入字符串长度中。 这意味着，在应用于对象时，C 和 c + + 程序员或用 C 或 c + + 编写的库可能会导致字符串不一定有效 <xref:System.String> ：

- 或函数返回的值 `strlen` `wcslen` 不一定相等 <xref:System.String.Length%2A?displayProperty=nameWithType> 。

- 或函数创建的字符串 `strcpy_s` `wcscpy_s` 不一定与方法创建的字符串完全相同 <xref:System.String.Copy%2A?displayProperty=nameWithType> 。

 你应确保用于实例化对象的本机 C 和 c + + 代码 <xref:System.String> ，以及 <xref:System.String> 通过平台调用传递对象的代码，不会假定嵌入的 null 字符标记字符串的末尾。

 当对字符串进行排序时，字符串中嵌入的空字符的处理方式也会不同， (或在搜索字符串时) 与该字符串进行比较。 在两个字符串之间执行区分区域性的比较（包括使用固定区域性的比较）时，将忽略 Null 字符。 它们仅被视为顺序比较或不区分大小写的序号比较。 另一方面，在使用、和等方法搜索字符串时，始终会考虑嵌入的 null 字符 <xref:System.String.Contains%2A> <xref:System.String.StartsWith%2A> <xref:System.String.IndexOf%2A> 。

<a name="Indexes"></a>
## <a name="strings-and-indexes"></a>字符串和索引
 索引是 <xref:System.Char> 中 (不是 Unicode 字符) 的对象的位置 <xref:System.String> 。 索引是从零开始的非负数字，从字符串中的第一个位置开始，即索引位置零。 许多搜索方法（如 <xref:System.String.IndexOf%2A> 和 <xref:System.String.LastIndexOf%2A> ）返回字符串实例中字符或子字符串的索引。

 <xref:System.String.Chars%2A>属性允许你 <xref:System.Char> 按对象在字符串中的索引位置访问各个对象。 由于 <xref:System.String.Chars%2A> 属性是 (Visual Basic) 或 c # ) 中的索引器 (中的默认属性，因此可以 <xref:System.Char> 通过使用如下所示的代码，访问字符串中的各个对象。 此代码将查找字符串中的空格或标点字符，以确定字符串包含的单词数。

 [!code-cpp[System.String.Class#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp-interactive[System.String.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]

 由于 <xref:System.String> 类实现 <xref:System.Collections.IEnumerable> 接口，因此还可以 <xref:System.Char> 使用构造来循环访问字符串中的对象 `foreach` ，如下面的示例所示。

 [!code-cpp[System.String.Class#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp-interactive[System.String.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]

 连续索引值可能不对应于连续的 Unicode 字符，因为 Unicode 字符可能被编码为多个 <xref:System.Char> 对象。 特别是，字符串可能包含多字符单元，这些文本由一个后跟一个或多个组合字符或代理项对的基本字符构成。 若要使用 Unicode 字符而不使用 <xref:System.Char> 对象，请使用 <xref:System.Globalization.StringInfo?displayProperty=nameWithType> 和 <xref:System.Globalization.TextElementEnumerator> 类，或者使用 <xref:System.String.EnumerateRunes%2A?displayProperty=nameWithType> 方法和 <xref:System.Text.Rune> 结构。 下面的示例演示适用于对象的代码与 <xref:System.Char> 使用 Unicode 字符的代码之间的差异。 它比较句子的每个单词中的字符数或文本元素数。 该字符串包含后跟组合字符的基本字符的两个序列。

 [!code-cpp[System.String.Class#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp-interactive[System.String.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]

 此示例通过使用 <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType> 方法和 <xref:System.Globalization.TextElementEnumerator> 类来枚举字符串中的所有文本元素，来处理文本元素。 还可以通过调用方法来检索包含每个文本元素的起始索引的数组 <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType> 。

 有关使用文本单元而不是单个值的详细信息 <xref:System.Char> ，请参阅 [.net 中的字符编码简介](/dotnet/standard/base-types/character-encoding-introduction)。

<a name="Nulls"></a>
## <a name="null-strings-and-empty-strings"></a>空字符串和空字符串
 已声明但尚未赋值的字符串为 `null` 。 尝试对该字符串调用方法会引发 <xref:System.NullReferenceException> 。 空字符串不同于空字符串，这是一个字符串，其值为 "" 或 <xref:System.String.Empty?displayProperty=nameWithType> 。 在某些情况下，如果将 null 字符串或空字符串作为参数传递给方法调用，将引发异常。 例如，将空字符串传递给方法会 <xref:System.Int32.Parse%2A?displayProperty=nameWithType> 引发 <xref:System.ArgumentNullException> ，传递空字符串会引发 <xref:System.FormatException> 。 在其他情况下，方法参数可以为 null 字符串或空字符串。 例如，如果您正在为 <xref:System.IFormattable> 某个类提供实现，则需要将空字符串和空字符串作为常规 ( "G" ) 格式说明符。

 <xref:System.String>类包含以下两个简便方法，使您能够测试字符串是否为 `null` 或为空：

- <xref:System.String.IsNullOrEmpty%2A>，指示字符串是 `null` 还是等于  <xref:System.String.Empty?displayProperty=nameWithType> 。 此方法无需使用如下所示的代码：

     [!code-cpp[System.String.Class.Null#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]

- <xref:System.String.IsNullOrWhiteSpace%2A>，指示字符串是 `null` 、等于 <xref:System.String.Empty?displayProperty=nameWithType> 还是仅由空白字符组成。 此方法无需使用如下所示的代码：

     [!code-cpp[System.String.Class.Null#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]

 下面的示例 <xref:System.String.IsNullOrEmpty%2A> 在 <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> 自定义类的实现中使用方法 `Temperature` 。 方法支持 "G"、"C"、"F" 和 "K" 格式字符串。 如果将值为的空格式字符串或格式字符串 `null` 传递给方法，则将其值更改为 "G" 格式字符串。

 [!code-cpp[System.String.Class.Null#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]

<a name="Immutability"></a>
## <a name="immutability-and-the-stringbuilder-class"></a>永久性和 StringBuilder 类
 <xref:System.String>对象被称为不可变 (只读) ，因为在创建后，不能修改它的值。 用于修改对象的方法 <xref:System.String> 实际上会返回一个 <xref:System.String> 包含修改的新对象。

 由于字符串是不可变的，因此，对显示为单个字符串的内容执行重复添加或删除操作的字符串操作例程可能会显著降低性能。 例如，下面的代码使用随机数生成器在0x0001 到0x052F 范围内创建1000字符的字符串。 尽管代码显示使用字符串串联将新字符追加到名为的现有字符串，但 `str` 它实际上 <xref:System.String> 为每个串联操作创建了一个新的对象。

 [!code-cpp[System.String.Class#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]

 <xref:System.Text.StringBuilder> <xref:System.String> 对于对字符串的值进行多次更改的操作，可以使用类，而不是类。 与类的实例不同 <xref:System.String> ， <xref:System.Text.StringBuilder> 对象是可变的; 当您连接、追加或删除字符串中的子字符串时，将对单个字符串执行这些操作。 完成修改对象的值后 <xref:System.Text.StringBuilder> ，可以调用其 <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> 方法将其转换为字符串。 下面的示例将替换 <xref:System.String> 前面的示例中使用的，以将范围中的1000个随机字符连接到0x0001，以使用对象进行 0x052F <xref:System.Text.StringBuilder> 。

 [!code-cpp[System.String.Class#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]

<a name="CultureSensitive"></a>
## <a name="ordinal-vs-culture-sensitive-operations"></a>序号与区分区域性的操作
 类的成员 <xref:System.String> 对对象执行序号或区分区域性的 (语言) 操作 <xref:System.String> 。 序号运算作用于每个对象的数值 <xref:System.Char> 。 区分区域性的操作将作用于对象的值 <xref:System.String> ，并考虑特定于区域性的大小写、排序、格式设置和分析规则。 在显式声明的区域性或隐式当前区域性的上下文中执行区分区域性的操作。 当在同一字符串中执行两种类型的操作时，它们会产生不同的结果。

.NET 还支持不区分区域性的语言字符串操作，方法是使用固定区域性 (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>) ，这是松散的，这是基于英语独立于区域的区域性设置的。 不同于其他 <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> 设置，保证固定区域性的设置在一台计算机、系统、系统和 .net 版本之间保持一致。 固定区域性可被视为一种黑色框，可确保在所有区域性中进行字符串比较和排序的稳定性。

> [!IMPORTANT]
> 如果你的应用程序对符号标识符（如文件名或命名管道）做出安全决策，或对保存的数据（例如 XML 文件中基于文本的数据）进行安全决策，则操作应使用序号比较，而不是区分区域性的比较。 这是因为区分区域性的比较可能会产生不同的结果，具体取决于有效的区域性，而序号比较仅依赖于所比较字符的二进制值。

> [!IMPORTANT]
> 执行字符串操作的大多数方法都包含一个具有类型为的参数的重载 <xref:System.StringComparison> ，使您可以指定该方法是执行序号还是区分区域性的操作。 通常，应调用此重载，使方法调用的意图清晰明了。 有关对字符串使用序号和区分区域性的操作的最佳实践和指南，请参阅 [使用字符串的最佳做法](/dotnet/standard/base-types/best-practices-strings)。

 用于 [大小写](#casing)、 [分析和格式](#parsing)、 [比较和排序](#comparison)的操作以及 [相等性测试](#equality) 的操作可以是序号或区分区域性的。 以下各节介绍操作的每个类别。

> [!TIP]
> 应始终调用方法重载，使方法调用的意图清晰。 例如， <xref:System.String.Compare(System.String%2CSystem.String)> 使用当前区域性的约定，而不是调用方法来对两个字符串执行区分区域性的比较，应使用 <xref:System.String.Compare(System.String%2CSystem.String%2CSystem.StringComparison)> 参数的值调用方法 <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> `comparisonType` 。 有关详细信息，请参阅[有关使用字符串的最佳实践](/dotnet/standard/base-types/best-practices-strings)。

您可以从以下链接下载排序权重表，其中包含有关排序和比较操作中使用的字符权重的信息的一组文本文件：

- Windows ( .NET Framework 和 .NET Core) ： [排序权重表](https://www.microsoft.com/download/details.aspx?id=10921)
- Windows 10 可能2019更新或更高版本 ( .NET 5 +) 以及 Linux 和 macOS ( .NET Core 和 .NET 5 +) ： [默认 Unicode 排序规则元素表](https://www.unicode.org/Public/UCA/latest/allkeys.txt)

<a name="casing"></a>
### <a name="casing"></a>大小写
 大小写规则确定如何更改 Unicode 字符的大小写;例如，从小写到大写。 通常，大小写操作在字符串比较之前执行。 例如，可能会将字符串转换为大写形式，以便可以将其与另一个大写字符串进行比较。 可以通过调用或方法将字符串中的字符转换为小写 <xref:System.String.ToLower%2A> <xref:System.String.ToLowerInvariant%2A> ，并可以通过调用或方法将其转换为大写 <xref:System.String.ToUpper%2A> <xref:System.String.ToUpperInvariant%2A> 。 此外，还可以使用 <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> 方法将字符串转换为词首字母大写。

[!INCLUDE[platform-note](~/includes/c-and-posix-cultures.md)]

 大小写操作可以基于当前区域性的规则、指定的区域性或固定区域性。 由于大小写映射可能会因所使用的区域性而异，因此大小写操作的结果可能会因区域性而异。 大小写的实际差异为三种类型：

- 拉丁文大写字母 I (U + 0049) ，拉丁文小写字母 I (U + 0069) ，拉丁文大写字母 I 与上面的点 (U + 0130) ，以及拉丁文小写字母无点 I (U + 0131) 。 在 tr-TR (土耳其语 (土耳其) # A3 and az-AZ (阿塞拜疆，拉丁语) 文化，在 tr，az，and az-Latn 中立文化中，小写等效于拉丁大写字母 I 的小写字母无点 i，并且上面带有带点的大写等效字符 i。 在所有其他区域性（包括固定区域性）中，拉丁文小写字母 I 和拉丁大写字母 I 是小写和大写等效项。

     下面的示例演示了在依赖于区分区域性的大小写比较的情况下，用于防止文件系统访问的字符串比较可能会失败。  (应使用固定区域性的大小写约定。 ) 

     [!code-csharp[System.String.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]

- 固定区域性与所有其他区域性之间的大小写映射差异。 在这些情况下，使用固定区域性的大小写规则将字符更改为大写或小写将返回相同的字符。 对于所有其他区域性，它返回不同的字符。 下表列出了一些受影响的字符。

    |字符|如果更改为|返回|
    |---------------|-------------------|-------------|
    |微米符号 (U + 00B5) |大写|希腊语大写字母 MU (U +-39C) |
    |拉丁文大写字母 I 与上点 (U + 0130) |小写|拉丁文小写字母 I (U + 0069) |
    |拉丁文小写字母无点 (U + 0131) |大写|拉丁文大写字母 I (U + 0049) |
    |拉丁文小写字母长 S (U + 017F) |大写|拉丁文大写字母 S (U + 0053) |
    |拉丁文大写字母 D 与小写字母 Z 一起出现 (U + 01C5) |小写|拉丁文小写字母 DZ 与抑扬符 (U + 01C6) |
    |结合希腊语 YPOGEGRAMMENI (U + 0345) |大写|希腊语大写字母 IOTA (U + 0399) |

- ASCII 字符范围内两个字母混合大小写对的大小写差异。 在大多数区域性中，两字母混合大小写与等效的双字母大写或小写对相等。 对于以下区域性中的以下两个字母对，这并不是这样，因为在每种情况下，它们将与二个连字符进行比较：

    -   hr-HR (克罗地亚语 (克罗地亚) # A3 区域性中的 "V6d-lj-h2e" 和 "nJ"。

    -   cs-CZ 中的 "cH" (捷克 (捷克共和国) # A3 和 sk-SK (斯洛伐克语 (# A7 区域性。

    -   da 中的 "aA"-深色 (丹麦 (丹麦) # A3 区域性。

    -    (匈牙利语 (匈牙利) # A3 区域性中的 "cS"、"dZ"、"dZS"、"nY"、"sZ"、"tY" 和 "zS"。

    -   es ES_tradnl 中的 "cH" 和 "lL" (西班牙语 (西班牙，传统排序) # A3 区域性。

    -   VN (越南语 (越南) # A3 区域性中的 "cH"、"gI"、"kH"、"nG" "nH"、"pH"、"qU"、"tH" 和 "tR"。

     但是，出现这种对等区分区域性的比较时可能会产生问题，因为这些对在固定字符串或标识符中不常见。

 下面的示例演示了在将字符串转换为大写时，区域性之间的大小写规则的一些差异。

 [!code-cpp[System.String.Class#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]

<a name="parsing"></a>
### <a name="parsing-and-formatting"></a>分析和格式化
 格式设置和分析是反向操作。 格式设置规则确定如何将值（如日期和时间或数字）转换为其字符串表示形式，而分析规则确定如何将字符串表示形式转换为值（如日期和时间）。 格式设置和分析规则都依赖于区域性约定。 下面的示例说明了解释特定于区域性的日期字符串时可能出现的多义性。 如果不知道用于生成日期字符串的区域性约定，则不可能知道03/01/2011、3/1/2011 和01/03/2011 是表示年1月 2011 3 日还是年3月 2011 1 日。

 [!code-cpp[System.String.Class#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]

 同样，如下面的示例所示，单个字符串可以生成不同的日期，具体取决于在分析操作中使用约定的区域性。

 [!code-cpp[System.String.Class#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]

<a name="comparison"></a>
### <a name="string-comparison-and-sorting"></a>字符串比较和排序
 用于比较和排序字符串的约定因区域性而异。 例如，排序顺序可能基于拼音或字符的直观表示形式。 在东亚语言中，按文字的笔画和部首对字符进行排序。 排序也取决于字母表使用的排序语言和区域性。 例如，丹麦语包含一个 "Æ" 字符，该字符在字母表中的 "Z" 之后排序。 此外，比较可以区分大小写或不区分大小写，而大小写规则可能会因区域性而异。 另一方面，序号比较在比较和排序字符串时使用字符串中各个字符的 Unicode 码位。

 排序规则确定 Unicode 字符的字母顺序，以及两个字符串之间的相互比较。 例如， <xref:System.String.Compare(System.String%2CSystem.String%2CSystem.StringComparison)?displayProperty=nameWithType> 方法基于参数比较两个字符串 <xref:System.StringComparison> 。 如果参数值为 <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> ，则该方法执行使用当前区域性的约定的语言比较; 如果参数值为 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> ，则该方法执行序号比较。 因此，正如下面的示例中所示，如果当前区域性为美国英语，则使用区分区域性的比较) 对方法的第一次调用会将 <xref:System.String.Compare(System.String%2CSystem.String%2CSystem.StringComparison)?displayProperty=nameWithType> "a" (视为 "a"，但使用序号) 比较 (对同一方法的第二次调用会将 "a" 视为大于 "a"。

 [!code-cpp[System.String.Class#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]

 .NET 支持 word、string 和 ordinal 排序规则：

- 单词排序会对字符串执行区分区域性的比较，在这些字符串中，某些非字母数字的 Unicode 字符可能会分配有特殊的权重。 例如，连字符 ( ) 可能会分配非常小的权重，以便在排序列表中彼此相邻显示 "合作比较" 和 "共同操作"。 有关 <xref:System.String> 使用单词排序规则比较两个字符串的方法列表，请参阅 " [按类别列出的字符串操作](#ByCategory) " 部分。

- 字符串排序还会执行区分区域性的比较。 它类似于单词排序，只不过没有特殊情况，所有非字母数字的符号都在所有字母数字 Unicode 字符之前。 可以使用字符串排序规则来比较两个字符串，方法是调用 <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> 具有参数的方法重载，该 `options` 参数提供值 <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType> 。 请注意，这是 .NET 提供的唯一方法，可使用字符串排序规则来比较两个字符串。

- 序号排序根据字符串中每个对象的数值来比较字符串 <xref:System.Char> 。 序号比较会自动区分大小写，因为字符的小写和大写版本具有不同的码位。 但是，如果 case 不重要，则可以指定忽略大小写的序号比较。 这等效于使用固定区域性将字符串转换为大写，然后对结果执行序号比较。 有关 <xref:System.String> 使用序号排序规则比较两个字符串的方法的列表，请参阅 [按类别列出的字符串操作](#ByCategory) 部分。

 区分区域性的比较是显式或隐式使用 <xref:System.Globalization.CultureInfo> 对象（包括属性指定的固定区域性）的任何比较 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 。 隐式区域性为当前区域性，由 <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> 和 <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> 属性指定。 字母字符的排序顺序有相当大的变化形式 (即， <xref:System.Char.IsLetter%2A?displayProperty=nameWithType> 属性 `true`) 跨区域性返回的字符。 您可以通过 <xref:System.Globalization.CultureInfo> 向字符串比较方法（如）提供对象来指定使用特定区域性约定的区分区域性的比较 <xref:System.String.Compare(System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions)> 。 您可以通过将 <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> 、或 <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> 除或之外的任何枚举成员提供 <xref:System.Globalization.CompareOptions> <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> 给方法的适当重载 <xref:System.String.Compare%2A> ，来指定使用当前区域性的约定的区分区域性的比较。 通常，区分区域性的比较适用于排序，而序号比较不是。 序号比较通常适用于确定两个字符串是否相等 (也就是说，确定标识) 而不区分区域性的比较。

 下面的示例阐释区分区域性和顺序比较之间的差异。 该示例计算三个字符串： "Apple"、"Æble" 和 "AEble"，使用序号比较以及 "" 和 "en-us" 区域性的约定 (其中每个都是调用方法时的默认区域性 <xref:System.String.Compare%2A>) 。 由于丹麦语将字符 "Æ" 视为单个字母，并在字母表中的 "Z" 后对其进行排序，因此字符串 "Æble" 大于 "Apple"。 但是，"Æble" 不会视为等效于 "AEble"，因此 "Æble" 还会大于 "AEble"。 En-us 区域性不包含字母 "Æ"，而是将其视为等效于 "AE"，这说明 "Æble" 小于 "Apple" 但等于 "AEble" 的原因。 另一方面，序号比较会将 "Apple" 视为小于 "Æble"，将 "Æble" 视为大于 "AEble"。

 [!code-csharp[System.String.Class#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]

 使用以下一般准则来选择适当的排序或字符串比较方法：

- 如果希望根据用户的区域性对字符串进行排序，则应根据当前区域性的约定对它们进行排序。 如果用户的区域性发生更改，则排序字符串的顺序也会相应地发生更改。 例如，同义词库应用程序应始终基于用户的区域性对单词进行排序。

- 如果希望根据特定区域性的约定对字符串进行排序，则应通过将 <xref:System.Globalization.CultureInfo> 表示该区域性的对象提供给比较方法进行排序。 例如，在旨在向学生讲授特定语言的应用程序中，你希望根据使用该语言的某个区域性的约定对字符串进行排序。

- 如果希望字符串顺序在不同的区域性中保持不变，则应根据固定区域性的约定或使用序号比较对它们进行排序。 例如，使用序号排序来组织文件、进程、互斥体或命名管道的名称。

- 对于涉及安全决策的比较 (例如用户名是否有效) ，应始终通过调用方法的重载来执行顺序相等性测试 <xref:System.String.Equals%2A> 。

> [!NOTE]
> 字符串比较中使用的区分区域性的排序和大小写规则取决于 .NET 的版本。 在 .NET Core 上，字符串比较依赖于基础操作系统支持的 Unicode 标准版本。 在 Windows 8 或更高版本上运行的 .NET Framework 4.5 及更高版本中，排序、大小写、规范化和 Unicode 字符信息符合 Unicode 6.0 标准。 在其他 Windows 操作系统上，它们遵循 Unicode 5.0 标准。

 有关 word、字符串和顺序排序规则的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 主题。 有关何时使用每个规则的其他建议，请参阅 [使用字符串的最佳做法](/dotnet/standard/base-types/best-practices-strings)。

 通常，您不会直接调用字符串比较方法（如） <xref:System.String.Compare%2A> 来确定字符串的排序顺序。 相反，通过排序方法（如或）调用比较 <xref:System.Array.Sort%2A?displayProperty=nameWithType> 方法 <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> 。 下面的示例使用当前区域性执行四个不同的排序操作 (单词排序、使用固定区域性进行排序、序号排序和使用固定区域性的字符串排序) 而无需显式调用字符串比较方法，尽管它们确实指定了要使用的比较类型。 请注意，每种类型的排序在其数组中生成唯一的字符串排序。

 [!code-cpp[System.String.Class#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]

> [!TIP]
> 在内部，.NET 使用排序键来支持区分区域性的字符串比较。 对于字符串中的每个字符，都赋予若干类排序权重，包括字母、大小写和变音符。 由类表示的排序关键字 <xref:System.Globalization.SortKey> 为特定字符串提供了这些权重的存储库。 如果你的应用程序对相同的一组字符串执行大量搜索或排序操作，则可以通过为其使用的所有字符串生成和存储排序关键字来提高其性能。 需要进行排序或比较操作时，请使用排序关键字而不是字符串。 有关更多信息，请参见 <xref:System.Globalization.SortKey> 类。

 如果未指定字符串比较约定，将对 <xref:System.Array.Sort(System.Array)?displayProperty=nameWithType> 字符串执行区分区域性、区分大小写的排序等方法。 下面的示例演示更改当前区域性如何影响数组中已排序字符串的顺序。 它创建一个包含三个字符串的数组。 首先，它将 `System.Threading.Thread.CurrentThread.CurrentCulture` 属性设置为 en-US，并调用 <xref:System.Array.Sort(System.Array)?displayProperty=nameWithType> 方法。 生成的排序顺序基于英语 (美国) 区域性的排序约定。 接着，此示例将 `System.Threading.Thread.CurrentThread.CurrentCulture` 属性设置为 da-DK 并再次调用 <xref:System.Array.Sort%2A?displayProperty=nameWithType> 方法。 请注意，最终排序顺序与使用 en-US 时的结果不一样，因为这次使用的是针对丹麦语（丹麦）的排序约定。

 [!code-csharp[Conceptual.Strings.Comparing#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]

> [!WARNING]
> 如果比较字符串的主要目的是确定它们是否相等，应调用 <xref:System.String.Equals%2A?displayProperty=nameWithType> 方法。 通常，应使用 <xref:System.String.Equals%2A> 来执行序号比较。 <xref:System.String.Compare%2A?displayProperty=nameWithType>方法主要用于对字符串进行排序。

 字符串搜索方法（如 <xref:System.String.StartsWith%2A?displayProperty=nameWithType> 和 <xref:System.String.IndexOf%2A?displayProperty=nameWithType> ）也可以执行区分区域性或序号字符串比较。 下面的示例使用方法说明了序号和区分区域性的比较之间的差异 <xref:System.String.IndexOf%2A> 。 区分区域性的搜索，其中，当前区域性为英语 (美国) 将子字符串 "oe" 与连字 "–" 相匹配。 由于软连字符 (U + 00AD) 是宽度为零的字符，因此搜索会将软连字符视为等效于 <xref:System.String.Empty?displayProperty=nameWithtype> 并在字符串的开头找到匹配项。 另一方面，序号搜索在任一情况下都找不到匹配项。

 [!code-cpp[System.String.Class#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]

### <a name="search-in-strings"></a>在字符串中搜索
 字符串搜索方法（如 <xref:System.String.StartsWith%2A?displayProperty=nameWithType> 和 <xref:System.String.IndexOf%2A?displayProperty=nameWithType> ）也可以执行区分区域性或序号的字符串比较，以确定是否在指定字符串中找到了字符或子字符串。

 类中搜索单独字符的搜索方法（如 <xref:System.String> <xref:System.String.IndexOf%2A> 方法）或一组字符（如方法）中的一种搜索方法 <xref:System.String.IndexOfAny%2A> 都执行序号搜索。 若要对字符执行区分区域性的搜索，必须调用 <xref:System.Globalization.CompareInfo> 方法，如 <xref:System.Globalization.CompareInfo.IndexOf(System.String%2CSystem.Char)?displayProperty=nameWithType> 或 <xref:System.Globalization.CompareInfo.LastIndexOf(System.String%2CSystem.Char)?displayProperty=nameWithType> 。 请注意，使用序号和区分区域性的比较搜索字符的结果可能会有很大的不同。 例如，搜索预构成 Unicode 字符（如连字 "Æ" (U + 00C6) ）可能会以正确的顺序（例如 "AE" (U + 041U + 0045) ）匹配其任何组件的出现位置，具体取决于区域性。 下面的示例演示了在 <xref:System.String.IndexOf(System.Char)?displayProperty=nameWithType> <xref:System.Globalization.CompareInfo.IndexOf(System.String%2CSystem.Char)?displayProperty=nameWithType> 搜索单个字符时和方法之间的差异。 使用 en-us 区域性约定时，在字符串 "高空" 中找到连字 "æ" (U + 00E6) ，但不能在使用 da-深色区域性或执行序号比较时使用。

 [!code-csharp[System.String.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]

 另一方面， <xref:System.String> 搜索字符串（而不是字符）的类方法执行区分区域性的搜索（如果搜索选项未由类型的参数显式指定） <xref:System.StringComparison> 。 唯一的例外是 <xref:System.String.Contains%2A> ，它执行序号搜索。

<a name="equality"></a>
### <a name="testing-for-equality"></a>测试是否相等

使用 <xref:System.String.Compare%2A?displayProperty=nameWithType> 方法来确定两个字符串在排序顺序中的关系。 通常，这是一个区分区域性的操作。 与此相反，请调用 <xref:System.String.Equals%2A?displayProperty=nameWithType> 方法来测试是否相等。 由于测试相等性通常会将用户输入与某个已知的字符串（如有效用户名、密码或文件系统路径）进行比较，因此通常为序号运算。

> [!WARNING]
> 可以通过调用方法来测试相等性 <xref:System.String.Compare%2A?displayProperty=nameWithType> ，并确定返回值是否为零。 但是，不建议使用这种做法。 若要确定两个字符串是否相等，应调用方法的重载之一 <xref:System.String.Equals%2A?displayProperty=nameWithType> 。 要调用的首选重载是实例 <xref:System.String.Equals(System.String%2CSystem.StringComparison)> 方法或静态 <xref:System.String.Equals(System.String%2CSystem.String%2CSystem.StringComparison)> 方法，因为这两个方法都包含 <xref:System.StringComparison?displayProperty=nameWithType> 显式指定比较类型的参数。

 下面的示例说明了在应改用序号时执行区分区域性比较是否相等的危险。 在这种情况下，代码的目的是禁止从以 "FILE://" 或 "file://" 开头的 url 进行文件系统访问，方法是对 URL 开头使用字符串 "FILE://" 执行不区分大小写的比较。 但是，如果在以 "file://" 开头的 URL 上使用土耳其语 (土耳其) 区域性来执行区分区域性的比较，则相等比较将失败，因为土耳其语大写字母等效于小写的 "i"，而不是 "i"。 因此，无意允许文件系统访问。 另一方面，如果执行了序号比较，则相等比较将成功，并且拒绝文件系统访问。

 [!code-cpp[System.String.Class#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]

<a name="Normalization"></a>
## <a name="normalization"></a>标准化
 某些 Unicode 字符具有多个表示形式。 例如，以下任何代码点都可以表示字母 "ắ"：

- U + 1EAF

- U + 0103 U + 0301

- U + 0061 U + 0306 U + 0301

 单个字符的多个表示形式使得搜索、排序、匹配和其他字符串操作复杂化。

 Unicode 标准定义了一个名为规范化的进程，该进程为其任何等效的二进制表示形式返回 Unicode 字符的一个二进制表示形式。 规范化可以使用多种算法，这些算法采用不同的规则。 .NET 支持 Unicode 范式 C、D、GLM-KC-QNW 和 KD。 将字符串规范化为同一范式后，可以使用序号比较对它们进行比较。

 序号比较是 <xref:System.Char> 每个字符串中相应对象的 Unicode 标量值的二进制比较。 <xref:System.String>类包括多个可执行序号比较的方法，其中包括：

- 包含参数的、、、、 <xref:System.String.Compare%2A> <xref:System.String.Equals%2A> <xref:System.String.StartsWith%2A>  <xref:System.String.EndsWith%2A> <xref:System.String.IndexOf%2A> 和 <xref:System.String.LastIndexOf%2A> 方法 <xref:System.StringComparison> 的任何重载。 如果 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 为此参数提供或的值，则方法会执行序号比较 <xref:System.StringComparison.OrdinalIgnoreCase> 。

- 方法的重载 <xref:System.String.CompareOrdinal%2A> 。

- 默认情况下使用序号比较的方法，例如 <xref:System.String.Contains%2A> 、 <xref:System.String.Replace%2A> 和 <xref:System.String.Split%2A> 。

- <xref:System.Char>在字符串实例中搜索值或数组中元素的方法 <xref:System.Char> 。 此类方法包括 <xref:System.String.IndexOf(System.Char)> 和 <xref:System.String.Split(System.Char%5B%5D)> 。

 可以通过调用方法来确定字符串是否规范化为范式 C <xref:System.String.IsNormalized?displayProperty=nameWithType> ，也可以调用 <xref:System.String.IsNormalized(System.Text.NormalizationForm)?displayProperty=nameWithType> 方法来确定字符串是否规范化为指定的范式。 还可以调用方法将 <xref:System.String.Normalize?displayProperty=nameWithType> 字符串转换为范式 C，也可以调用 <xref:System.String.Normalize(System.Text.NormalizationForm)?displayProperty=nameWithType> 方法将字符串转换为指定的范式。 有关规范化和比较字符串的分步信息，请参阅 <xref:System.String.Normalize> 和 <xref:System.String.Normalize(System.Text.NormalizationForm)> 方法。

 以下简单示例演示了字符串规范化。 它在三个不同的字符串中以三种不同的方式定义字母 "ố"，并使用相等的序号比较来确定每个字符串与其他两个字符串不同。 然后，它将每个字符串转换为支持的范式，并再次对每个字符串采用指定范式的序号比较。 在每种情况下，第二个相等测试会显示字符串是否相等。

 [!code-cpp[System.String.Class#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]

 有关规范化和范式的详细信息，请参阅 <xref:System.Text.NormalizationForm?displayProperty=nameWithType> ，以及 [Unicode 标准附录 #15：](https://unicode.org/reports/tr15/) unicode.org 网站上的 Unicode 范式和 [规范化常见问题解答](https://www.unicode.org/faq/normalization.html) 。

<a name="ByCategory"></a>
## <a name="string-operations-by-category"></a>按类别列出的字符串操作
 此 <xref:System.String> 类提供了成员，用于比较字符串，测试字符串是否相等，查找字符串中的字符或子字符串，修改字符串，从字符串中提取子字符串，组合字符串，格式化值，复制字符串，以及规范化字符串。

### <a name="compare-strings"></a>比较字符串
 您可以通过使用以下方法来比较字符串，以确定它们在排序顺序中的相对位置 <xref:System.String> ：

- <xref:System.String.Compare%2A> 返回一个整数，该整数指示在排序顺序中一个字符串与另一个字符串的关系。

- <xref:System.String.CompareOrdinal%2A> 返回一个整数，该整数指示一个字符串与另一个字符串的关系是否基于其码位的比较。

- <xref:System.String.CompareTo%2A> 返回一个整数，该整数指示当前字符串实例与排序顺序中的第二个字符串之间的关系。 <xref:System.String.CompareTo(System.String)>方法 <xref:System.IComparable> 为类提供和 <xref:System.IComparable%601> 实现 <xref:System.String> 。

### <a name="test-strings-for-equality"></a>测试字符串的相等性

调用 <xref:System.String.Equals%2A> 方法来确定两个字符串是否相等。 实例 <xref:System.String.Equals(System.String%2CSystem.String%2CSystem.StringComparison)> 和静态 <xref:System.String.Equals(System.String%2CSystem.StringComparison)> 重载使你能够指定比较是区分区域性还是序号，以及是否考虑或忽略大小写。 大多数相等测试都是序号，并且确定对系统资源的访问权限的相等性比较 (如文件系统对象) 应始终为序号。

### <a name="find-characters-in-a-string"></a>查找字符串中的字符

<xref:System.String>类包含两种搜索方法：

- 返回一个 <xref:System.Boolean> 值以指示特定子字符串是否出现在字符串实例中的方法。 其中包括 <xref:System.String.Contains%2A> 、 <xref:System.String.EndsWith%2A> 和 <xref:System.String.StartsWith%2A> 方法。

- 指示字符串实例中子字符串的起始位置的方法。 其中包括 <xref:System.String.IndexOf%2A> 、 <xref:System.String.IndexOfAny%2A> 、 <xref:System.String.LastIndexOf%2A> 和 <xref:System.String.LastIndexOfAny%2A> 方法。

> [!WARNING]
> 如果要在字符串中搜索特定模式而不是特定子字符串，应使用正则表达式。 有关详细信息，请参阅 [.Net 正则表达式](/dotnet/standard/base-types/regular-expressions)。

### <a name="modify-a-string"></a>修改字符串

<xref:System.String>类包括以下用于修改字符串值的方法：

- <xref:System.String.Insert%2A> 将字符串插入到当前 <xref:System.String> 实例中。

- <xref:System.String.PadLeft%2A> 在字符串的开头插入一个或多个指定字符的匹配项。

- <xref:System.String.PadRight%2A> 在字符串的末尾插入指定字符的一个或多个匹配项。

- <xref:System.String.Remove%2A> 删除当前实例中的子字符串 <xref:System.String> 。

- <xref:System.String.Replace%2A> 将子字符串替换为当前实例中的另一个子字符串 <xref:System.String> 。

- <xref:System.String.ToLower%2A><xref:System.String.ToLowerInvariant%2A>将字符串中的所有字符转换为小写。

- <xref:System.String.ToUpper%2A><xref:System.String.ToUpperInvariant%2A>将字符串中的所有字符转换为大写。

- <xref:System.String.Trim%2A> 删除字符串开头和结尾的所有匹配项。

- <xref:System.String.TrimEnd%2A> 删除字符串末尾的所有匹配项。

- <xref:System.String.TrimStart%2A> 从字符串的开头移除字符的所有匹配项。

> [!IMPORTANT]
> 所有字符串修改方法都将返回新的 <xref:System.String> 对象。 它们不会修改当前实例的值。

### <a name="extract-substrings-from-a-string"></a>从字符串中提取子字符串

<xref:System.String.Split%2A?displayProperty=nameWithType>方法将单个字符串分隔为多个字符串。 方法的重载允许您指定多个分隔符，以限制该方法提取的子字符串的数量，并可指定是否 (空字符串（当分隔符为相邻时) 会包含在返回的字符串中）。

### <a name="combine-strings"></a>合并字符串

以下 <xref:System.String> 方法可用于字符串串联：

- <xref:System.String.Concat%2A> 将一个或多个子字符串合并为一个字符串。

- <xref:System.String.Join%2A> 将一个或多个子字符串连接到单个元素，并在每个子字符串之间添加分隔符。

### <a name="format-values"></a>设置值格式

<xref:System.String.Format%2A?displayProperty=nameWithType>方法使用复合格式设置功能将字符串中的一个或多个占位符替换为一些对象或值的字符串表示形式。 <xref:System.String.Format%2A>方法通常用于执行以下操作：

- 在字符串中嵌入数值的字符串表示形式。

- 在字符串中嵌入日期和时间值的字符串表示形式。

- 在字符串中嵌入枚举值的字符串表示形式。

- 在字符串中嵌入支持接口的某些对象的字符串表示形式 <xref:System.IFormattable> 。

- 如果为，则在较大字符串中右对齐或左对齐字段中的子字符串。

 有关格式化操作和示例的详细信息，请参阅 " <xref:System.String.Format%2A> 重载摘要"。

### <a name="copy-a-string"></a>复制字符串

您可以调用以下 <xref:System.String> 方法来创建字符串的副本：

- <xref:System.String.Clone%2A> 返回对现有对象的引用 <xref:System.String> 。

- <xref:System.String.Copy%2A> 创建现有字符串的副本。

- <xref:System.String.CopyTo%2A> 将部分字符串复制到字符数组。

### <a name="normalize-a-string"></a>规范化字符串

在 Unicode 中，单个字符可以有多个码位。 规范化将这些等效字符转换为相同的二进制表示形式。 <xref:System.String.Normalize%2A?displayProperty=nameWithType>方法执行规范化， <xref:System.String.IsNormalized%2A?displayProperty=nameWithType> 方法确定字符串是否规范化。

有关详细信息和示例，请参阅本主题前面的 [规范化](#Normalization) 部分。

 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://www.microsoft.com/download/details.aspx?id=10921">仅限 Windows ( .NET Framework 和 .NET Core 的权重表) </related>
    <related type="ExternalDocumentation" href="https://www.unicode.org/Public/UCA/latest/allkeys.txt">默认 Unicode 排序规则元素表</related>
    <threadsafe>此类型是线程安全的。</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.ICloneable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Text.StringBuilder" />
    <altmember cref="T:System.Globalization.CultureInfo" />
    <related type="Article" href="/dotnet/standard/base-types/formatting-types">设置 .NET 中类型的格式</related>
    <related type="Article" href="/dotnet/standard/base-types/best-practices-strings">有关使用 .NET 中字符串的最佳做法</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.String" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
本节内容：

[重载的构造函数语法](#Syntax)\
[Parameters](#Params)\
[不同](#Exceptions)\
[我要调用哪种方法？](#Tasks)\
[创建字符串](#Creating_Strings)\
[处理重复的字符串](#Repetitive)

实例化字符串示例：

[使用字符串赋值](#Ctor1_Example)\
[使用字符数组](#Ctor2_Example)\
[使用字符数组的一部分并重复使用单个字符](#Ctor3_Example)\
[使用指向字符数组的指针](#Ctor4_Example)\
[使用指针和数组的范围](#Ctor5_Example)\
[使用带符号字节数组的指针](#Ctor6_Example)

<a name="Syntax"></a>
## <a name="overloaded-constructor-syntax"></a>重载的构造函数语法

字符串构造函数分为两类：不带指针参数的类，以及带有指针参数的构造函数。 使用指针的构造函数不符合 CLS。 此外，Visual Basic 不支持使用指针，并且 c # 要求使用指针的代码在不安全的上下文中运行。 有关详细信息，请参阅 [unsafe](/dotnet/csharp/language-reference/keywords/unsafe)。

有关选择重载的其他指导，请参阅 [应该调用哪种方法？](#Tasks)。

 `String(Char[] value)`\
 将新实例初始化为由 Unicode 字符数组指示的值。 此构造函数将 Unicode 字符复制 ([示例](#Ctor2_Example)) 。

 `String(Char[] value, Int32 startIndex, Int32 length)`\
 将新实例初始化为由 Unicode 字符数组指示的值、该数组内的起始字符位置和长度 ([示例](#Ctor3_Example)) 。

 `String(Char c, Int32 count)`\
 将新的实例初始化为指定 Unicode 字符指示的值， ([示例](#Ctor3_Example)) 重复指定的次数。

 `String(char* value)`\
 **(不符合 CLS)** 将新的实例初始化为由指向 Unicode 字符数组的指针指示的值，该数组由 null 字符 (U + 0000 或 "\ 0" ) 终止。  ([示例](#Ctor4_Example)) 。

 权限： <xref:System.Security.SecurityCriticalAttribute> 需要直接调用方的完全信任。 部分受信任的或透明的代码不能使用此成员。

 `String(char* value, Int32 startIndex, Int32 length)`\
 **(不符合 CLS)** 将新的实例初始化为由指向 Unicode 字符数组的指针、该数组内的起始字符位置和一个长度指示的值。 构造函数从 `value` 索引处开始复制 Unicode 字符 `startIndex` ，并在索引-1 处结束， `startIndex`  +  `length` ([示例](#Ctor5_Example)) 。

 权限： <xref:System.Security.SecurityCriticalAttribute> 需要直接调用方的完全信任。 部分受信任的或透明的代码不能使用此成员。

 `String(SByte* value)`\
 **(不符合 CLS)** 将新的实例初始化为由指向8位有符号整数数组的指针指示的值。 假定数组表示使用当前系统代码页编码的字符串 (即) 指定的编码 <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> 。 构造函数将处理从 `value` 指针指定的位置开始的字符，直到到达 (0x00)  ([示例](#Ctor6_Example)) 。

 权限： <xref:System.Security.SecurityCriticalAttribute> 需要直接调用方的完全信任。 部分受信任的或透明的代码不能使用此成员。

 `String(SByte* value, Int32 startIndex, Int32 length)`\
 **(不符合 CLS)** 将新实例初始化为由指向8位有符号整数数组的指针、该数组内的起始位置和一个长度指示的值。  假定数组表示使用当前系统代码页编码的字符串 (即) 指定的编码 <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> 。 构造函数从开始 `startIndex` ，到 `startIndex`  +  `length` -1 ([示例](#Ctor6_Example)) 的值处理字符。

 权限： <xref:System.Security.SecurityCriticalAttribute> 需要直接调用方的完全信任。 部分受信任的或透明的代码不能使用此成员。

 `String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)`\
 **(不符合 CLS)** 将新实例初始化为由指向8位有符号整数数组的指针、该数组内的起始位置、长度和对象指示的值 <xref:System.Text.Encoding> 。

 权限： <xref:System.Security.SecurityCriticalAttribute> 需要直接调用方的完全信任。 部分受信任的或透明的代码不能使用此成员。

<a name="Params"></a>
## <a name="parameters"></a>参数

下面是 <xref:System.String> 不包含指针参数的构造函数所使用的参数的完整列表。 对于每个重载使用的参数，请参阅上述重载语法。

|参数|类型|描述|
|---------------|----------|-----------------|
|`value`|<xref:System.Char>[]|Unicode 字符的数组。|
|`c`|<xref:System.Char>|一个 Unicode 字符。|
|`startIndex`|<xref:System.Int32>|`value`新字符串中第一个字符的起始位置。<br /><br /> 默认值：0|
|`length`|<xref:System.Int32>|要包含在新字符串中的中的字符数 `value` 。<br /><br /> 默认值：30<xref:System.Array.Length%2A?displayProperty=nameWithType>|
|`count`|<xref:System.Int32>|`c`在新字符串中重复字符的次数。 如果 `count` 为零，则新对象的值为 <xref:System.String.Empty?displayProperty=nameWithType> 。|

 下面是 <xref:System.String> 包含指针参数的构造函数所使用的参数的完整列表。 对于每个重载使用的参数，请参阅上述重载语法。

|参数|类型|描述|
|---------------|----------|-----------------|
|`value`|<xref:System.Char>*<br /><br /> \- 或 -<br /><br /> <xref:System.SByte>\*|指向以 null 结尾的 Unicode 字符数组的指针或一个8位有符号整数数组。 如果 `value` 为 `null` 或空数组，则新字符串的值为 <xref:System.String.Empty?displayProperty=nameWithType> 。|
|`startIndex`|<xref:System.Int32>|数组元素的索引，该元素定义新字符串中的第一个字符。<br /><br /> 默认值：0|
|`length`|<xref:System.Int32>|用于创建新字符串的数组元素的数目。 如果 length 为零，则构造函数将创建一个值为的字符串 <xref:System.String.Empty?displayProperty=nameWithType> 。<br /><br /> 默认值：30<xref:System.Array.Length%2A?displayProperty=nameWithType>|
|`enc`|<xref:System.Text.Encoding>|一个对象，该对象指定如何对 `value` 数组进行编码。<br /><br /> 默认值： <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> ，或系统的当前 ANSI 代码页|

<a name="Exceptions"></a>
## <a name="exceptions"></a>异常
 下面是不包含指针参数的构造函数引发的异常列表。

|异常|条件|引发者|
|---------------|---------------|---------------|
|<xref:System.ArgumentNullException>|`value` 为 `null`。|<xref:System.String.%23ctor(System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32)>|
|<xref:System.ArgumentOutOfRangeException>|`startIndex`、 `length` 或 `count` 小于零。<br /><br /> - 或 -<br /><br /> `startIndex` 与 `length` 的和大于 `value` 中的元素数。<br /><br /> - 或 -<br /><br /> `count` 小于零。|<xref:System.String.%23ctor(System.Char%2CSystem.Int32)><br /><br /> <xref:System.String.%23ctor(System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32)>|

 下面是包含指针参数的构造函数引发的异常列表。

|异常|条件|引发者|
|---------------|---------------|---------------|
|<xref:System.ArgumentException>|`value` 指定包含无效 Unicode 字符的数组。<br /><br /> - 或 -<br /><br /> `value`或 `value`  +  `startIndex` 指定的地址小于64k。<br /><br /> - 或 -<br /><br /> <xref:System.String>无法从字节数组初始化新的实例， `value` 因为不 `value` 使用默认代码页编码。|带有指针的所有构造函数。|
|<xref:System.ArgumentNullException>|`value` 为 null。|<xref:System.String.%23ctor(System.SByte%2A)><br /><br /> <xref:System.String.%23ctor(System.SByte%2A%2CSystem.Int32%2CSystem.Int32)><br /><br /> <xref:System.String.%23ctor(System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding)>|
|<xref:System.ArgumentOutOfRangeException>|当前进程不具有对所有通过地址访问的字符的读取访问权限。<br /><br /> - 或 -<br /><br /> `startIndex` 或 `length` 小于零，`value` + `startIndex` 导致指针溢出，或者当前进程不具有对所有寻址字符的读取访问权限。<br /><br /> - 或 -<br /><br /> 新字符串的长度太大，无法分配。|带有指针的所有构造函数。|
|<xref:System.AccessViolationException>|`value`，或 `value`  +  `startIndex`  +  `length` 为-1，则指定无效的地址。|<xref:System.String.%23ctor(System.SByte%2A)><br /><br /> <xref:System.String.%23ctor(System.SByte%2A%2CSystem.Int32%2CSystem.Int32)><br /><br /> <xref:System.String.%23ctor(System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding)>|

<a name="Tasks"></a>
## <a name="which-method-do-i-call"></a>我要调用哪种方法？

|功能|调用或使用|
|--------|-----------------|
|创建一个字符串。|从字符串文字或现有字符串赋值 ([示例](#Ctor1_Example)) |
|从整个字符数组创建字符串。|<xref:System.String.%23ctor(System.Char%5B%5D)> ([示例](#Ctor2_Example)) |
|从字符数组的一部分创建字符串。|<xref:System.String.%23ctor(System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32)> ([示例](#Ctor3_Example)) |
|创建多次重复相同字符的字符串。|<xref:System.String.%23ctor(System.Char%2CSystem.Int32)> ([示例](#Ctor3_Example)) |
|从指向 Unicode 或宽字符数组的指针创建一个字符串。|<xref:System.String.%23ctor(System.Char%2A)>|
|使用其指针从 Unicode 或宽字符数组的一部分创建字符串。|<xref:System.String.%23ctor(System.Char%2A%2CSystem.Int32%2CSystem.Int32)>|
|创建 c + + 数组中的字符串 `char` 。|<xref:System.String.%23ctor(System.SByte%2A)>, <xref:System.String.%23ctor(System.SByte%2A%2CSystem.Int32%2CSystem.Int32)><br /><br /> - 或 -<br /><br /> <xref:System.String.%23ctor(System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding)>|
|从 ASCII 字符创建一个字符串。|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=nameWithType>|

<a name="Creating_Strings"></a>
## <a name="create-strings"></a>创建字符串

以编程方式创建字符串时最常用的方法是简单赋值，如 [本示例](#Ctor1_Example)中所示。 <xref:System.String>类还包括四种类型的构造函数重载，可用于从以下值创建字符串：

- 从字符数组 (由 UTF-16 编码的字符组成的数组) 。 您可以 <xref:System.String> 从整个数组或其中某个部分的字符创建新的对象。 <xref:System.String.%23ctor(System.Char%5B%5D)>构造函数将数组中的所有字符复制到新字符串中。 <xref:System.String.%23ctor(System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32)>构造函数将索引中的字符复制 `startIndex` 到索引 `startIndex`  +  `length` -1 到新的字符串。 如果 `length` 为零，则新字符串的值为 <xref:System.String.Empty?displayProperty=nameWithType> 。

  如果你的代码重复实例化具有相同值的字符串，则可以使用创建字符串的替代方法来提高应用程序性能。 有关详细信息，请参阅 [处理重复的字符串](#Repetitive)。

- 使用构造函数从零次、一次或多次重复的单个字符 <xref:System.String.%23ctor(System.Char%2CSystem.Int32)> 。 如果 `count` 为零，则新字符串的值为 <xref:System.String.Empty?displayProperty=nameWithType> 。

- 通过使用 <xref:System.String.%23ctor(System.Char%2A)> 或构造函数从指向以 null 结尾的字符数组的指针 <xref:System.String.%23ctor(System.Char%2A%2CSystem.Int32%2CSystem.Int32)> 。 整个数组或指定范围可用于初始化字符串。 构造函数从指定的指针或从指定的指针加上 `startIndex` 并继续到数组的末尾或为字符复制一系列 Unicode 字符 `length` 。 如果 `value` 为 null 指针或 `length` 为零，则构造函数将创建一个值为的字符串 <xref:System.String.Empty?displayProperty=nameWithType> 。 如果复制操作继续到数组末尾，并且数组不是以 null 终止的，则构造函数行为与系统相关。 这种情况可能导致访问冲突。

  如果数组包含任何嵌入的 null 字符 (U + 0000 或 "\ 0" ) 并且 <xref:System.String.%23ctor(System.Char%2A%2CSystem.Int32%2CSystem.Int32)> 调用了重载，则字符串实例将包含包含 `length` 任何嵌入的 null 字符。 下面的示例演示在将包含两个 null 字符的数组的指针传递到方法时会发生的情况 <xref:System.String.%23ctor(System.Char%2A%2CSystem.Int32%2CSystem.Int32)> 。 由于地址是数组的开头，数组中的所有元素都将添加到字符串，因此构造函数将实例化包含10个字符的字符串，包括两个嵌入的 null。 另一方面，如果将同一个数组传递给 <xref:System.String.%23ctor(System.Char%2A)> 构造函数，则结果是一个四个字符的字符串，该字符串不包含第一个 null 字符。

  [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
  [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]

  数组必须包含 Unicode 字符。 在 c + + 中，这意味着必须将字符数组定义为 managed <xref:System.Char> [] 类型或非托管 `wchar_t` [] 类型。

  如果 <xref:System.String.%23ctor(System.Char%2A)> 调用了重载，且数组不是以 null 结尾的，或者如果 <xref:System.String.%23ctor(System.Char%2A%2CSystem.Int32%2CSystem.Int32)> 调用了重载，并且 `startIndex`  +  `length` -1 包括的范围超出了为字符序列分配的内存，则构造函数的行为将与系统相关，并可能会发生访问冲突。

- 从指向有符号字节数组的指针。 整个数组或指定范围可用于初始化字符串。 可以使用默认代码页编码来解释字节序列，也可以在构造函数调用中指定编码。 如果构造函数尝试从整个数组中实例化不是以 null 结尾的字符串，或者从 `value`  +  `startIndex` -1 到-1 的数组范围超出了为 `value`  +  `startIndex`  +  `length` 数组分配的内存，则此构造函数的行为与系统相关，并可能会发生访问冲突。

  这三个构造函数将有符号字节数组作为参数，主要用于将 c + + `char` 数组转换为字符串，如以下示例中所示：

  [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]

  如果数组包含任何 null 字符 ( "\ 0" ) 或值为0的字节 <xref:System.String.%23ctor(System.SByte%2A%2CSystem.Int32%2CSystem.Int32)> ，并且调用了重载，则字符串实例将包含 `length` 任何嵌入的 null 字符。 下面的示例演示在将包含两个 null 字符的数组的指针传递到方法时会发生的情况 <xref:System.String.%23ctor(System.SByte%2A%2CSystem.Int32%2CSystem.Int32)> 。 由于地址是数组的开头，数组中的所有元素都将添加到字符串，因此构造函数将实例化包含10个字符的字符串，包括两个嵌入的 null。 另一方面，如果将同一个数组传递给 <xref:System.String.%23ctor(System.SByte%2A)> 构造函数，则结果是一个四个字符的字符串，该字符串不包含第一个 null 字符。

  [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
  [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]

  由于 <xref:System.String.%23ctor(System.SByte%2A)> 和 <xref:System.String.%23ctor(System.SByte%2A%2CSystem.Int32%2CSystem.Int32)> 构造函数 `value` 使用默认的 ANSI 代码页进行解释，因此，使用相同的字节数组调用这些构造函数可能会在不同系统上创建具有不同值的字符串。

<a name="Repetitive"></a>
## <a name="handle-repetitive-strings"></a>处理重复的字符串

分析或解码文本流的应用通常使用 <xref:System.String.%23ctor(System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32)> 构造函数或方法将 <xref:System.Text.StringBuilder.Append(System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32)?displayProperty=nameWithType> 字符序列转换为字符串。 重复创建具有相同值的新字符串，而不是创建和重用一个字符串会浪费内存。 如果您可能会通过调用构造函数反复创建相同的字符串值 <xref:System.String.%23ctor(System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32)> ，即使您事先事先不知道这些相同的字符串值，也可以改用查找表。

例如，假设您从包含 XML 标记和特性的文件中读取和分析字符流。 分析流时，会反复遇到某些标记 (即具有符号表示) 的字符序列。 与字符串 "0"、"1"、"true" 和 "false" 等效的标记可能经常出现在 XML 流中。

你可以创建一个 <xref:System.Xml.NameTable?displayProperty=nameWithType> 对象来保存通常出现的字符串，而不是将每个标记转换为一个新字符串。 <xref:System.Xml.NameTable>对象可提高性能，因为它检索存储的字符串，而不分配临时内存。 如果遇到标记，请使用 <xref:System.Xml.NameTable.Get(System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32)?displayProperty=nameWithType> 方法从表中检索标记。 如果标记存在，则方法返回相应的字符串。 如果该标记不存在，请使用 <xref:System.Xml.NameTable.Add(System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32)?displayProperty=nameWithType> 方法将该标记插入到表中，并获取相应的字符串。

<a name="Ctor1_Example"></a>
## <a name="example-1-use-string-assignment"></a>示例1：使用字符串赋值

下面的示例通过为字符串赋值来创建一个新字符串。 它通过将第一个字符串的值分配给它来创建第二个字符串。 这是实例化新对象的两种最常用的方法 <xref:System.String> 。

:::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp" id="Snippet1":::
:::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs" interactive="try-dotnet" id="Snippet1":::
:::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb" id="Snippet1":::

<a name="Ctor2_Example"></a>
## <a name="example-2-use-a-character-array"></a>示例2：使用字符数组

下面的示例演示如何 <xref:System.String> 从字符数组创建新的对象。

:::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp" id="Snippet1":::
:::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs" interactive="try-dotnet-method" id="Snippet1":::
:::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb" id="Snippet1":::

<a name="Ctor3_Example"></a>
## <a name="example-3-use-a-portion-of-a-character-array-and-repeating-a-single-character"></a>示例3：使用字符数组的一部分并重复单个字符

下面的示例演示如何 <xref:System.String> 从字符数组的一部分创建一个新的对象，以及如何创建一个新的 <xref:System.String> 对象，该对象包含单个字符的多个匹配项。

:::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp" id="Snippet3":::
:::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs" interactive="try-dotnet-method" id="Snippet3":::
:::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb" id="Snippet3":::

<a name="Ctor4_Example"></a>
## <a name="example-4-use-a-pointer-to-a-character-array"></a>示例4：使用指向字符数组的指针

下面的示例演示如何 <xref:System.String> 从指向字符数组的指针创建新的对象。 必须使用编译器开关编译 c # 示例 `/unsafe` 。

[!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
[!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]

<a name="Ctor5_Example"></a>
## <a name="example-5-instantiate-a-string-from-a-pointer-and-a-range-of-an-array"></a>示例5：从指针和数组的范围实例化字符串

下面的示例检查某个字符数组的元素中是否有句点或感叹号。 如果找到了一个字符串，则会从该标点符号前面的数组中的字符实例化一个字符串。 如果不是，则会实例化包含数组全部内容的字符串。 必须使用编译器开关编译 c # 示例 `/unsafe` 。

[!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
[!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]

<a name="Ctor6_Example"></a>
## <a name="example-6-instantiate-a-string-from-a-pointer-to-a-signed-byte-array"></a>示例6：从指向有符号字节数组的指针实例化字符串

下面的示例演示如何 <xref:System.String> 使用构造函数创建类的实例 <xref:System.String.%23ctor(System.SByte%2A)> 。

[!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
[!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value">指向以 null 终止的 Unicode 字符数组的指针。</param>
        <summary>将 <see cref="T:System.String" /> 类的新实例初始化为由指向 Unicode 字符数组的指定指针指示的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
> 有关此和其他构造函数重载的示例和综合使用信息 `String` ，请参阅 <xref:System.String.%23ctor%2A> 构造函数摘要。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">当前进程不具有对所有通过地址访问的字符的读取访问权限。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> 指定的数组包含无效的 Unicode 字符，或 <paramref name="value" /> 指定的地址小于 64000。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new string : char[] -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Unicode 字符的数组。</param>
        <summary>将 <see cref="T:System.String" /> 类的新实例初始化为指定字符数组中指示的 Unicode 字符。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
> 有关此和其他构造函数重载的示例和综合使用信息 `String` ，请参阅 <xref:System.String.%23ctor%2A> 构造函数摘要。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="new string : ReadOnlySpan&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">Unicode 字符的只读范围。</param>
        <summary>将 <see cref="T:System.String" /> 类的新实例初始化为指定只读范围中指示的 Unicode 字符。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">一个指针，指向以 null 结尾的 8 位带符号整数数组。 使用当前系统代码页编码（即由 <see cref="P:System.Text.Encoding.Default" /> 指定的编码）来解释整数。</param>
        <summary>将 <see cref="T:System.String" /> 类的新实例初始化为由指向 8 位有符号整数数组的指针指示的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
> 有关此和其他构造函数重载的示例和综合使用信息 `String` ，请参阅 <xref:System.String.%23ctor%2A> 构造函数摘要。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">如果 <paramref name="value" /> 采用 ANSI 进行编码，那么无法使用 <paramref name="value" /> 初始化 <see cref="T:System.String" /> 的新实例。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">要初始化的新字符串的长度（该长度由 <paramref name="value" /> 的 null 终止字符确定）太大，无法分配。</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" /> 指定的地址无效。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As Char, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char c, int count);" />
      <MemberSignature Language="F#" Value="new string : char * int -&gt; string" Usage="new System.string (c, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c">一个 Unicode 字符。</param>
        <param name="count"><paramref name="c" /> 出现的次数。</param>
        <summary>将 <see cref="T:System.String" /> 类的新实例初始化为由重复指定次数的指定 Unicode 字符指示的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
> 有关此和其他构造函数重载的示例和综合使用信息 `String` ，请参阅 <xref:System.String.%23ctor%2A> 构造函数摘要。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 小于零。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">指向 Unicode 字符数组的指针。</param>
        <param name="startIndex"><paramref name="value" /> 内的起始位置。</param>
        <param name="length">要使用的 <paramref name="value" /> 内的字符数。</param>
        <summary>将 <see cref="T:System.String" /> 类的新实例初始化为由指向 Unicode 字符数组的指定指针指示的值、该数组内的起始字符位置和一个长度指示的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
> 有关此和其他构造函数重载的示例和综合使用信息 `String` ，请参阅 <xref:System.String.%23ctor%2A> 构造函数摘要。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 或 <paramref name="length" /> 小于零，<paramref name="value" /> + <paramref name="startIndex" /> 导致指针溢出，或者当前进程不具有对所有寻址字符的读取访问权限。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> 指定的数组包含无效的 Unicode 字符，或 <paramref name="value" /> + <paramref name="startIndex" /> 指定的地址小于 64000。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : char[] * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Unicode 字符的数组。</param>
        <param name="startIndex"><paramref name="value" /> 内的起始位置。</param>
        <param name="length">要使用的 <paramref name="value" /> 内的字符数。</param>
        <summary>将 <see cref="T:System.String" /> 类的新实例初始化为由 Unicode 字符数组、该数组内的起始字符位置和一个长度指示的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
> 有关此和其他构造函数重载的示例和综合使用信息 `String` ，请参阅 <xref:System.String.%23ctor%2A> 构造函数摘要。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 或 <paramref name="length" /> 小于零。

- 或 -

<paramref name="startIndex" /> 与 <paramref name="length" /> 的和大于 <paramref name="value" /> 中的元素数。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">指向 8 位带符号整数数组的指针。 使用当前系统代码页编码（即由 <see cref="P:System.Text.Encoding.Default" /> 指定的编码）来解释整数。</param>
        <param name="startIndex"><paramref name="value" /> 内的起始位置。</param>
        <param name="length">要使用的 <paramref name="value" /> 内的字符数。</param>
        <summary>将 <see cref="T:System.String" /> 类的新实例初始化为由指向 8 位有符号整数数组的指定指针、该数组内的起始位置和一个长度指示的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
> 有关此和其他构造函数重载的示例和综合使用信息 `String` ，请参阅 <xref:System.String.%23ctor%2A> 构造函数摘要。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 或 <paramref name="length" /> 小于零。

- 或 -

由 <paramref name="value" /> + <paramref name="startIndex" /> 指定的地址对于当前平台而言太大；也就是说，此地址计算溢出。

- 或 -

要初始化的新字符串的长度太大，无法分配。</exception>
        <exception cref="T:System.ArgumentException">由 <paramref name="value" /> + <paramref name="startIndex" /> 指定的地址小于 64K。

- 或 -

如果 <paramref name="value" /> 采用 ANSI 进行编码，那么无法使用 <paramref name="value" /> 初始化 <see cref="T:System.String" /> 的新实例。</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" />、<paramref name="startIndex" /> 和 <paramref name="length" /> 共同指定的地址无效。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding? enc);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length, System::Text::Encoding ^ enc);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int * System.Text.Encoding -&gt; string" Usage="new System.string (value, startIndex, length, enc)" />
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="enc" Type="System.Text.Encoding" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">指向 8 位带符号整数数组的指针。</param>
        <param name="startIndex"><paramref name="value" /> 内的起始位置。</param>
        <param name="length">要使用的 <paramref name="value" /> 内的字符数。</param>
        <param name="enc">一个对象，用于指定如何对 <paramref name="value" /> 所引用的数组进行编码。 如果 <paramref name="enc" /> 为 <see langword="null" />，则假定以 ANSI 编码。</param>
        <summary>将 <see cref="T:System.String" /> 的新实例初始化为由指向 8 位有符号整数数组的指定指针、该数组内的起始位置、长度以及 <see cref="T:System.Text.Encoding" /> 对象指示的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
> 有关此和其他构造函数重载的示例和综合使用信息 `String` ，请参阅 <xref:System.String.%23ctor%2A> 构造函数摘要。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 或 <paramref name="length" /> 小于零。

- 或 -

由 <paramref name="value" /> + <paramref name="startIndex" /> 指定的地址对于当前平台而言太大；也就是说，此地址计算溢出。

- 或 -

要初始化的新字符串的长度太大，无法分配。</exception>
        <exception cref="T:System.ArgumentException">由 <paramref name="value" /> + <paramref name="startIndex" /> 指定的地址小于 64K。

- 或 -

如果 <paramref name="value" /> 按照指定的 <paramref name="enc" /> 进行编码，那么无法使用 <paramref name="value" /> 初始化 <see cref="T:System.String" /> 的新实例。</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" />、<paramref name="startIndex" /> 和 <paramref name="length" /> 共同指定的地址无效。</exception>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">当前的字符串中的位置。</param>
        <summary>获取当前 <see cref="T:System.Char" /> 对象中位于指定位置的 <see cref="T:System.String" /> 对象。</summary>
        <value>位于 <paramref name="index" /> 位置的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `index`参数是从零开始的。

 此属性返回 <xref:System.Char> 参数所指定位置处的对象 `index` 。 但是，Unicode 字符可能由多个表示 <xref:System.Char> 。 使用 <xref:System.Globalization.StringInfo?displayProperty=nameWithType> 类来处理 Unicode 字符，而不是 <xref:System.Char> 对象。 有关详细信息，请参阅类概述中的 "Char 对象和 Unicode 字符" 一节 <xref:System.String> 。

 在 c # 中， <xref:System.String.Chars%2A> 属性是一个索引器。 在 Visual Basic 中，这是类的默认属性 <xref:System.String> 。 <xref:System.Char>可以使用如下代码访问字符串中的每个对象。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb" id="Snippet1":::

## Examples
 下面的示例演示如何在例程中使用此索引器来验证字符串。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> 大于或等于此对象的长度或小于零。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.GetEnumerator" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="string.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回对此 <see cref="T:System.String" />实例的引用。</summary>
        <returns>此 <see cref="T:System.String" /> 实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 返回值不是此实例的独立副本;它只是相同数据的另一个视图。 使用 <xref:System.String.Copy%2A> 或 <xref:System.String.CopyTo%2A> 方法来创建一个 <xref:System.String> 与此实例具有相同值的单独对象。

 因为 <xref:System.String.Clone%2A> 方法只是返回现有的字符串实例，所以很少需要直接调用它。

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Copy(System.String)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>比较两个指定的 <see cref="T:System.String" /> 对象，并返回一个指示二者在排序顺序中的相对位置的整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.String.Compare%2A> 方法的所有重载返回一个 32 位有符号整数，指示两个比较数之间的词法关系。

|“值”|条件|
|-----------|---------------|
|小于零|在排序顺序中，第一个子字符串在第二个子字符串之前。|
|零|子字符串在排序顺序中出现的位置相同或 `length` 为零。|
|大于零|第一个子字符串在排序顺序中后跟第二个子字符串。|

> [!WARNING]
> 应尽可能调用 <xref:System.String.Compare%2A> 包含参数的方法的重载 <xref:System.StringComparison> 。 有关详细信息，请参阅[有关使用字符串的最佳实践](/dotnet/standard/base-types/best-practices-strings)。

 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/base-types/best-practices-strings">有关使用 .NET 中字符串的最佳做法</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string -&gt; int" Usage="System.string.Compare (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">要比较的第一个字符串。</param>
        <param name="strB">要比较的第二个字符串。</param>
        <summary>比较两个指定的 <see cref="T:System.String" /> 对象，并返回一个指示二者在排序顺序中的相对位置的整数。</summary>
        <returns>一个 32 位带符号整数，指示两个比较数之间的词法关系。

 <list type="table"><listheader><term> “值”

 </term><description> 条件

 </description></listheader><item><term> 小于零

 </term><description><paramref name="strA" /> 在排序顺序中位于 <paramref name="strB" /> 之前。

 </description></item><item><term> 零

 </term><description><paramref name="strA" /> 与 <paramref name="strB" /> 在排序顺序中出现的位置相同。

 </description></item><item><term> 大于零

 </term><description><paramref name="strA" /> 在排序顺序中位于 <paramref name="strB" /> 之后。

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 比较使用当前区域性来获取特定于区域性的信息，如大小写规则和单个字符的字母顺序。 例如，区域性可以指定将某些字符组合视为单个字符，或以特定方式比较大写和小写字符，或字符的排序顺序取决于其前面或后面的字符。

 使用字词排序规则执行比较。 有关 word、字符串和顺序排序的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 。

> [!WARNING]
> 在比较字符串时，应调用 <xref:System.String.Compare(System.String%2CSystem.String%2CSystem.StringComparison)> 方法，这要求您显式指定方法使用的字符串比较的类型。 有关详细信息，请参阅[有关使用字符串的最佳实践](/dotnet/standard/base-types/best-practices-strings)。

 其中一个或两个比较字可以为 `null` 。 按照定义，包含空字符串 ( "" ) 中的任何字符串都会比较大于 null 引用;和两个 null 引用的比较结果相等。

 当发现不相等或已比较两个字符串时，将终止比较。 但是，如果两个字符串的比较结果等于一个字符串的末尾，而另一个字符串还剩个字符，则包含剩余字符的字符串将被视为更大的字符串。 返回值是执行的最后一次比较的结果。

 当比较受区域性特定的大小写规则影响时，可能会出现意外的结果。 例如，在土耳其语中，以下示例产生了错误的结果，因为土耳其语中的文件系统不会将语言大小写规则用于 "file" 中的字母 "i"。

 [!code-cpp[System.String.Compare#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]

 使用序号比较将路径名称与 "file" 进行比较。 要执行此操作，正确的代码如下所示：

 [!code-cpp[System.String.Compare#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]

## Examples
 下面的示例调用 <xref:System.String.Compare(System.String%2CSystem.String)> 方法来比较三组字符串。

 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp-interactive[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]

 在下面的示例中， `ReverseStringComparer` 类演示了如何用方法来计算两个字符串 <xref:System.String.Compare%2A> 。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp" id="Snippet7":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs" interactive="try-dotnet" id="Snippet7":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb" id="Snippet7":::

 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>字符集包括可忽略字符。 <see cref="M:System.String.Compare(System.String,System.String)" />当方法执行区分区域性的比较时，它不会考虑此类字符。 例如，如果以下代码在 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 或更高版本上运行，则使用软连字符将 "动物" 与 "动物" 的 "动物" 比较（使用 "ani"） (或 U + 00AD) 指示这两个字符串是等效的。

[！ code-csharp[system.web. 比较 # 21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare21.cs#21)][！ code-vb[system.web. 比较 # 21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare21.vb#21)]

若要在字符串比较中识别可忽略字符，请调用 <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> 方法，并 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 为参数提供或的值 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> `comparisonType` 。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">要比较的第一个字符串。</param>
        <param name="strB">要比较的第二个字符串。</param>
        <param name="ignoreCase">若要在比较过程中忽略大小写，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>比较两个指定的 <see cref="T:System.String" /> 对象（其中忽略或考虑其大小写），并返回一个整数，指示二者在排序顺序中的相对位置。</summary>
        <returns>一个 32 位带符号整数，指示两个比较数之间的词法关系。

 <list type="table"><listheader><term> “值”

 </term><description> 条件

 </description></listheader><item><term> 小于零

 </term><description><paramref name="strA" /> 在排序顺序中位于 <paramref name="strB" /> 之前。

 </description></item><item><term> 零

 </term><description><paramref name="strA" /> 与 <paramref name="strB" /> 在排序顺序中出现的位置相同。

 </description></item><item><term> 大于零

 </term><description><paramref name="strA" /> 在排序顺序中位于 <paramref name="strB" /> 之后。

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 比较使用当前区域性来获取特定于区域性的信息，如大小写规则和单个字符的字母顺序。 例如，区域性可以指定将某些字符组合视为单个字符，或以特定方式比较大写和小写字符，或字符的排序顺序取决于其前面或后面的字符。

 使用字词排序规则执行比较。 有关 word、字符串和顺序排序的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 。

> [!WARNING]
> 在比较字符串时，应调用 <xref:System.String.Compare(System.String%2CSystem.String%2CSystem.StringComparison)> 方法，这要求您显式指定方法使用的字符串比较的类型。 有关详细信息，请参阅[有关使用字符串的最佳实践](/dotnet/standard/base-types/best-practices-strings)。

 其中一个或两个比较字可以为 `null` 。 按照定义，包含空字符串 ( "" ) 中的任何字符串都会比较大于 null 引用;和两个 null 引用的比较结果相等。

 当发现不相等或已比较两个字符串时，将终止比较。 但是，如果两个字符串的比较结果等于一个字符串的末尾，而另一个字符串还剩个字符，则包含剩余字符的字符串将被视为更大的字符串。 返回值是执行的最后一次比较的结果。

 当比较受区域性特定的大小写规则影响时，可能会出现意外的结果。 例如，在土耳其语中，以下示例产生了错误的结果，因为土耳其语中的文件系统不会将语言大小写规则用于 "file" 中的字母 "i"。

 [!code-cpp[System.String.Compare#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]

 使用序号比较将路径名称与 "file" 进行比较。 要执行此操作，正确的代码如下所示：

 [!code-cpp[System.String.Compare#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]

## Examples
 下面的示例演示 <xref:System.String.Compare(System.String%2CSystem.String%2CSystem.Boolean)> 方法等效于在 <xref:System.String.ToUpper%2A> <xref:System.String.ToLower%2A> 比较字符串时使用或。

 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp-interactive[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]

 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>字符集包括可忽略字符。 <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" />当方法执行区分区域性的比较时，它不会考虑此类字符。 例如，如果以下代码在 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 或更高版本上运行，则使用软连字符的 "动物" (区分区域性、不区分大小写的 "动物" 或 U + 00AD) 指示这两个字符串是等效的。

[！ code-csharp[system.web. 比较 # 22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare22.cs#22)][！ code-vb[system.web. 比较 # 22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare22.vb#22)]

若要在字符串比较中识别可忽略字符，请调用 <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> 方法，并 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 为参数提供或的值 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> <paramref name="comparisonType" /> 。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * StringComparison -&gt; int" Usage="System.string.Compare (strA, strB, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">要比较的第一个字符串。</param>
        <param name="strB">要比较的第二个字符串。</param>
        <param name="comparisonType">一个枚举值，用于指定比较中要使用的规则。</param>
        <summary>使用指定的规则比较两个指定的 <see cref="T:System.String" /> 对象，并返回一个整数，指示二者在排序顺序中的相对位置。</summary>
        <returns>一个 32 位带符号整数，指示两个比较数之间的词法关系。

 <list type="table"><listheader><term> “值”

 </term><description> 条件

 </description></listheader><item><term> 小于零

 </term><description><paramref name="strA" /> 在排序顺序中位于 <paramref name="strB" /> 之前。

 </description></item><item><term> 零

 </term><description><paramref name="strA" /> 与 <paramref name="strB" /> 在排序顺序中的位置相同。

 </description></item><item><term> 大于零

 </term><description><paramref name="strA" /> 在排序顺序中位于 <paramref name="strB" /> 之后。

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `comparisonType`参数指示比较应使用当前的或固定的区域性，是接受还是忽略比较规则的大小写，还是使用 word (区分区域性的) 或序号 (不区分区域性的) 排序规则。

 其中一个或两个比较字可以为 `null` 。 按照定义，包含空字符串 ( "" ) 中的任何字符串都会比较大于 null 引用;和两个 null 引用的比较结果相等。

 当发现不相等或已比较两个字符串时，将终止比较。 但是，如果两个字符串的比较结果等于一个字符串的末尾，而另一个字符串还剩个字符，则包含剩余字符的字符串将被视为更大的字符串。 返回值是执行的最后一次比较的结果。

 当比较受区域性特定的大小写规则影响时，可能会出现意外的结果。 例如，在土耳其语中，以下示例产生了错误的结果，因为土耳其语中的文件系统不会将语言大小写规则用于 "file" 中的字母 "i"。

 [!code-cpp[System.String.Compare#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]

 使用序号比较将路径名称与 "file" 进行比较。 要执行此操作，正确的代码如下所示：

 [!code-cpp[System.String.Compare#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]

## Examples
 下面的示例比较字母 "I" 的三个版本。 结果受区域性选择的影响，是否忽略大小写，以及是否执行序号比较。

 [!code-cpp[System.String.CompareCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</exception>
        <exception cref="T:System.NotSupportedException">不支持 <see cref="T:System.StringComparison" />。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符。 <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" />当方法执行区分区域性的比较时，它不会考虑此类字符。 若要在比较中识别可忽略字符，请 <see cref="F:System.StringComparison.Ordinal" /> 为参数提供值或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> <paramref name="comparisonType" /> 。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="strA">要比较的第一个字符串。</param>
        <param name="strB">要比较的第二个字符串。</param>
        <param name="ignoreCase">若要在比较过程中忽略大小写，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <param name="culture">一个对象，提供区域性特定的比较信息。</param>
        <summary>比较两个指定的 <see cref="T:System.String" /> 对象（其中忽略或考虑其大小写，并使用区域性特定的信息干预比较），并返回一个整数，指示二者在排序顺序中的相对位置。</summary>
        <returns>一个 32 位带符号整数，指示两个比较数之间的词法关系。

 <list type="table"><listheader><term> “值”

 </term><description> 条件

 </description></listheader><item><term> 小于零

 </term><description><paramref name="strA" /> 在排序顺序中位于 <paramref name="strB" /> 之前。

 </description></item><item><term> 零

 </term><description><paramref name="strA" /> 与 <paramref name="strB" /> 在排序顺序中出现的位置相同。

 </description></item><item><term> 大于零

 </term><description><paramref name="strA" /> 在排序顺序中位于 <paramref name="strB" /> 之后。

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 该比较使用 `culture` 参数获取特定于区域性的信息，如大小写规则和单个字符的字母顺序。 例如，区域性可以指定将某些字符组合视为单个字符，或以特定方式比较大写和小写字符，或字符的排序顺序取决于其前面或后面的字符。

 使用字词排序规则执行比较。 有关 word、字符串和顺序排序的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 。

 其中一个或两个比较字可以为 `null` 。 按照定义，包含空字符串 ( "" ) 中的任何字符串都会比较大于 null 引用;和两个 null 引用的比较结果相等。

 当发现不相等或已比较两个字符串时，将终止比较。 但是，如果两个字符串的比较结果等于一个字符串的末尾，而另一个字符串还剩个字符，则包含剩余字符的字符串将被视为更大的字符串。 返回值是执行的最后一次比较的结果。

 当比较受区域性特定的大小写规则影响时，可能会出现意外的结果。 例如，在土耳其语中，以下示例产生了错误的结果，因为土耳其语中的文件系统不会将语言大小写规则用于 "file" 中的字母 "i"。

 [!code-cpp[System.String.Compare#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]

 使用序号比较将路径名称与 "file" 进行比较。 要执行此操作，正确的代码如下所示：

 [!code-cpp[System.String.Compare#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]

## Examples
 下面的示例演示区域性如何影响比较。 在捷克语-捷克语，"ch" 是大于 "d" 的单个字符。 但是，在英语美国区域性中，"ch" 包含两个字符，"c" 小于 "d"。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符。 <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />当方法执行区分区域性的比较时，它不会考虑此类字符。 例如，如果以下代码在 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 或更高版本上运行，在使用软连字符的情况下，不区分大小写的 "动物" (使用软连字符，或使用固定区域性的 U + 00AD) ，则指示这两个字符串是等效的。

[！ code-csharp[system.web. 比较 # 23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare23.cs#23)][！ code-vb[system.string. 比较 # 23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare23.vb#23)]

若要在字符串比较中识别可忽略字符，请调用 <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> 方法，并 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 为参数提供或的值 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> <paramref name="options" /> 。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, strB, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="strA">要比较的第一个字符串。</param>
        <param name="strB">要比较的第二个字符串。</param>
        <param name="culture">提供区域性特定的比较信息的区域性。</param>
        <param name="options">要在执行比较时使用的选项（如忽略大小写或符号）。</param>
        <summary>对两个指定的 <see cref="T:System.String" /> 对象进行比较，使用指定的比较选项和区域性特定的信息来影响比较，并返回一个整数，该整数指示这两个字符串在排序顺序中的关系。</summary>
        <returns>一个 32 位带符号整数，该整数指示 <paramref name="strA" /> 与 <paramref name="strB" /> 之间的词法关系，如下表所示

 <list type="table"><listheader><term> “值”

 </term><description> 条件

 </description></listheader><item><term> 小于零

 </term><description><paramref name="strA" /> 在排序顺序中位于 <paramref name="strB" /> 之前。

 </description></item><item><term> 零

 </term><description><paramref name="strA" /> 与 <paramref name="strB" /> 在排序顺序中出现的位置相同。

 </description></item><item><term> 大于零

 </term><description><paramref name="strA" /> 在排序顺序中位于 <paramref name="strB" /> 之后。

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 该比较使用 `culture` 参数获取特定于区域性的信息，如大小写规则和单个字符的字母顺序。 例如，特定的区域性可以指定将某些字符组合视为单个字符、以特定方式进行比较的大写和小写字符，或字符的排序顺序取决于其前面或后面的字符。

> [!CAUTION]
> 此 <xref:System.String.Compare(System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions)> 方法主要用于排序或 alphabetizing 操作。 当方法调用的主要目的是确定两个字符串是否等效时，不应使用此方法，即，当方法调用的目的是测试零) 的返回值时 (。 若要确定两个字符串是否相等，请调用 <xref:System.String.Equals%2A> 方法。

 可以通过参数进一步指定比较，该 `options` 参数由一个或多个枚举成员组成 <xref:System.Globalization.CompareOptions> 。 但是，由于此方法的目的是执行区分区域性的字符串比较， <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> 因此和 <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> 值不起作用。

 两者或两个比较字都可以 `null` 。 按照定义，任何字符串（包括 <xref:System.String.Empty?displayProperty=nameWithType> 、）比较大于 null 引用，而两个 null 引用的比较结果相等。

 当发现不相等或已比较两个字符串时，将终止比较。 但是，如果两个字符串的比较结果与一个字符串的末尾相等，而另一个字符串还剩个字符，则将剩余字符视为更大的字符串。

## Examples
 下面的示例以三种不同的方式对两个字符串进行比较：对 en-us 区域性使用语言比较;对于 en-us 区域性，使用区分语言区分大小写的比较;和使用序号比较。 它说明了这三种比较方法如何产生三个不同的结果。

 [!code-cpp[System.String.Compare#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> 不是 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />当方法执行区分区域性的比较时，它不会考虑此类字符。 若要在比较中识别可忽略字符，请 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 为参数提供值或 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> <paramref name="options" /> 。</para></block>
        <altmember cref="Overload:System.String.CompareOrdinal" />
        <altmember cref="Overload:System.String.CompareTo" />
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">要在比较中使用的第一个字符串。</param>
        <param name="indexA"><paramref name="strA" /> 中子字符串的位置。</param>
        <param name="strB">要在比较中使用的第二个字符串。</param>
        <param name="indexB"><paramref name="strB" /> 中子字符串的位置。</param>
        <param name="length">要比较的子字符串中字符的最大数量。</param>
        <summary>比较两个指定的 <see cref="T:System.String" /> 对象的子字符串，并返回一个指示二者在排序顺序中的相对位置的整数。</summary>
        <returns>一个 32 位有符号整数，指示两个比较数之间的词法关系。

 <list type="table"><listheader><term> 值

 </term><description> 条件

 </description></listheader><item><term> 小于零

 </term><description> <paramref name="strA" /> 中的子字符串在排序顺序中位于 <paramref name="strB" /> 中的子字符串之前。

 </description></item><item><term> 零

 </term><description> 子字符串在排序顺序中出现的位置相同或 <paramref name="length" /> 为零。

 </description></item><item><term> 大于零

 </term><description> <paramref name="strA" /> 中的子字符串在排序顺序中位于 <paramref name="strB" /> 中的子字符串之后。

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 要比较的子字符串 `strA` 在 `indexA` 和中的开始 `strB` 处 `indexB` 。 `indexA`和 `indexB` 都是从零开始的; 即，和中的第一个字符位于 `strA` `strB` 位置零。 第一个子字符串的长度等于 `strA` 减号 `indexA` 加1的长度。 第二个子字符串的长度等于 `strB` 减号 `indexB` 加1。

 要比较的字符数是两个子字符串的长度中较小的一个和 `length` 。 `indexA`、 `indexB` 和 `length` 参数必须为非负。

 比较使用当前区域性来获取特定于区域性的信息，如大小写规则和单个字符的字母顺序。 例如，区域性可以指定将某些字符组合视为单个字符，或以特定方式比较大写和小写字符，或字符的排序顺序取决于其前面或后面的字符。

 使用字词排序规则执行比较。 有关 word、字符串和顺序排序的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 。

> [!WARNING]
> 在比较字符串时，应调用 <xref:System.String.Compare(System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison)> 方法，这要求您显式指定方法使用的字符串比较的类型。 有关详细信息，请参阅[有关使用字符串的最佳实践](/dotnet/standard/base-types/best-practices-strings)。

 其中一个或两个比较字可以为 `null` 。 按照定义，包含空字符串 ( "" ) 中的任何字符串都会比较大于 null 引用;和两个 null 引用的比较结果相等。

 当发现不相等或比较两个子字符串时，将终止比较。 但是，如果两个字符串的比较结果等于一个字符串的末尾，而另一个字符串还剩个字符，则包含剩余字符的字符串将被视为更大的字符串。 返回值是执行的最后一次比较的结果。

 当比较受区域性特定的大小写规则影响时，可能会出现意外的结果。 例如，在土耳其语中，以下示例产生了错误的结果，因为土耳其语中的文件系统不会将语言大小写规则用于 "file" 中的字母 "i"。

 [!code-cpp[System.String.Compare#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]

 使用序号比较将路径名称与 "file" 进行比较。 要执行此操作，正确的代码如下所示：

 [!code-cpp[System.String.Compare#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]

## Examples
 下面的示例比较两个子字符串。

 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp-interactive[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> 大于 <paramref name="strA" />.<see cref="P:System.String.Length" />。

- 或 -

 <paramref name="indexB" /> 大于 <paramref name="strB" />.<see cref="P:System.String.Length" />。

- 或 -

 <paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 为负数。

- 或 -

<paramref name="indexA" /> 或 <paramref name="indexB" /> 为 <see langword="null" />，并且 <paramref name="length" /> 大于零。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符。 此 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> 方法在执行语言或区分区域性的比较时不考虑这些字符。 若要在比较中识别可忽略字符，请调用 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> 方法，并为 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 参数提供值或 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> <paramref name="comparisonType" /> 。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="strA">要在比较中使用的第一个字符串。</param>
        <param name="indexA"><paramref name="strA" /> 中子字符串的位置。</param>
        <param name="strB">要在比较中使用的第二个字符串。</param>
        <param name="indexB"><paramref name="strB" /> 中子字符串的位置。</param>
        <param name="length">要比较的子字符串中字符的最大数量。</param>
        <param name="ignoreCase">若要在比较过程中忽略大小写，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>比较两个指定的 <see cref="T:System.String" /> 对象的子字符串（忽略或考虑其大小写），并返回一个整数，指示二者在排序顺序中的相对位置。</summary>
        <returns>一个 32 位带符号整数，指示两个比较数之间的词法关系。

 <list type="table"><listheader><term> “值”

 </term><description> 条件

 </description></listheader><item><term> 小于零

 </term><description> <paramref name="strA" /> 中的子字符串在排序顺序中位于 <paramref name="strB" /> 中的子字符串之前。

 </description></item><item><term> 零

 </term><description> 子字符串在排序顺序中出现的位置相同或 <paramref name="length" /> 为零。

 </description></item><item><term> 大于零

 </term><description> <paramref name="strA" /> 中的子字符串在排序顺序中位于 <paramref name="strB" /> 中的子字符串之后。

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 要比较的子字符串在中的开始 `strA` `indexA` ，位于中 `strB` `indexB` 。 `indexA`和 `indexB` 都是从零开始的; 即，和中的第一个字符位于 `strA` `strB` 位置零。 第一个子字符串的长度等于 `strA` 减号 `indexA` 加1的长度。 第二个子字符串的长度等于 `strB` 减号 `indexB` 加1。

 要比较的字符数是两个子字符串的长度中较小的一个和 `length` 。 `indexA`、 `indexB` 和 `length` 参数必须为非负。

 比较使用当前区域性来获取特定于区域性的信息，如大小写规则和单个字符的字母顺序。 例如，区域性可以指定将某些字符组合视为单个字符，或以特定方式比较大写和小写字符，或字符的排序顺序取决于其前面或后面的字符。

 使用字词排序规则执行比较。 有关 word、字符串和顺序排序的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 。

> [!WARNING]
> 在比较字符串时，应调用 <xref:System.String.Compare(System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison)> 方法，这要求您显式指定方法使用的字符串比较的类型。 有关详细信息，请参阅[有关使用字符串的最佳实践](/dotnet/standard/base-types/best-practices-strings)。

 其中一个或两个比较字可以为 `null` 。 按照定义，包含空字符串 ( "" ) 中的任何字符串都会比较大于 null 引用;和两个 null 引用的比较结果相等。

 当发现不相等或比较两个子字符串时，将终止比较。 但是，如果两个字符串的比较结果等于一个字符串的末尾，而另一个字符串还剩个字符，则包含剩余字符的字符串将被视为更大的字符串。 返回值是执行的最后一次比较的结果。

 当比较受区域性特定的大小写规则影响时，可能会出现意外的结果。 例如，在土耳其语中，以下示例产生了错误的结果，因为土耳其语中的文件系统不会将语言大小写规则用于 "file" 中的字母 "i"。

 [!code-cpp[System.String.Compare#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]

 路径名称需要按固定方式进行比较。 要执行此操作，正确的代码如下所示。

 [!code-cpp[System.String.Compare#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]

## Examples
 下面的示例对两个仅大小写不同的子字符串执行两次比较。 第一个比较忽略大小写，第二个比较考虑用例。

 [!code-cpp[string.compare4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp-interactive[string.compare4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> 大于 <paramref name="strA" />.<see cref="P:System.String.Length" />。

- 或 -

 <paramref name="indexB" /> 大于 <paramref name="strB" />.<see cref="P:System.String.Length" />。

- 或 -

 <paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 为负数。

- 或 -

<paramref name="indexA" /> 或 <paramref name="indexB" /> 为 <see langword="null" />，并且 <paramref name="length" /> 大于零。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符。 此 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> 方法在执行语言或区分区域性的比较时不考虑这些字符。 若要在比较中识别可忽略字符，请调用 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> 方法，并为 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 参数提供值或 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> <paramref name="comparisonType" /> 。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * StringComparison -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="5" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">要在比较中使用的第一个字符串。</param>
        <param name="indexA"><paramref name="strA" /> 中子字符串的位置。</param>
        <param name="strB">要在比较中使用的第二个字符串。</param>
        <param name="indexB"><paramref name="strB" /> 中子字符串的位置。</param>
        <param name="length">要比较的子字符串中字符的最大数量。</param>
        <param name="comparisonType">一个枚举值，用于指定比较中要使用的规则。</param>
        <summary>使用指定的规则比较两个指定的 <see cref="T:System.String" /> 对象的子字符串，并返回一个整数，指示二者在排序顺序中的相对位置。</summary>
        <returns>一个 32 位带符号整数，指示两个比较数之间的词法关系。

 <list type="table"><listheader><term> “值”

 </term><description> 条件

 </description></listheader><item><term> 小于零

 </term><description> <paramref name="strA" /> 中的子字符串在排序顺序中位于 <paramref name="strB" /> 中的子字符串之前。

 </description></item><item><term> 零

 </term><description> 子字符串在排序顺序中出现的位置相同，或 <paramref name="length" /> 参数为零。

 </description></item><item><term> 大于零

 </term><description> <paramref name="strA" /> 中的子字符串在排序顺序中位于 <paramref name="strB" /> 中的子字符串之后。

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 要比较的子字符串 `strA` 在 `indexA` 和中的开始 `strB` 处 `indexB` 。 `indexA`和 `indexB` 都是从零开始的; 即，和中的第一个字符位于 `strA` `strB` 位置零，而不是位置1。 第一个子字符串的长度等于 `strA` 减号 `indexA` 加1的长度。 第二个子字符串的长度等于 `strB` 减号 `indexB` 加1。

 要比较的字符数是两个子字符串的长度中较小的一个和 `length` 。 `indexA`、 `indexB` 和 `length` 参数必须为非负。

 `comparisonType`参数指示比较应使用当前的或固定的区域性，是接受还是忽略比较规则的大小写，还是使用 word (区分区域性的) 或序号 (不区分区域性的) 排序规则。

 其中一个或两个比较字可以为 `null` 。 按照定义，包含空字符串 ( "" ) 中的任何字符串都会比较大于 null 引用;和两个 null 引用的比较结果相等。

 当发现不相等或比较两个子字符串时，将终止比较。 但是，如果两个字符串的比较结果等于一个字符串的末尾，而另一个字符串还剩个字符，则包含剩余字符的字符串将被视为更大的字符串。 返回值是执行的最后一次比较的结果。

 当比较受区域性特定的大小写规则影响时，可能会出现意外的结果。 例如，在土耳其语中，以下示例产生了错误的结果，因为土耳其语中的文件系统不会将语言大小写规则用于 "file" 中的字母 "i"。

 [!code-cpp[System.String.Compare#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]

 使用序号比较将路径名称与 "file" 进行比较。 要执行此操作，正确的代码如下所示：

 [!code-cpp[System.String.Compare#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]

## Examples
 下面的示例比较两个子字符串。

 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp-interactive[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> 大于 <paramref name="strA" />.<see cref="P:System.String.Length" />。

- 或 -

 <paramref name="indexB" /> 大于 <paramref name="strB" />.<see cref="P:System.String.Length" />。

- 或 -

 <paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 为负数。

- 或 -

<paramref name="indexA" /> 或 <paramref name="indexB" /> 为 <see langword="null" />，并且 <paramref name="length" /> 大于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符。 此 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> 方法在执行语言或区分区域性的比较时不考虑这些字符。 若要在比较中识别可忽略字符，请 <see cref="F:System.StringComparison.Ordinal" /> 为参数提供值或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> <paramref name="comparisonType" /> 。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="strA">要在比较中使用的第一个字符串。</param>
        <param name="indexA"><paramref name="strA" /> 中子字符串的位置。</param>
        <param name="strB">要在比较中使用的第二个字符串。</param>
        <param name="indexB"><paramref name="strB" /> 中子字符串的位置。</param>
        <param name="length">要比较的子字符串中字符的最大数量。</param>
        <param name="ignoreCase">若要在比较过程中忽略大小写，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <param name="culture">一个对象，提供区域性特定的比较信息。</param>
        <summary>比较两个指定的 <see cref="T:System.String" /> 对象（其中忽略或考虑其大小写，并使用区域性特定的信息干预比较），并返回一个整数，指示二者在排序顺序中的相对位置。</summary>
        <returns>一个整数，指示两个比较字之间的词法关系。

 <list type="table"><listheader><term> “值”

 </term><description> 条件

 </description></listheader><item><term> 小于零

 </term><description> <paramref name="strA" /> 中的子字符串在排序顺序中位于 <paramref name="strB" /> 中的子字符串之前。

 </description></item><item><term> 零

 </term><description> 子字符串在排序顺序中出现的位置相同或 <paramref name="length" /> 为零。

 </description></item><item><term> 大于零

 </term><description> <paramref name="strA" /> 中的子字符串在排序顺序中位于 <paramref name="strB" /> 中的子字符串之后。

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 要比较的子字符串在中的开始 `strA` `indexA` ，位于中 `strB` `indexB` 。 `indexA`和 `indexB` 都是从零开始的; 即，和中的第一个字符位于 `strA` `strB` 位置零，而不是位置1。 第一个子字符串的长度等于 `strA` 减号 `indexA` 加1的长度。 第二个子字符串的长度等于 `strB` 减号 `indexB` 加1。

 要比较的字符数是两个子字符串的长度中较小的一个和 `length` 。 `indexA`、 `indexB` 和 `length` 参数必须为非负。

 该比较使用 `culture` 参数获取特定于区域性的信息，如大小写规则和单个字符的字母顺序。 例如，区域性可以指定将某些字符组合视为单个字符，或以特定方式比较大写和小写字符，或字符的排序顺序取决于其前面或后面的字符。

 使用字词排序规则执行比较。 有关 word、字符串和顺序排序的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 。

 其中一个或两个比较字可以为 `null` 。 按照定义，包含空字符串 ( "" ) 中的任何字符串都会比较大于 null 引用;和两个 null 引用的比较结果相等。

 当发现不相等或比较两个子字符串时，将终止比较。 但是，如果两个字符串的比较结果等于一个字符串的末尾，而另一个字符串还剩个字符，则包含剩余字符的字符串将被视为更大的字符串。 返回值是执行的最后一次比较的结果。

 当比较受区域性特定的大小写规则影响时，可能会出现意外的结果。 例如，在土耳其语中，以下示例产生了错误的结果，因为土耳其语中的文件系统不会将语言大小写规则用于 "file" 中的字母 "i"。

 [!code-cpp[System.String.Compare#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]

 使用序号比较将路径名称与 "file" 进行比较。 要执行此操作，正确的代码如下所示：

 [!code-cpp[System.String.Compare#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]

## Examples
 下面的示例使用不同的区域性比较两个子字符串，并忽略子字符串的大小写。 区域性的选择会影响字母 "I" 的比较方式。

 [!code-cpp[string.compare5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> 大于 <paramref name="strA" />.<see cref="P:System.String.Length" />。

- 或 -

 <paramref name="indexB" /> 大于 <paramref name="strB" />.<see cref="P:System.String.Length" />。

- 或 -

 <paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 为负数。

- 或 -

<paramref name="strA" /> 或 <paramref name="strB" /> 为 <see langword="null" />，并且 <paramref name="length" /> 大于零。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符。 此 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> 方法在执行语言或区分区域性的比较时不考虑这些字符。 若要在比较中识别可忽略字符，请调用 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> 方法，并为 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 参数提供值或 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> <paramref name="options" /> 。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="strA">要在比较中使用的第一个字符串。</param>
        <param name="indexA"><paramref name="strA" /> 中子字符串开始的位置。</param>
        <param name="strB">要在比较中使用的第二个字符串。</param>
        <param name="indexB"><paramref name="strB" /> 中子字符串开始的位置。</param>
        <param name="length">要比较的子字符串中字符的最大数量。</param>
        <param name="culture">一个对象，提供区域性特定的比较信息。</param>
        <param name="options">要在执行比较时使用的选项（如忽略大小写或符号）。</param>
        <summary>对两个指定 <see cref="T:System.String" /> 对象的子字符串进行比较，使用指定的比较选项和区域性特定的信息来影响比较，并返回一个整数，该整数指示这两个子字符串在排序顺序中的关系。</summary>
        <returns>一个整数，该整数用于指示两个子字符串之间的词法关系，如下表所示。

 <list type="table"><listheader><term> “值”

 </term><description> 条件

 </description></listheader><item><term> 小于零

 </term><description> <paramref name="strA" /> 中的子字符串在排序顺序中位于 <paramref name="strB" /> 中的子字符串之前。

 </description></item><item><term> 零

 </term><description> 子字符串在排序顺序中出现的位置相同或 <paramref name="length" /> 为零。

 </description></item><item><term> 大于零

 </term><description> <paramref name="strA" /> 中的子字符串在排序顺序中位于 <paramref name="strB" /> 中的子字符串之后。

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 要比较的子字符串的起始 `strA` 位置 `indexA` 和位置 `strB` `indexB` 。 第一个子字符串的长度是减号的长度 `strA` `indexA` 。 第二个子字符串的长度是减号的 `strB` 长度 `indexB` 。

 要比较的字符数是两个子字符串的长度中较小的一个和 `length` 。 `indexA`、 `indexB` 和 `length` 参数必须为非负。

 该比较使用 `culture` 参数获取特定于区域性的信息，如大小写规则和单个字符的字母顺序。 例如，特定的区域性可以指定将某些字符组合视为单个字符、以特定方式进行比较的大写和小写字符，或字符的排序顺序取决于其前面或后面的字符。

> [!CAUTION]
> 此 <xref:System.String.Compare(System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions)> 方法主要用于排序或 alphabetizing 操作。 当方法调用的主要目的是确定两个子字符串是否等效时，不应使用此方法，即，当方法调用的目的是测试零) 的返回值时 (。 若要确定两个字符串是否相等，请调用 <xref:System.String.Equals%2A> 方法。

 `strA`和均 `strB` 可为 `null` 。 按照定义，任何字符串（包括 <xref:System.String.Empty?displayProperty=nameWithType> 、）比较大于 null 引用，而两个 null 引用的比较结果相等。

 可以通过参数进一步指定比较，该 `options` 参数由一个或多个枚举成员组成 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 。 但是，由于此方法的目的是执行区分区域性的字符串比较， <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> 因此和 <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> 值不起作用。

 当发现不相等或比较两个子字符串时，将终止比较。 但是，如果两个字符串的比较结果与一个字符串的末尾相等，而另一个字符串还剩个字符，则将剩余字符视为更大的字符串。 返回值是执行的最后一次比较的结果。

## Examples
 下面的示例使用 <xref:System.String.Compare(System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions)> 方法来比较两个人员的姓氏。 然后，它按字母顺序列出。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> 不是 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> 大于 <paramref name="strA" /><see langword=".Length" />。

- 或 -

 <paramref name="indexB" /> 大于 <paramref name="strB" /><see langword=".Length" />。

- 或 -

 <paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 为负数。

- 或 -

<paramref name="strA" /> 或 <paramref name="strB" /> 为 <see langword="null" />，并且 <paramref name="length" /> 大于零。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符。 此 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> 方法在执行语言或区分区域性的比较时不考虑这些字符。 若要在比较中识别可忽略字符，请 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 为参数提供值或 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> <paramref name="options" /> 。</para></block>
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareOrdinal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>通过计算每个字符串中相应 <see cref="T:System.String" /> 对象的数值来比较两个 <see cref="T:System.Char" /> 对象。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * string -&gt; int" Usage="System.string.CompareOrdinal (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">要比较的第一个字符串。</param>
        <param name="strB">要比较的第二个字符串。</param>
        <summary>通过计算每个字符串中相应 <see cref="T:System.String" /> 对象的数值来比较两个指定的 <see cref="T:System.Char" /> 对象。</summary>
        <returns>一个整数，指示两个比较字之间的词法关系。

 <list type="table"><listheader><term> “值”

 </term><description> 条件

 </description></listheader><item><term> 小于零

 </term><description><paramref name="strA" /> 小于 <paramref name="strB" />。

 </description></item><item><term> 零

 </term><description><paramref name="strA" /> 与 <paramref name="strB" /> 相等。

 </description></item><item><term> 大于零

 </term><description><paramref name="strA" /> 大于 <paramref name="strB" />。

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法使用序号排序规则执行区分大小写的比较。 有关 word、字符串和顺序排序的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 。 若要使用序号排序规则执行不区分大小写的比较，请调用 <xref:System.String.Compare(System.String%2CSystem.String%2CSystem.StringComparison)> 方法，并将 `comparisonType` 参数设置为 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 。

 由于 <xref:System.String.CompareOrdinal(System.String%2CSystem.String)> 是静态方法，因此 `strA` `strB` 可以是 `null` 。 如果这两个值都为 `null` ，则该方法将返回 0 (零) ，这指示 `strA` 和 `strB` 相等。 如果只有一个值为 `null` ，则该方法会将非 null 值视为更大的值。

## Examples
 下面的示例对两个仅大小写不同的字符串执行和序号比较。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * int * string * int * int -&gt; int" Usage="System.string.CompareOrdinal (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">要在比较中使用的第一个字符串。</param>
        <param name="indexA"><paramref name="strA" /> 中子字符串的起始索引。</param>
        <param name="strB">要在比较中使用的第二个字符串。</param>
        <param name="indexB"><paramref name="strB" /> 中子字符串的起始索引。</param>
        <param name="length">要比较的子字符串中字符的最大数量。</param>
        <summary>通过计算每个子字符串中相应 <see cref="T:System.String" /> 对象的数值来比较两个指定的 <see cref="T:System.Char" /> 对象的子字符串。</summary>
        <returns>一个 32 位带符号整数，指示两个比较数之间的词法关系。

 <list type="table"><listheader><term> “值”

 </term><description> 条件

 </description></listheader><item><term> 小于零

 </term><description> <paramref name="strA" /> 中的子字符串小于 <paramref name="strB" /> 中的子字符串。

 </description></item><item><term> 零

 </term><description> 子字符串相等，或者 <paramref name="length" /> 为零。

 </description></item><item><term> 大于零

 </term><description> <paramref name="strA" /> 中的子字符串大于 <paramref name="strB" /> 中的子字符串。

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `indexA`、 `indexB` 和 `length` 参数必须为非负。

 比较的字符数是较小的长度 `strA` `indexA` ，长度 `strB` 小于 `indexB` 或等于 `length` 。

 此方法使用序号排序规则执行区分大小写的比较。 有关 word、字符串和顺序排序的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 。 若要使用序号排序规则执行不区分大小写的比较，请调用 <xref:System.String.Compare(System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison)> 方法，并将 `comparisonType` 参数设置为 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 。

 由于 <xref:System.String.CompareOrdinal(System.String%2CSystem.String)> 是静态方法，因此 `strA` `strB` 可以是 `null` 。 如果这两个值都为 `null` ，则该方法将返回 0 (零) ，这指示 `strA` 和 `strB` 相等。 如果只有一个值为 `null` ，则该方法会将非 null 值视为更大的值。

## Examples
 下面的示例演示 <xref:System.String.CompareOrdinal%2A> 并 <xref:System.String.Compare%2A> 使用不同的排序顺序。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="strA" /> 不为 <see langword="null" /> ，且 <paramref name="indexA" /> 大于 <paramref name="strA" />.<see cref="P:System.String.Length" />。

- 或 -

 <paramref name="strB" /> 不为 <see langword="null" /> ，且 <paramref name="indexB" /> 大于 <paramref name="strB" />.<see cref="P:System.String.Length" />。

- 或 -

 <paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 为负数。</exception>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将此实例与指定对象或 <see cref="T:System.String" /> 进行比较，并返回一个整数，该整数指示此实例在排序顺序中是位于指定对象或 <see cref="T:System.String" /> 之前、之后还是与其出现在同一位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法的两个重载都 <xref:System.String.CompareTo%2A> 执行区分区域性和区分大小写的比较。 不能使用此方法来执行不区分区域性或序号比较。 为实现代码清晰度，建议你避免方法， <xref:System.String.CompareTo%2A> 并改为调用 <xref:System.String.Compare%2A> 方法。

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="string.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">一个对象，其计算结果为 <see cref="T:System.String" />。</param>
        <summary>将此实例与指定的 <see cref="T:System.Object" /> 进行比较，并指示此实例在排序顺序中是位于指定的 <see cref="T:System.Object" /> 之前、之后还是与其出现在同一位置。</summary>
        <returns>一个 32 位带符号整数，该整数指示此实例在排序顺序中是位于 <paramref name="value" /> 参数之前、之后还是与其出现在同一位置。

 <list type="table"><listheader><term> “值”

 </term><description> 条件

 </description></listheader><item><term> 小于零

 </term><description> 此实例位于 <paramref name="value" /> 之前。

 </description></item><item><term> 零

 </term><description> 此实例在排序顺序中的位置与 <paramref name="value" /> 相同。

 </description></item><item><term> 大于零

 </term><description> 此实例位于 <paramref name="value" /> 之后。

- 或 -

 <paramref name="value" /> 为 <see langword="null" />。

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `value` 必须是一个 <xref:System.String> 对象。

> [!CAUTION]
> 此 <xref:System.String.CompareTo%2A> 方法主要用于排序或 alphabetizing 操作。 当方法调用的主要目的是确定两个字符串是否相等时，不应使用此方法。 若要确定两个字符串是否相等，请调用 <xref:System.String.Equals%2A> 方法。

 此方法使用当前区域性执行区分大小写的 (区分大小写的) 比较。 有关 word、字符串和顺序排序的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 。

 有关此方法的行为的详细信息，请参阅方法的 "备注" 部分 <xref:System.String.Compare(System.String%2CSystem.String)?displayProperty=nameWithType> 。

## Examples
 下面的示例将 <xref:System.String.CompareTo%2A> 方法与一起使用 <xref:System.Object> 。 因为它尝试将实例与 <xref:System.String> 对象进行比较 `TestClass` ，所以方法会引发 <xref:System.ArgumentException> 。

 [!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> 不是 <see cref="T:System.String" />。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符。 <see cref="M:System.String.CompareTo(System.Object)" />当方法执行区分区域性的比较时，它不会考虑此类字符。 例如，如果以下代码在 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 或更高版本上运行，则使用软连字符将 "动物" 与 ("00AD" 进行比较，或使用 U +) 指示这两个字符串是等效的。

[！ code-csharp[CompareTo # 1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)][！ code-vb[CompareTo # 1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)]

若要在字符串比较中识别可忽略字符，请调用 <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> 方法。</para></block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::String ^ strB);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : string -&gt; int&#xA;override this.CompareTo : string -&gt; int" Usage="string.CompareTo strB" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(string strB) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::String ^ strB);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="member this.CompareTo : string -&gt; int" Usage="string.CompareTo strB" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB">要与此实例进行比较的字符串。</param>
        <summary>将此实例与指定的 <see cref="T:System.String" /> 对象进行比较，并指示此实例在排序顺序中是位于指定的字符串之前、之后还是与其出现在同一位置。</summary>
        <returns>一个 32 位带符号整数，该整数指示此实例在排序顺序中是位于 <paramref name="strB" /> 参数之前、之后还是与其出现在同一位置。

 <list type="table"><listheader><term> “值”

 </term><description> 条件

 </description></listheader><item><term> 小于零

 </term><description> 此实例位于 <paramref name="strB" /> 之前。

 </description></item><item><term> 零

 </term><description> 此实例在排序顺序中的位置与 <paramref name="strB" /> 相同。

 </description></item><item><term> 大于零

 </term><description> 此实例位于 <paramref name="strB" /> 之后。

- 或 -

 <paramref name="strB" /> 为 <see langword="null" />。

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法使用当前区域性执行区分大小写的 (区分大小写的) 比较。 有关 word、字符串和顺序排序的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 。

> [!CAUTION]
> 此 <xref:System.String.CompareTo%2A> 方法主要用于排序或 alphabetizing 操作。 当方法调用的主要目的是确定两个字符串是否相等时，不应使用此方法。 若要确定两个字符串是否相等，请调用 <xref:System.String.Equals%2A> 方法。

 有关此方法的行为的详细信息，请参阅方法的 "备注" 部分 <xref:System.String.Compare(System.String%2CSystem.String)> 。

 此方法实现 <xref:System.IComparable%601?displayProperty=nameWithType> 接口，且执行方式略优于 <xref:System.String.CompareTo(System.Object)?displayProperty=nameWithType> 方法，因为它不必确定 `strB` 自变量是否为必须进行装箱的可变值类型，并且无需将其参数从转换 <xref:System.Object> 为 <xref:System.String> 。

## Examples
 下面的示例使用 <xref:System.String.CompareTo%2A> 方法将当前字符串实例与另一个字符串进行比较。

 [!code-cpp[stringcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]

 下面的示例演示了多个值和引用类型的 CompareTo 方法的泛型和非泛型版本。

 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]

 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>字符集包括可忽略字符。 <see cref="M:System.String.CompareTo(System.String)" />当方法执行区分区域性的比较时，它不会考虑此类字符。 例如，如果以下代码在 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 或更高版本上运行，则使用软连字符将 "动物" 与 ("00AD" 进行比较，或使用 U +) 指示这两个字符串是等效的。

[！ code-csharp[CompareTo # 2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)][！ code-vb[CompareTo # 2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)]

若要在字符串比较中识别可忽略字符，请调用 <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> 方法。</para></block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>连接 <see cref="T:System.String" /> 的一个或多个实例，或 <see cref="T:System.String" /> 的一个或多个实例的值的 <see cref="T:System.Object" /> 表示形式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

> [!NOTE]
> 你还可以使用语言的字符串串联运算符（如 `+` c # 中的）， `&` 或 `+` 在 Visual Basic 中连接字符串。 这两个编译器都将串连运算符转换为对的重载之一的调用 `String.Concat` 。

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;string&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt;? values);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="values">一个集合对象，该对象实现 <see cref="T:System.Collections.Generic.IEnumerable`1" />，且其泛型类型参数为 <see cref="T:System.String" />。</param>
        <summary>串联类型为 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 的 <see cref="T:System.String" /> 构造集合的成员。</summary>
        <returns><paramref name="values" /> 中的串联字符串；如果 <paramref name="values" /> 为空 <see langword="IEnumerable(Of String)" />，则为 <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法连接中的每个对象 `values` ; 它不添加任何分隔符。 若要指定每个成员之间的分隔符 `values` ，请调用 <xref:System.String.Join(System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D)> 方法。

 <xref:System.String.Empty?displayProperty=nameWithtype>字符串用于替换中的任何 null 元素 `values` 。

 如果 `values` ，则为 `IEnumerable(Of String)`，则此方法返回 <xref:System.String.Empty?displayProperty=nameWithType>。 如果 `values` 为 `null` ，则该方法将引发 <xref:System.ArgumentNullException> 异常。

 <xref:System.String.Concat(System.Collections.Generic.IEnumerable%7BSystem.String%7D)> 是一种简便方法，使您可以连接集合中的每个元素， `IEnumerable(Of String)` 而无需先将元素转换为字符串数组。 它对于 Language-Integrated 查询 (LINQ) 查询表达式特别有用。 下面的示例将 `List(Of String)` 包含字母表的大写或小写字母的对象传递给 lambda 表达式，该表达式选择等于或大于特定字母 (的字母，在本例中为 "M" ) 。 `IEnumerable(Of String)`方法返回的集合 <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> 传递给 <xref:System.String.Concat(System.Collections.Generic.IEnumerable%7BSystem.String%7D)> 方法，以单个字符串的形式显示结果。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb" id="Snippet3":::

## Examples
 下面的示例使用埃拉托色 of 尼斯筛法算法来计算小于或等于100的质数。 它将结果分配给 <xref:System.Collections.Generic.List%601> 类型的对象，然后将该对象 <xref:System.String> 传递给 <xref:System.String.Concat(System.Collections.Generic.IEnumerable%7BSystem.String%7D)> 方法。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb" id="Snippet2":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Concat : obj -&gt; string" Usage="System.string.Concat arg0" />
      <MemberSignature Language="C#" Value="public static string Concat (object? arg0);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">要表示的对象，或 <see langword="null" />。</param>
        <summary>创建指定对象的字符串表示形式。</summary>
        <returns><paramref name="arg0" /> 的值的字符串表示形式，如果 <see cref="F:System.String.Empty" /> 为 <paramref name="arg0" />，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.String.Concat(System.Object)>方法 `arg0` 通过调用其无参数的方法将表示为字符串 `ToString` 。

## Examples
 下面的示例演示 <xref:System.String.Concat%2A> 方法。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params object[] args);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Concat : obj[] -&gt; string" Usage="System.string.Concat args" />
      <MemberSignature Language="C#" Value="public static string Concat (params object[]? args);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">一个对象数组，其中包含要连接的元素。</param>
        <summary>连接指定 <see cref="T:System.Object" /> 数组中的元素的字符串表示形式。</summary>
        <returns><paramref name="args" /> 中元素的值的串联字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 方法 `args` 通过调用该对象的无参数方法来连接中的每个对象，而不 `ToString` 会添加任何分隔符。

 <xref:System.String.Empty?displayProperty=nameWithType> 用于替代数组中的任何 null 对象。

## Examples
 下面的示例演示如何将方法用于 <xref:System.String.Concat%2A> <xref:System.Object> 数组。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="args" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.OutOfMemoryException">内存不足。</exception>
        <block subset="none" type="usage"><para>C + + 代码不会调用此方法。 C + + 编译器解析对 <see cref="Overload:System.String.Concat" /> 的调用，该调用具有四个或更多对象参数作为对的调用 <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> 。</para></block>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params string[] values);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray values As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : string[] -&gt; string" Usage="System.string.Concat values" />
      <MemberSignature Language="C#" Value="public static string Concat (params string[]? values);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values">字符串实例的数组。</param>
        <summary>连接指定的 <see cref="T:System.String" /> 数组的元素。</summary>
        <returns><paramref name="values" /> 的串联元素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法连接中的每个对象 `values` ; 它不添加任何分隔符。

 <xref:System.String.Empty?displayProperty=nameWithtype>字符串用于替代数组中的任何 null 对象。

## Examples
 下面的示例演示如何将方法用于 <xref:System.String.Concat%2A> <xref:System.String> 数组。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.OutOfMemoryException">内存不足。</exception>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1)" />
      <MemberSignature Language="C#" Value="public static string? Concat (object arg0, object arg1);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">要连接的第一个对象。</param>
        <param name="arg1">要连接的第二个对象。</param>
        <summary>连接两个指定对象的字符串表示形式。</summary>
        <returns><paramref name="arg0" /> 和 <paramref name="arg1" /> 的值的串联字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 方法 `arg0` `arg1` 通过调用和的无参数方法连接和，而 `ToString` `arg0` `arg1` 不添加任何分隔符。

 <xref:System.String.Empty?displayProperty=nameWithType> 用于替代任何空参数。

 如果任何一个参数为数组引用，则该方法将连接一个表示该数组的字符串，而不是它的成员 (例如 "System.string []" ) 。

## Examples
 下面的示例演示 <xref:System.String.Concat%2A> 方法。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string? Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="str0">要连接的第一个只读字符范围。</param>
        <param name="str1">要连接的第二个只读字符范围。</param>
        <summary>连接两个指定的只读字符范围的字符串表示形式。</summary>
        <returns><paramref name="str0" /> 和 <paramref name="str1" /> 的值的串联字符串表示形式。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberSignature Language="C#" Value="public static string? Concat (string str0, string str1);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">要串联的第一个字符串。</param>
        <param name="str1">要串联的第二个字符串。</param>
        <summary>连接 <see cref="T:System.String" /> 的两个指定实例。</summary>
        <returns><paramref name="str0" /> 和 <paramref name="str1" /> 的串联。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 方法连接 `str0` 和 `str1` ; 它不添加任何分隔符。

 <xref:System.String.Empty?displayProperty=nameWithtype>字符串用于替代任何空参数。

## Examples
 下面的示例将用户的名字、中间名和姓氏连接起来。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2)" />
      <MemberSignature Language="C#" Value="public static string? Concat (object arg0, object arg1, object arg2);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">要连接的第一个对象。</param>
        <param name="arg1">要连接的第二个对象。</param>
        <param name="arg2">要连接的第三个对象。</param>
        <summary>连接三个指定对象的字符串表示形式。</summary>
        <returns><paramref name="arg0" />、<paramref name="arg1" /> 和 <paramref name="arg2" /> 的值的串联字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 方法 `arg0` `arg1` `arg2` 通过调用每个对象的无参数方法连接、和，而 `ToString` 不添加任何分隔符。

 <xref:System.String.Empty?displayProperty=nameWithType> 用于替代任何空参数。

## Examples
 下面的示例演示 <xref:System.String.Concat%2A> 方法。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string? Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1, valuetype System.ReadOnlySpan`1&lt;char&gt; str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char), str2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="str2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="str0">要连接的第一个只读字符范围。</param>
        <param name="str1">要连接的第二个只读字符范围。</param>
        <param name="str2">要连接的第三个只读字符范围。</param>
        <summary>连接三个指定的只读字符范围的字符串表示形式。</summary>
        <returns><paramref name="str0" />、<paramref name="str1" /> 和 <paramref name="str2" /> 的值的已连接字符串表示形式。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberSignature Language="C#" Value="public static string? Concat (string str0, string str1, string str2);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">要串联的第一个字符串。</param>
        <param name="str1">要串联的第二个字符串。</param>
        <param name="str2">要比较的第三个字符串。</param>
        <summary>连接 <see cref="T:System.String" /> 的三个指定实例。</summary>
        <returns><paramref name="str0" />、<paramref name="str1" /> 和 <paramref name="str2" /> 的串联。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 方法连接 `str0` 、和，而 `str1` `str2` 不添加任何分隔符。

## Examples
 下面的示例使用 <xref:System.String.Concat%2A> 方法连接三个字符串并显示结果。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp" id="Snippet6":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs" interactive="try-dotnet" id="Snippet6":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb" id="Snippet6":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg3" Type="System.Object" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="arg0">要连接的第一个对象。</param>
        <param name="arg1">要连接的第二个对象。</param>
        <param name="arg2">要连接的第三个对象。</param>
        <param name="arg3">要连接的第四个对象。</param>
        <summary>将四个指定对象的字符串表示形式与可选变量长度参数列表中指定的任何对象串联起来。</summary>
        <returns>参数列表中的每个值的连接字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
> 此 API 不符合 CLS。 符合 CLS 的替代方法是 <xref:System.String.Concat(System.Object%5B%5D)?displayProperty=nameWithType>。 C # 和 Visual Basic 编译器会自动将对此方法的调用解析为对的调用 <xref:System.String.Concat(System.Object%5B%5D)?displayProperty=nameWithType> 。

 方法通过调用其无参数方法连接参数列表中的每个对象，而不 `ToString` 会添加任何分隔符。

 <xref:System.String.Empty?displayProperty=nameWithType> 用于替代任何空参数。

> [!NOTE]
> 方法的最后一个参数  <xref:System.String.Concat%2A> 是要连接的一个或多个附加对象的以逗号分隔的可选列表。

## Examples
 下面的示例演示 <xref:System.String.Concat(System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object)> 如何使用方法连接变量参数的列表。 在这种情况下，将调用方法并带有九个参数。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>此方法使用关键字进行标记 <see langword="vararg" /> ，这意味着它支持数量可变的参数。 可以从 Visual C++ 调用方法，但不能从 c # 或 Visual Basic 代码中调用。 C # 和 Visual Basic 编译器将调用解析为对的调用 <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> <see cref="M:System.String.Concat(System.Object[])" /> 。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string? Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2, ReadOnlySpan&lt;char&gt; str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1, valuetype System.ReadOnlySpan`1&lt;char&gt; str2, valuetype System.ReadOnlySpan`1&lt;char&gt; str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char), str2 As ReadOnlySpan(Of Char), str3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2, ReadOnlySpan&lt;char&gt; str3);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="str2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="str3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="str0">要连接的第一个只读字符范围。</param>
        <param name="str1">要连接的第二个只读字符范围。</param>
        <param name="str2">要连接的第三个只读字符范围。</param>
        <param name="str3">要连接的第四个只读字符范围。</param>
        <summary>连接四个指定的只读字符范围的字符串表示形式。</summary>
        <returns><paramref name="str0" />、<paramref name="str1" />、<paramref name="str2" /> 和 <paramref name="str3" /> 的值的已连接字符串表示形式。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String, str3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2, System::String ^ str3);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberSignature Language="C#" Value="public static string? Concat (string str0, string str1, string str2, string str3);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">要串联的第一个字符串。</param>
        <param name="str1">要串联的第二个字符串。</param>
        <param name="str2">要比较的第三个字符串。</param>
        <param name="str3">要比较的第四个字符串。</param>
        <summary>连接 <see cref="T:System.String" /> 的四个指定实例。</summary>
        <returns><paramref name="str0" />、<paramref name="str1" />、<paramref name="str2" /> 和 <paramref name="str3" /> 的串联。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 方法会连接 `str0` 、 `str1` 、 `str2` 和， `str3` 但不会添加任何分隔符。

## Examples
 下面的示例定义一个包含四个字母的单词的数组，并将其各个字母存储到字符串数组中，以便对它们进行编码。 然后，它会调用 <xref:System.String.Concat(System.String%2CSystem.String%2CSystem.String%2CSystem.String)> 方法来重新组合打乱的单词。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat(Of T) (values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;'T&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><paramref name="values" /> 成员的类型。</typeparam>
        <param name="values">一个实现 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 接口的集合对象。</param>
        <summary>串联 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 实现的成员。</summary>
        <returns><paramref name="values" /> 中的串联成员。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法连接中的每个对象 `values` ; 它不添加任何分隔符。

 <xref:System.String.Empty?displayProperty=nameWithtype>字符串用于替代任何空参数。

 <xref:System.String.Concat%60%601(System.Collections.Generic.IEnumerable%7B%60%600%7D)> 是一种简便方法，使您可以连接集合中的每个元素， <xref:System.Collections.Generic.IEnumerable%601> 而无需先将元素转换为字符串。 如示例所示，它对于 Language-Integrated 查询 (LINQ) 查询表达式特别有用。 集合中每个对象的字符串表示形式 <xref:System.Collections.Generic.IEnumerable%601> 都是通过调用该对象的 `ToString` 方法派生的。

## Examples
 下面的示例定义了一个非常简单的 `Animal` 类，其中包含动物的名称及其所属的顺序。 然后，它定义一个 <xref:System.Collections.Generic.List%601> 对象，该对象包含多个 `Animal` 对象。 <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>调用扩展方法以提取 `Animal` 其 `Order` 属性等于 "啮齿类" 的对象。 结果传递给 <xref:System.String.Concat%60%601(System.Collections.Generic.IEnumerable%7B%60%600%7D)> 方法并显示到控制台。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs" interactive="try-dotnet" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb" id="Snippet4":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value);" />
      <MemberSignature Language="F#" Value="member this.Contains : char -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">要查找的字符。</param>
        <summary>返回一个值，该值指示指定的字符是否出现在此字符串中。</summary>
        <returns>如果 <paramref name="value" /> 参数在此字符串中出现，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法执行 (区分大小写和不区分区域性的) 比较。
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Contains : string -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要搜寻的字符串。</param>
        <summary>返回一个值，该值指示指定的子串是否出现在此字符串中。</summary>
        <returns>如果 <see langword="true" /> 参数出现在此字符串中，或者 <paramref name="value" /> 为空字符串 ("")，则为 <paramref name="value" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法执行 (区分大小写和不区分区域性的) 比较。 搜索从该字符串的第一个字符位置开始，并继续到最后一个字符的位置。

若要执行区分区域性或不区分大小写的比较：

- 在 .NET Core 2.1 及更高版本上： <xref:System.String.Contains(System.Char,System.StringComparison)> 改为调用重载。

- .NET Framework 上：创建自定义方法。 下面的示例阐释了这种方法。 它定义了一个 <xref:System.String> 扩展方法，该方法包含一个 <xref:System.StringComparison> 参数，并指示当使用指定的字符串比较形式时，字符串是否包含子字符串。

 [!code-csharp[System.String.Contains#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]

 如果对子字符串 `value` 在当前实例中的位置感兴趣，则可以调用 <xref:System.String.IndexOf%2A> 方法来获取其第一次出现的起始位置，也可以调用 <xref:System.String.LastIndexOf%2A> 方法来获取其最后一个匹配项的起始位置。 <xref:System.String.IndexOf(System.String)>如果在字符串实例中找到子字符串，则该示例包括对方法的调用。

## Examples
 下面的示例确定字符串 "fox" 是否为熟悉的引号的子字符串。 如果在字符串中找到 "fox"，则它还会显示其起始位置。

 [!code-cpp[String.Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp-interactive[String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : char * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">要查找的字符。</param>
        <param name="comparisonType">一个枚举值，用于指定比较中要使用的规则。</param>
        <summary>使用指定的比较规则返回一个值，该值指示指定的字符是否出现在此字符串中。</summary>
        <returns>如果 <paramref name="value" /> 参数在此字符串中出现，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : string * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">要搜寻的字符串。</param>
        <param name="comparisonType">一个枚举值，用于指定比较中要使用的规则。</param>
        <summary>使用指定的比较规则返回一个值，该值指示指定的字符串是否出现在此字符串中。</summary>
        <returns>如果 <see langword="true" /> 参数出现在此字符串中，或者 <paramref name="value" /> 为空字符串 ("")，则为 <paramref name="value" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Copy (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Copy(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Copy : string -&gt; string" Usage="System.string.Copy str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1">
          <AttributeName Language="C#">[System.Obsolete("This API should not be used to create mutable strings. See https://go.microsoft.com/fwlink/?linkid=2084035 for alternatives.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("This API should not be used to create mutable strings. See https://go.microsoft.com/fwlink/?linkid=2084035 for alternatives.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="str">要复制的字符串。</param>
        <summary>创建一个与指定的 <see cref="T:System.String" /> 具有相同值的 <see cref="T:System.String" /> 的新实例。</summary>
        <returns>值与 <paramref name="str" /> 相同的新字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

`Copy`方法返回一个 <xref:System.String> 对象，该对象与原始字符串具有相同的值，但表示不同的对象引用。 这不同于赋值操作，后者将现有字符串引用分配给其他对象变量。

> [!IMPORTANT]
> 从 .NET Core 3.0 开始，此方法已过时。 但是，我们不建议在任何 .NET 实现中使用。 特别是，由于 .NET Core 3.0 中的字符串暂存发生了更改，因此，在某些情况下，该 `Copy` 方法将不会创建新的字符串，而只会返回对现有暂存字符串的引用。

根据要调用方法的原因 `Copy` ，有多种方法可供选择：

- 如果希望在修改字符串的操作中使用不同的字符串实例，请使用原始字符串实例。 因为字符串是不可变的，所以字符串操作会创建一个新的字符串实例，而原始字符串不受影响。 在这种情况下，不应将新字符串引用分配给原始字符串变量。 下面的示例进行了这方面的演示。

  [!code-csharp[Performing a string operation](~/samples/snippets/csharp/api/system/string/copy/program.cs#1)]
  [!code-vb[Performing a string operation](~/samples/snippets/visualbasic/api/system/string/copy/program.vb#1)]

   在这种情况下，在 `Copy` 调用方法之前调用方法以创建新字符串会 <xref:System.String.Substring%2A> 创建一个新的字符串实例。

- 如果要创建具有与原始字符串相同的内容的可变缓冲区，请调用 <xref:System.String.ToCharArray%2A?displayProperty=nameWithType> 或 <xref:System.Text.StringBuilder.%23ctor(System.String)?displayProperty=nameWithType> 构造函数。 例如：

  [!code-csharp[Performing a string operation](~/samples/snippets/csharp/api/system/string/copy/program.cs#2)]
  [!code-vb[Performing a string operation](~/samples/snippets/visualbasic/api/system/string/copy/program.vb#2)]

- 如果要创建字符串的可变副本以便可以使用不安全代码修改字符串内容，请使用 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> 方法。 下面的示例使用 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> 方法获取指向非托管内存中复制字符串的位置的指针，将字符串中每个字符的 Unicode 码位递增一，并将生成的字符串复制回托管字符串。

  [!code-csharp[Performing a string operation](~/samples/snippets/csharp/api/system/string/copy/program.cs#3)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="string.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">要复制的此实例中第一个字符的索引。</param>
        <param name="destination">此实例中的字符所复制到的 Unicode 字符数组。</param>
        <param name="destinationIndex"><paramref name="destination" /> 中的索引，在此处开始复制操作。</param>
        <param name="count">此实例中要复制到 <paramref name="destination" /> 的字符数。</param>
        <summary>将指定数目的字符从此实例中的指定位置复制到 Unicode 字符数组中的指定位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法将 `count` 字符从此 `sourceIndex` 实例的位置复制到 `destinationIndex` 字符数组的位置 `destination` 。 此方法不调整 `destination` 字符数组的大小; 它必须具有足够数量的元素来容纳复制的字符或方法引发 <xref:System.ArgumentOutOfRangeException> 。

 `sourceIndex` 和 `destinationIndex` 是从零开始的。

## Examples
 下面的示例演示 <xref:System.String.CopyTo%2A> 方法。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" />、<paramref name="destinationIndex" /> 或 <paramref name="count" /> 为负

- 或 -

 <paramref name="sourceIndex" /> 不标识当前实例中的位置。

- 或 -

 <paramref name="destinationIndex" /> 不标识 <paramref name="destination" /> 数组中的有效索引。

- 或 -

 <paramref name="count" /> 大于从 <paramref name="sourceIndex" /> 到此实例末尾的子字符串的长度

- 或 -

 <paramref name="count" /> 大于从 <paramref name="destinationIndex" /> 到 <paramref name="destination" /> 数组末尾的子数组的长度。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Create&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static string Create&lt;TState&gt; (int length, TState state, System.Buffers.SpanAction&lt;char,TState&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Create&lt;TState&gt;(int32 length, !!TState state, class System.Buffers.SpanAction`2&lt;char, !!TState&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Create``1(System.Int32,``0,System.Buffers.SpanAction{System.Char,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of TState) (length As Integer, state As TState, action As SpanAction(Of Char, TState)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static System::String ^ Create(int length, TState state, System::Buffers::SpanAction&lt;char, TState&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member Create : int * 'State * System.Buffers.SpanAction&lt;char, 'State&gt; -&gt; string" Usage="System.string.Create (length, state, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="action" Type="System.Buffers.SpanAction&lt;System.Char,TState&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="TState">要传递到的元素的类型 <paramref name="action" /> 。</typeparam>
        <param name="length">要创建的字符串的长度。</param>
        <param name="state">要传递给 <paramref name="action" /> 的元素。</param>
        <param name="action">用于初始化字符串的回叫。</param>
        <summary>创建一个具有特定长度的新字符串，并在创建后使用指定的回叫对其进行初始化。</summary>
        <returns>创建的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks
传递给的目标跨度的初始内容未 `action` 定义。 因此，委托负责确保已分配范围的每个元素。 否则，结果字符串可能包含随机字符。
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ Empty;" />
      <MemberSignature Language="F#" Value=" staticval mutable Empty : string" Usage="System.string.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示空字符串。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此字段的值是长度为零的字符串 ""。

 在应用程序代码中，此字段最常用于赋值，以将字符串变量初始化为空字符串。 若要测试字符串的值是否为 `null` 或 <xref:System.String.Empty?displayProperty=nameWithType> ，请使用 <xref:System.String.IsNullOrEmpty%2A> 方法。

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="EndsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定此字符串实例的结尾是否与指定的字符串匹配。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As Char) As Boolean" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(char value);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndsWith : char -&gt; bool" Usage="string.EndsWith value" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">要与此实例末尾的字符进行比较的字符。</param>
        <summary>确定此字符串实例的结尾是否与指定的字符匹配。</summary>
        <returns>如果 <see langword="true" /> 与此实例的末尾匹配，则为 <paramref name="value" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

此方法使用当前区域性执行区分大小写和区分区域性的比较。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要与此实例末尾的子字符串进行比较的字符串。</param>
        <summary>确定此字符串实例的结尾是否与指定的字符串匹配。</summary>
        <returns>如果 <see langword="true" /> 与此实例的末尾匹配，则为 <paramref name="value" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法 `value` 与此实例末尾的子字符串进行比较，其长度与相同 `value` ，并返回一个指示是否相等的指示。 若要相等， `value` 必须是对此实例的引用，或与此实例的末尾匹配。

 此方法使用当前区域性执行区分大小写的 (区分大小写的) 比较。

## Examples
 下面的示例指示数组中的每个字符串是否以句点结束， ( "。) 。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb" id="Snippet1":::

 下面的示例定义了一个 `StripEndTags` 方法，该方法使用 <xref:System.String.EndsWith(System.String)> 方法从行的末尾删除 HTML 结束标记。 请注意，将  `StripEndTags` 以递归方式调用方法，以确保删除行末尾处的多个 HTML 结束标记。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>如 [使用字符串的最佳做法](/dotnet/standard/base-types/best-practices-strings)中所述，建议你避免调用替换默认值的字符串比较方法，并改为调用需要显式指定参数的方法。 若要通过使用当前区域性的字符串比较规则来确定某个字符串是否以特定子字符串结束，请使用 <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> 其参数的值调用方法重载 <see cref="F:System.StringComparison.CurrentCulture" /> <paramref name="comparisonType" /> 。</para></block>
        <altmember cref="M:System.String.StartsWith(System.String)" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * StringComparison -&gt; bool" Usage="string.EndsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要与此实例末尾的子字符串进行比较的字符串。</param>
        <param name="comparisonType">枚举值之一，用于确定如何比较此字符串与 <paramref name="value" />。</param>
        <summary>确定使用指定的比较选项进行比较时此字符串实例的结尾是否与指定的字符串匹配。</summary>
        <returns>如果 <see langword="true" /> 参数与此字符串的末尾匹配，则为 <paramref name="value" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.String.EndsWith%2A>方法将 `value` 参数与此字符串末尾的子字符串进行比较，并返回一个值，该值指示它们是否相等。 若要相等， `value` 必须是对此同一个字符串的引用，必须为空字符串 ( "" ) ，或者必须与此字符串的末尾匹配。 方法所执行的比较的类型 <xref:System.String.EndsWith%2A> 取决于参数的值 `comparisonType` 。

## Examples
 下面的示例确定字符串是否以特定子字符串结束。 结果受区域性选择的影响，是否忽略大小写，以及是否执行序号比较。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo? culture);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.EndsWith (value, ignoreCase, culture)" />
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">要与此实例末尾的子字符串进行比较的字符串。</param>
        <param name="ignoreCase">若要在比较过程中忽略大小写，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <param name="culture">确定如何对此实例与 <paramref name="value" /> 进行比较的区域性信息。 如果 <paramref name="culture" /> 为 <see langword="null" />，则使用当前区域性。</param>
        <summary>确定在使用指定的区域性进行比较时此字符串实例的结尾是否与指定的字符串匹配。</summary>
        <returns>如果 <see langword="true" /> 参数与此字符串的末尾匹配，则为 <paramref name="value" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法将 `value` 参数与此字符串末尾与相同的子字符串进行比较 `value` ，并返回一个值，该值指示它们是否相等。 若要相等， `value` 必须是对此同一个实例的引用，或与此字符串的末尾匹配。

 此方法使用指定的大小写和区域性执行 word (区分区域性的) 比较。

## Examples
 下面的示例确定字符串是否出现在另一个字符串的末尾。 <xref:System.String.EndsWith%2A>方法使用区分大小写、不区分大小写和影响搜索结果的不同区域性多次调用。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateRunes">
      <MemberSignature Language="C#" Value="public System.Text.StringRuneEnumerator EnumerateRunes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.StringRuneEnumerator EnumerateRunes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EnumerateRunes" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateRunes () As StringRuneEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringRuneEnumerator EnumerateRunes();" />
      <MemberSignature Language="F#" Value="member this.EnumerateRunes : unit -&gt; System.Text.StringRuneEnumerator" Usage="string.EnumerateRunes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringRuneEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从此字符串返回 <see cref="T:System.Text.Rune" /> 的枚举。</summary>
        <returns>一个字符串 Rune 枚举器。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

### Remarks

无效的序列在枚举中表示 <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType> 。

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定两个 <see cref="T:System.String" /> 对象是否具有相同的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="string.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要与此实例进行比较的字符串。</param>
        <summary>确定此实例是否与指定的对象（也必须是 <see cref="T:System.String" /> 对象）具有相同的值。</summary>
        <returns>如果 <see langword="true" /> 是一个 <paramref name="obj" /> 且其值与此实例相等，则为 <see cref="T:System.String" />；否则为 <see langword="false" />。  如果 <paramref name="obj" /> 为 <see langword="null" />，则此方法返回 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法执行 (区分大小写和不区分区域性的) 比较。

## Examples
 下面的示例演示 <xref:System.String.Equals%2A> 方法。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::String ^ value);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.Equals : string -&gt; bool" Usage="string.Equals value" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要与此实例进行比较的字符串。</param>
        <summary>确定此实例是否与另一个指定的 <see cref="T:System.String" /> 对象具有相同的值。</summary>
        <returns>如果 <see langword="true" /> 参数的值与此实例的值相同，则为 <paramref name="value" />；否则为 <see langword="false" />。 如果 <paramref name="value" /> 为 <see langword="null" />，则此方法返回 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法执行 (区分大小写和不区分区域性的) 比较。

## Examples
 下面的示例演示 <xref:System.String.Equals%2A> 方法。 它将标题-大写字母 "File" 与等效的单词、其小写等效项、大写等效项以及包含拉丁文小写字母无点的单词（I (U + 0131) 而不是拉丁小写字母 I (U + 0069) 进行比较。 由于 <xref:System.String.Equals(System.String)> 方法执行序号比较，因此只有与相同单词的比较返回 `true` 。

 [!code-csharp[System.String.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string -&gt; bool" Usage="System.string.Equals (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">要比较的第一个字符串，或 <see langword="null" />。</param>
        <param name="b">要比较的第二个字符串，或 <see langword="null" />。</param>
        <summary>确定两个指定的 <see cref="T:System.String" /> 对象是否具有相同的值。</summary>
        <returns>如果 <see langword="true" /> 的值与 <paramref name="a" /> 的值相同，则为 <paramref name="b" />；否则为 <see langword="false" />。 如果 <paramref name="a" /> 和 <paramref name="b" /> 均为 <see langword="null" />，此方法将返回 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法执行 (区分大小写和不区分区域性的) 比较。

## Examples
 下面的示例演示 <xref:System.String.Equals%2A> 方法。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.Equals : string * StringComparison -&gt; bool" Usage="string.Equals (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要与此实例进行比较的字符串。</param>
        <param name="comparisonType">枚举值之一，用于指定如何比较字符串。</param>
        <summary>确定此字符串是否与另一个指定的 <see cref="T:System.String" /> 对象具有相同的值。 参数指定区域性、大小写以及比较所用的排序规则。</summary>
        <returns>如果 <see langword="true" /> 参数的值与此字符串相同，则为 <paramref name="value" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `comparisonType`参数指示比较是否应使用当前或固定的区域性，以服从或忽略所比较的两个字符串的大小写，或使用 word 或序号排序规则。

## Examples
 下面的示例创建一个字符串数组，该数组由大写的 "I"、小写 "i" 和无点 "ı" 组成。 然后，它调用 <xref:System.String.Equals(System.String%2CSystem.StringComparison)> 方法，通过使用每个可能的枚举值对它们进行比较 <xref:System.StringComparison> 。

 [!code-csharp[System.String.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]

 下面的示例通过使用枚举的每个成员来比较四组单词 <xref:System.StringComparison> 。  这种比较使用英语 (美国) 和萨米语 (高瑞典) 文化的约定。 请注意，在 en-us 区域性中，字符串 "encyclopædia" 和 "encyclopaedia" 被视为等效，而不是在北瑞典 (北瑞典) 文化中。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs" interactive="try-dotnet" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb" id="Snippet4":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string * StringComparison -&gt; bool" Usage="System.string.Equals (a, b, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="b" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="a">要比较的第一个字符串，或 <see langword="null" />。</param>
        <param name="b">要比较的第二个字符串，或 <see langword="null" />。</param>
        <param name="comparisonType">枚举值之一，用于指定比较的规则。</param>
        <summary>确定两个指定的 <see cref="T:System.String" /> 对象是否具有相同的值。 参数指定区域性、大小写以及比较所用的排序规则。</summary>
        <returns>如果 <see langword="true" /> 参数的值与 <paramref name="a" /> 参数的值相同，则为 <paramref name="b" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `comparisonType`参数指示比较是否应使用当前或固定的区域性，以服从或忽略所比较的两个字符串的大小写，或使用 word 或序号排序规则。

## Examples
 下面的示例通过使用枚举的每个成员来比较四组单词 <xref:System.StringComparison> 。  这种比较使用英语 (美国) 和萨米语 (高瑞典) 文化的约定。 请注意，在 en-us 区域性中，字符串 "encyclopædia" 和 "encyclopaedia" 被视为等效，而不是在北瑞典 (北瑞典) 文化中。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb" id="Snippet3":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将对象的值转换为基于指定格式的字符串，并将其插入到另一个字符串。

如果不熟悉 `String.Format` 方法，请参阅 [String.Format 方法入门](#Starting)一节来进行快速了解。

有关 `String.Format` 方法的常规文档，请参阅[备注](#remarks-top)部分。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

<a name="remarks-top"></a>
## Remarks

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)]

 本节内容：

 [开始处理字符串. 格式方法](#Starting)\
 [我要调用哪种方法？](#FTaskList)\
 [Format 方法 brief](#Format_Brief)\
 [格式项](#FormatItem)\
 [如何设置参数的格式](#HowFormatted)\
 [设置具有相同索引的项的格式](#SameIndex)\
 [格式设置和区域性](#Format_Culture)\
 [自定义格式设置操作](#Format_Custom)\
 [字符串格式 Q &](#QA)

<a name="Starting"></a>
## <a name="get-started-with-the-stringformat-method"></a>开始处理字符串. 格式方法
 <xref:System.String.Format%2A?displayProperty=nameWithType>如果需要将对象、变量或表达式的值插入到另一个字符串，请使用。 例如，可以将值的值插入 <xref:System.Decimal> 字符串中，以单个字符串的形式向用户显示该值：

 [!code-cpp[System.String.Format#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp-interactive[System.String.Format#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]

 您可以控制该值的格式：

 [!code-cpp[System.String.Format#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp[System.String.Format#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]

 除了格式设置，还可以控制对齐方式和间距。

 ### <a name="insert-a-string"></a>插入字符串

 <xref:System.String.Format%2A?displayProperty=nameWithType> 以格式字符串开头，后跟一个或多个将转换为字符串并在格式字符串中的指定位置插入的对象或表达式。 例如：

 [!code-cpp[System.String.Format#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp-interactive[System.String.Format#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]

 `{0}`格式字符串中的是格式项。 `0` 对象的索引，该对象的字符串值将在该位置插入。  (索引从0开始 ) 。如果要插入的对象不是字符串，则调用它的方法将其 `ToString` 转换为一个字符串，然后再将其插入到结果字符串中。

 下面是使用两个格式项和对象列表中的两个对象的另一个示例：

 [!code-cpp[System.String.Format#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp[System.String.Format#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]

 只要每个格式项的索引在对象列表中都有匹配的对象，就可以拥有任意数量的格式项以及对象列表中的任意多个对象。 您也不必担心您调用的是哪个重载;编译器将为您选择合适的一个。

 ### <a name="control-formatting"></a>控件格式设置
 可以在格式项中的索引后跟格式字符串，以控制如何设置对象的格式。 例如， `{0:d}` 将 "d" 格式字符串应用于对象列表中的第一个对象。 下面是一个包含单个对象和两个格式项的示例：

 [!code-cpp[System.String.Format#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp[System.String.Format#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]

 许多类型都支持格式字符串，其中[包括标准和](/dotnet/standard/base-types/standard-numeric-format-strings)[自](/dotnet/standard/base-types/custom-numeric-format-strings)定义格式字符串 (的所有数字类型) [、标准和](/dotnet/standard/base-types/standard-date-and-time-format-strings)自[定义格式字符串](/dotnet/standard/base-types/custom-date-and-time-format-strings))  (的所有日期和时间均[为标准和](/dotnet/standard/base-types/standard-timespan-format-strings)自[定义](/dotnet/standard/base-types/custom-timespan-format-strings)格式字符串 (、所有枚举类型[枚举类型](/dotnet/standard/base-types/enumeration-format-strings)以及[guid](xref:System.Guid.ToString(System.String))。 您还可以将对格式字符串的支持添加到您自己的类型中。

 ### <a name="control-spacing"></a>控件间距
 您可以通过使用诸如的语法（ `{0,12}` 插入12个字符的字符串）来定义插入到结果字符串中的字符串的宽度。 在这种情况下，第一个对象的字符串表示形式在12个字符的字段中右对齐。   (如果第一个对象的字符串表示形式的长度超过12个字符，则将忽略首选字段宽度，并将整个字符串插入到结果字符串中。 ) 

 下面的示例定义了一个包含字符串 "Year" 和一些年份字符串的6字符字段，以及一个包含字符串 "人口" 和一些人口数据的15个字符的字段。 请注意，字符在字段中右对齐。

 [!code-cpp[System.String.Format#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp[System.String.Format#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting3.cs#33)]
 [!code-vb[System.String.Format#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]

 ### <a name="control-alignment"></a>控件对齐
 默认情况下，如果指定字段宽度，则字符串在其字段内右对齐。 若要在字段中左对齐字符串，请在字段宽度前面加上负号，如 `{0,-12}` 定义12个字符左对齐字段。

 下面的示例与上一个示例类似，不同之处在于它会将标签和数据保持一致。

 [!code-cpp[System.String.Format#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp[System.String.Format#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]

 <xref:System.String.Format%2A?displayProperty=nameWithType> 使用复合格式设置功能。 有关更多信息，请参见[复合格式设置](/dotnet/standard/base-types/composite-formatting)。

<a name="FTaskList"></a>
## <a name="which-method-do-i-call"></a>我要调用哪种方法？

|功能|调用|
|--------|----------|
|使用当前区域性的约定设置一个或多个对象的格式。|除了包含参数的重载以外 `provider` ，其余 <xref:System.String.Format%2A> 重载包含一个参数， <xref:System.String> 后跟一个或多个对象参数。 因此，不必确定要 <xref:System.String.Format%2A> 调用的重载。 根据参数列表，语言编译器会从没有参数的重载中选择相应的重载 `provider` 。 例如，如果参数列表具有五个参数，则编译器将调用 <xref:System.String.Format(System.String%2CSystem.Object%5B%5D)> 方法。|
|通过使用特定区域性的约定来设置一个或多个对象的格式。|以 <xref:System.String.Format%2A> 参数开头的每个重载 `provider` 后跟一个 <xref:System.String> 参数和一个或多个对象参数。 因此，不必确定要调用的特定 <xref:System.String.Format%2A> 重载。 语言编译器根据参数列表，从具有参数的重载中选择适当的重载 `provider` 。 例如，如果参数列表具有五个参数，则编译器将调用 <xref:System.String.Format(System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D)> 方法。|
|使用实现或实现执行自定义格式设置操作 <xref:System.ICustomFormatter> <xref:System.IFormattable> 。|四个具有参数的重载中的任何一个 `provider` 。 编译器根据参数列表，从具有参数的重载中选择适当的重载 `provider` 。|

<a name="Format_Brief"></a>
## <a name="the-format-method-in-brief"></a>Format 方法 brief

 该方法的每个重载都 <xref:System.String.Format%2A> 使用 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) ，以复合格式字符串形式包含从零开始的索引占位符（称为 *格式项*）。 在运行时，每个格式项都替换为参数列表中相应参数的字符串表示形式。 如果参数的值为，则 `null` 将格式项替换为 <xref:System.String.Empty?displayProperty=nameWithType> 。 例如，以下对方法的调用 <xref:System.String.Format(System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object)> 包含一个格式字符串，其中包含三个格式项、、 {0} {1} 和 {2} ，以及包含三个项的参数列表。

 [!code-cpp[System.String.Format#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp[System.String.Format#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]

<a name="FormatItem"></a>
## <a name="the-format-item"></a>格式项
 格式项具有以下语法：

```
{index[,alignment][:formatString]}
```

 方括号表示可选元素。 需要左大括号和右大括号。  (在格式字符串中包含文本左大括号或右大括号，请参阅[复合格式设置](/dotnet/standard/base-types/composite-formatting)一文中的[转义大括号](/dotnet/standard/base-types/composite-formatting#escaping-braces)部分。 ) 

 例如，设置货币值格式的格式项可能如下所示：

 [!code-cpp[System.String.Format#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp[System.String.Format#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]
 [!code-vb[System.String.Format#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatsyntax1.vb#12)]

 格式项包含以下元素：

 index\
 自变量的从零开始的索引，其字符串表示形式将包含在字符串中的此位置。 如果此参数为 `null` ，则字符串中此位置将包含空字符串。

 *关联*\
 可选。 一个有符号整数，它指示要插入自变量的字段的总长度，并指定该参数是右对齐的， (是正整数) 还是) 负整数 (左对齐。 如果省略 *对齐方式*，则会在不带前导空格或尾随空格的字段中插入相应参数的字符串表示形式。

 如果 *对齐* 值小于要插入的参数的长度，则将忽略 *对齐* ，并使用参数的字符串表示形式的长度作为字段宽度。

 *说明符*\
 可选。 一个字符串，指定相应参数的结果字符串的格式。 如果省略 *格式说明符*，则将调用相应的参数的无参数 `ToString` 方法，以生成其字符串表示形式。 如果指定格式 *字符串*，则该格式项引用的参数必须实现 <xref:System.IFormattable> 接口。 支持格式字符串的类型包括：

- 所有整型和浮点类型。  (参见 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 和 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。 ) 

- <xref:System.DateTime> 和 <xref:System.DateTimeOffset>。  (参见 [标准日期和时间格式字符串](/dotnet/standard/base-types/standard-date-and-time-format-strings) 和 [自定义日期和时间格式字符串](/dotnet/standard/base-types/custom-date-and-time-format-strings)。 ) 

- 所有枚举类型。  (参见 [枚举格式字符串](/dotnet/standard/base-types/enumeration-format-strings)。 ) 

- <xref:System.TimeSpan> 值。  (参见 [标准 Timespan 格式字符串](/dotnet/standard/base-types/standard-timespan-format-strings) 和 [自定义时间跨度格式字符串](/dotnet/standard/base-types/custom-timespan-format-strings)。 ) 

- GUID。  (参见 <xref:System.Guid.ToString(System.String)?displayProperty=nameWithType> 方法。 ) 

 但请注意，任何自定义类型都可以实现 <xref:System.IFormattable> 或扩展现有类型的 <xref:System.IFormattable> 实现。

 下面的示例使用 `alignment` 和 `formatString` 参数来生成格式化的输出。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp" id="Snippet9":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs" interactive="try-dotnet-method" id="Snippet9":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb" id="Snippet9":::

<a name="HowFormatted"></a>
## <a name="how-arguments-are-formatted"></a>如何设置参数的格式
 格式项从字符串的开头按顺序处理。 每个格式项都具有与方法的参数列表中的对象相对应的索引。 <xref:System.String.Format%2A>方法检索参数并按如下方式派生其字符串表示形式：

- 如果参数为 `null` ，则该方法将插入 <xref:System.String.Empty?displayProperty=nameWithType> 到结果字符串中。 不必担心如何处理 <xref:System.NullReferenceException> null 参数。

- 如果调用 <xref:System.String.Format(System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D)> 重载并且 `provider` 对象的 <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> 实现返回非 null <xref:System.ICustomFormatter> 实现，则会将参数传递给其 <xref:System.ICustomFormatter.Format(System.String%2CSystem.Object%2CSystem.IFormatProvider)?displayProperty=nameWithType> 方法。 如果格式项包含格式 *字符串* 参数，则它将作为第一个参数传递给方法。 如果 <xref:System.ICustomFormatter> 实现可用并且产生一个非空字符串，则返回该字符串作为参数的字符串表示形式; 否则，将执行下一步。

- 如果参数实现 <xref:System.IFormattable> 接口， <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> 则调用其实现。

- 调用了自变量的无参数 `ToString` 方法，该方法可重写或继承基类实现。

 有关截获对方法的调用， <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> 并允许你查看 <xref:System.String.Format%2A> 方法为复合格式字符串中的每个格式项传递到格式设置方法的信息，请参阅 [示例：截获提供程序和罗马数字格式化程序](#Format7_Example)。

 有关详细信息，请参阅[复合格式设置](/dotnet/standard/base-types/composite-formatting)一文中的 "[处理顺序](/dotnet/standard/base-types/composite-formatting##processing-order)" 部分。

<a name="SameIndex"></a>
## <a name="format-items-that-have-the-same-index"></a>设置具有相同索引的项的格式
 <xref:System.String.Format%2A> <xref:System.FormatException> 如果索引项的索引大于或等于参数列表中的参数数目，则该方法将引发异常。 但是， `format` 只要多个格式项具有相同的索引，就可以包含比参数更多的格式项。 在以下示例中，对方法的调用中 <xref:System.String.Format(System.String%2CSystem.Object)> ，参数列表具有单个参数，但格式字符串包含两个格式项：一个显示数字的十进制值，另一个显示其十六进制值。

 [!code-csharp-interactive[System.String.Format2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]

<a name="Format_Culture"></a>
## <a name="format-and-culture"></a>格式和区域性
 通常，使用当前区域性的约定（由属性返回），将参数列表中的对象转换为其字符串表示形式 <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> 。 可以通过调用包含参数的的重载之一来控制此行为 <xref:System.String.Format%2A> `provider` 。 `provider`参数是一个 <xref:System.IFormatProvider> 实现，提供用于使格式设置过程适中的自定义和区域性特定的格式设置信息。

 此 <xref:System.IFormatProvider> 接口具有一个成员， <xref:System.IFormatProvider.GetFormat%2A> 该成员负责返回提供格式设置信息的对象。 .NET 具有三种 <xref:System.IFormatProvider> 实现，它们提供区域性特定的格式设置：

- <xref:System.Globalization.CultureInfo>. 其 <xref:System.Globalization.CultureInfo.GetFormat%2A> 方法返回一个特定于区域性的 <xref:System.Globalization.NumberFormatInfo> 对象，用于设置数值的格式，以及 <xref:System.Globalization.DateTimeFormatInfo> 用于设置日期和时间值格式的区域性特定的对象。

- <xref:System.Globalization.DateTimeFormatInfo>，它用于日期和时间值的区域性特定格式设置。 其 <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> 方法返回自身。

- <xref:System.Globalization.NumberFormatInfo>，它用于指定数值的区域性特定格式。 其 <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> 属性返回自身。

<a name="Format_Custom"></a>
## <a name="custom-formatting-operations"></a>自定义格式设置操作
 您还可以调用 <xref:System.String.Format%2A> 具有类型的参数的方法的任何重载 `provider` <xref:System.IFormatProvider> 来执行自定义格式设置操作。 例如，可以将整数的格式设置为标识号或电话号码。 若要执行自定义格式设置，你 `provider` 的参数必须实现 <xref:System.IFormatProvider> 和 <xref:System.ICustomFormatter> 接口。 当向 <xref:System.String.Format%2A> 方法传递 <xref:System.ICustomFormatter> 实现作为 `provider` 参数时， <xref:System.String.Format%2A> 方法将调用其   <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> 实现并请求类型的对象 <xref:System.ICustomFormatter> 。 然后，它调用返回的 <xref:System.ICustomFormatter> 对象的 <xref:System.ICustomFormatter.Format%2A> 方法，以设置传递给它的复合字符串中的每个格式项的格式。

 有关提供自定义格式设置解决方案的详细信息，请参阅 [如何：定义和使用自定义数值格式提供程序](/dotnet/standard/base-types/how-to-define-and-use-custom-numeric-format-providers) 和 <xref:System.ICustomFormatter> 。 有关将整数转换为格式化自定义数字的示例，请参阅 [示例：自定义格式设置操作](#Format6_Example)。 有关将无符号字节转换为罗马数字的示例，请参阅 [示例：截获提供程序和罗马数字格式化程序](#Format7_Example)。

<a name="Format6_Example"></a>
### <a name="example-a-custom-formatting-operation"></a>示例：自定义格式设置操作
 此示例定义格式提供程序，该提供程序将整数值的格式设置为 x-xxxxx-xx 形式的客户帐户号。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp" id="Snippet2":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb" id="Snippet2":::

<a name="Format7_Example"></a>
### <a name="example-an-intercept-provider-and-roman-numeral-formatter"></a>示例：截距提供程序和罗马数字格式化程序
 此示例定义了一个自定义格式提供程序，该提供程序实现 <xref:System.ICustomFormatter> 和 <xref:System.IFormatProvider> 接口以执行两项操作：

- 它将显示传递到其实现的参数 <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> 。 这使我们能够查看方法将哪些参数 <xref:System.String.Format(System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D)> 传递到其尝试设置格式的每个对象的自定义格式设置实现。 调试应用程序时，这会很有用。

- 如果要设置格式的对象是要使用 "R" 标准格式字符串设置格式的无符号字节值，则自定义格式化程序将数值的格式设置为罗马数字。

 [!code-cpp[System.String.Format#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp[System.String.Format#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]

<a name="QA"></a>
## <a name="stringformat-q--a"></a>字符串格式 Q &

### <a name="why-do-you-recommend-string-interpolation-over-calls-to-the-stringformat-method"></a>为什么建议通过调用方法来插入字符串 `String.Format` ？

字符串内插为：

- 更灵活。 它可用于任何字符串，无需调用支持复合格式设置的方法。 否则，必须调用 <xref:System.String.Format%2A> 方法或支持复合格式设置的其他方法，如 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 或 <xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType> 。

- 可读性更强。 由于插入到字符串中的表达式出现在内插表达式中（而不是自变量列表中），因此，内插字符串的代码和读取更为容易。 由于其可读性更高，内插字符串不仅可以替换对复合格式方法的调用，还可以在字符串串联操作中使用，以生成更简洁简洁的代码。

下面两个代码示例的比较说明了经营字符串连接和对复合格式设置方法的调用的内插字符串。 在下面的示例中，使用多个字符串串联操作会生成详细的代码和难于阅读的代码。

[!code-csharp[non-interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated1.cs#QAInterpolated)]
[!code-vb[non-interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated1.vb)]

与此相反，在下面的示例中使用内插字符串会生成比字符串串联语句更清晰、更简洁的代码，并对 <xref:System.String.Format%2A> 上一示例中的方法进行调用。

[!code-csharp[interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated2.cs#QAInterpolated2)]
[!code-vb[interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated2.vb)]

### <a name="where-can-i-find-a-list-of-the-predefined-format-strings-that-can-be-used-with-format-items"></a>在哪里可以找到可用于格式项的预定义格式字符串列表？

- 对于所有整型和浮点类型，请参阅 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 和 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。

- 对于日期和时间值，请参阅 [标准日期和时间格式字符串](/dotnet/standard/base-types/standard-date-and-time-format-strings) 和 [自定义日期和时间格式字符串](/dotnet/standard/base-types/custom-date-and-time-format-strings)。

- 对于枚举值，请参阅 [枚举格式字符串](/dotnet/standard/base-types/enumeration-format-strings)。

- 有关 <xref:System.TimeSpan> 值，请参阅  [标准 Timespan 格式字符串](/dotnet/standard/base-types/standard-timespan-format-strings) 和 [自定义 timespan 格式字符串](/dotnet/standard/base-types/custom-timespan-format-strings)。

- 有关 <xref:System.Guid> 值，请参阅引用页的 "备注" 部分 <xref:System.Guid.ToString(System.String)?displayProperty=nameWithType> 。

### <a name="how-do-i-control-the-alignment-of-the-result-strings-that-replace-format-items"></a>如何实现控制替换格式项的结果字符串的对齐方式吗？
 格式项的一般语法为：

```
{index[,alignment][: formatString]}
```

 其中， *对齐方式* 是一个定义字段宽度的带符号整数。 如果此值为负数，则字段中的文本为左对齐。 如果为正数，则文本右对齐。

### <a name="how-do-i-control-the-number-of-digits-after-the-decimal-separator"></a>如何实现控制小数点分隔符后的位数？
 除 "D" (之外的所有 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) （仅适用于整数) "G"、"R" 和 "X"）都允许使用精度说明符定义结果字符串中的小数位数。 下面的示例使用标准数字格式字符串来控制结果字符串中的小数位数。

 [!code-csharp[System.String.Format#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]

 如果使用的是 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)，请使用 "0" 格式说明符控制结果字符串中的小数位数，如下面的示例所示。

 [!code-csharp-interactive[System.String.Format#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]

### <a name="how-do-i-control-the-number-of-integral-digits"></a>如何实现控制整数位数？
 默认情况下，格式设置操作仅显示非零整数位数。 如果要设置整数格式，则可以使用带有 "D" 和 "X" 标准格式字符串的精度说明符来控制数字的位数。

 [!code-csharp-interactive[System.String.Format#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]

 可以通过使用 "0" [自定义数值格式说明符](/dotnet/standard/base-types/custom-numeric-format-strings)，使用前导零填充整数或浮点数，以生成具有指定数量整数位数的结果字符串，如下面的示例所示。

 [!code-csharp-interactive[System.String.Format#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]

### <a name="how-many-items-can-i-include-in-the-format-list"></a>可以在 "格式" 列表中包含多少项？
 没有实际限制。 方法的第二个参数 <xref:System.String.Format(System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D)> 使用特性进行标记 <xref:System.ParamArrayAttribute> ，这允许您将分隔的列表或对象数组作为格式列表包括在内。

<a name="braces"></a>
### <a name="how-do-i-include-literal-braces--and--in-the-result-string"></a>如何实现在结果字符串中包含 "{" 和 "}" ( 文本大括号 ) 
 例如，如何防止下面的方法调用引发 <xref:System.FormatException> 异常？

 [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]

 单个左大括号或右大括号始终解释为格式项的开头或结尾。 若要按原义解释，则必须对其进行转义。 通过添加另一个大括号 ( "{{" 和 "}}" 而不是 "{" 和 "}" ) 来转义大括号，如以下方法调用所示：

 [!code-csharp-interactive[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]

 不过，甚至可以轻松地误解转义大括号。 建议在格式列表中包含大括号，并使用格式项将它们插入到结果字符串中，如下面的示例所示。

 [!code-csharp-interactive[System.String.Format#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]

### <a name="why-does-my-call-to-the-stringformat-method-throw-a-formatexception"></a>为什么调用字符串。 Format 方法会引发 FormatException？
 最常见的原因是，格式项的索引不与 "格式" 列表中的对象相对应。 通常，这表示您已 misnumbered 格式项的索引，或者您忘记在 "格式" 列表中包含一个对象。 尝试包含非转义的左大括号或右大括号会引发 <xref:System.FormatException> 。 偶尔，异常是由键入错误引起的;例如，典型的错误是错误地键入了 "[" (左括号) 而不是 "{" (左大括号) 。

### <a name="if-the-formatsystemiformatprovidersystemstringsystemobject-method-supports-parameter-arrays-why-does-my-code-throw-an-exception-when-i-use-an-array"></a>如果 (IFormatProvider，System.string，system.object [] ) 方法的格式支持参数数组，则我的代码在使用数组时为什么会引发异常？
 例如，以下代码将引发 <xref:System.FormatException> 异常：

 [!code-csharp[System.String.Format#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]

 这是编译器重载决策的问题。 由于编译器无法将整数数组转换为对象数组，因此它将整数数组视为单个参数，因此它将调用 <xref:System.String.Format(System.String%2CSystem.Object)> 方法。 引发此异常的原因是存在四个格式项，但在 "格式" 列表中只有一个项。

 因为 Visual Basic 和 c # 都不能将整数数组转换为对象数组，所以必须在调用方法之前自行执行转换 <xref:System.String.Format(System.String%2CSystem.Object%5B%5D)> 。 以下示例提供了一个实现。

 [!code-csharp-interactive[System.String.Format#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]

## Examples

调用方法的多 <xref:System.String.Format%2A> 个示例贯穿本文的 " [备注](#remarks-top) " 部分。

你还可以下载一组完整的 `String.Format` 示例，其中包括 [适用于 c # 的 .net Core 项目](https://docs.microsoft.com/samples/dotnet/samples/string-format/)。

下面是本文中包含的一些示例：

### <a name="create-a-format-string"></a>创建格式字符串

[插入字符串](#insert-a-string)\
[格式项](#the-format-item)\
[设置具有相同索引的项的格式](#format-items-that-have-the-same-index)

### <a name="control-formatted-output"></a>控制格式化输出

[控制格式设置](#control-formatting)\
[控制间距](#control-spacing)\
[控制对齐方式](#control-alignment)\
[控制整数位数](#how-do-i-control-the-number-of-integral-digits)\
[控制小数点分隔符后的位数](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)\
[在结果字符串中包含字面大括号](#braces)

### <a name="make-format-strings-culture-sensitive"></a>使格式字符串区分区域性

[区分区域性的格式设置](#culture-sensitive-formatting)

### <a name="customize-the-formatting-operation"></a>自定义格式设置操作

[自定义格式设置操作](#example-a-custom-formatting-operation)\
[截距提供程序和罗马数字格式化程序](#example-an-intercept-provider-and-roman-numeral-formatter)

 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">设置 .NET 中类型的格式</related>
        <related type="Article" href="/dotnet/standard/base-types/composite-formatting">复合格式设置</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-date-and-time-format-strings">标准日期和时间格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-date-and-time-format-strings">自定义日期和时间格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">标准数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">自定义数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-timespan-format-strings">标准 TimeSpan 格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-timespan-format-strings">自定义的 TimeSpan 格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/enumeration-format-strings">枚举格式字符串</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj -&gt; string" Usage="System.string.Format (format, arg0)" />
      <MemberSignature Language="C#" Value="public static string Format (string format, object? arg0);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">[复合格式字符串](/dotnet/standard/base-types/composite-formatting)。</param>
        <param name="arg0">要设置格式的对象。</param>
        <summary>将字符串中的一个或多个格式项替换为指定对象的字符串表示形式。</summary>
        <returns><paramref name="format" /> 的副本，其中的任何格式项均替换为 <paramref name="arg0" /> 的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)]

此方法使用 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将表达式的值转换为其字符串表示形式，并将该表示形式嵌入到字符串中。

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-a-single-argument"></a>示例：设置单个参数的格式

 下面的示例使用 <xref:System.String.Format(System.String%2CSystem.Object)> 方法在字符串中间嵌入单个年龄。

 [!code-cpp[System.String.Format#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp-interactive[System.String.Format#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 中的格式项无效。

- 或 -

格式项的索引不为零。</exception>
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">设置 .NET 中类型的格式</related>
        <related type="Article" href="/dotnet/standard/base-types/composite-formatting">复合格式设置</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-date-and-time-format-strings">标准日期和时间格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-date-and-time-format-strings">自定义日期和时间格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">标准数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">自定义数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-timespan-format-strings">标准 TimeSpan 格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-timespan-format-strings">自定义的 TimeSpan 格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/enumeration-format-strings">枚举格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[] args);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj[] -&gt; string" Usage="System.string.Format (format, args)" />
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[]? args);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">[复合格式字符串](/dotnet/standard/base-types/composite-formatting)。</param>
        <param name="args">一个对象数组，其中包含零个或多个要设置格式的对象。</param>
        <summary>将指定字符串中的格式项替换为指定数组中相应对象的字符串表示形式。</summary>
        <returns><paramref name="format" /> 的副本，其中格式项已替换为 <paramref name="args" /> 中相应对象的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)]

此方法使用 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将4个或更多表达式的值转换为它们的字符串表示形式，并将这些表示形式嵌入到字符串中。 由于 `args` 参数是用特性标记的 <xref:System.ParamArrayAttribute?displayProperty=nameWithType> ，因此可以将对象作为单个参数或数组传递给方法 <xref:System.Object> 。

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-format-more-than-three-arguments"></a>示例：格式化三个以上的参数

 此示例将创建一个字符串，其中包含特定日期的高温和低温度数据。 复合格式字符串在 c # 示例中有五个格式项，在 Visual Basic 示例中有六个格式项。 两个格式项定义其对应值的字符串表示形式的宽度，第一个格式项还包括标准日期和时间格式字符串。

 [!code-cpp[System.String.Format#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp[System.String.Format#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]

 还可以传递要格式化为数组而不是参数列表的对象。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp" id="Snippet10":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs" interactive="try-dotnet" id="Snippet10":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb" id="Snippet10":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 或 <paramref name="args" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 无效。

- 或 -

格式项的索引小于零，或者大于或等于 <paramref name="args" /> 数组的长度。</exception>
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">设置 .NET 中类型的格式</related>
        <related type="Article" href="/dotnet/standard/base-types/composite-formatting">复合格式设置</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-date-and-time-format-strings">标准日期和时间格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-date-and-time-format-strings">自定义日期和时间格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">标准数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">自定义数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-timespan-format-strings">标准 TimeSpan 格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-timespan-format-strings">自定义的 TimeSpan 格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/enumeration-format-strings">枚举格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj -&gt; string" Usage="System.string.Format (provider, format, arg0)" />
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider? provider, string format, object? arg0);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <param name="format">[复合格式字符串](/dotnet/standard/base-types/composite-formatting)。</param>
        <param name="arg0">要设置格式的对象。</param>
        <summary>将指定字符串中的一个或多个格式项替换为对应对象的字符串表示形式。 参数提供区域性特定的格式设置信息。</summary>
        <returns><paramref name="format" /> 的副本，其中的一个或多个格式项已替换为 <paramref name="arg0" /> 的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)]

此方法使用 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将表达式的值转换为其字符串表示形式，并将该表示形式嵌入到字符串中。 在执行转换时，方法使用区分区域性的格式设置或自定义格式化程序。 方法 `arg0` 通过调用其 tostring **(IFormatProvider)** 方法转换为其字符串表示形式; 如果对象的相应格式项包含格式字符串，则通过调用其 **Tostring (string，IFormatProvider)** 方法来转换为字符串表示形式。 如果这些方法不存在，它将调用对象的无参数 **ToString** 方法。

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 无效。

- 或 -

格式项的索引不为零。</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, params object[] args);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj[] -&gt; string" Usage="System.string.Format (provider, format, args)" />
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider? provider, string format, params object[]? args);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <param name="format">[复合格式字符串](/dotnet/standard/base-types/composite-formatting)。</param>
        <param name="args">一个对象数组，其中包含零个或多个要设置格式的对象。</param>
        <summary>将字符串中的格式项替换为指定数组中相应对象的字符串表示形式。 参数提供区域性特定的格式设置信息。</summary>
        <returns><paramref name="format" /> 的副本，其中格式项已替换为 <paramref name="args" /> 中相应对象的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)]

此方法使用 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将4个或更多表达式转换为其字符串表示形式，并将这些表示形式嵌入到字符串中。 在执行转换时，方法使用区分区域性的格式设置或自定义格式化程序。 方法通过调用其 tostring <xref:System.Object> **(IFormatProvider)** 方法来将每个参数转换为其字符串表示形式; 如果对象的相应格式项包含格式字符串，则通过调用其 **Tostring (string，IFormatProvider)** 方法来将其转换为字符串表示形式。 如果这些方法不存在，它将调用对象的无参数 **ToString** 方法。

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]

<a name="culture-sensitive-formatting" />

### <a name="example-culture-sensitive-formatting"></a>示例：区分区域性的格式设置

 此示例使用 <xref:System.String.Format(System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D)> 方法通过使用几个不同的区域性显示某些日期和时间值的字符串表示形式和数值。

 [!code-csharp-interactive[System.String.Format2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 或 <paramref name="args" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 无效。

- 或 -

格式项的索引小于零，或者大于或等于 <paramref name="args" /> 数组的长度。</exception>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.ICustomFormatter" />
        <altmember cref="T:System.IFormatProvider" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">设置 .NET 中类型的格式</related>
        <related type="Article" href="/dotnet/standard/base-types/composite-formatting">复合格式设置</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-date-and-time-format-strings">标准日期和时间格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-date-and-time-format-strings">自定义日期和时间格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">标准数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">自定义数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-timespan-format-strings">标准 TimeSpan 格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-timespan-format-strings">自定义的 TimeSpan 格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/enumeration-format-strings">枚举格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1)" />
      <MemberSignature Language="C#" Value="public static string Format (string format, object? arg0, object? arg1);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">[复合格式字符串](/dotnet/standard/base-types/composite-formatting)。</param>
        <param name="arg0">要设置格式的第一个对象。</param>
        <param name="arg1">要设置格式的第二个对象。</param>
        <summary>将字符串中的格式项替换为两个指定对象的字符串表示形式。</summary>
        <returns><paramref name="format" /> 的副本，其中的格式项替换为 <paramref name="arg0" /> 和 <paramref name="arg1" /> 的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)]

此方法使用 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将两个表达式的值转换为它们的字符串表示形式，并将这些表示形式嵌入到字符串中。

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-format-two-arguments"></a>示例：设置两个参数的格式

 此示例使用 <xref:System.String.Format(System.String%2CSystem.Object%2CSystem.Object)> 方法来显示通用对象中存储的时间和温度数据 <xref:System.Collections.Generic.Dictionary%602> 。 请注意，尽管只有两个要设置格式的对象，但格式字符串具有三个格式项。 这是因为列表中的第一个对象 (日期和时间值) 由两个格式项使用：第一个格式项显示时间，第二个对象显示日期。

 [!code-cpp[System.String.Format#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp[System.String.Format#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 无效。

- 或 -

格式项的索引不为零或一。</exception>
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">设置 .NET 中类型的格式</related>
        <related type="Article" href="/dotnet/standard/base-types/composite-formatting">复合格式设置</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-date-and-time-format-strings">标准日期和时间格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-date-and-time-format-strings">自定义日期和时间格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">标准数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">自定义数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-timespan-format-strings">标准 TimeSpan 格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-timespan-format-strings">自定义的 TimeSpan 格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/enumeration-format-strings">枚举格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1)" />
      <MemberSignature Language="C#" Value="public static string? Format (IFormatProvider provider, string? format, object arg0, object arg1);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <param name="format">[复合格式字符串](/dotnet/standard/base-types/composite-formatting)。</param>
        <param name="arg0">要设置格式的第一个对象。</param>
        <param name="arg1">要设置格式的第二个对象。</param>
        <summary>将字符串中的格式项替换为两个指定对象的字符串表示形式。 参数提供区域性特定的格式设置信息。</summary>
        <returns><paramref name="format" /> 的副本，其中的格式项替换为 <paramref name="arg0" /> 和 <paramref name="arg1" /> 的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)]

此方法使用 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将两个表达式转换为其字符串表示形式，并将这些表示形式嵌入字符串。 在执行转换时，方法使用区分区域性的格式设置或自定义格式化程序。 方法通过调用其 tostring <xref:System.Object> **(IFormatProvider)** 方法来将每个参数转换为其字符串表示形式; 如果对象的相应格式项包含格式字符串，则通过调用其 **Tostring (string，IFormatProvider)** 方法来将其转换为字符串表示形式。 如果这些方法不存在，它将调用对象的无参数 **ToString** 方法。

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 无效。

- 或 -

格式项的索引不为零或一。</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1, arg2)" />
      <MemberSignature Language="C#" Value="public static string? Format (string? format, object arg0, object arg1, object arg2);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">[复合格式字符串](/dotnet/standard/base-types/composite-formatting)。</param>
        <param name="arg0">要设置格式的第一个对象。</param>
        <param name="arg1">要设置格式的第二个对象。</param>
        <param name="arg2">要设置格式的第三个对象。</param>
        <summary>将字符串中的格式项替换为三个指定对象的字符串表示形式。</summary>
        <returns><paramref name="format" /> 的副本，其中的格式项已替换为 <paramref name="arg0" />、<paramref name="arg1" /> 和 <paramref name="arg2" /> 的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)]

此方法使用 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将三个表达式的值转换为其字符串表示形式，并将这些表示形式嵌入到字符串中。

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-format-three-arguments"></a>示例：设置三个参数的格式

 此示例使用 <xref:System.String.Format(System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object)> 方法创建一个字符串，该字符串演示 `And` 具有两个整数值的布尔运算的结果。 请注意，格式字符串包含六个格式项，但该方法在其参数列表中只有三个项，因为每个项都以两种不同的方式进行格式设置。

 [!code-cpp[System.String.Format#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp-interactive[System.String.Format#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 无效。

- 或 -

格式项的索引小于零，或者大于二。</exception>
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">设置 .NET 中类型的格式</related>
        <related type="Article" href="/dotnet/standard/base-types/composite-formatting">复合格式设置</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1, arg2)" />
      <MemberSignature Language="C#" Value="public static string? Format (IFormatProvider provider, string? format, object arg0, object arg1, object arg2);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="4" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <param name="format">[复合格式字符串](/dotnet/standard/base-types/composite-formatting)。</param>
        <param name="arg0">要设置格式的第一个对象。</param>
        <param name="arg1">要设置格式的第二个对象。</param>
        <param name="arg2">要设置格式的第三个对象。</param>
        <summary>将字符串中的格式项替换为三个指定对象的字符串表示形式。 参数提供区域性特定的格式设置信息。</summary>
        <returns><paramref name="format" /> 的副本，其中的格式项已替换为 <paramref name="arg0" />、<paramref name="arg1" /> 和 <paramref name="arg2" /> 的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)]

此方法使用 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将三个表达式转换为其字符串表示形式，并将这些表示形式嵌入字符串。 在执行转换时，方法使用区分区域性的格式设置或自定义格式化程序。 方法通过调用其 tostring <xref:System.Object> **(IFormatProvider)** 方法来将每个参数转换为其字符串表示形式; 如果对象的相应格式项包含格式字符串，则通过调用其 **Tostring (string，IFormatProvider)** 方法来将其转换为字符串表示形式。 如果这些方法不存在，它将调用对象的无参数 **ToString** 方法。

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 无效。

- 或 -

格式项的索引小于零，或者大于二。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As CharEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CharEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; CharEnumerator" Usage="string.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索一个可以循环访问此字符串中的每个字符的对象。</summary>
        <returns>枚举器对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!TIP]
> 不是调用 <xref:System.String.GetEnumerator%2A> 方法来检索用于 <xref:System.CharEnumerator> 枚举字符串的对象，而应改为使用语言的迭代构造 (c # 中的 c + +/clr 和 Visual Basic) 。 c # 中的[foreach](/dotnet/csharp/language-reference/keywords/foreach-in) ，[适用](/cpp/dotnet/for-each-in)于 c + +/clr 中的每个，[每个](/dotnet/visual-basic/language-reference/statements/for-each-next-statement)Visual Basic) 。

 此方法使您可以循环访问字符串中的单个字符。 例如，Visual Basic `For Each` 和 c # `foreach` 语句调用此方法以返回一个 <xref:System.CharEnumerator> 对象，该对象可提供对此字符串实例中字符的只读访问。

## Examples
 下面的示例将循环访问多个字符串中的字符，并显示有关其各个字符的信息。 它使用语言迭代构造，而不是调用 <xref:System.String.GetEnumerator%2A> 方法。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="P:System.String.Chars(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="string.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回该字符串的哈希代码。</summary>
        <returns>32 位有符号整数哈希代码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 的行为 <xref:System.String.GetHashCode%2A> 依赖于其实现，该实现可能会从公共语言运行时的一个版本更改为另一个版本。 导致这种情况的原因是提高的性能 <xref:System.String.GetHashCode%2A> 。

> [!IMPORTANT]
> 如果两个字符串对象相等，则该 <xref:System.String.GetHashCode%2A> 方法将返回相同的值。 但是，每个唯一字符串值没有唯一的哈希代码值。 不同的字符串可以返回相同的哈希代码。
>
> 哈希代码本身不一定是稳定的。 相同字符串的哈希代码可跨 .net 实现、跨 .NET 版本和跨 .NET 平台 (例如，.NET 的单个版本32位和64位) 。 在某些情况下，它们甚至不同于应用程序域。 这意味着，同一程序的两次后续运行可能返回不同的哈希代码。
>
> 因此，哈希代码决不能在创建它们的应用程序域的外部使用，它们永远不应用作集合中的键字段，它们永远不会保留。
>
> 最后，如果需要加密型强哈希，请不要使用哈希代码（而不是加密哈希函数返回的值）。 对于加密哈希，请使用派生自 <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> 或类的类 <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> 。
>
> 有关哈希代码的详细信息，请参阅 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 。

 在桌面应用中，你可以使用[ \<UseRandomizedStringHashAlgorithm> 元素](/dotnet/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element)基于每个应用程序域生成唯一的哈希代码。 这可以减少冲突数，并改善使用哈希表的插入和查找的整体性能。 下面的示例演示如何使用[ \<UseRandomizedStringHashAlgorithm> 元素](/dotnet/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element)。 它定义一个 `DisplayString` 类，该类包含一个私有字符串常量， `s` 其值为 "This is a string"。 它还包括显示字符串值及其哈希代码的 `ShowStringHashCode` 方法以及该方法在其中执行的应用程序域的名称。

 [!code-csharp[System.String.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]

 当您在未提供配置文件的情况下运行该示例时，它会显示类似下面的输出。 请注意，字符串的散列码在两个应用程序域中是相同的。

```
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC
String 'This is a string.' in domain 'NewDomain': 941BCEAC
```

 但是，如果将以下配置文件添加到示例目录，然后运行该示例，则同一个字符串的哈希代码将通过应用程序域进行区分。

```xml
<?xml version ="1.0"?>
<configuration>
   <runtime>
      <UseRandomizedStringHashAlgorithm enabled="1" />
   </runtime>
</configuration>
```

 存在配置文件时，示例会显示以下输出：

```
String 'This is a string.' in domain 'PerDomain.exe': 5435776D
String 'This is a string.' in domain 'NewDomain': 75CC8236
```

> [!IMPORTANT]
> 哈希代码用于有效地从哈希表中插入和检索密钥对象。 但哈希代码不能唯一标识字符串。 相同的字符串具有相同的哈希代码，但公共语言运行时还可以将相同的哈希代码分配给不同的字符串。 此外，哈希代码可根据 .NET 版本、单个版本内的平台和应用程序域的不同而不同。 因此，不应序列化或保留哈希代码值，也不应将其用作哈希表或字典中的键。

 有关哈希代码和方法的使用的其他信息 `GetHashCode` ，请参阅 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 。

## Examples
 下面的示例演示 <xref:System.String.GetHashCode%2A> 使用各种输入字符串的方法。

 [!code-cpp[system.string.gethashcode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]

 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>返回的值 <see cref="M:System.String.GetHashCode" /> 与平台相关。 它在 .NET Framework 的32位和64位版本上有所不同。 它还可能在不同版本的 .NET Framework 和 .NET Core 之间有所不同。</para></block>
        <altmember cref="M:System.Object.GetHashCode" />
        <related type="Article" href="/dotnet/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element">&lt;UseRandomizedStringHashAlgorithm &gt; 元素</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (value As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="System.string.GetHashCode value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">一个只读字符范围。</param>
        <summary>返回所提供的只读字符范围的哈希代码。</summary>
        <returns>32 位有符号整数哈希代码。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode(StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : StringComparison -&gt; int" Usage="string.GetHashCode comparisonType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="comparisonType">一个枚举值，用于指定比较中要使用的规则。</param>
        <summary>使用指定的规则返回此字符串的哈希代码。</summary>
        <returns>32 位有符号整数哈希代码。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : ReadOnlySpan&lt;char&gt; * StringComparison -&gt; int" Usage="System.string.GetHashCode (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">一个只读字符范围。</param>
        <param name="comparisonType">一个枚举值，用于指定比较中要使用的规则。</param>
        <summary>使用指定的规则返回所提供的只读字符范围的哈希代码。</summary>
        <returns>32 位有符号整数哈希代码。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPinnableReference">
      <MemberSignature Language="C#" Value="public ref readonly char GetPinnableReference ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char GetPinnableReference() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetPinnableReference" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPinnableReference () As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; char ^ GetPinnableReference();" />
      <MemberSignature Language="F#" Value="member this.GetPinnableReference : unit -&gt; char" Usage="string.GetPinnableReference " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Char</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-5.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回对索引 0 处字符串的元素的引用。</summary>
        <returns>一个字符，表示对索引 0 处字符串的元素的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

`GetPinnableReference`方法返回一个可用于 <xref:System.String> 在内存中固定的字符。 需要在 <xref:System.String> fixed 语句中支持的使用。

          ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">字符串为 NULL。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="string.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回 <see cref="T:System.String" /> 类的 <see cref="T:System.TypeCode" />。</summary>
        <returns>枚举常数 <see cref="F:System.TypeCode.String" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的示例显示了 <xref:System.TypeCode> 类型的枚举常数 <xref:System.String> 。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>报告指定 Unicode 字符或字符串在此实例中的第一个匹配项的从零开始的索引。 如果未在此实例中找到该字符或字符串，则此方法返回 -1。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">要查找的 Unicode 字符。</param>
        <summary>报告指定 Unicode 字符在此字符串中的第一个匹配项的从零开始的索引。</summary>
        <returns>如果找到该字符，则为 <paramref name="value" /> 的从零开始的索引位置；如果未找到，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 索引编号从0开始。

 此方法执行一个序号 (不区分区域性的) 搜索，其中，仅当字符的 Unicode 标量值相同时，才将其视为等效于另一个字符。 若要执行区分区域性的搜索，请使用 <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> 方法，其中表示预构成字符的 Unicode 标量值（如连字 "Æ" (U + 00C6) ）可能被视为等效于正确序列中任何字符的组成部分（例如 "AE" (U + 0041，u + 0045) ，具体取决于区域性）。

## Examples
 下面的示例演示如何 <xref:System.String> 使用方法搜索字符 <xref:System.String.IndexOf%2A> 。

 [!code-cpp[System.String.IndexOf#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp-interactive[System.String.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要搜寻的字符串。</param>
        <summary>报告指定字符串在此实例中的第一个匹配项的从零开始的索引。</summary>
        <returns>如果找到该字符串，则为 <paramref name="value" /> 的从零开始的索引位置；如果未找到该字符串，则为 -1。 如果 <paramref name="value" /> 为 <see cref="F:System.String.Empty" />，则返回值为 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 索引编号从0开始。

 此方法使用当前区域性执行 (区分大小写和区分区域性的) 搜索。 搜索从该实例的第一个字符位置开始，并继续到最后一个字符的位置。

 字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 在区分区域性的搜索中，如果 `value` 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果 `value` 仅包含一个或多个可忽略字符，则该 <xref:System.String.IndexOf(System.String)> 方法将始终返回 0 (零) ，以指示在当前实例的开头处找到匹配项。 在下面的示例中， <xref:System.String.IndexOf(System.String)> 方法用于查找 (软连字符的三个子字符串 (U + 00AD) ，软连字符后跟 "n"，软连字符后跟两个字符串中的 "m" ) 。 只有一个字符串包含软连字符。 如果该示例在 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 或更高版本上运行，则在每种情况下，因为软连字符是可忽略字符，所以，结果与中未包含软连字符的结果相同 `value` 。 仅搜索软连字符时，方法将返回 0 (零) ，以指示它已在字符串的开头找到匹配项。

 [!code-csharp[System.String.IndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]

## Examples
 下面的示例在 "动物" 中搜索 "n"。 因为字符串索引从零开始，而不是从零开始，所以 <xref:System.String.IndexOf(System.String)> 方法指示 "n" 位于位置1。

 [!code-cpp[System.String.IndexOf#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp-interactive[System.String.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]

 下面的示例使用 <xref:System.String.IndexOf%2A> 方法来确定某一句子中动物名称的起始位置。 然后，它将使用此位置插入描述动物的形容词。

 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>如 [使用字符串的最佳做法](/dotnet/standard/base-types/best-practices-strings)中所述，建议你避免调用替换默认值的字符串比较方法，并改为调用需要显式指定参数的方法。 若要使用当前区域性的比较规则查找字符串实例内子字符串的第一个索引，请使用 <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> 其参数的值调用方法重载 <see cref="F:System.StringComparison.CurrentCulture" /> `comparisonType` 。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要查找的 Unicode 字符。</param>
        <param name="startIndex">搜索起始位置。</param>
        <summary>报告指定 Unicode 字符在此字符串中的第一个匹配项的从零开始的索引。 该搜索从指定字符位置开始。</summary>
        <returns>如果找到该字符，则为从字符串的起始位置开始的 <paramref name="value" /> 从零开始的索引位置；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 索引编号从0开始。 `startIndex` 参数可以介于 0 到字符串实例的长度。 如果 `startIndex` 等于字符串实例的长度，则此方法返回-1。

 搜索范围从 `startIndex` 到字符串的末尾。

 此方法执行一个序号 (不区分区域性的) 搜索，其中，仅当字符的 Unicode 标量值相同时，才将其视为等效于另一个字符。 若要执行区分区域性的搜索，请使用 <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> 方法，其中表示预构成字符的 Unicode 标量值（如连字 "Æ" (U + 00C6) ）可能被视为等效于正确序列中任何字符的组成部分（例如 "AE" (U + 0041，u + 0045) ，具体取决于区域性）。

## Examples
 下面的示例演示 <xref:System.String.IndexOf%2A> 方法。

 [!code-cpp[string.indexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp-interactive[string.indexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 小于 0（零）或大于此字符串的长度。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">要查找的字符。</param>
        <param name="comparisonType">指定搜索规则的枚举值。</param>
        <summary>报告指定 Unicode 字符在此字符串中的第一个匹配项的从零开始的索引。 一个参数指定要用于指定字符的搜索类型。</summary>
        <returns>如果找到该字符，则为 <paramref name="value" /> 的从零开始的索引位置；如果未找到，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

索引编号从0开始。

`comparisonType`参数是一个 <xref:System.StringComparison> 枚举成员，用于指定对参数的搜索 `value` 是使用当前还是固定的区域性，区分大小写或不区分大小写，或者使用单词或序号比较规则。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要搜寻的字符串。</param>
        <param name="startIndex">搜索起始位置。</param>
        <summary>报告指定字符串在此实例中的第一个匹配项的从零开始的索引。 该搜索从指定字符位置开始。</summary>
        <returns>如果找到该字符串，则为从当前实例的起始位置开始的从零开始的 <paramref name="value" /> 的索引位置；否则为 -1。 如果 <paramref name="value" /> 为 <see cref="F:System.String.Empty" />，则返回值为 <paramref name="startIndex" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 索引编号从0开始。 `startIndex` 参数可以介于 0 到字符串实例的长度。 如果 `startIndex` 等于字符串实例的长度，则此方法返回-1。

 此方法使用当前区域性执行 (区分大小写和区分区域性的) 搜索。 搜索从 `startIndex` 该实例的字符位置开始，并继续到最后一个字符的位置。

 字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 在区分区域性的搜索中，如果 `value` 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果 `value` 仅包含一个或多个可忽略字符，则该 <xref:System.String.IndexOf(System.String%2CSystem.Int32)> 方法将始终返回 `startIndex` ，这是搜索开始处的字符位置。 在下面的示例中， <xref:System.String.IndexOf(System.String%2CSystem.Int32)> 方法用于查找软连字符 (U + 00AD 的位置) 后跟两个字符串中的 "m"。 只有一个字符串包含必需的子字符串。 如果本示例在 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 或更高版本上运行，则在这两种情况下，因为软连字符是可忽略字符，该方法将返回字符串中的 "m" 的索引。 注意对于第一个字符串，包含软连字符后跟“m”，该方法无法返回该软连字符的索引，而是返回“m”的索引。

 [!code-csharp[System.String.IndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]

## Examples
 下面的示例在目标字符串中搜索指定字符串的所有匹配项。

 [!code-cpp[stringindexof4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 小于 0（零）或大于此字符串的长度。</exception>
        <block subset="none" type="usage"><para>如 [使用字符串的最佳做法](/dotnet/standard/base-types/best-practices-strings)中所述，建议你避免调用替换默认值的字符串比较方法，并改为调用需要显式指定参数的方法。 若要通过使用当前区域性的比较规则查找特定字符位置之后发生的子字符串的第一个索引，请使用 <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> 值为的参数调用方法重载 <see cref="F:System.StringComparison.CurrentCulture" /> `comparisonType` 。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要搜寻的字符串。</param>
        <param name="comparisonType">指定搜索规则的枚举值之一。</param>
        <summary>报告指定的字符串在当前 <see cref="T:System.String" /> 对象中的第一个匹配项的从零开始的索引。 一个参数指定要用于指定字符串的搜索类型。</summary>
        <returns>如果找到该字符串，则为 <paramref name="value" /> 参数的索引位置；如果未找到该字符串，则为 -1。 如果 <paramref name="value" /> 为 <see cref="F:System.String.Empty" />，则返回值为 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 索引编号从0开始。

 `comparisonType`参数指定 `value` 使用当前或固定区域性搜索参数，使用区分大小写或不区分大小写的搜索，以及使用 word 或序号比较规则。

## Examples
 下面的示例演示了方法的三个重载 <xref:System.String.IndexOf%2A> ，这些重载使用枚举的不同值在另一个字符串内查找字符串的第一个匹配项 <xref:System.StringComparison> 。

 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 在区分区域性的搜索 (即，如果 <paramref name="comparisonType" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果 <paramref name="value" /> 仅包含一个或多个可忽略字符，则该 <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> 方法将始终返回 0 (零) ，以指示在当前实例的开头处找到匹配项。

在下面的示例中， <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> 方法用于查找 (软连字符的三个子字符串 (U + 00AD) ，软连字符后跟 "n"，软连字符后跟两个字符串中的 "m" ) 。 只有一个字符串包含软连字符。 如果本示例在 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 或更高版本上运行，因为软连字符是可忽略的字符，所以区分区域性的搜索返回的值与在搜索字符串中未包含软连字符时返回的值相同。 不过，序号搜索成功地在一个字符串中查找软连字符，并报告从第二个字符串中缺少它。

[！ code-csharp[IndexOf # 26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable26.cs#26)][！ code-vb[IndexOf # 26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable26.vb#26)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要查找的 Unicode 字符。</param>
        <param name="startIndex">搜索起始位置。</param>
        <param name="count">要检查的字符位置数。</param>
        <summary>报告指定字符在此实例中的第一个匹配项的从零开始的索引。 搜索从指定字符位置开始，并检查指定数量的字符位置。</summary>
        <returns>如果找到该字符，则为从字符串的起始位置开始的 <paramref name="value" /> 从零开始的索引位置；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 搜索从开始 `startIndex` ，并继续到 `startIndex`  +  `count` -1。 位于处的字符 `startIndex`  +  `count` 不包含在搜索中。

 索引编号从 0 (零开始) 。 `startIndex` 参数可以介于 0 到字符串实例的长度。

 此方法执行一个序号 (不区分区域性的) 搜索，其中，仅当字符的 Unicode 标量值相同时，才将其视为等效于另一个字符。 若要执行区分区域性的搜索，请使用 <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> 方法，其中表示预构成字符的 Unicode 标量值（如连字 "Æ" (U + 00C6) ）可能被视为等效于正确序列中任何字符的组成部分（例如 "AE" (U + 0041，u + 0045) ，具体取决于区域性）。

## Examples
 下面的示例演示 <xref:System.String.IndexOf%2A> 方法。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 或 <paramref name="startIndex" /> 为负数。

- 或 -

 <paramref name="startIndex" /> 大于此字符串的长度。

- 或 -

 <paramref name="count" /> 大于此字符串的长度减 <paramref name="startIndex" />。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要搜寻的字符串。</param>
        <param name="startIndex">搜索起始位置。</param>
        <param name="count">要检查的字符位置数。</param>
        <summary>报告指定字符串在此实例中的第一个匹配项的从零开始的索引。 搜索从指定字符位置开始，并检查指定数量的字符位置。</summary>
        <returns>如果找到该字符串，则为从当前实例的起始位置开始的从零开始的 <paramref name="value" /> 的索引位置；否则为 -1。 如果 <paramref name="value" /> 为 <see cref="F:System.String.Empty" />，则返回值为 <paramref name="startIndex" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 索引编号从 0 (零开始) 。 `startIndex` 参数可以介于 0 到字符串实例的长度。

 此方法使用当前区域性执行 (区分大小写和区分区域性的) 搜索。 搜索从开始 `startIndex` ，并继续到 `startIndex`  +  `count` -1。 位于处的字符 `startIndex`  +  `count` 不包含在搜索中。

 字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 在区分区域性的搜索中，如果 `value` 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果 `value` 仅包含一个或多个可忽略字符，则该 <xref:System.String.IndexOf(System.String%2CSystem.Int32%2CSystem.Int32)> 方法将始终返回 `startIndex` ，这是搜索开始处的字符位置。 在下面的示例中， <xref:System.String.IndexOf(System.String%2CSystem.Int32%2CSystem.Int32)> 方法用于查找软连字符 (U + 00AD) 的位置，并在两个字符串中从第三个到第六个字符位置开始的 "m"。 只有一个字符串包含必需的子字符串。 如果该示例在 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 或更高版本上运行，则在这两种情况下，因为软连字符是可忽略的字符，所以当执行区分区域性的比较时，该方法将返回字符串中的 "m" 的索引。 注意对于第一个字符串，包含软连字符后跟“m”，该方法无法返回该软连字符的索引，而是返回“m”的索引。

 [!code-csharp[System.String.IndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]

## Examples
 下面的示例查找字符串 "he" 在另一个字符串的子字符串中的所有匹配项的索引。 请注意，必须为每个搜索迭代重新计算要搜索的字符数。

 [!code-cpp[string.indexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp-interactive[string.indexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 或 <paramref name="startIndex" /> 为负数。

- 或 -

 <paramref name="startIndex" /> 大于此字符串的长度。

- 或 -

 <paramref name="count" /> 大于此字符串的长度减 <paramref name="startIndex" />。</exception>
        <block subset="none" type="usage"><para>如 [使用字符串的最佳做法](/dotnet/standard/base-types/best-practices-strings)中所述，建议你避免调用替换默认值的字符串比较方法，并改为调用需要显式指定参数的方法。 若要使用当前区域性的比较规则来执行此操作，请使用的 <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> 参数的值调用方法重载 <see cref="F:System.StringComparison.CurrentCulture" /> `comparisonType` 。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要搜寻的字符串。</param>
        <param name="startIndex">搜索起始位置。</param>
        <param name="comparisonType">指定搜索规则的枚举值之一。</param>
        <summary>报告指定的字符串在当前 <see cref="T:System.String" /> 对象中的第一个匹配项的从零开始的索引。 参数指定当前字符串中的起始搜索位置以及用于指定字符串的搜索类型。</summary>
        <returns>如果找到该字符串，则为从当前实例的起始位置开始的从零开始的 <paramref name="value" /> 参数索引位置；否则为 -1。 如果 <paramref name="value" /> 为 <see cref="F:System.String.Empty" />，则返回值为 <paramref name="startIndex" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 索引编号从0开始。 `startIndex` 参数可以介于 0 到字符串实例的长度。 如果 `startIndex` 等于字符串实例的长度，则此方法返回-1。

 `comparisonType`参数指定 `value` 使用当前或固定区域性搜索参数，使用区分大小写或不区分大小写的搜索，以及使用 word 或序号比较规则。

## Examples
 下面的示例演示了方法的三个重载 <xref:System.String.IndexOf%2A> ，这些重载使用枚举的不同值在另一个字符串内查找字符串的第一个匹配项 <xref:System.StringComparison> 。

 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 小于 0（零）或大于此字符串的长度。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 在区分区域性的搜索 (即，如果 <paramref name="comparisonType" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果 <paramref name="value" /> 仅包含一个或多个可忽略字符，则该 <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> 方法将始终返回 <paramref name="startIndex" /> ，这是搜索开始处的字符位置。

在下面的示例中， <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> 方法用于查找软连字符 (U + 00AD 的位置) 后跟一个从两个字符串中的第三个字符位置开始的 "m"。 只有一个字符串包含必需的子字符串。 如果该示例在 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 或更高版本上运行，则在这两种情况下，因为软连字符是可忽略的字符，所以当执行区分区域性的比较时，该方法将返回字符串中的 "m" 的索引。 注意对于第一个字符串，包含软连字符后跟“m”，该方法无法返回该软连字符的索引，而是返回“m”的索引。 只有当此方法执行序号比较时，它才会在第一个字符串中返回软连字符的索引。

[！ code-csharp[IndexOf # 25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable25.cs#25)][！ code-vb[IndexOf # 25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable25.vb#25)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要搜寻的字符串。</param>
        <param name="startIndex">搜索起始位置。</param>
        <param name="count">要检查的字符位置数。</param>
        <param name="comparisonType">指定搜索规则的枚举值之一。</param>
        <summary>报告指定的字符串在当前 <see cref="T:System.String" /> 对象中的第一个匹配项的从零开始的索引。 参数指定当前字符串中的起始搜索位置、要搜索的当前字符串中的字符数量，以及要用于指定字符串的搜索类型。</summary>
        <returns>如果找到该字符串，则为从当前实例的起始位置开始的从零开始的 <paramref name="value" /> 参数索引位置；否则为 -1。 如果 <paramref name="value" /> 为 <see cref="F:System.String.Empty" />，则返回值为 <paramref name="startIndex" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 索引编号从 0 (零开始) 。 `startIndex` 参数可以介于 0 到字符串实例的长度。

 搜索从开始 `startIndex` ，并继续到 `startIndex`  +  `count` -1。 位于处的字符 `startIndex`  +  `count` 不包含在搜索中。

 `comparisonType`参数指定 `value` 使用当前或固定区域性搜索参数，使用区分大小写或不区分大小写的搜索，以及使用 word 或序号比较规则。

## Examples
 下面的示例演示了方法的三个重载 <xref:System.String.IndexOf%2A> ，这些重载使用枚举的不同值在另一个字符串内查找字符串的第一个匹配项 <xref:System.StringComparison> 。

 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 或 <paramref name="startIndex" /> 为负数。

- 或 -

 <paramref name="startIndex" /> 大于此实例的长度。

- 或 -

 <paramref name="count" /> 大于此字符串的长度减 <paramref name="startIndex" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 在区分区域性的搜索 (即，如果 <paramref name="comparisonType" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果 <paramref name="value" /> 仅包含一个或多个可忽略字符，则该 <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> 方法将始终返回 <paramref name="startIndex" /> ，这是搜索开始处的字符位置。

在下面的示例中， <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> 方法用于查找软连字符 (U + 00AD) 的位置，并在两个字符串中从第三个到第六个字符位置开始的 "m"。 只有一个字符串包含必需的子字符串。 如果该示例在 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 或更高版本上运行，则在这两种情况下，因为软连字符是可忽略的字符，所以当执行区分区域性的比较时，该方法将返回字符串中的 "m" 的索引。 但当它执行序号比较时，它只查找第一个字符串中的子字符串。 请注意，对于包含软连字符后跟 "m" 的软连字符的第一个字符串，该方法将无法返回软连字符的索引，而是在执行区分区域性的比较时返回 "m" 的索引。 只有当此方法执行序号比较时，它才会在第一个字符串中返回软连字符的索引。

[！ code-csharp[IndexOf # 24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable24.cs#24)][！ code-vb[IndexOf # 24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable24.vb#24)]</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>报告指定 Unicode 字符数组中的任意字符在此实例中第一个匹配项的索引。 如果未在此实例中找到数组中的字符，则此方法返回 -1。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] -&gt; int" Usage="string.IndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Unicode 字符数组，包含一个或多个要查找的字符。</param>
        <summary>报告指定 Unicode 字符数组中的任意字符在此实例中第一个匹配项的从零开始的索引。</summary>
        <returns>在此实例中第一次找到 <paramref name="anyOf" /> 中的任意字符的索引位置（从零开始）；如果未找到 <paramref name="anyOf" /> 中的字符，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 索引编号从0开始。

 的搜索 `anyOf` 区分大小写。 如果 `anyOf` 为空数组，该方法将在字符串的开头找到匹配项 (即索引零) 。

 此方法执行一个序号 (不区分区域性的) 搜索，其中，仅当字符的 Unicode 标量值相同时，才将其视为等效于另一个字符。 若要执行区分区域性的搜索，请使用 <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> 方法，其中表示预构成字符的 Unicode 标量值（如连字 "Æ" (U + 00C6) ）可能被视为等效于正确序列中任何字符的组成部分（例如 "AE" (U + 0041，u + 0045) ，具体取决于区域性）。

## Examples
 下面的示例查找字符串中的第一个元音。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Unicode 字符数组，包含一个或多个要查找的字符。</param>
        <param name="startIndex">搜索起始位置。</param>
        <summary>报告指定 Unicode 字符数组中的任意字符在此实例中第一个匹配项的从零开始的索引。 该搜索从指定字符位置开始。</summary>
        <returns>在此实例中第一次找到 <paramref name="anyOf" /> 中的任意字符的索引位置（从零开始）；如果未找到 <paramref name="anyOf" /> 中的字符，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 索引编号从0开始。 `startIndex`参数的范围可以介于0到字符串实例的长度之间。

 搜索范围从 `startIndex` 到字符串的末尾。

 的搜索 `anyOf` 区分大小写。

 此方法执行一个序号 (不区分区域性的) 搜索，其中，仅当字符的 Unicode 标量值相同时，才将其视为等效于另一个字符。 若要执行区分区域性的搜索，请使用 <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> 方法，其中表示预构成字符的 Unicode 标量值（如连字 "Æ" (U + 00C6) ）可能被视为等效于正确序列中任何字符的组成部分（例如 "AE" (U + 0041，u + 0045) ，具体取决于区域性）。

## Examples
 下面的示例查找字符串 "is" 在另一个字符串的子字符串中的匹配项的索引。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 为负数。

- 或 -

 <paramref name="startIndex" /> 大于此实例中的字符数。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Unicode 字符数组，包含一个或多个要查找的字符。</param>
        <param name="startIndex">搜索起始位置。</param>
        <param name="count">要检查的字符位置数。</param>
        <summary>报告指定 Unicode 字符数组中的任意字符在此实例中第一个匹配项的从零开始的索引。 搜索从指定字符位置开始，并检查指定数量的字符位置。</summary>
        <returns>在此实例中第一次找到 <paramref name="anyOf" /> 中的任意字符的索引位置（从零开始）；如果未找到 <paramref name="anyOf" /> 中的字符，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 搜索从开始 `startIndex` ，并继续到 `startIndex`  +  `count` -1。 位于处的字符 `startIndex`  +  `count` 不包含在搜索中。

 索引编号从0开始。 `startIndex`参数的范围可以介于0到字符串实例的长度之间。

 的搜索 `anyOf` 区分大小写。

 此方法执行一个序号 (不区分区域性的) 搜索，其中，仅当字符的 Unicode 标量值相同时，才将其视为等效于另一个字符。 若要执行区分区域性的搜索，请使用 <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> 方法，其中表示预构成字符的 Unicode 标量值（如连字 "Æ" (U + 00C6) ）可能被视为等效于正确序列中任何字符的组成部分（例如 "AE" (U + 0041，u + 0045) ，具体取决于区域性）。

## Examples
 下面的示例查找字符串 "辅助" 的任何字符在另一个字符串的子字符串中的匹配项的索引。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 或 <paramref name="startIndex" /> 为负数。

- 或 -

 <paramref name="count" /> + <paramref name="startIndex" /> 大于此实例中的字符数。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (startIndex As Integer, value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Insert(int startIndex, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; string" Usage="string.Insert (startIndex, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex">插入的从零开始的索引位置。</param>
        <param name="value">要插入的字符串。</param>
        <summary>返回一个新的字符串，在此实例中的指定的索引位置插入指定的字符串。</summary>
        <returns>与此实例等效的一个新字符串，但在该字符串的 <paramref name="value" /> 位置处插入了 <paramref name="startIndex" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果 `startIndex` 等于此实例的长度， `value` 则将追加到此实例的末尾。

> [!NOTE]
> 此方法不会修改当前实例的值。 相反，它会返回一个新字符串， `value` 并将其插入到当前实例中。

 例如，返回值 `"abc".Insert(2, "XYZ")` 为 "abXYZc"。

## Examples
 下面的示例在字符串的索引 3) 的字符 (的第四个字符位置插入一个空格字符。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb" id="Snippet1":::

 以下控制台应用程序将提示用户输入一个或多个形容词来描述两个动物。 然后，它调用 <xref:System.String.Insert%2A> 方法将用户输入的文本插入到字符串中。

 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 为负数或大于此实例的长度。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Intern (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Intern(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Intern : string -&gt; string" Usage="System.string.Intern str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="str">要在暂存池中搜索的字符串。</param>
        <summary>检索系统对指定 <see cref="T:System.String" /> 的引用。</summary>
        <returns>如果暂存了 <paramref name="str" />，则返回系统对其的引用；否则返回对值为 <paramref name="str" /> 的字符串的新引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 公共语言运行时通过维护名为拘留池的表来节省字符串存储，该表包含对程序中以编程方式声明或创建的每个唯一文本字符串的单个引用。 因此，系统中仅存在一个具有特定值的文本字符串的实例。

 例如，如果将相同的文本字符串分配给几个变量，则运行时将从暂存池中检索到文本字符串的相同引用，并将其分配给每个变量。

 <xref:System.String.Intern%2A>方法使用拘留池搜索等于值的字符串 `str` 。 如果存在这样的字符串，则返回暂存池中的引用。 如果该字符串不存在，则会将对的引用 `str` 添加到拘留池中，然后返回该引用。

 在下面的示例中，已暂存值为 "MyTest" 的字符串 s1，因为它是程序中的文本。 <xref:System.Text.StringBuilder?displayProperty=nameWithType>类将生成一个与 s1 具有相同值的新字符串对象。 对该字符串的引用将分配给 s2。 <xref:System.String.Intern%2A>方法搜索与 s2 具有相同值的字符串。 由于存在这样的字符串，因此该方法将返回分配给 s1 的相同引用。 然后，将该引用分配给 s3。 引用 s1 和 s2 比较不相等，因为它们引用不同的对象;引用 s1 和 s3 比较相等，因为它们引用相同的字符串。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb" id="Snippet1":::

 将此方法与方法进行比较 <xref:System.String.IsInterned%2A> 。

## <a name="version-considerations"></a>版本注意事项

 在中 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] ， <xref:System.String.Intern%2A> 方法将恢复为其在 .NET Framework 1.0 和1.1 中的行为，并在其中包含空字符串。 在下面的示例中，为变量 `str1` 赋值 <xref:System.String.Empty?displayProperty=nameWithtype> ，并 `str2` <xref:System.String.Empty?displayProperty=nameWithtype> 通过 <xref:System.String.Intern%2A> 在将值为的对象转换为字符串后调用方法，将对的引用分配给该变量 <xref:System.Text.StringBuilder> <xref:System.String.Empty?displayProperty=nameWithtype> 。 然后，比较和中包含的引用是否 `str1` `str2` 相等。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb" id="Snippet2":::

 在 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] 和中 [!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)] ， `str1` 和 `str2` 不相等。 在所有其他版本中， `str1` 和 `str2` 相等。

## <a name="performance-considerations"></a>性能注意事项
 如果尝试减少应用程序分配的内存总量，请记住，暂存字符串具有两个不需要的副作用。 首先，在 <xref:System.String> 公共语言运行时 (CLR) 终止之前，为暂存对象分配的内存不大可能被释放。 原因在于，在 <xref:System.String> 应用程序甚至应用程序域终止后，CLR 对暂存对象的引用可能会保持不变。 其次，若要暂存字符串，必须先创建字符串。 <xref:System.String>即使将最终回收内存，仍必须分配对象使用的内存。

<xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType>枚举成员将程序集标记为不需要字符串的暂留。 您可以 <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> 使用属性应用于程序集 <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> 。 此外，当你使用 [Ngen.exe (本机映像生成器) ](/dotnet/framework/tools/ngen-exe-native-image-generator) 以便在运行时提前编译程序集时，不会在模块之间暂存字符串。

## Examples
 下面的示例使用三个相同值的字符串来确定新创建的字符串和暂存的字符串是否相等。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.String.IsInterned(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string? IsInterned (string str);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInterned (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ IsInterned(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsInterned : string -&gt; string" Usage="System.string.IsInterned str" />
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="str">要在暂存池中搜索的字符串。</param>
        <summary>检索对指定 <see cref="T:System.String" /> 的引用。</summary>
        <returns>如果 <paramref name="str" /> 在公共语言运行时的暂存池中，则返回对它的引用；否则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 公共语言运行时自动维护一个名为拘留池的表，该表包含在程序中声明的每个唯一文本字符串常量的单个实例，以及 <xref:System.String> 通过调用方法以编程方式添加的任何唯一实例 <xref:System.String.Intern%2A> 。

 拘留池节省了字符串存储。 如果将文本字符串常量分配给几个变量，则每个变量将设置为引用拘留池中的相同常量，而不是引用具有相同值的多个不同实例 <xref:System.String> 。

 此方法查找 `str` 暂存池中的。 如果已 `str` 暂存，则返回对该实例的引用; 否则 `null` 返回。

 将此方法与方法进行比较 <xref:System.String.Intern%2A> 。

 此方法不返回布尔值。 如果调用方法，因为您需要一个指示是否暂存特定字符串的布尔值，则可以使用如下所示的代码。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb" id="Snippet1":::

> [!NOTE]
> 使用 [Ngen.exe (本机映像生成器) ](/dotnet/framework/tools/ngen-exe-native-image-generator) 将程序集安装到本地计算机上的本机映像缓存中时，可以重写拘留池的使用。 有关详细信息，请参阅 "备注" 部分中属性的性能注意事项 <xref:System.String.Intern%2A> 。

## Examples
 下面的示例演示了编译器自动暂存文本字符串。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.String.Intern(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指示此字符串是否符合特定的 Unicode 范式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的示例确定字符串是否已成功规范化为各种范式。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : unit -&gt; bool" Usage="string.IsNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>指示此字符串是否符合 Unicode 范式 C。</summary>
        <returns>如果此字符串符合范式 C，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 某些 Unicode 字符具有多个等效的二进制表示形式，其中包含组合和/或复合 Unicode 字符的集合。 单个字符存在多个表示形式会使搜索、排序、匹配和其他操作复杂化。

 Unicode 标准定义了一个名为规范化的进程，该进程在给定任何等效的二进制表示形式的字符时返回一个二进制表示形式。 可以通过多个算法（称为标准化形式）来执行规范化，它们遵循不同的规则。 .NET 当前支持范式 C、D、GLM-KC-QNW 和 KD。

 有关支持的 Unicode 范式的说明，请参阅 <xref:System.Text.NormalizationForm?displayProperty=nameWithType> 。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前实例包含无效的 Unicode 字符。</exception>
        <block subset="none" type="usage"><para>此 <see cref="Overload:System.String.IsNormalized" /> 方法 <see langword="false" /> 会在遇到字符串中第一个非规范化字符时立即返回。 因此，如果字符串包含非规范化字符后跟无效的 Unicode 字符，则该 <see cref="Overload:System.String.Normalize" /> 方法将引发， <see cref="T:System.ArgumentException" /> 但 <see cref="Overload:System.String.IsNormalized" /> 返回 <see langword="false" /> 。</para></block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized (normalizationForm As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : System.Text.NormalizationForm -&gt; bool" Usage="string.IsNormalized normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">一个 Unicode 范式。</param>
        <summary>指示此字符串是否符合指定的 Unicode 范式。</summary>
        <returns>如果此字符串符合由 <see langword="true" /> 参数指定的范式，则为 <paramref name="normalizationForm" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 某些 Unicode 字符具有多个等效的二进制表示形式，其中包含组合和/或复合 Unicode 字符的集合。 单个字符存在多个表示形式会使搜索、排序、匹配和其他操作复杂化。

 Unicode 标准定义了一个名为规范化的进程，该进程在给定任何等效的二进制表示形式的字符时返回一个二进制表示形式。 可以通过多个算法（称为标准化形式）来执行规范化，它们遵循不同的规则。 .NET 当前支持范式 C、D、GLM-KC-QNW 和 KD。

 有关支持的 Unicode 范式的说明，请参阅 <xref:System.Text.NormalizationForm?displayProperty=nameWithType> 。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前实例包含无效的 Unicode 字符。</exception>
        <block subset="none" type="usage"><para>此 <see cref="Overload:System.String.IsNormalized" /> 方法 <see langword="false" /> 会在遇到字符串中第一个非规范化字符时立即返回。 因此，如果字符串包含非规范化字符后跟无效的 Unicode 字符，则该 <see cref="Overload:System.String.Normalize" /> 方法将引发， <see cref="T:System.ArgumentException" /> 但 <see cref="Overload:System.String.IsNormalized" /> 返回 <see langword="false" /> 。</para></block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrEmpty (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrEmpty(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrEmpty : string -&gt; bool" Usage="System.string.IsNullOrEmpty value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要测试的字符串。</param>
        <summary>指示指定的字符串是 <see langword="null" /> 还是空字符串 ("")。</summary>
        <returns>如果 <see langword="true" /> 参数为 <paramref name="value" /> 或空字符串 ("")，则为 <see langword="null" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.String.IsNullOrEmpty%2A> 是一种便捷方法，使您能够同时测试 <xref:System.String> 是 `null` 还是其值为 <xref:System.String.Empty?displayProperty=nameWithType> 。 它等效于以下代码：

 [!code-cpp[System.String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp-interactive[System.String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]

 您可以使用 <xref:System.String.IsNullOrWhiteSpace%2A> 方法来测试字符串是否为 `null` ，其值为 <xref:System.String.Empty?displayProperty=nameWithType> ，或仅由空白字符组成。

## <a name="what-is-a-null-string"></a>什么是空字符串？

如果尚未为 `null` 它分配值 (c + + 和 Visual Basic) ，或者显式为其赋值，则为字符串 `null` 。 尽管 [复合格式设置](/dotnet/standard/base-types/composite-formatting) 功能可以适当地处理空字符串（如下面的示例所示），但如果其成员引发，则尝试调用它 <xref:System.NullReferenceException> 。

[!code-cpp[System.String.IsNullOrEmpty#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
[!code-csharp-interactive[System.String.IsNullOrEmpty#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
[!code-vb[System.String.IsNullOrEmpty#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]

## <a name="what-is-an-empty-string"></a>什么是空字符串？

如果字符串显式分配空字符串 ( "" ) 或，则为空字符串 <xref:System.String.Empty?displayProperty=nameWithType> 。 空字符串的为 <xref:System.String.Length%2A> 0。  下面的示例创建一个空字符串并显示其值和它的长度。

[!code-cpp[System.String.IsNullOrEmpty#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
[!code-csharp-interactive[System.String.IsNullOrEmpty#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
[!code-vb[System.String.IsNullOrEmpty#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]

## Examples
 下面的示例检查三个字符串，并确定每个字符串是否有值、是否为空字符串或是否为 `null` 。

 [!code-cpp[String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp-interactive[String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrWhiteSpace (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrWhiteSpace(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrWhiteSpace : string -&gt; bool" Usage="System.string.IsNullOrWhiteSpace value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要测试的字符串。</param>
        <summary>指示指定的字符串是 <see langword="null" />、空还是仅由空白字符组成。</summary>
        <returns>如果 <see langword="true" /> 参数为 <paramref name="value" /> 或 <see langword="null" />，或者如果 <see cref="F:System.String.Empty" /> 仅由空白字符组成，则为 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.String.IsNullOrWhiteSpace%2A> 是一种简便的方法，类似于以下代码，但它提供了优异的性能：

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb" id="Snippet2":::

 空白字符由 Unicode 标准定义。 <xref:System.String.IsNullOrWhiteSpace%2A>当将值 `true` 作为空白字符传递给方法时，该方法将解释返回值的任何字符 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 。

## Examples
 下面的示例创建一个字符串数组，然后将数组的每个元素传递给 <xref:System.String.IsNullOrWhiteSpace%2A> 方法。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>连接指定数组的元素或集合的成员，在每个元素或成员之间使用指定的分隔符。</summary>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[]? values);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[] values);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">要用作分隔符的字符。 只有在 <paramref name="separator" /> 具有多个元素时，<paramref name="value" /> 才包括在返回的字符串中。</param>
        <param name="values">将连接其字符串表示形式的对象数组。</param>
        <summary>连接对象数组的字符串表示形式，其中在每个成员之间使用指定的分隔符。</summary>
        <returns>一个由 <paramref name="values" /> 的元素组成的字符串，这些元素以 <paramref name="separator" /> 字符分隔。

- 或 -

如果 <paramref name="values" /> 包含零个元素或 <paramref name="values" /> 的所有元素都为 <see langword="null" />，则为 <see cref="F:System.String.Empty" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.OutOfMemoryException">生成的字符串长度超出了允许的最大长度 (<see cref="F:System.Int32.MaxValue" />)。</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[]? value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[] value);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="value" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">要用作分隔符的字符。 只有在 <paramref name="separator" /> 具有多个元素时，<paramref name="value" /> 才包括在返回的字符串中。</param>
        <param name="value">要连接的字符串数组。</param>
        <summary>连接字符串数组，其中在每个成员之间使用指定的分隔符。</summary>
        <returns>一个由 <paramref name="value" /> 的元素组成的字符串，这些元素以 <paramref name="separator" /> 字符分隔。

- 或 -

如果 <paramref name="value" /> 包含零个元素或 <paramref name="value" /> 的所有元素都为 <see langword="null" />，则为 <see cref="F:System.String.Empty" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.OutOfMemoryException">生成的字符串长度超出了允许的最大长度 (<see cref="F:System.Int32.MaxValue" />)。</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;string&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberSignature Language="C#" Value="public static string Join (string? separator, System.Collections.Generic.IEnumerable&lt;string&gt;? values);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">要用作分隔符的字符串。<paramref name="separator" /> 包括在返回的字符串中（只有在 <paramref name="values" /> 具有多个元素时）。</param>
        <param name="values">一个包含要串联的字符串的集合。</param>
        <summary>串联类型为 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 的 <see cref="T:System.String" /> 构造集合的成员，其中在每个成员之间使用指定的分隔符。</summary>
        <returns>一个由 <paramref name="values" /> 的成员组成的字符串，这些成员以 <paramref name="separator" /> 字符串分隔。

- 或 -

如果 <paramref name="values" /> 包含零个元素或 <paramref name="values" /> 的所有元素都为 <see langword="null" />，则为 <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果 `separator` 为 `null` ，则改为使用 () 的空字符串 <xref:System.String.Empty?displayProperty=nameWithType> 。 如果的任何成员 `values` 为 `null` ，则改为使用空字符串。

 <xref:System.String.Join(System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D)> 是一种简便方法，使您可以连接集合中的每个元素， `IEnumerable(Of String)` 而无需先将元素转换为字符串数组。 它对于 Language-Integrated 查询 (LINQ) 查询表达式特别有用。 下面的示例将 `List(Of String)` 包含字母表的大写或小写字母的对象传递给 lambda 表达式，该表达式选择等于或大于特定字母 (的字母，在本例中为 "M" ) 。 `IEnumerable(Of String)`方法返回的集合 <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> 传递给 <xref:System.String.Join(System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D)> 方法，以单个字符串的形式显示结果。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs" interactive="try-dotnet" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb" id="Snippet4":::

## Examples
 下面的示例使用埃拉托色 of 尼斯筛法算法来计算小于或等于100的质数。 它将结果分配给 <xref:System.Collections.Generic.List%601> 类型的对象，然后将该对象 <xref:System.String> 传递给 <xref:System.String.Join(System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D)> 方法。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb" id="Snippet3":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.OutOfMemoryException">生成的字符串长度超出了允许的最大长度 (<see cref="F:System.Int32.MaxValue" />)。</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params object[] values);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberSignature Language="C#" Value="public static string Join (string? separator, params object[]? values);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">要用作分隔符的字符串。 只有在 <paramref name="separator" /> 具有多个元素时，<paramref name="values" /> 才包括在返回的字符串中。</param>
        <param name="values">一个数组，其中包含要连接的元素。</param>
        <summary>串联对象数组的各个元素，其中在每个元素之间使用指定的分隔符。</summary>
        <returns>一个由 <paramref name="values" /> 的元素组成的字符串，这些元素以 <paramref name="separator" /> 字符串分隔。 如果 <paramref name="values" /> 为空数组，该方法将返回 <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果 `separator` 为 `null` ，或者第一个元素之外的任何元素 `values` 为 `null` ，则改为使用空字符串 (<xref:System.String.Empty?displayProperty=nameWithType>) 。 如果的第一个元素为，请参阅 "调用方的说明" 部分 `values` `null` 。

 <xref:System.String.Join(System.String%2CSystem.Object%5B%5D)> 是一种简便方法，使您可以连接对象数组中的每个元素，而无需将其元素显式转换为字符串。 数组中每个对象的字符串表示形式是通过调用该对象的方法派生的 `ToString` 。

## Examples
 下面的示例使用埃拉托色 of 尼斯筛法算法来计算小于或等于100的质数。 它将结果赋给一个整数数组，然后将其传递给 <xref:System.String.Join(System.String%2CSystem.Object%5B%5D)> 方法。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.OutOfMemoryException">生成的字符串长度超出了允许的最大长度 (<see cref="F:System.Int32.MaxValue" />)。</exception>
        <block subset="none" type="usage"><para>如果的第一个元素 <paramref name="values" /> 为 <see langword="null" /> ，则该 <see cref="M:System.String.Join(System.String,System.Object[])" /> 方法不会连接中的元素， <paramref name="values" /> 而是返回 <see cref="F:System.String.Empty" /> 。 此问题有多种解决方法。 最简单的方法是将值赋给 <see cref="F:System.String.Empty" /> 数组的第一个元素，如下面的示例所示。

[！ code-csharp-interactive[system.string # 6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)][！ code-vb[system.string # 6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</para></block>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params string[] value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray value As String()) As String" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ value);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberSignature Language="C#" Value="public static string Join (string? separator, params string[]? value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String()) As String" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">要用作分隔符的字符串。 只有在 <paramref name="separator" /> 具有多个元素时，<paramref name="value" /> 才包括在返回的字符串中。</param>
        <param name="value">一个数组，其中包含要连接的元素。</param>
        <summary>串联字符串数组的所有元素，其中在每个元素之间使用指定的分隔符。</summary>
        <returns>一个由 <paramref name="value" /> 中的元素组成的字符串，这些元素以 <paramref name="separator" /> 字符串分隔。 如果 <paramref name="value" /> 为空数组，该方法将返回 <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 例如，如果 `separator` 为 "，"，的元素为 `value` "apple"、"橙色"、"grape" 和 "梨"，则 `Join(separator, value)` 返回 "apple，橙色，grape，梨"。

 如果 `separator` 为 `null` ，则改为使用 () 的空字符串 <xref:System.String.Empty?displayProperty=nameWithType> 。 如果中的任何元素 `value` 为 `null` ，则改为使用空字符串。

## Examples
 下面的示例演示 <xref:System.String.Join%2A> 方法。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.OutOfMemoryException">生成的字符串长度超出了允许的最大长度 (<see cref="F:System.Int32.MaxValue" />)。</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[]? value, int startIndex, int count);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="value" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="separator">连接字符串数组，其中在每个成员之间使用指定的分隔符，并且从位于指定索引处的元素开始，并包含指定数量的元素。</param>
        <param name="value">要连接的字符串数组。</param>
        <param name="startIndex">要连接的 <paramref name="value" /> 中的第一个项。</param>
        <param name="count">要连接的 <paramref name="value" /> 中的元素数，从位于 <paramref name="startIndex" /> 位置的元素开始。</param>
        <summary>连接字符串数组，其中在每个成员之间使用指定的分隔符，并且从位于 <paramref name="startIndex" /> 位置的 <paramref name="value" /> 中的元素开始，并连接多达 <paramref name="count" /> 个元素。</summary>
        <returns>一个由 <paramref name="value" /> 的元素组成的字符串，这些元素以 <paramref name="separator" /> 字符分隔。

- 或 -

如果 <paramref name="count" /> 为零，<paramref name="value" /> 没有元素，或 <paramref name="value" /> 的全部元素均为 <see langword="null" /> 或 <see cref="F:System.String.Empty" />，则为 <see cref="F:System.String.Empty" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 或 <paramref name="count" /> 为负。

- 或 -

<paramref name="startIndex" /> 大于 <paramref name="value" /> 的长度   - <paramref name="count" />。</exception>
        <exception cref="T:System.OutOfMemoryException">生成的字符串长度超出了允许的最大长度 (<see cref="F:System.Int32.MaxValue" />)。</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberSignature Language="C#" Value="public static string Join (string? separator, string[]? value, int startIndex, int count);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">要用作分隔符的字符串。 只有在 <paramref name="separator" /> 具有多个元素时，<paramref name="value" /> 才包括在返回的字符串中。</param>
        <param name="value">一个数组，其中包含要连接的元素。</param>
        <param name="startIndex"><paramref name="value" /> 中要使用的第一个元素。</param>
        <param name="count">要使用的 <paramref name="value" /> 的元素数。</param>
        <summary>串联字符串数组的指定元素，其中在每个元素之间使用指定的分隔符。</summary>
        <returns>由 <paramref name="value" /> 中的字符串组成的字符串，这些字符串以 <paramref name="separator" /> 字符串分隔。

- 或 -

 如果 <see cref="F:System.String.Empty" /> 为零，<paramref name="count" /> 没有元素，或 <paramref name="value" /> 以及 <paramref name="separator" /> 的全部元素均为 <paramref name="value" />，则为 <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 例如，如果 `separator` 为 "，"，的元素为 `value` "apple"、"橙色"、"grape" 和 "梨"，则 `Join(separator, value, 1, 2)` 返回 "橙色，grape"。

 如果 `separator` 为 `null` ，则改为使用 () 的空字符串 <xref:System.String.Empty?displayProperty=nameWithType> 。 如果中的任何元素 `value` 为 `null` ，则改为使用空字符串。

## Examples
 下面的示例连接水果名称数组中的两个元素。

 [!code-cpp[string.join2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp-interactive[string.join2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 或 <paramref name="count" /> 小于 0。

- 或 -

<paramref name="startIndex" /> 加上 <paramref name="count" /> 大于 <paramref name="value" />中的元素数。</exception>
        <exception cref="T:System.OutOfMemoryException">内存不足。</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As Char, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><paramref name="values" /> 成员的类型。</typeparam>
        <param name="separator">要用作分隔符的字符。 只有在 <paramref name="separator" /> 具有多个元素时，<paramref name="values" /> 才包括在返回的字符串中。</param>
        <param name="values">一个包含要串联的对象的集合。</param>
        <summary>串联集合的成员，其中在每个成员之间使用指定的分隔符。</summary>
        <returns>一个由 <paramref name="values" /> 的成员组成的字符串，这些成员以 <paramref name="separator" /> 字符分隔。 如果 <paramref name="values" /> 没有成员，则该方法返回 <see cref="F:System.String.Empty" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.OutOfMemoryException">生成的字符串长度超出了允许的最大长度 (<see cref="F:System.Int32.MaxValue" />)。</exception>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As String, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string? separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><paramref name="values" /> 成员的类型。</typeparam>
        <param name="separator">要用作分隔符的字符串。 只有在 <paramref name="separator" /> 具有多个元素时，<paramref name="values" /> 才包括在返回的字符串中。</param>
        <param name="values">一个包含要串联的对象的集合。</param>
        <summary>串联集合的成员，其中在每个成员之间使用指定的分隔符。</summary>
        <returns>一个由 <paramref name="values" /> 的成员组成的字符串，这些成员以 <paramref name="separator" /> 字符串分隔。 如果 <paramref name="values" /> 没有成员，则该方法返回 <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果 `separator` 为 `null` ，则改为使用 () 的空字符串 <xref:System.String.Empty?displayProperty=nameWithType> 。 如果的任何成员 `values` 为 `null` ，则改为使用空字符串。

 <xref:System.String.Join%60%601(System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D)> 是一种简便方法，使您可以连接集合的每个成员， <xref:System.Collections.Generic.IEnumerable%601> 无需先将其转换为字符串。 集合中每个对象的字符串表示形式 <xref:System.Collections.Generic.IEnumerable%601> 都是通过调用该对象的 `ToString` 方法派生的。

 此方法对于 Language-Integrated 查询 (LINQ) 查询表达式特别有用。 例如，下面的代码定义了一个非常简单的 `Animal` 类，其中包含动物的名称及其所属的顺序。 然后，它定义 <xref:System.Collections.Generic.List%601> 包含多个对象的对象 `Animal` 。 <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>调用扩展方法以提取 `Animal` 其 `Order` 属性等于 "啮齿类" 的对象。 结果传递给 <xref:System.String.Join%60%601(System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D)> 方法。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs" interactive="try-dotnet" id="Snippet5":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb" id="Snippet5":::

## Examples
 下面的示例使用埃拉托色 of 尼斯筛法算法来计算小于或等于100的质数。 它将结果分配给 <xref:System.Collections.Generic.List%601> 类型为 integer 的对象，然后将该对象传递给 <xref:System.String.Join%60%601(System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D)> 方法。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb" id="Snippet2":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.OutOfMemoryException">生成的字符串长度超出了允许的最大长度 (<see cref="F:System.Int32.MaxValue" />)。</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>报告指定 Unicode 字符或字符串在此实例中的最后一个匹配项的从零开始的索引的位置。 如果未在此实例中找到该字符或字符串，则此方法返回 -1。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">要查找的 Unicode 字符。</param>
        <summary>报告指定 Unicode 字符在此实例中的最后一个匹配项的从零开始的索引的位置。</summary>
        <returns>如果找到该字符，则为 <paramref name="value" /> 的从零开始的索引位置；如果未找到，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 索引编号从0开始。 也就是说，字符串中的第一个字符位于索引零，最后一个字符为 <xref:System.String.Length%2A> -1。

 此方法从该实例的最后一个字符位置开始搜索，然后在 `value` 找到或检查了第一个字符位置之前，向后翻一层。 搜索区分大小写。

 此方法执行一个序号 (不区分区域性的) 搜索，其中，仅当字符的 Unicode 标量值相同时，才将其视为等效于另一个字符。 若要执行区分区域性的搜索，请使用 <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> 方法，其中表示预构成字符的 Unicode 标量值（如连字 "Æ" (U + 00C6) ）可能被视为等效于正确序列中任何字符的组成部分（例如 "AE" (U + 0041，u + 0045) ，具体取决于区域性）。

## Examples
 下面的示例定义了一个 `ExtractFilename` 方法，该方法使用 <xref:System.String.LastIndexOf(System.Char)> 方法查找字符串中的最后一个目录分隔符字符并提取字符串的文件名。 如果文件存在，则方法将返回文件名，而不返回其路径。

 [!code-csharp[System.String.LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要搜寻的字符串。</param>
        <summary>报告指定字符串在此实例中的最后一个匹配项的从零开始的索引的位置。</summary>
        <returns>如果找到该字符串，则为 <paramref name="value" /> 的从零开始的起始索引位置；如果未找到该字符串，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

索引编号从0开始。 也就是说，字符串中的第一个字符位于索引零，最后一个字符为 <xref:System.String.Length%2A> -1。

此搜索从该实例的最后一个字符位置开始，并在 `value` 找到或已检查第一个字符位置之前的某个时间开始向后滚动。

此方法使用当前区域性执行 (区分大小写和区分区域性的) 搜索。

字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 在区分区域性的搜索中，如果 `value` 包含一个可忽略字符，则结果与移除了该字符的搜索等效。

在下面的示例中， <xref:System.String.LastIndexOf%28System.String%29> 方法用于查找两个子字符串， (软连字符后跟 "n"，软连字符后跟 "m" ) 在两个字符串中。 只有一个字符串包含软连字符。 如果该示例在 .NET Framework 4 或更高版本上运行，则在每种情况下，因为软连字符是可忽略字符，则结果与软连字符不在中的情况相同 `value` 。

 [!code-csharp[System.String.LastIndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]

## Examples
 下面的示例在标记开始和结束字符串时，删除字符串中的开始和关闭 HTML 标记。 如果字符串以右括号字符结尾 ( ">" ) ，则该示例使用 <xref:System.String.LastIndexOf%2A> 方法来查找结束标记的开头。

 [!code-csharp[System.String.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>如 [使用字符串的最佳做法](/dotnet/standard/base-types/best-practices-strings)中所述，建议你避免调用替换默认值的字符串比较方法，并改为调用需要显式指定参数的方法。 若要通过使用当前区域性的比较规则查找字符串实例内子字符串的最后一个索引，请使用的 <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> 参数的值调用方法重载 <see cref="F:System.StringComparison.CurrentCulture" /> <paramref name="comparisonType" /> 。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要查找的 Unicode 字符。</param>
        <param name="startIndex">搜索的起始位置。 从 <paramref name="startIndex" /> 此实例的开头开始搜索。</param>
        <summary>报告指定 Unicode 字符在此实例中的最后一个匹配项的从零开始的索引的位置。 在指定的字符位置开始和在向后的右边该字符串的开头处理的搜索。</summary>
        <returns>如果找到该字符，则为 <paramref name="value" /> 的从零开始的索引位置；如果未找到该字符或当前实例等于 <see cref="F:System.String.Empty" />，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 索引编号从0开始。 也就是说，字符串中的第一个字符位于索引零，最后一个字符为 <xref:System.String.Length%2A> -1。 此方法开始搜索 `startIndex` 此实例的字符位置，并沿当前实例的开头向后移动，直到 `value` 找到或已检查第一个字符位置。 例如，如果 `startIndex` 为 <xref:System.String.Length%2A> -1，则方法会搜索字符串中最后一个字符的每个字符。 搜索区分大小写。

 此方法执行一个序号 (不区分区域性的) 搜索，其中，仅当字符的 Unicode 标量值相同时，才将其视为等效于另一个字符。 若要执行区分区域性的搜索，请使用 <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> 方法，其中表示预构成字符的 Unicode 标量值（如连字 "Æ" (U + 00C6) ）可能被视为等效于正确序列中任何字符的组成部分（例如 "AE" (U + 0041，u + 0045) ，具体取决于区域性）。

## Examples
 下面的示例查找字符串中出现的所有字符的索引，该索引从字符串的末尾到字符串的开头。

 [!code-cpp[string.lastindexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 小于零或大于等于当前实例的长度。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要搜寻的字符串。</param>
        <param name="startIndex">搜索起始位置。 从 <paramref name="startIndex" /> 此实例的开头开始搜索。</param>
        <summary>报告指定字符串在此实例中的最后一个匹配项的从零开始的索引的位置。 在指定的字符位置开始和在向后的右边该字符串的开头处理的搜索。</summary>
        <returns>如果找到该字符串，则为 <paramref name="value" /> 的从零开始的起始索引位置；如果未找到该字符串或当前实例等于 <see cref="F:System.String.Empty" />，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 索引编号从0开始。 也就是说，字符串中的第一个字符位于索引零，最后一个字符为 <xref:System.String.Length%2A> -1。

 此搜索从 `startIndex` 该实例的字符位置开始，并在 `value` 找到或已检查第一个字符位置之前向后继续。 例如，如果 `startIndex` 为 <xref:System.String.Length%2A> -1，则方法会搜索字符串中最后一个字符的每个字符。

 此方法使用当前区域性执行 (区分大小写和区分区域性的) 搜索。

 字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 在区分区域性的搜索中，如果 `value` 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 在下面的示例中， <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> 方法用于查找子字符串，其中包含软连字符 (U + 00AD) ，并在字符串前面或包含最后的 "m"。 如果该示例在 .NET Framework 4 或更高版本上运行，则将忽略搜索字符串中的软连字符，调用方法以查找由软连字符和 "m" 组成的子字符串，并将 "m" 的位置返回到字符串中，而调用该方法可查找包含软连字符的子字符串，"n" 将返回 "n" 的位置。

 [!code-csharp[System.String.LastIndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]

## Examples
 下面的示例查找目标字符串中字符串的所有匹配项的索引，从目标字符串的末尾到目标字符串的开头。

 [!code-cpp[string.lastindexof7#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 小于零或大于当前实例的长度。

- 或 -

当前实例等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 小于-1 或大于零。</exception>
        <block subset="none" type="usage"><para>如 [使用字符串的最佳做法](/dotnet/standard/base-types/best-practices-strings)中所述，建议你避免调用替换默认值的字符串比较方法，并改为调用需要显式指定参数的方法。 若要通过使用当前区域性的比较规则查找特定字符位置之前的子字符串的索引，请使用 <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> 其参数的值调用方法重载 <see cref="F:System.StringComparison.CurrentCulture" /> <paramref name="comparisonType" /> 。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * StringComparison -&gt; int" Usage="string.LastIndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要搜寻的字符串。</param>
        <param name="comparisonType">指定搜索规则的枚举值之一。</param>
        <summary>报告指定字符串在当前 <see cref="T:System.String" /> 对象中最后一个匹配项的从零开始的索引。 一个参数指定要用于指定字符串的搜索类型。</summary>
        <returns>如果找到该字符串，则为 <paramref name="value" /> 参数的从零开始的起始索引位置；如果未找到该字符串，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

索引编号从0开始。 也就是说，字符串中的第一个字符位于索引零，最后一个字符为 <xref:System.String.Length%2A> -1。

`comparisonType`参数指定 `value` 使用以下内容搜索参数：

- 当前区域性或固定区域性。
- 区分大小写或不区分大小写的搜索。
- 字词比较规则或序号比较规则。

此搜索从该实例的最后一个字符位置开始，并在 `value` 找到或已检查第一个字符位置之前的某个时间开始向后滚动。

## Examples
 下面的示例演示了方法的三个重载 <xref:System.String.LastIndexOf%2A> ，这些重载使用枚举的不同值在另一个字符串内查找字符串的最后一个匹配项 <xref:System.StringComparison> 。

 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 在区分区域性的搜索 (即，如果 <paramref name="options" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。

在下面的示例中， <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> 方法用于查找两个子字符串 (软连字符后跟 "n"，软连字符后跟 "m" ) 在两个字符串中。 只有一个字符串包含软连字符。 如果该示例在 .NET Framework 4 或更高版本上运行，因为软连字符是可忽略的字符，所以区分区域性的搜索返回的值与在搜索字符串中未包含软连字符时返回的值相同。 不过，序号搜索成功地在一个字符串中查找软连字符，并报告从第二个字符串中缺少它。

[！ code-csharp[LastIndexOf # 26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof26.cs#26)][！ code-vb[LastIndexOf # 26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof26.vb#26)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要查找的 Unicode 字符。</param>
        <param name="startIndex">搜索的起始位置。 从 <paramref name="startIndex" /> 此实例的开头开始搜索。</param>
        <param name="count">要检查的字符位置数。</param>
        <summary>报告指定的 Unicode 字符在此实例内的子字符串中的最后一个匹配项的从零开始的索引的位置。 搜索在指定字符位置的数目的字符串开始时，开始指定字符和其后面的位置。</summary>
        <returns>如果找到该字符，则为 <paramref name="value" /> 的从零开始的索引位置；如果未找到该字符或当前实例等于 <see cref="F:System.String.Empty" />，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 索引编号从0开始。 也就是说，字符串中的第一个字符位于索引零，最后一个字符为 <xref:System.String.Length%2A> -1。

 此方法从 `startIndex` 字符位置开始搜索，并沿此实例的开头向后移动，直到 `value` 找到了或已检查了个 `count` 字符位置。 例如，如果 `startIndex` 为 <xref:System.String.Length%2A> -1，则该方法将在 `count` 字符串的最后一个字符中搜索向后字符。 搜索区分大小写。

 此方法执行一个序号 (不区分区域性的) 搜索，其中，仅当字符的 Unicode 标量值相同时，才将其视为等效于另一个字符。 若要执行区分区域性的搜索，请使用 <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> 方法，其中表示预构成字符的 Unicode 标量值（如连字 "Æ" (U + 00C6) ）可能被视为等效于正确序列中任何字符的组成部分（例如 "AE" (U + 0041，u + 0045) ，具体取决于区域性）。

## Examples
 下面的示例查找子字符串中某个字符的所有匹配项的索引，该索引从子字符串的末尾到子字符串的开头。

 [!code-cpp[string.lastindexof2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 小于零或大于等于当前实例的长度。

- 或 -

当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> - <paramref name="count" /> + 1 小于零。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要搜寻的字符串。</param>
        <param name="startIndex">搜索起始位置。 从 <paramref name="startIndex" /> 此实例的开头开始搜索。</param>
        <param name="count">要检查的字符位置数。</param>
        <summary>报告指定字符串在此实例中的最后一个匹配项的从零开始的索引的位置。 搜索在指定字符位置的数目的字符串开始时，开始指定字符和其后面的位置。</summary>
        <returns>如果找到该字符串，则为 <paramref name="value" /> 的从零开始的起始索引位置；如果未找到该字符串或当前实例等于 <see cref="F:System.String.Empty" />，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 索引编号从0开始。 也就是说，字符串中的第一个字符位于索引零，最后一个字符为 <xref:System.String.Length%2A> -1。

 此搜索从 `startIndex` 该实例的字符位置开始，并在找到或已检查了个 `value` 字符位置之前向后继续 `count` 。 例如，如果 `startIndex` 为 <xref:System.String.Length%2A> -1，则该方法将在 `count` 字符串的最后一个字符中搜索向后字符。

 此方法使用当前区域性执行 (区分大小写和区分区域性的) 搜索。

 字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 在区分区域性的搜索中，如果 `value` 包含一个可忽略字符，则结果与移除了该字符的搜索等效。

在下面的示例中， <xref:System.String.LastIndexOf%2A> 方法用于查找软连字符 (U + 00AD 的位置) 后跟两个字符串中的 "m" 或 "n"。 只有一个字符串包含软连字符。 如果包含软连字符后跟 "m" 的字符串，则在 `LastIndexOf` 搜索软连字符后跟 "m" 时，将返回 "m" 的索引。

 [!code-csharp[System.String.LastIndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]

## Examples
 下面的示例查找子字符串中字符串的所有匹配项的索引（从子字符串的末尾到子字符串的开头）。

 [!code-cpp[string.lastindexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 为负数。

- 或 -

当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 为负数。

- 或 -

当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 大于此实例的长度。

- 或 -

当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> - <paramref name="count" /> + 1 指定不在此实例内的位置。

- 或 -

当前实例等于 <see cref="F:System.String.Empty" /> 并且 <paramref name="start" /> 小于 -1 或大于零。

- 或 -

当前实例等于 <see cref="F:System.String.Empty" /> 并且 <paramref name="count" /> 大于 1。</exception>
        <block subset="none" type="usage"><para>如 [使用字符串的最佳做法](/dotnet/standard/base-types/best-practices-strings)中所述，建议你避免调用替换默认值的字符串比较方法，并改为调用需要显式指定参数的方法。 若要通过使用当前区域性的比较规则来执行此操作，请使用的 <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> 参数的值调用方法重载 <see cref="F:System.StringComparison.CurrentCulture" /> <paramref name="comparisonType" /> 。</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要搜寻的字符串。</param>
        <param name="startIndex">搜索起始位置。 从 <paramref name="startIndex" /> 此实例的开头开始搜索。</param>
        <param name="comparisonType">指定搜索规则的枚举值之一。</param>
        <summary>报告指定字符串在当前 <see cref="T:System.String" /> 对象中最后一个匹配项的从零开始的索引。 在指定的字符位置开始和在向后的右边该字符串的开头处理的搜索。 一个参数指定要执行搜索指定字符串的比较类型。</summary>
        <returns>如果找到该字符串，则为 <paramref name="value" /> 参数的从零开始的起始索引位置；如果未找到该字符串或当前实例等于 <see cref="F:System.String.Empty" />，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 索引编号从0开始。 也就是说，字符串中的第一个字符位于索引零，最后一个字符为 <xref:System.String.Length%2A> -1。

 搜索从 `startIndex` 字符位置开始，一直向后移动，直到 `value` 找到或已检查第一个字符位置。 例如，如果 `startIndex` 为 <xref:System.String.Length%2A> -1，则方法会搜索字符串中最后一个字符的每个字符。

 `comparisonType`参数指定 `value` 使用当前或固定区域性搜索参数，使用区分大小写或不区分大小写的搜索，以及使用 word 或序号比较规则。

## Examples
 下面的示例演示了方法的三个重载 <xref:System.String.LastIndexOf%2A> ，这些重载使用枚举的不同值在另一个字符串内查找字符串的最后一个匹配项 <xref:System.StringComparison> 。

 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 小于零或大于当前实例的长度。

- 或 -

当前实例等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 小于-1 或大于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 在区分区域性的搜索 (即，如果 <paramref name="comparisonType" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。

在下面的示例中， <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> 方法用于查找软连字符 (U + 00AD 的位置) 后跟 "m"，从两个字符串中的最后一个 "m" 开始。 只有一个字符串包含必需的子字符串。 如果在这两种情况下，该示例在 .NET Framework 4 或更高版本上运行，则在这两种情况下，因为软连字符为可忽略字符，所以当执行区分区域性的比较时，该方法将返回字符串中的 "m" 的索引。 请注意，对于包含软连字符后跟 "m" 的软连字符的第一个字符串，该方法返回 "m" 的索引，而不是软连字符的索引。 只有当此方法执行序号比较时，它才会在第一个字符串中返回软连字符的索引。

[！ code-csharp[LastIndexOf # 25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof25.cs#25)][！ code-vb[LastIndexOf # 25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof25.vb#25)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要搜寻的字符串。</param>
        <param name="startIndex">搜索起始位置。 从 <paramref name="startIndex" /> 此实例的开头开始搜索。</param>
        <param name="count">要检查的字符位置数。</param>
        <param name="comparisonType">指定搜索规则的枚举值之一。</param>
        <summary>报告指定字符串在此实例中的最后一个匹配项的从零开始的索引的位置。 搜索在所指定的字符位置的数目的字符串开始时，开始指定字符和其后面的位置。 一个参数指定要执行搜索指定字符串的比较类型。</summary>
        <returns>如果找到该字符串，则为 <paramref name="value" /> 参数的从零开始的起始索引位置；如果未找到该字符串或当前实例等于 <see cref="F:System.String.Empty" />，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 索引编号从0开始。 也就是说，字符串中的第一个字符位于索引零，最后一个字符为 <xref:System.String.Length%2A> -1。

 搜索从 `startIndex` 字符位置开始，一直向后移动，直到 `value` 找到或检查了个 `count` 字符位置。 例如，如果 `startIndex` 为 <xref:System.String.Length%2A> -1，则该方法将在 `count` 字符串的最后一个字符中搜索向后字符。

 `comparisonType`参数指定 `value` 使用以下内容搜索参数：

- 当前区域性或固定区域性。
- 区分大小写或不区分大小写的搜索。
- 字词比较规则或序号比较规则。

## Examples
 下面的示例演示了方法的三个重载 <xref:System.String.LastIndexOf%2A> ，这些重载使用枚举的不同值在另一个字符串内查找字符串的最后一个匹配项 <xref:System.StringComparison> 。

 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 为负数。

- 或 -

当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 为负数。

- 或 -

当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 大于此实例的长度。

- 或 -

当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> + 1 - <paramref name="count" /> 指定不在此实例内的位置。

- 或 -

当前实例等于 <see cref="F:System.String.Empty" /> 并且 <paramref name="start" /> 小于 -1 或大于零。

- 或 -

当前实例等于 <see cref="F:System.String.Empty" /> 并且 <paramref name="count" /> 大于 1。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 在区分区域性的搜索 (即，如果 <paramref name="comparisonType" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。

在下面的示例中， <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> 方法用于查找软连字符 (U + 00AD 的位置) 后跟一个 "m"，但在两个字符串中的最后一个字符位置之前的第一个字符位置。 只有一个字符串包含必需的子字符串。 如果在这两种情况下，该示例在 .NET Framework 4 或更高版本上运行，则在这两种情况下，因为软连字符为可忽略字符，所以当执行区分区域性的比较时，该方法将返回字符串中的 "m" 的索引。 但当它执行序号比较时，它只查找第一个字符串中的子字符串。 请注意，对于包含软连字符后跟 "m" 的软连字符的第一个字符串，该方法在执行区分区域性的比较时返回 "m" 的索引。 只有当此方法执行序号比较时，它才会在第一个字符串中返回软连字符的索引。

[！ code-csharp[LastIndexOf # 24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof24.cs#24)][！ code-vb[LastIndexOf # 24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof24.vb#24)]</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>报告在 Unicode 数组中指定的一个或多个字符在此实例中的最后一个匹配项的从零开始的索引的位置。 如果未在此实例中找到数组中的字符，则此方法返回 -1。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] -&gt; int" Usage="string.LastIndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Unicode 字符数组，包含一个或多个要查找的字符。</param>
        <summary>报告在 Unicode 数组中指定的一个或多个字符在此实例中的最后一个匹配项的从零开始的索引的位置。</summary>
        <returns>最后一次在此实例中找到 <paramref name="anyOf" /> 中的任意字符的索引位置；如果未找到 <paramref name="anyOf" /> 中的字符，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 索引编号从0开始。

 此方法从该实例的最后一个字符位置开始搜索，并在开始时向后继续，直到找到中的字符 `anyOf` 或检查了第一个字符位置。 搜索区分大小写。

 此方法执行一个序号 (不区分区域性的) 搜索，其中，仅当字符的 Unicode 标量值相同时，才将其视为等效于另一个字符。 若要执行区分区域性的搜索，请使用 <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> 方法，其中表示预构成字符的 Unicode 标量值（如连字 "Æ" (U + 00C6) ）可能被视为等效于正确序列中任何字符的组成部分（例如 "AE" (U + 0041，u + 0045) ，具体取决于区域性）。

## Examples
 下面的示例查找字符串 "is" 中的任何字符在另一个字符串中的最后一个匹配项的索引。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Unicode 字符数组，包含一个或多个要查找的字符。</param>
        <param name="startIndex">搜索起始位置。 从 <paramref name="startIndex" /> 此实例的开头开始搜索。</param>
        <summary>报告在 Unicode 数组中指定的一个或多个字符在此实例中的最后一个匹配项的从零开始的索引的位置。 在指定的字符位置开始和在向后的右边该字符串的开头处理的搜索。</summary>
        <returns>最后一次在此实例中找到 <paramref name="anyOf" /> 中的任意字符的索引位置；如果未找到 <paramref name="anyOf" /> 中的字符或者当前实例等于<see cref="F:System.String.Empty" />，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 索引编号从0开始。

 此方法从 `startIndex` 该实例的字符位置开始搜索，并在开始时向后移动，直到找到中的字符 `anyOf` 或检查了第一个字符位置。 搜索区分大小写。

 此方法执行一个序号 (不区分区域性的) 搜索，其中，仅当字符的 Unicode 标量值相同时，才将其视为等效于另一个字符。 若要执行区分区域性的搜索，请使用 <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> 方法，其中表示预构成字符的 Unicode 标量值（如连字 "Æ" (U + 00C6) ）可能被视为等效于正确序列中任何字符的组成部分（例如 "AE" (U + 0041，u + 0045) ，具体取决于区域性）。

## Examples
 下面的示例查找字符串 "is" 中任何字符的最后一个匹配项的索引，该字符串位于另一个字符串的子字符串中。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 指定不在此实例内的位置。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Unicode 字符数组，包含一个或多个要查找的字符。</param>
        <param name="startIndex">搜索起始位置。 从 <paramref name="startIndex" /> 此实例的开头开始搜索。</param>
        <param name="count">要检查的字符位置数。</param>
        <summary>报告在 Unicode 数组中指定的一个或多个字符在此实例中的最后一个匹配项的从零开始的索引的位置。 搜索在指定字符位置的数目的字符串开始时，开始指定字符和其后面的位置。</summary>
        <returns>最后一次在此实例中找到 <paramref name="anyOf" /> 中的任意字符的索引位置；如果未找到 <paramref name="anyOf" /> 中的字符或者当前实例等于<see cref="F:System.String.Empty" />，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 索引编号从0开始。

 此方法从 `startIndex` 该实例的字符位置开始搜索，并在开始时向后移动，直到找到了中的一个字符 `anyOf` 或 `count` 已检查了个字符位置。 搜索区分大小写。

 此方法执行一个序号 (不区分区域性的) 搜索，其中，仅当字符的 Unicode 标量值相同时，才将其视为等效于另一个字符。 若要执行区分区域性的搜索，请使用 <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> 方法，其中表示预构成字符的 Unicode 标量值（如连字 "Æ" (U + 00C6) ）可能被视为等效于正确序列中任何字符的组成部分（例如 "AE" (U + 0041，u + 0045) ，具体取决于区域性）。

## Examples
 下面的示例查找字符串 "帮助" 中的任意字符在另一个字符串的子字符串中的最后一个匹配项的索引。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="count" /> 或 <paramref name="startIndex" /> 为负数。

- 或 -

当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 减去 <paramref name="count" /> 再加 1 小于零。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.string.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前 <see cref="T:System.String" /> 对象中的字符数。</summary>
        <value>当前字符串中字符的数量。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.String.Length%2A>属性返回 <xref:System.Char> 此实例中的对象数，而不是 Unicode 字符数。 原因是 Unicode 字符可能由多个表示 <xref:System.Char> 。 使用 <xref:System.Globalization.StringInfo?displayProperty=nameWithType> 类来处理每个 Unicode 字符，而不是每个 Unicode 字符 <xref:System.Char> 。

 在某些语言（如 C 和 c + +）中，空字符表示字符串的末尾。 在 .NET 中，可以在字符串中嵌入空字符。 如果字符串中包含一个或多个 null 字符，则它们将包含在总字符串的长度中。 例如，在下面的字符串中，子字符串 "abc" 和 "def" 由 null 字符分隔。 <xref:System.String.Length%2A>属性返回7，这表示它包含六个字母字符以及 null 字符。

 [!code-cpp[System.String.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp-interactive[System.String.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]

## Examples
 下面的示例演示了 <xref:System.String.Length%2A> 属性。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Normalize">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个新字符串，其二进制表示形式符合特定的 Unicode 范式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的示例将一个字符串规范化为四个范式中的每一个，确认该字符串已规范化为指定范式，然后列出规范化字符串中的码位。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize();" />
      <MemberSignature Language="F#" Value="member this.Normalize : unit -&gt; string" Usage="string.Normalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个新字符串，其文本值与此字符串相同，但其二进制表示形式符合 Unicode 范式 C。</summary>
        <returns>一个新的规范化字符串，其文本值与此字符串相同，但其二进制表示形式符合范式 C。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 某些 Unicode 字符具有多个等效的二进制表示形式，其中包含组合和/或复合 Unicode 字符的集合。 例如，以下任何代码点都可以表示字母 "ắ"：

- U + 1EAF

- U + 0103 U + 0301

- U + 0061 U + 0306 U + 0301

 单个字符存在多个表示形式会使搜索、排序、匹配和其他操作复杂化。

 Unicode 标准定义了一个名为规范化的进程，该进程在给定任何等效的二进制表示形式的字符时返回一个二进制表示形式。 可以通过多个算法（称为标准化形式）来执行规范化，它们遵循不同的规则。 .NET 支持由 Unicode 标准定义的四种范式 (C、D、GLM-KC-QNW 和 KD) 。 如果两个字符串用同一范式表示，则可以使用序号比较对它们进行比较。

 若要规范化和比较两个字符串，请执行以下操作：

1.  获取要从输入源（如文件或用户输入设备）进行比较的字符串。

2.  调用 <xref:System.String.Normalize> 方法以将字符串规范化为范式 C。

3.  若要比较两个字符串，请调用支持序号字符串比较的方法，如 <xref:System.String.Compare(System.String%2CSystem.String%2CSystem.StringComparison)> 方法，并将或的值 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 作为参数提供 <xref:System.StringComparison> 。 若要对规范化字符串数组进行排序，请将 `comparer` 或的值传递给的 <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> 适当重载 <xref:System.Array.Sort%2A?displayProperty=nameWithType> 。

4.  根据上一步指示的顺序，在已排序的输出中发出字符串。

 有关支持的 Unicode 范式的说明，请参阅 <xref:System.Text.NormalizationForm?displayProperty=nameWithType> 。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前实例包含无效的 Unicode 字符。</exception>
        <block subset="none" type="usage"><para>此 <see cref="Overload:System.String.IsNormalized" /> 方法 <see langword="false" /> 会在遇到字符串中第一个非规范化字符时立即返回。 因此，如果字符串包含非规范化字符后跟无效的 Unicode 字符，则该 <see cref="Overload:System.String.Normalize" /> 方法将引发， <see cref="T:System.ArgumentException" /> 但 <see cref="Overload:System.String.IsNormalized" /> 返回 <see langword="false" /> 。</para></block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize (normalizationForm As NormalizationForm) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.Normalize : System.Text.NormalizationForm -&gt; string" Usage="string.Normalize normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">一个 Unicode 范式。</param>
        <summary>返回一个新字符串，其文本值与此字符串相同，但其二进制表示形式符合指定的 Unicode 范式。</summary>
        <returns>一个新字符串，其文本值与此字符串相同，但其二进制表示形式符合由 <paramref name="normalizationForm" /> 参数指定的范式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 某些 Unicode 字符具有多个等效的二进制表示形式，其中包含组合和/或复合 Unicode 字符的集合。 单个字符存在多个表示形式会使搜索、排序、匹配和其他操作复杂化。

 Unicode 标准定义了一个名为规范化的进程，该进程在给定任何等效的二进制表示形式的字符时返回一个二进制表示形式。 可以通过多个算法（称为标准化形式）来执行规范化，它们遵循不同的规则。 .NET 支持由 Unicode 标准定义的四种范式 (C、D、GLM-KC-QNW 和 KD) 。 如果两个字符串用同一范式表示，则可以使用序号比较对它们进行比较。

 若要规范化和比较两个字符串，请执行以下操作：

1.  获取要从输入源（如文件或用户输入设备）进行比较的字符串。

2.  调用 <xref:System.String.Normalize(System.Text.NormalizationForm)> 方法以将字符串规范化为指定的范式。

3.  若要比较两个字符串，请调用支持序号字符串比较的方法，如 <xref:System.String.Compare(System.String%2CSystem.String%2CSystem.StringComparison)> 方法，并将或的值 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 作为参数提供 <xref:System.StringComparison> 。 若要对规范化字符串数组进行排序，请将 `comparer` 或的值传递给的 <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> 适当重载 <xref:System.Array.Sort%2A?displayProperty=nameWithType> 。

4.  根据上一步指示的顺序，在已排序的输出中发出字符串。

 有关支持的 Unicode 范式的说明，请参阅 <xref:System.Text.NormalizationForm?displayProperty=nameWithType> 。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前实例包含无效的 Unicode 字符。</exception>
        <block subset="none" type="usage"><para>此 <see cref="Overload:System.String.IsNormalized" /> 方法 <see langword="false" /> 会在遇到字符串中第一个非规范化字符时立即返回。 因此，如果字符串包含非规范化字符后跟无效的 Unicode 字符，则该 <see cref="Overload:System.String.Normalize" /> 方法可能会引发， <see cref="T:System.ArgumentException" /> 但 <see cref="Overload:System.String.IsNormalized" /> 返回 <see langword="false" /> 。</para></block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member ( = ) : string * string -&gt; bool" Usage="a = b" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">要比较的第一个字符串，或 <see langword="null" />。</param>
        <param name="b">要比较的第二个字符串，或 <see langword="null" />。</param>
        <summary>确定两个指定的字符串是否具有相同的值。</summary>
        <returns>如果 <see langword="true" /> 的值与 <paramref name="a" /> 的值相同，则为 <paramref name="b" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.String.op_Equality%2A>方法定义类的相等运算符的运算 <xref:System.String> 。 它将启用示例部分中所示的代码。 运算符反过来调用静态 <xref:System.String.Equals(System.String%2CSystem.String)> 方法，该方法执行 (区分大小写和不区分区域性的) 比较。

> [!NOTE]
> Visual Basic 编译器不会将相等运算符解析为对方法的调用 <xref:System.String.op_Equality%2A> 。 相反，相等运算符包装对方法的调用 <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> 。

## Examples
 下面的示例演示了相等运算符。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs" interactive="try-dotnet" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;char&gt; (string? value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;char&gt; op_Implicit(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Implicit(System.String)~System.ReadOnlySpan{System.Char}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;char&gt;(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.string.op_Implicit value" />
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;char&gt; (string value);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">要隐式转换的字符串。</param>
        <summary>定义给定字符串到只读字符范围的隐式转换。</summary>
        <returns>表示字符串的新只读字符范围。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : string * string -&gt; bool" Usage="System.string.op_Inequality (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">要比较的第一个字符串，或 <see langword="null" />。</param>
        <param name="b">要比较的第二个字符串，或 <see langword="null" />。</param>
        <summary>确定两个指定的字符串是否具有不同的值。</summary>
        <returns>如果 <see langword="true" /> 的值与 <paramref name="a" /> 的值不同，则为 <paramref name="b" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.String.op_Inequality%2A>方法为类定义不相等运算符的运算 <xref:System.String> 。   它将启用示例部分中所示的代码。

 <xref:System.String.op_Inequality%2A>运算符反过来调用静态 <xref:System.String.Equals(System.String%2CSystem.String)> 方法，该方法执行 (区分大小写和不区分区域性的) 比较。

> [!NOTE]
> Visual Basic 编译器不会将不相等运算符解析为对方法的调用 <xref:System.String.op_Inequality%2A> 。 相反，不等运算符包装对方法的调用 <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> 。

## Examples
 下面的示例演示不等运算符。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs" interactive="try-dotnet" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PadLeft">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个指定长度的新字符串，其中在当前字符串的开头填充空格或指定的 Unicode 字符。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int -&gt; string" Usage="string.PadLeft totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">结果字符串中的字符数，等于原始字符数加上任何其他填充字符。</param>
        <summary>返回一个新字符串，该字符串通过在此实例中的字符左侧填充空格来达到指定的总长度，从而实现右对齐。</summary>
        <returns>与此实例等效的一个新字符串，但该字符串为右对齐，因此，在左侧填充所需任意数量的空格，使长度达到 <paramref name="totalWidth" />。 但是，如果 <paramref name="totalWidth" /> 小于此实例的长度，则此方法返回对现有实例的引用。 如果 <paramref name="totalWidth" /> 等于此实例的长度，则此方法返回与此实例相同的新字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Unicode 空格定义为十六进制0x0020。

 <xref:System.String.PadLeft(System.Int32)>方法用于填充返回的字符串的开头。 这意味着，当与从右到左的语言结合使用时，它将填充字符串的右侧部分。

> [!NOTE]
> 如果 <xref:System.String.PadLeft%2A> 方法用空白字符填充当前实例，则此方法不会修改当前实例的值。 相反，它会返回一个新字符串，该字符串使用前导空格填充，使其总长度为 `totalWidth` 个字符。

## Examples
 下面的示例演示 <xref:System.String.PadLeft%2A> 方法。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> 小于零。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int * char -&gt; string" Usage="string.PadLeft (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">结果字符串中的字符数，等于原始字符数加上任何其他填充字符。</param>
        <param name="paddingChar">Unicode 填充字符。</param>
        <summary>返回一个新字符串，该字符串通过在此实例中的字符左侧填充指定的 Unicode 字符来达到指定的总长度，从而使这些字符右对齐。</summary>
        <returns>与此实例等效的一个新字符串，但该字符串为右对齐，因此，在左侧填充所需任意数量的 <paramref name="paddingChar" /> 字符，使长度达到 <paramref name="totalWidth" />。 但是，如果 <paramref name="totalWidth" /> 小于此实例的长度，则此方法返回对现有实例的引用。 如果 <paramref name="totalWidth" /> 等于此实例的长度，则此方法返回与此实例相同的新字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.String.PadLeft(System.Int32%2CSystem.Char)>方法用于填充返回的字符串的开头。 这意味着，当与从右到左的语言结合使用时，它将填充字符串的右侧部分。

> [!NOTE]
> 如果 <xref:System.String.PadLeft%2A> 方法用空白字符填充当前实例，则此方法不会修改当前实例的值。 相反，它会返回一个新字符串，该字符串使用前导字符填充， `paddingChar` 使其总长度为 `totalWidth` 个字符。

## Examples
 下面的示例演示 <xref:System.String.PadLeft%2A> 方法。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> 小于零。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PadRight">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个指定长度的新字符串，其中在当前字符串的结尾填充空格或指定的 Unicode 字符。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int -&gt; string" Usage="string.PadRight totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">结果字符串中的字符数，等于原始字符数加上任何其他填充字符。</param>
        <summary>返回一个新字符串，该字符串通过在此字符串中的字符右侧填充空格来达到指定的总长度，从而使这些字符左对齐。</summary>
        <returns>与此实例等效的一个新字符串，但该字符串为左对齐，因此，在右侧填充所需任意数量的空格，使长度达到 <paramref name="totalWidth" />。 但是，如果 <paramref name="totalWidth" /> 小于此实例的长度，则此方法返回对现有实例的引用。 如果 <paramref name="totalWidth" /> 等于此实例的长度，则此方法返回与此实例相同的新字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Unicode 空格定义为十六进制0x0020。

 <xref:System.String.PadRight(System.Int32)>方法用于填充返回的字符串的末尾。 这意味着，当与从右到左的语言结合使用时，它将填充字符串的左侧部分。

> [!NOTE]
> 如果 <xref:System.String.PadRight%2A> 方法用空白字符填充当前实例，则此方法不会修改当前实例的值。 相反，它会返回一个新字符串，该字符串用尾随空格填充，使其总长度为 `totalWidth` 个字符。

## Examples
 下面的示例演示 <xref:System.String.PadRight%2A> 方法。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> 小于零。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int * char -&gt; string" Usage="string.PadRight (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">结果字符串中的字符数，等于原始字符数加上任何其他填充字符。</param>
        <param name="paddingChar">Unicode 填充字符。</param>
        <summary>返回一个新字符串，该字符串通过在此字符串中的字符右侧填充指定的 Unicode 字符来达到指定的总长度，从而使这些字符左对齐。</summary>
        <returns>与此实例等效的一个新字符串，但该字符串为左对齐，因此，在右侧填充所需任意数量的 <paramref name="paddingChar" /> 字符，使长度达到 <paramref name="totalWidth" />。 但是，如果 <paramref name="totalWidth" /> 小于此实例的长度，则此方法返回对现有实例的引用。 如果 <paramref name="totalWidth" /> 等于此实例的长度，则此方法返回与此实例相同的新字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.String.PadRight(System.Int32%2CSystem.Char)>方法用于填充返回的字符串的末尾。 这意味着，当与从右到左的语言结合使用时，它将填充字符串的左侧部分。

> [!NOTE]
> 如果 <xref:System.String.PadRight%2A> 方法用空白字符填充当前实例，则此方法不会修改当前实例的值。 相反，它会返回一个新字符串，该字符串用尾随字符填充， `paddingChar` 使其总长度为 `totalWidth` 个字符。

## Examples
 下面的示例演示 <xref:System.String.PadRight%2A> 方法。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> 小于零。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个新字符串，它相当于从当前字符串删除了指定数量的字符。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Remove : int -&gt; string" Usage="string.Remove startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="startIndex">开始删除字符的从零开始的位置。</param>
        <summary>返回当前实例中从指定位置到最后位置的所有以删除的字符的新字符串。</summary>
        <returns>一个新字符串，除所删除的字符之外，该字符串与此字符串等效。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 在中 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] ，字符串是从零开始的。 参数的值的 `startIndex` 范围可以介于0到字符串实例的长度之间。

> [!NOTE]
> 此方法不会修改当前实例的值。 相反，它会返回一个新字符串，其中的所有字符都从 `startIndex` 一个位置移到原始字符串的末尾。

## Examples
 下面的示例演示 <xref:System.String.Remove%2A> 方法。 "下一步到最后一种情况" 从字符串的末尾开始删除从指定索引处开始的所有文本。 最后一种情况从指定的索引开始删除三个字符。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 小于零。

- 或 -

 <paramref name="startIndex" /> 指定不在此字符串中的位置。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; string" Usage="string.Remove (startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">开始删除字符的从零开始的位置。</param>
        <param name="count">要删除的字符数。</param>
        <summary>返回指定数量字符在当前这个实例起始点在已删除的指定的位置的新字符串。</summary>
        <returns>一个新字符串，除所删除的字符之外，该字符串与此实例等效。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 在中 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] ，字符串是从零开始的。 参数的值的 `startIndex` 范围可以介于0到字符串实例的长度之间。

> [!NOTE]
> 此方法不会修改当前实例的值。 相反，它会返回一个新字符串，其中已删除参数指定的字符数 `count` 。 在指定的位置删除字符 `startIndex` 。

## Examples
 下面的示例演示如何删除完整名称中的中间名。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 或 <paramref name="count" /> 小于零。

- 或 -

 <paramref name="startIndex" /> 加 <paramref name="count" /> 指定此实例之外的位置。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个新字符串，其中已将当前字符串中的指定 Unicode 字符或 <see cref="T:System.String" /> 的所有匹配项替换为其他指定的 Unicode 字符或 <see cref="T:System.String" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; string" Usage="string.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">要替换的 Unicode 字符。</param>
        <param name="newChar">要替换出现的所有 <paramref name="oldChar" /> 的 Unicode 字符。</param>
        <summary>返回一个新字符串，其中此实例中出现的所有指定 Unicode 字符都替换为另一个指定的 Unicode 字符。</summary>
        <returns>等效于此实例（除了 <paramref name="oldChar" /> 的所有实例都已替换为 <paramref name="newChar" /> 外）的字符串。 如果在当前实例中找不到 <paramref name="oldChar" />，此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法执行 (区分大小写和不区分区域性的序号) 搜索以查找 `oldChar` 。

> [!NOTE]
> 此方法不会修改当前实例的值。 相反，它会返回一个新字符串，其中的所有匹配项 `oldChar` 都将替换为 `newChar` 。

 由于此方法返回修改后的字符串，因此可以将对方法的连续调用链接在一起， <xref:System.String.Replace%2A> 以对原始字符串执行多次替换。 方法调用从左至右执行。 下面的示例进行了这方面的演示。

 [!code-csharp-interactive[System.String.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]

## Examples
 下面的示例通过用逗号替换一系列数字之间的空格来创建逗号分隔值列表。

 [!code-cpp[string.replace1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp-interactive[string.replace1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="string.Replace (oldValue, newValue)" />
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string? newValue);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">要替换的字符串。</param>
        <param name="newValue">要替换 <paramref name="oldValue" /> 的所有匹配项的字符串。</param>
        <summary>返回一个新字符串，其中当前实例中出现的所有指定字符串都替换为另一个指定的字符串。</summary>
        <returns>等效于当前字符串（除了 <paramref name="oldValue" /> 的所有实例都已替换为 <paramref name="newValue" /> 外）的字符串。 如果在当前实例中找不到 <paramref name="oldValue" />，此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果 `newValue` 为 `null` ，则删除的所有匹配项 `oldValue` 。

> [!NOTE]
> 此方法不会修改当前实例的值。 相反，它会返回一个新字符串，其中的所有匹配项 `oldValue` 都将替换为 `newValue` 。

 此方法执行 (区分大小写和不区分区域性的序号) 搜索以查找 `oldValue` 。

 由于此方法返回修改后的字符串，因此可以将对方法的连续调用链接在一起， <xref:System.String.Replace%2A> 以对原始字符串执行多次替换。 方法调用从左至右执行。 下面的示例进行了这方面的演示。

 [!code-csharp-interactive[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]

## Examples
 下面的示例演示如何使用 <xref:System.String.Replace%2A> 方法更正拼写错误。

 [!code-cpp[stringreplace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp-interactive[stringreplace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="oldValue" /> 为空字符串 ("")。</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string? newValue, StringComparison comparisonType);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, comparisonType As StringComparison) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * StringComparison -&gt; string" Usage="string.Replace (oldValue, newValue, comparisonType)" />
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="newValue" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="oldValue">要替换的字符串。</param>
        <param name="newValue">要替换 <paramref name="oldValue" /> 的所有匹配项的字符串。</param>
        <param name="comparisonType">枚举值之一，用于确定在此实例内搜索 <paramref name="oldValue" /> 的方法。</param>
        <summary>返回一个新字符串，其中当前实例中出现的所有指定字符串都使用提供的比较类型替换为另一个指定的字符串。</summary>
        <returns>等效于当前字符串（除了 <paramref name="oldValue" /> 的所有实例都已替换为 <paramref name="newValue" /> 外）的字符串。 如果在当前实例中找不到 <paramref name="oldValue" />，此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
如果 `newValue` 为 `null` ，则删除的所有匹配项 `oldValue` 。

> [!NOTE]
> 此方法不会修改当前实例的值。 相反，它会返回一个新字符串，其中的所有匹配项 `oldValue` 都将替换为 `newValue` 。

此方法执行搜索以查找 `oldValue` 使用所述的区域性和区分大小写 `comparisonType` 。

由于此方法返回修改后的字符串，因此可以将对方法的连续调用链接在一起， <xref:System.String.Replace%2A> 以对原始字符串执行多次替换。 方法调用从左至右执行。 下面的示例进行了这方面的演示。

[!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
[!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="oldValue" /> 为空字符串 ("")。</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string? newValue, bool ignoreCase, System.Globalization.CultureInfo? culture);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, ignoreCase As Boolean, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * bool * System.Globalization.CultureInfo -&gt; string" Usage="string.Replace (oldValue, newValue, ignoreCase, culture)" />
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="newValue" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="oldValue">要替换的字符串。</param>
        <param name="newValue">要替换 <paramref name="oldValue" /> 的所有匹配项的字符串。</param>
        <param name="ignoreCase">在比较时忽略大小写则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <param name="culture">比较时要使用的区域性。</param>
        <summary>返回一个新字符串，其中当前实例中出现的所有指定字符串都使用提供的区域性和区分大小写属性替换为另一个指定的字符串。</summary>
        <returns>等效于当前字符串（除了 <paramref name="oldValue" /> 的所有实例都已替换为 <paramref name="newValue" /> 外）的字符串。 如果在当前实例中找不到 <paramref name="oldValue" />，此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
如果 `newValue` 为 `null` ，则删除的所有匹配项 `oldValue` 。

> [!NOTE]
> 此方法不会修改当前实例的值。 相反，它会返回一个新字符串，其中的所有匹配项 `oldValue` 都将替换为 `newValue` 。

此方法 `oldValue` 使用提供的 `culture` 和 `ignoreCase` 区分大小写来执行搜索以查找。

由于此方法返回修改后的字符串，因此可以将对方法的连续调用链接在一起， <xref:System.String.Replace%2A> 以对原始字符串执行多次替换。 方法调用从左至右执行。 下面的示例进行了这方面的演示。

[!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
[!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="oldValue" /> 为空字符串 ("")。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回的字符串数组包含此实例中的子字符串（由指定字符串或 Unicode 字符数组的元素分隔）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<xref:System.String.Split%2A> 用于将分隔的字符串拆分为子字符串。 您可以使用字符数组或字符串数组来指定零个或多个分隔字符或字符串。 如果未指定任何分隔字符，则将字符串拆分为空白字符。

使用方法的重载 <xref:System.String.Split%2A> ，可以限制方法)  (方法返回的子字符串的数量 <xref:System.String.Split(System.Char%5B%5D%2CSystem.Int32)> ，以指定是否在和方法)  (的结果中包含空字符串和/或剪裁子字符串 <xref:System.String.Split(System.Char%5B%5D%2CSystem.StringSplitOptions)> <xref:System.String.Split(System.String%5B%5D%2CSystem.StringSplitOptions)> ，或者 () <xref:System.String.Split(System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions)> 和 <xref:System.String.Split(System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions)> 方法。

> [!TIP]
> <xref:System.String.Split%2A>方法并非总是将分隔的字符串拆分为子字符串的最佳方式。 如果您不希望提取分隔字符串的所有子字符串，或者您想要基于某个模式（而不是一组分隔符字符）分析字符串，请考虑使用正则表达式，或将使用方法返回字符索引的搜索方法之一组合起来 <xref:System.String.Substring%2A> 。 有关详细信息，请参阅 [从字符串中提取子](/dotnet/standard/base-types/divide-up-strings)字符串。

## <a name="example"></a>示例

下面的示例显示了三种不同的 `String.Split()` 重载。 第一个示例调用 <xref:System.String.Split(System.Char[])> 重载，并传入单个分隔符。

[!code-csharp-interactive[Intro#1](~/samples/snippets/csharp/system/string.split/intro.cs#1)]
[!code-vb[Intro#1](~/samples/snippets/visualbasic/system/string.split/intro.vb#1)]

正如你所看到的那样，两个子字符串之间包含句点字符 (`.`)。 如果要排除句点字符，可以将句点字符添加为额外的分隔符。 下面的示例演示了如何执行此操作。

[!code-csharp-interactive[Intro#2](~/samples/snippets/csharp/system/string.split/intro.cs#2)]
[!code-vb[Intro#2](~/samples/snippets/visualbasic/system/string.split/intro.vb#2)]

子字符串之间的句点消息，但现在包含了两个额外的空子字符串。 这些空子字符串表示单词与其后的句点之间的子字符串。 若要从生成的数组中删除空字符串，可以调用 <xref:System.String.Split(System.Char[],System.StringSplitOptions)> 重载，并为 `options` 参数指定 <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>。

[!code-csharp-interactive[Intro#3](~/samples/snippets/csharp/system/string.split/intro.cs#3)]
[!code-vb[Intro#3](~/samples/snippets/visualbasic/system/string.split/intro.vb#3)]

各个重载的部分 `String.Split()` 包含进一步的示例。

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (params char[] separator);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (ParamArray separator As Char()) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(... cli::array &lt;char&gt; ^ separator);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] -&gt; string[]" Usage="string.Split separator" />
      <MemberSignature Language="C#" Value="public string[] Split (params char[]? separator);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">分隔字符的数组、不包含分隔符的空数组或 <see langword="null" />。</param>
        <summary>根据指定的分隔字符将字符串拆分为子字符串。</summary>
        <returns>一个数组，其元素包含此实例中的子字符串，这些子字符串由 <paramref name="separator" /> 中的一个或多个字符分隔。 有关详细信息，请参阅“备注”部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

当使用一组已知的字符分隔字符串时，可以使用 <xref:System.String.Split(System.Char%5B%5D)> 方法将其分隔为子字符串。

分隔符字符不包含在返回数组的元素中。 例如，如果分隔符数组包含字符 "-"，而当前字符串实例的值为 "aa-bb-cc"，则该方法将返回包含三个元素的数组： "aa"、"bb" 和 "cc"。

如果此实例不包含中的任何字符 `separator` ，则返回的数组由包含此实例的单个元素组成。

的每个元素 `separator` 定义单独的分隔符字符。 如果两个分隔符相邻，或在此实例的开头或结尾找到了分隔符，则返回数组中的相应元素包含 <xref:System.String.Empty?displayProperty=nameWithtype> 。

下表显示了一些示例。

| 语言     | 字符串值             | Separator              | 返回数组                 |
|--------------|--------------------------|------------------------|--------------------------------|
| C#           | "42, 12, 19"             | new Char [] {"，"，""}  | {"42", "", "12", "", "19"}     |
| Visual Basic | "42, 12, 19"             | Char ( # A1 = {"，" c，"" c} )  | {"42", "", "12", "", "19"}     |
| C#           | "42. 12 ... 19."            | new Char [] {"."}       | {"42"，""，"12"，""，"19"，""} |
| Visual Basic | "42. 12 ... 19."            | Char ( # A1 = {"."ansi-c        | {"42"，""，"12"，""，"19"，""} |
| C#           | 香蕉                 | new Char [] {"."}       | {"香蕉"}                     |
| Visual Basic | 香蕉                 | Char ( # A1 = {"."ansi-c        | {"香蕉"}                     |
| C#           | "Darb\nSmarba"           | new Char [] {}          | {"Darb", "Smarba"}             |
| Visual Basic | "Darb" & vbLf & "Smarba" | Char ( # A1 = {}            | {"Darb", "Smarba"}             |
| C#           | "Darb\nSmarba"           | Null                   | {"Darb", "Smarba"}             |
| Visual Basic | "Darb" & vbLf & "Smarba" | 无                | {"Darb", "Smarba"}             |

### <a name="the-separator-array"></a>分隔符数组

分隔符的每个元素都定义一个由单个字符组成的单独分隔符。

如果 `separator` 参数为 `null` 或不包含任何字符，则该方法将空白字符视为分隔符。 空白字符由 Unicode 标准定义， <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> `true` 如果向其传递空白字符，该方法将返回。

### <a name="stringsplitchar-and-compiler-overload-resolution"></a>字符串拆分 (Char [] ) 和编译器重载决策

尽管此重载的单个参数 <xref:System.String.Split%2A?displayProperty=nameWithType> 是字符数组，但你可以使用单个字符调用它，如下面的示例所示。

[!code-csharp-interactive[CompilerResolution#1](~/samples/snippets/csharp/system/string.split/compiler-resolution.cs#1)]
[!code-vb[System.String.Split#12](~/samples/snippets/visualbasic/system/string.split/compiler-resolution.vb#12)]

由于 `separator` 参数使用特性进行修饰 <xref:System.ParamArrayAttribute> ，因此编译器会将单个字符解释为单元素字符数组。 这种情况并非 <xref:System.String.Split%2A?displayProperty=nameWithType> 包含参数的其他重载的情况 `separator` ; 必须以参数形式将字符数组显式传递给这些重载 `separator` 。

### <a name="comparison-details"></a>比较详细信息

<xref:System.String.Split(System.Char%5B%5D)>方法提取此字符串中的子字符串，这些子字符串由数组中的一个或多个字符分隔 `separator` ，并将这些子字符串作为数组的元素返回。

<xref:System.String.Split(System.Char%5B%5D)>方法通过使用区分大小写的序号排序规则执行比较来查找分隔符。 有关 word、字符串和序号排序的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 枚举。

### <a name="performance-considerations"></a>性能注意事项

<xref:System.String.Split%2A>方法为返回的数组对象分配内存，并为 <xref:System.String> 每个数组元素分配一个对象。 如果你的应用程序需要最佳性能，或者在你的应用程序中管理内存分配非常重要，请考虑使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法。 你还可以选择使用 <xref:System.String.Compare%2A> 方法来查找字符串中的子字符串。

若要在分隔符处拆分字符串，请使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法在字符串中查找分隔符。 若要将字符串拆分为分隔符字符串，请使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法查找分隔符字符串的第一个字符。 然后，使用 <xref:System.String.Compare%2A> 方法来确定第一个字符后面的字符是否等于分隔符字符串的剩余字符。

此外，如果使用相同的字符集拆分多个方法调用中的字符串 <xref:System.String.Split%2A> ，请考虑创建一个数组，并在每个方法调用中引用它。 这可以显著降低每个方法调用的额外开销。

## Examples

下面的示例演示了如何通过将空格字符 (` `) 和制表符 (`\t`) 作为分隔符来从文本块提取各个单词。 要拆分的字符串同时包含这两个字符。

[!code-csharp-interactive[System.String.Split#1](~/samples/snippets/csharp/system/string.split/basic.cs#1)]
[!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/system/string.split/basic.vb#1)]

 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 和早期版本中，如果向 <see cref="M:System.String.Split(System.Char[])" /> 方法传递的 <paramref name="separator" /> 是 <see langword="null" /> 或不包含任何字符，则该方法将使用一组略微不同的空白字符来拆分字符串，而不是使用 <see cref="M:System.String.Trim(System.Char[])" /> 方法来剪裁字符串。 从 .NET Framework 4 开始，这两个方法都使用一组相同的 Unicode 空白字符。</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="separator">一个字符，用于分隔此字符串中的子字符串。</param>
        <param name="options">枚举值的按位组合，用于指定是否剪裁子字符串并包含空子字符串。</param>
        <summary>基于指定的分隔字符和（可选）选项将字符串拆分为子字符串。</summary>
        <returns>一个数组，其元素包含此实例中的子字符串，这些子字符串由 <paramref name="separator" /> 分隔。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int -&gt; string[]" Usage="string.Split (separator, count)" />
      <MemberSignature Language="C#" Value="public string[] Split (char[]? separator, int count);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">分隔此字符串中子字符串的字符数组、不包含分隔符的空数组或 <see langword="null" />。</param>
        <param name="count">要返回的子字符串的最大数量。</param>
        <summary>根据指定的分隔字符将一个字符串拆分成最大数量的子字符串。</summary>
        <returns>一个数组，其元素包含此实例中的子字符串，这些子字符串由 <paramref name="separator" /> 中的一个或多个字符分隔。 有关详细信息，请参阅“备注”部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 分隔符字符不包含在返回数组的元素中。

 如果此实例不包含中的任何字符 `separator` ，则返回的数组由包含此实例的单个元素组成。 如果 `count` 为零，则返回空数组。

 如果 `separator` 参数为 `null` 或不包含任何字符，则假定空格字符为分隔符。 空白字符由 Unicode 标准定义， <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> `true` 如果传递给它，则方法将返回。

 的每个元素 `separator` 定义单独的分隔符字符。 如果两个分隔符相邻，或在此实例的开头或结尾找到了分隔符，则对应的数组元素包含 <xref:System.String.Empty?displayProperty=nameWithtype> 。

 如果 `count` 此实例中有多个子字符串，则返回 `count - 1` 值的第一个元素中会返回第一个子字符串 `count - 1` ，并且返回值的最后一个元素中会返回此实例中的剩余字符。

 如果 `count` 大于子字符串的数目，则将返回可用的子字符串，并且不会引发异常。

下表显示了一些示例。

| 语言     | 字符串值             | Separator              | 返回数组                 |
|--------------|--------------------------|------------------------|--------------------------------|
| C#           | "42, 12, 19"             | new Char [] {"，"，""}  | {"42", "", "12", "", "19"}     |
| Visual Basic | "42, 12, 19"             | Char ( # A1 = {"，" c，"" c} )  | {"42", "", "12", "", "19"}     |
| C#           | "42. 12 ... 19."            | new Char [] {"."}       | {"42"，""，"12"，""，"19"，""} |
| Visual Basic | "42. 12 ... 19."            | Char ( # A1 = {"."ansi-c        | {"42"，""，"12"，""，"19"，""} |
| C#           | 香蕉                 | new Char [] {"."}       | {"香蕉"}                     |
| Visual Basic | 香蕉                 | Char ( # A1 = {"."ansi-c        | {"香蕉"}                     |
| C#           | "Darb\nSmarba"           | new Char [] {}          | {"Darb", "Smarba"}             |
| Visual Basic | "Darb" & vbLf & "Smarba" | Char ( # A1 = {}            | {"Darb", "Smarba"}             |
| C#           | "Darb\nSmarba"           | Null                   | {"Darb", "Smarba"}             |
| Visual Basic | "Darb" & vbLf & "Smarba" | 无                | {"Darb", "Smarba"}             |

### <a name="performance-considerations"></a>性能注意事项
 <xref:System.String.Split%2A>方法为返回的数组对象分配内存，并为 <xref:System.String> 每个数组元素分配一个对象。 如果你的应用程序需要最佳性能，或者在你的应用程序中管理内存分配非常重要，请考虑使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法，并根据需要使用 <xref:System.String.Compare%2A> 方法来查找字符串中的子字符串。

 如果要在分隔符处拆分字符串，请使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法来查找字符串中的分隔符。 如果要将字符串拆分为分隔符字符串，请使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法查找分隔符字符串的第一个字符。 然后，使用 <xref:System.String.Compare%2A> 方法来确定第一个字符后面的字符是否等于分隔符字符串的剩余字符。

 此外，如果使用相同的字符集拆分多个方法调用中的字符串 <xref:System.String.Split%2A> ，请考虑创建一个数组，并在每个方法调用中引用它。 这可以显著降低每个方法调用的额外开销。

## Examples
 下面的示例演示如何 `count` 使用来限制返回的字符串的数目 <xref:System.String.Split%2A> 。

[!code-csharp-interactive[String.Split#1](~/samples/snippets/csharp/system/string.split/limit.cs#1)]
[!code-vb[String.Split#1](~/samples/snippets/visualbasic/system/string.split/limit.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 为负数。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 和早期版本中，如果向 <see cref="M:System.String.Split(System.Char[])" /> 方法传递的 <paramref name="separator" /> 是 <see langword="null" /> 或不包含任何字符，则该方法将使用一组略微不同的空白字符来拆分字符串，而不是使用 <see cref="M:System.String.Trim(System.Char[])" /> 方法来剪裁字符串。 从 .NET Framework 4 开始，这两个方法都使用一组相同的 Unicode 空白字符。</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberSignature Language="C#" Value="public string[] Split (char[]? separator, StringSplitOptions options);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">分隔此字符串中子字符串的字符数组、不包含分隔符的空数组或 <see langword="null" />。</param>
        <param name="options">枚举值的按位组合，用于指定是否剪裁子字符串并包含空子字符串。</param>
        <summary>根据指定的分隔字符和选项将字符串拆分为子字符串。</summary>
        <returns>一个数组，其元素包含此字符串中的子字符串，这些子字符串由 <paramref name="separator" /> 中的一个或多个字符分隔。 有关详细信息，请参阅“备注”部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

分隔符字符 (数组中的字符 `separator`) 不包含在返回数组的元素中。 例如，如果 `separator` 数组包含字符 "-"，而当前字符串实例的值为 "aa-bb-cc"，则该方法将返回包含三个元素的数组： "aa"、"bb" 和 "cc"。

如果此实例不包含中的任何字符 `separator` ，则返回的数组由包含此实例的单个元素组成。

如果 `options` 参数为 <xref:System.StringSplitOptions.RemoveEmptyEntries> ，并且此实例的长度为零，则该方法将返回一个空数组。

的每个元素都 `separator` 定义一个由单个字符组成的单独分隔符。 如果 `options` 参数为 <xref:System.StringSplitOptions.None> ，并且两个分隔符相邻，或在此实例的开头或结尾找到了分隔符，则对应的数组元素包含 <xref:System.String.Empty?displayProperty=nameWithType> 。 例如，如果 `separator` 包含两个元素， `'-'` 并且 `'_'` 字符串实例的值为 "- \_ aa- \_ "，并且参数的值 `options` 为 <xref:System.StringSplitOptions.None> ，则该方法将返回一个字符串数组，其中包含以下五个元素：

1. <xref:System.String.Empty?displayProperty=nameWithType>，它表示位于索引0处的 "-" 字符之前的空字符串。

2. <xref:System.String.Empty?displayProperty=nameWithType>，它表示位于索引0处的 "-" 字符和索引1处 "_" 字符之间的空字符串。

3. "aa"。

4. <xref:System.String.Empty?displayProperty=nameWithType>，它表示位于索引4处的 "-" 字符后面的空字符串。

5. <xref:System.String.Empty?displayProperty=nameWithType>，它表示位于索引5的 "_" 字符之后的空字符串。

### <a name="the-separator-array"></a>分隔符数组

如果 `separator` 参数为 `null` 或不包含任何字符，则假定空格字符为分隔符。 空白字符由 Unicode 标准定义， <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> `true` 如果传递给它，则方法将返回。

若要 `null` 为 `char[] separator` 参数传递，必须指示的类型， `null` 以消除其他一些重载（如）的调用 <xref:System.String.Split(System.String[],System.StringSplitOptions)> 。 下面的示例演示了几种明确识别此重载的方式。

[!code-csharp-interactive[Identify#5](~/samples/snippets/csharp/system/string.split/identify.cs#5)]
[!code-vb[System.String.Split#5](~/samples/snippets/visualbasic/system/string.split/identify.vb#5)]

### <a name="comparison-details"></a>比较详细信息
 <xref:System.String.Split%2A>方法提取此字符串中的子字符串，这些子字符串由参数中的一个或多个字符分隔 `separator` ，并将这些子字符串作为数组的元素返回。

 <xref:System.String.Split%2A>方法通过使用区分大小写的序号排序规则执行比较来查找分隔符。 有关 word、字符串和序号排序的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 枚举。

### <a name="performance-considerations"></a>性能注意事项
 <xref:System.String.Split%2A>方法为返回的数组对象分配内存，并为 <xref:System.String> 每个数组元素分配一个对象。 如果你的应用程序需要最佳性能，或者在你的应用程序中管理内存分配非常重要，请考虑使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法，并根据需要使用 <xref:System.String.Compare%2A> 方法来查找字符串中的子字符串。

 如果要在分隔符处拆分字符串，请使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法来查找字符串中的分隔符。 如果要将字符串拆分为分隔符字符串，请使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法查找分隔符字符串的第一个字符。 然后，使用 <xref:System.String.Compare%2A> 方法来确定第一个字符后面的字符是否等于分隔符字符串的剩余字符。

 此外，如果使用相同的字符集拆分多个方法调用中的字符串 <xref:System.String.Split%2A> ，请考虑创建一个数组，并在每个方法调用中引用它。 这可以显著降低每个方法调用的额外开销。

## Examples
 下面的示例使用 <xref:System.StringSplitOptions> 枚举来包括或排除方法生成的子字符串 <xref:System.String.Split%2A> 。

 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[Options#1](~/samples/snippets/csharp/system/string.split/options.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/system/string.split/omit.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> 不是 <see cref="T:System.StringSplitOptions" /> 值之一。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 和早期版本中，如果向 <see cref="M:System.String.Split(System.Char[])" /> 方法传递的 <paramref name="separator" /> 是 <see langword="null" /> 或不包含任何字符，则该方法将使用一组略微不同的空白字符来拆分字符串，而不是使用 <see cref="M:System.String.Trim(System.Char[])" /> 方法来剪裁字符串。 从 .NET Framework 4 开始，这两个方法都使用一组相同的 Unicode 空白字符。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string? separator, StringSplitOptions options = System.StringSplitOptions.None);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="separator">一个字符串，用于分隔此字符串中的子字符串。</param>
        <param name="options">枚举值的按位组合，用于指定是否剪裁子字符串并包含空子字符串。</param>
        <summary>根据提供的字符串分隔符将字符串拆分为多个子字符串。</summary>
        <returns>一个数组，其元素包含此实例中的子字符串，这些子字符串由 <paramref name="separator" /> 分隔。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberSignature Language="C#" Value="public string[] Split (string[]? separator, StringSplitOptions options);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">分隔此字符串中子字符串的字符串数组、不包含分隔符的空数组或 <see langword="null" />。</param>
        <param name="options">枚举值的按位组合，用于指定是否剪裁子字符串并包含空子字符串。</param>
        <summary>基于指定的分隔字符串和（可选）选项将字符串拆分为子字符串。</summary>
        <returns>一个数组，其元素包含此字符串中的子字符串，这些子字符串由 <paramref name="separator" /> 中的一个或多个字符串分隔。 有关详细信息，请参阅“备注”部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

当使用一组已知的字符串分隔字符串时，可以使用 <xref:System.String.Split%2A> 方法将其分隔为子字符串。

分隔符字符串不包含在返回数组的元素中。 例如，如果 `separator` 数组包含字符串 "--"，而当前字符串实例的值为 "aa--bb--cc"，则该方法将返回包含三个元素的数组： "aa"、"bb" 和 "cc"。

如果此实例不包含中的任何字符串 `separator` ，则返回的数组包含一个包含此实例的元素。

如果 `options` 参数为 <xref:System.StringSplitOptions.RemoveEmptyEntries> ，并且此实例的长度为零，则该方法将返回一个空数组。

的每个元素都 `separator` 定义一个由一个或多个字符组成的单独分隔符。 如果 `options` 参数为 <xref:System.StringSplitOptions.None> ，并且两个分隔符相邻，或在此实例的开头或结尾找到了分隔符，则对应的数组元素包含 <xref:System.String.Empty?displayProperty=nameWithType> 。 例如，如果 `separator` 包含两个元素 "-" 和 " \_ "，则字符串实例的值为 "- \_ aa- \_ "，而参数的值 `options` 为 <xref:System.StringSplitOptions.None> ，则该方法返回一个字符串数组，其中包含以下五个元素：

1. <xref:System.String.Empty?displayProperty=nameWithType>，它表示位于索引0处的 "-" 子字符串之前的空字符串。

2. <xref:System.String.Empty?displayProperty=nameWithType>，它表示位于索引0处的 "-" 子字符串与索引1处的 "_" 子字符串之间的空字符串。

3. "aa"。

4. <xref:System.String.Empty?displayProperty=nameWithType>，它表示位于索引4处的 "-" 子字符串后面的空字符串。

5. <xref:System.String.Empty?displayProperty=nameWithType>，它表示位于索引5的 "_" 子字符串之后的空字符串。

### <a name="the-separator-array"></a>分隔符数组

如果中的任何元素 `separator` 包含多个字符，则整个子字符串被视为分隔符。 例如，如果中的一个元素 `separator` 为 "10"，则尝试拆分字符串 "This10is10a10string"。 返回以下四元素数组： {"This"、"is"、"a"、"string"。 }.

如果 `separator` 参数为 `null` 或不包含非空字符串，则假定空格字符作为分隔符。 空白字符由 Unicode 标准定义， <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> `true` 如果传递给它，则方法将返回。

若要 `null` 为 `string[] separator` 参数传递，必须指示的类型， `null` 以消除其他一些重载（如）的调用 <xref:System.String.Split(System.Char[],System.StringSplitOptions)> 。 下面的示例演示了几种明确识别此重载的方式。

[!code-csharp-interactive[Identify#6](~/samples/snippets/csharp/system/string.split/identify.cs#6)]
[!code-vb[System.String.Split#6](~/samples/snippets/visualbasic/system/string.split/identify.vb#6)]

### <a name="comparison-details"></a>比较详细信息
 <xref:System.String.Split%2A>方法提取此字符串中的子字符串，这些子字符串由参数中的一个或多个字符串分隔 `separator` ，并将这些子字符串作为数组的元素返回。

 <xref:System.String.Split%2A>方法通过使用区分大小写的序号排序规则执行比较来查找分隔符。 有关 word、字符串和序号排序的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 枚举。

 <xref:System.String.Split%2A>方法将忽略 `separator` 其值为 `null` 或空字符串 ( "" ) 的任何元素。

 若要在中的字符串具有相同的字符时避免出现不明确的结果， `separator` 则 <xref:System.String.Split%2A> 操作将从实例值的开头开始，并与中的第一个元素（ `separator` 等于实例中的分隔符）匹配。 实例中的子字符串的出现顺序优先于中元素的顺序 `separator` 。

 例如，假设值为 "abcdef" 的实例。 如果中的第一个元素 `separator` 为 "ef"，第二个元素为 "bcde"，则拆分操作的结果将是一个字符串数组，其中包含两个元素： "a" 和 "f"。 这是因为，在遇到子字符串 "f" 之前，遇到了实例 "bcde" 中的子字符串，并与中的元素匹配 `separator` 。

 但是，如果的第一个元素 `separator` 为 "bcd"，第二个元素为 "bc"，则拆分操作的结果将是一个字符串数组，其中包含两个元素： "a" 和 "ef"。 这是因为 "bcd" 是中的第一个分隔符 `separator` ，它与实例中的分隔符相匹配。 如果分隔符的顺序已颠倒，因此第一个元素为 "bc"，第二个元素为 "bcd"，则结果将是一个字符串数组，其中包含两个元素： "a" 和 "def"。

### <a name="performance-considerations"></a>性能注意事项
 <xref:System.String.Split%2A>方法为返回的数组对象分配内存，并为 <xref:System.String> 每个数组元素分配一个对象。 如果你的应用程序需要最佳性能，或者在你的应用程序中管理内存分配非常重要，请考虑使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法，并根据需要使用 <xref:System.String.Compare%2A> 方法来查找字符串中的子字符串。

 如果要在分隔符处拆分字符串，请使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法来查找字符串中的分隔符。 如果要将字符串拆分为分隔符字符串，请使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法查找分隔符字符串的第一个字符。 然后，使用 <xref:System.String.Compare%2A> 方法来确定第一个字符后面的字符是否等于分隔符字符串的剩余字符。

 此外，如果使用相同的字符集拆分多个方法调用中的字符串 <xref:System.String.Split%2A> ，请考虑创建一个数组，并在每个方法调用中引用它。 这可以显著降低每个方法调用的额外开销。

## Examples

下面的示例说明了通过调用字符串的 <xref:System.String.Split(System.String%5B%5D%2CSystem.StringSplitOptions)?displayProperty=nameWithType> 方法（其 `options` 参数等于和）返回的数组中的 <xref:System.StringSplitOptions.None?displayProperty=nameWithType> 差异 <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> 。

[!code-csharp-interactive[Options#2](~/samples/snippets/csharp/system/string.split/options.cs#2)]
[!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/system/string.split/options.vb#1)]

下面的示例定义一个包含标点和空白字符的分隔符数组。 如果将此数组与的值一起传递 <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> 给方法，则将 <xref:System.String.Split(System.String%5B%5D%2CSystem.StringSplitOptions)> 返回一个由字符串中的单个单词组成的数组。

[!code-csharp-interactive[Options#3](~/samples/snippets/csharp/system/string.split/options.cs#3)]
[!code-vb[System.String.Split#7](~/samples/snippets/visualbasic/system/string.split/options.vb#7)]

请注意，在参数设置为的情况下调用方法 `options` <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> 。 这可以防止返回的数组包含 <xref:System.String.Empty?displayProperty=nameWithType> 表示标点符号和空白字符之间的空子字符串匹配项的值。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> 不是 <see cref="T:System.StringSplitOptions" /> 值之一。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 和早期版本中，如果向 <see cref="M:System.String.Split(System.Char[])" /> 方法传递的 <paramref name="separator" /> 是 <see langword="null" /> 或不包含任何字符，则该方法将使用一组略微不同的空白字符来拆分字符串，而不是使用 <see cref="M:System.String.Trim(System.Char[])" /> 方法来剪裁字符串。 从 .NET Framework 4 开始，这两个方法都使用一组相同的 Unicode 空白字符。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="separator">一个字符，用于分隔此实例中的子字符串。</param>
        <param name="count">数组中预期的最大元素数。</param>
        <param name="options">枚举值的按位组合，用于指定是否剪裁子字符串并包含空子字符串。</param>
        <summary>基于指定的分隔字符和（可选）选项将字符串拆分为最大数量的子字符串。
根据提供的字符分隔符将字符串拆分为最大数量的子字符串，可以选择忽略结果中的空子字符串。</summary>
        <returns>一个数组，该数组包含此实例中的至多 <paramref name="count" /> 个子字符串，这些子字符串由 <paramref name="separator" /> 分隔。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

如果该字符串已拆分 `count` 为1次，但尚未到达字符串的末尾，则返回的数组中的最后一个字符串将包含此实例的其余尾随子字符串（不变）。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberSignature Language="C#" Value="public string[] Split (char[]? separator, int count, StringSplitOptions options);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">分隔此字符串中子字符串的字符数组、不包含分隔符的空数组或 <see langword="null" />。</param>
        <param name="count">要返回的子字符串的最大数量。</param>
        <param name="options">枚举值的按位组合，用于指定是否剪裁子字符串并包含空子字符串。</param>
        <summary>基于指定的分隔字符和（可选）选项将字符串拆分为最大数量的子字符串。</summary>
        <returns>一个数组，该数组包含此字符串中的子字符串，这些子字符串由 <paramref name="separator" /> 中的一个或多个字符分隔。 有关详细信息，请参阅“备注”部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

分隔符字符不包含在返回数组的元素中。

如果此实例不包含中的任何字符 `separator` ，或者 `count` 参数为1，则返回的数组由包含此实例的单个元素组成。

如果 `separator` 参数为 `null` 或不包含任何字符，则假定空格字符为分隔符。 空白字符由 Unicode 标准定义， <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> `true` 如果传递给它，则方法将返回。

若要 `null` 为 `char[] separator` 参数传递，必须指示的类型， `null` 以消除其他一些重载（如）的调用 <xref:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)> 。 下面的示例演示了几种明确识别此重载的方式。

[!code-csharp-interactive[Identify#3](~/samples/snippets/csharp/system/string.split/identify.cs#3)]
[!code-vb[System.String.Split#3](~/samples/snippets/visualbasic/system/string.split/identify.vb#3)]

 如果 `count` 参数为零，或者 `options` 参数为 <xref:System.StringSplitOptions.RemoveEmptyEntries> ，并且此实例的长度为零，则返回空数组。

 的每个元素 `separator` 定义单独的分隔符字符。 如果 `options` 参数为 <xref:System.StringSplitOptions.None> ，并且两个分隔符相邻，或在此实例的开头或结尾找到了分隔符，则对应的数组元素包含 <xref:System.String.Empty?displayProperty=nameWithtype> 。

 如果 `count` 此实例中的子字符串多于个子字符串，则返回 `count` 值的第一个减1元素返回第一个减号子字符串 `count` ，并且在返回值的最后一个元素中返回此实例中剩余的字符。

 如果 `count` 大于子字符串的数目，则将返回可用的子字符串，并且不会引发异常。

### <a name="performance-considerations"></a>性能注意事项
 <xref:System.String.Split%2A>方法为返回的数组对象分配内存，并为 <xref:System.String> 每个数组元素分配一个对象。 如果你的应用程序需要最佳性能，或者在你的应用程序中管理内存分配非常重要，请考虑使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法，并根据需要使用 <xref:System.String.Compare%2A> 方法来查找字符串中的子字符串。

 如果要在分隔符处拆分字符串，请使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法来查找字符串中的分隔符。 如果要将字符串拆分为分隔符字符串，请使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法查找分隔符字符串的第一个字符。 然后，使用 <xref:System.String.Compare%2A> 方法来确定第一个字符后面的字符是否等于分隔符字符串的剩余字符。

 此外，如果使用相同的字符集拆分多个方法调用中的字符串 <xref:System.String.Split%2A> ，请考虑创建一个数组，并在每个方法调用中引用它。 这可以显著降低每个方法调用的额外开销。

## Examples

下面的示例使用 <xref:System.StringSplitOptions> 枚举来包括或排除方法生成的子字符串 <xref:System.String.Split%2A> 。

[!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
[!code-csharp-interactive[Options#1](~/samples/snippets/csharp/system/string.split/options.cs#1)]
[!code-vb[string.split3#1](~/samples/snippets/visualbasic/system/string.split/omit.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 为负数。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> 不是 <see cref="T:System.StringSplitOptions" /> 值之一。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 和早期版本中，如果向 <see cref="M:System.String.Split(System.Char[])" /> 方法传递的 <paramref name="separator" /> 是 <see langword="null" /> 或不包含任何字符，则该方法将使用一组略微不同的空白字符来拆分字符串，而不是使用 <see cref="M:System.String.Trim(System.Char[])" /> 方法来剪裁字符串。 从 .NET Framework 4 开始，这两个方法都使用一组相同的 Unicode 空白字符。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string? separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="separator">一个字符串，用于分隔此实例中的子字符串。</param>
        <param name="count">数组中预期的最大元素数。</param>
        <param name="options">枚举值的按位组合，用于指定是否剪裁子字符串并包含空子字符串。</param>
        <summary>基于指定的分隔字符串和（可选）选项将字符串拆分为最大数量的子字符串。</summary>
        <returns>一个数组，该数组包含此实例中的至多 <paramref name="count" /> 个子字符串，这些子字符串由 <paramref name="separator" /> 分隔。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

如果该字符串已拆分 `count` 为1次，但尚未到达字符串的末尾，则返回的数组中的最后一个字符串将包含此实例的其余尾随子字符串（不变）。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberSignature Language="C#" Value="public string[] Split (string[]? separator, int count, StringSplitOptions options);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">分隔此字符串中子字符串的字符串、不包含分隔符的空数组或 <see langword="null" />。</param>
        <param name="count">要返回的子字符串的最大数量。</param>
        <param name="options">枚举值的按位组合，用于指定是否剪裁子字符串并包含空子字符串。</param>
        <summary>基于指定的分隔字符串和（可选）选项将字符串拆分为最大数量的子字符串。</summary>
        <returns>一个数组，其元素包含此字符串中的子字符串，这些子字符串由 <paramref name="separator" /> 中的一个或多个字符串分隔。 有关详细信息，请参阅“备注”部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

分隔符字符串不包含在返回数组的元素中。

如果此实例不包含中的任何字符串 `separator` ，或者 `count` 参数为1，则返回的数组由包含此实例的单个元素组成。

如果 `separator` 参数为 `null` 或不包含任何字符，则假定空格字符为分隔符。 空白字符由 Unicode 标准定义， <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> `true` 如果传递给它，则方法将返回。

若要 `null` 为 `string[] separator` 参数传递，必须指示的类型， `null` 以消除其他一些重载（如）的调用 <xref:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)> 。 下面的示例演示了几种明确识别此重载的方式。

[!code-csharp-interactive[Identify#4](~/samples/snippets/csharp/system/string.split/identify.cs#4)]
[!code-vb[System.String.Split#4](~/samples/snippets/visualbasic/system/string.split/identify.vb#4)]

 如果 `count` 参数为零，或者 `options` 参数为 <xref:System.StringSplitOptions.RemoveEmptyEntries> ，并且此实例的长度为零，则返回空数组。

 的每个元素都 `separator` 定义一个由一个或多个字符组成的单独分隔符。 如果 `options` 参数为 <xref:System.StringSplitOptions.None> ，并且两个分隔符相邻，或在此实例的开头或结尾找到了分隔符，则对应的数组元素包含 <xref:System.String.Empty?displayProperty=nameWithtype> 。

 如果 `count` 此实例中的子字符串多于个子字符串，则返回 `count` 值的第一个减1元素返回第一个减号子字符串 `count` ，并且在返回值的最后一个元素中返回此实例中剩余的字符。

 如果 `count` 大于子字符串的数目，则将返回可用的子字符串，并且不会引发异常。

### <a name="the-separator-array"></a>分隔符数组

如果中的任何元素 `separator` 包含多个字符，则整个子字符串被视为分隔符。 例如，如果中的一个元素 `separator` 为 "10"，则尝试拆分字符串 "This10is10a10string"。 返回这四元素数组： {"This"、"is"、"a"、"string"。 }.

### <a name="comparison-details"></a>比较详细信息
 <xref:System.String.Split%2A>方法提取此字符串中的子字符串，这些子字符串由参数中的一个或多个字符串分隔 `separator` ，并将这些子字符串作为数组的元素返回。

 <xref:System.String.Split%2A>方法通过使用区分大小写的序号排序规则执行比较来查找分隔符。 有关 word、字符串和序号排序的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 枚举。

 <xref:System.String.Split%2A>方法将忽略 `separator` 其值为 `null` 或空字符串 ( "" ) 的任何元素。

 若要避免在中的字符串具有相同的字符时出现不明确 `separator` 的结果，该 <xref:System.String.Split%2A> 方法将从实例值的开头开始，并与中的第一个元素（ `separator` 该元素等于实例中的分隔符）匹配。 实例中的子字符串的出现顺序优先于中元素的顺序 `separator` 。

 例如，假设值为 "abcdef" 的实例。 如果中的第一个元素 `separator` 为 "ef"，第二个元素为 "bcde"，则拆分操作的结果为 "a" 和 "f"。 这是因为，在遇到子字符串 "f" 之前，遇到了实例 "bcde" 中的子字符串，并与中的元素匹配 `separator` 。

 但是，如果的第一个元素 `separator` 为 "bcd"，第二个元素为 "bc"，则拆分操作的结果为 "a" 和 "ef"。 这是因为 "bcd" 是中的第一个分隔符 `separator` ，它与实例中的分隔符相匹配。 如果分隔符的顺序已颠倒，因此第一个元素为 "bc"，第二个元素为 "bcd"，则结果为 "a" 和 "def"。

### <a name="performance-considerations"></a>性能注意事项
 <xref:System.String.Split%2A>方法为返回的数组对象分配内存，并为 <xref:System.String> 每个数组元素分配一个对象。 如果你的应用程序需要最佳性能，或者在你的应用程序中管理内存分配非常重要，请考虑使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法，并根据需要使用 <xref:System.String.Compare%2A> 方法来查找字符串中的子字符串。

 如果要在分隔符处拆分字符串，请使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法来查找字符串中的分隔符。 如果要将字符串拆分为分隔符字符串，请使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法查找分隔符字符串的第一个字符。 然后，使用 <xref:System.String.Compare%2A> 方法来确定第一个字符后面的字符是否等于分隔符字符串的剩余字符。

 此外，如果使用相同的字符集拆分多个方法调用中的字符串 <xref:System.String.Split%2A> ，请考虑创建一个数组，并在每个方法调用中引用它。 这可以显著降低每个方法调用的额外开销。

## Examples

下面的示例使用 <xref:System.StringSplitOptions> 枚举来包括或排除方法生成的子字符串 <xref:System.String.Split%2A> 。

[!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
[!code-csharp-interactive[Options#1](~/samples/snippets/csharp/system/string.split/options.cs#1)]
[!code-vb[string.split3#1](~/samples/snippets/visualbasic/system/string.split/omit.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 为负数。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> 不是 <see cref="T:System.StringSplitOptions" /> 值之一。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 和早期版本中，如果向 <see cref="M:System.String.Split(System.Char[])" /> 方法传递的 <paramref name="separator" /> 是 <see langword="null" /> 或不包含任何字符，则该方法将使用一组略微不同的空白字符来拆分字符串，而不是使用 <see cref="M:System.String.Trim(System.Char[])" /> 方法来剪裁字符串。 从 .NET Framework 4 开始，这两个方法都使用一组相同的 Unicode 空白字符。</para></block>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : char -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">要比较的字符。</param>
        <summary>确定此字符串实例是否以指定字符开始。</summary>
        <returns>如果 <see langword="true" /> 与此字符串的开头匹配，则为 <paramref name="value" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

此方法使用当前区域性执行区分大小写的 (区分大小写的) 比较。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要比较的字符串。</param>
        <summary>确定此字符串实例的开头是否与指定的字符串匹配。</summary>
        <returns>如果 <see langword="true" /> 与此字符串的开头匹配，则为 <paramref name="value" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

此方法 `value` 与此实例开头与相同的子字符串进行比较 `value` ，并返回一个指示是否相等的指示。 若要相等， `value` 必须是 () 的空字符串 <xref:System.String.Empty?displayProperty=nameWithType> ，必须是对此同一个实例的引用，或者必须与此实例的开头匹配。

此方法使用当前区域性执行区分大小写的 (区分大小写的) 比较。

## Examples

下面的示例定义了一个 `StripStartTags` 方法，该方法使用 <xref:System.String.StartsWith(System.String)> 方法从字符串的开头移除 HTML 开始标记。 请注意，将 `StripStartTags` 以递归方式调用方法，以确保删除行开头的多个 HTML 开始标记。 该示例不删除嵌入在字符串中的 HTML 标记。

:::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp" id="Snippet1":::
:::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs" interactive="try-dotnet" id="Snippet1":::
:::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb" id="Snippet1":::

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>如 [使用字符串的最佳做法](/dotnet/standard/base-types/best-practices-strings)中所述，建议你避免调用替换默认值的字符串比较方法，并改为调用需要显式指定参数的方法。 若要通过使用当前区域性的字符串比较规则来确定某个字符串是否以特定子字符串开头，请使用 <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> 其参数的值调用方法重载 <see cref="F:System.StringComparison.CurrentCulture" /> <paramref name="comparisonType" /> 。</para></block>
        <altmember cref="M:System.String.EndsWith(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * StringComparison -&gt; bool" Usage="string.StartsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要比较的字符串。</param>
        <param name="comparisonType">枚举值之一，用于确定如何比较此字符串与 <paramref name="value" />。</param>
        <summary>确定在使用指定的比较选项进行比较时此字符串实例的开头是否与指定的字符串匹配。</summary>
        <returns>如果此实例以 <see langword="true" /> 开头，则为 <paramref name="value" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.String.StartsWith%2A>方法将 `value` 参数与此字符串开头的子字符串进行比较，并返回一个值，该值指示它们是否相等。 若要相等， `value` 必须是对此同一个字符串的引用，必须为空字符串 ( "" ) ，或者必须与此字符串的开头匹配。 方法所执行的比较的类型 <xref:System.String.StartsWith%2A> 取决于参数的值 `comparisonType` 。 比较可以使用当前区域性的约定 (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> 和 <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) 或固定区域性 (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> 和 <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>) ），也可以由代码点 (或) 的逐字符比较 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 。 比较也可以区分大小写 (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> 、 <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> 或 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>) ），也可以忽略大小写 (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> ， <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType> <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>) 。

## Examples
 下面的示例在字符串 "the" 中搜索以 "the" 开头的字符串。 如示例的输出所示，对 <xref:System.String.StartsWith(System.String%2CSystem.StringComparison)> 执行不区分区域性但区分大小写比较的方法的调用无法匹配字符串，而执行区域性和不区分大小写比较的调用与字符串匹配。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp" id="Snippet2":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb" id="Snippet2":::

 下面的示例确定字符串是否以特定子字符串开头。 它初始化二维字符串数组。 第二个维度中的第一个元素包含一个字符串，第二个元素包含在第一个字符串的开头搜索的字符串。 结果受区域性选择的影响，是否忽略大小写，以及是否执行序号比较。 请注意，当字符串实例包含连字时，具有其连续字符的区分区域性的比较成功匹配。

 [!code-cpp[System.String.StartsWith#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo? culture);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.StartsWith (value, ignoreCase, culture)" />
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">要比较的字符串。</param>
        <param name="ignoreCase">若要在比较过程中忽略大小写，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <param name="culture">确定如何对此字符串与 <paramref name="value" /> 进行比较的区域性信息。 如果 <paramref name="culture" /> 为 <see langword="null" />，则使用当前区域性。</param>
        <summary>确定在使用指定的区域性进行比较时此字符串实例的开头是否与指定的字符串匹配。</summary>
        <returns>如果 <see langword="true" /> 参数与此字符串的开头匹配，则为 <paramref name="value" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法将 `value` 参数与此字符串开头与相同的子字符串进行比较 `value` ，并返回一个值，该值指示它们是否相等。 若要相等， `value` 必须是 () 的空字符串 <xref:System.String.Empty?displayProperty=nameWithType> ，必须是对此同一个实例的引用，或者必须与此实例的开头匹配。

 此方法使用指定的大小写和区域性执行比较。

## Examples
 下面的示例确定字符串是否出现在另一个字符串的开头。 <xref:System.String.StartsWith%2A>方法使用区分大小写、不区分大小写和影响搜索结果的不同区域性多次调用。

 [!code-csharp[system.string.StartsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Substring">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>从此实例检索子字符串。

 重载此成员。 有关此成员的完整信息（包括语法、用法和示例），请单击重载列表中的相应名称。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : int -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">此实例中子字符串的起始字符位置（从零开始）。</param>
        <summary>从此实例检索子字符串。 子字符串在指定的字符位置开始并一直到该字符串的末尾。</summary>
        <returns>与此实例中在 <paramref name="startIndex" /> 处开头的子字符串等效的一个字符串；如果 <see cref="F:System.String.Empty" /> 等于此实例的长度，则为 <paramref name="startIndex" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 调用 <xref:System.String.Substring(System.Int32)> 方法可从字符串中提取从指定字符位置开始并在字符串末尾结束的子字符串。 起始字符位置是从零开始的;换句话说，字符串中的第一个字符位于索引0，而不是索引1。 若要提取从指定字符位置开始并在字符串末尾之前结束的子字符串，请调用 <xref:System.String.Substring(System.Int32%2CSystem.Int32)> 方法。

> [!NOTE]
> 此方法不会修改当前实例的值。 相反，它会返回从当前字符串中的位置开始的新字符串 `startIndex` 。

 若要提取以特定字符或字符序列开头的子字符串，请调用方法（如  <xref:System.String.IndexOf%2A> 或） <xref:System.String.IndexOf%2A> 来获取的值 `startIndex` 。 第二个示例对此进行了说明：它提取在 "=" 字符后开始一个字符位置的键值。

 如果 `startIndex` 等于零，则此方法返回未更改的原始字符串。
## Examples
 下面的示例演示如何从字符串中获取子字符串。

 [!code-cpp[System.String.Substring#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp-interactive[System.String.Substring#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]

 下面的示例使用 <xref:System.String.Substring%2A> 方法将由 equals ( "=" 分隔的键/值对 ) 字符分隔开。

 [!code-csharp-interactive[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]

 <xref:System.String.IndexOf%2A>方法用于获取字符串中 equals 字符的位置。 对方法的调用 <xref:System.String.Substring(System.Int32%2CSystem.Int32)> 提取键名称，该键名称从字符串中的第一个字符开始，并针对对方法的调用返回的字符数进行扩展 <xref:System.String.IndexOf%2A> 。 然后，对方法的调用将 <xref:System.String.Substring(System.Int32)> 提取分配给该密钥的值。 它从 equals 字符之外的一个字符位置开始，并扩展到字符串的末尾。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 小于零或大于此实例的长度。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Substring : int * int -&gt; string" Usage="string.Substring (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">此实例中子字符串的起始字符位置（从零开始）。</param>
        <param name="length">子字符串中的字符数。</param>
        <summary>从此实例检索子字符串。 子字符串从指定的字符位置开始且具有指定的长度。</summary>
        <returns>与此实例中在 <paramref name="length" /> 处开头、长度为 <paramref name="startIndex" /> 的子字符串等效的一个字符串；如果 <see cref="F:System.String.Empty" /> 等于此实例的长度且 <paramref name="startIndex" /> 为零，则为 <paramref name="length" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 调用 <xref:System.String.Substring(System.Int32%2CSystem.Int32)> 方法可从字符串中提取从指定字符位置开始并在字符串末尾之前结束的子字符串。 起始字符位置是从零开始的;换句话说，字符串中的第一个字符位于索引0，而不是索引1。 若要提取从指定字符位置开始并持续到字符串末尾的子字符串，请调用 <xref:System.String.Substring(System.Int32)> 方法。

> [!NOTE]
> 此方法不会修改当前实例的值。 相反，它会返回一个新字符串，其中包含 `length` 从 `startIndex` 当前字符串中的位置开始的字符。

 `length`参数表示要从当前字符串实例中提取的字符的总数。 这包括索引处的起始字符  `startIndex` 。  换言之，此 <xref:System.String.Substring%2A> 方法尝试从索引 `startIndex` 到索引 `startIndex`  +  `length` -1 提取字符。

 若要提取以特定字符或字符序列开头的子字符串，请调用方法（如  <xref:System.String.IndexOf%2A> 或） <xref:System.String.LastIndexOf%2A> 来获取的值 `startIndex` 。

 如果子字符串从扩展 `startIndex` 到指定的字符序列，则可以调用方法（如  <xref:System.String.IndexOf%2A> 或） <xref:System.String.LastIndexOf%2A> 来获取结束字符或字符序列的索引。  然后，可以将该值转换为字符串中的索引位置，如下所示：

- 如果已搜索要标记子字符串末尾的单个字符，则 `length` 参数等于 `endIndex`  -  `startIndex` + 1，其中 `endIndex` 是或方法的返回值 <xref:System.String.IndexOf%2A> <xref:System.String.IndexOf%2A> 。 下面的示例从字符串中提取 "b" 字符的连续块。

     [!code-csharp-interactive[System.String.Substring#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]

- 如果已搜索多个字符来标记子字符串的末尾，则 `length` 参数等于 `endIndex`  +  `endMatchLength`  -  `startIndex` ，其中 `endIndex` 是或方法的返回值 <xref:System.String.IndexOf%2A> <xref:System.String.IndexOf%2A> ， `endMatchLength` 是标记子字符串末尾的字符序列的长度。 下面的示例提取包含 XML 元素的文本块 `<definition>` 。

     [!code-csharp-interactive[System.String.Substring#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]

- 如果字符或字符序列未包含在子字符串的末尾，则 `length` 参数等于 `endIndex`  -  `startIndex` ，其中 `endIndex` 是或方法的返回值 <xref:System.String.IndexOf%2A> <xref:System.String.IndexOf%2A> 。

 如果 `startIndex` 等于零并且等于当前字符串的长度，则此方法返回未更改的原始字符串。

## Examples
 下面的示例演示了一个简单的 <xref:System.String.Substring(System.Int32%2CSystem.Int32)> 方法调用方法，该方法从第六个字符位置开始的字符串中提取两个字符， (即索引为 5) 。

 [!code-csharp-interactive[System.String.Substring#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]

 下面的示例使用 <xref:System.String.Substring(System.Int32%2CSystem.Int32)> 以下三种情况中的方法来隔离字符串中的子字符串。 在两种情况下，将在比较中使用子字符串，在第三种情况下将引发异常，因为指定了无效的参数。

- 它提取索引) 2 处的字符串 (中的单个字符和第三个位置，并将其与 "c" 进行比较。 此比较返回 `true` 。

- 它从索引 3) 的字符串 (中的第四个位置提取零个字符，并将其传递给 <xref:System.String.IsNullOrEmpty%2A> 方法。 此方法返回 true，因为对方法的调用将 <xref:System.String.Substring%2A> 返回 <xref:System.String.Empty?displayProperty=nameWithType> 。

- 它将尝试从字符串中的第四个位置提取一个字符。 由于该位置没有任何字符，因此方法调用会引发 <xref:System.ArgumentOutOfRangeException> 异常。

 [!code-csharp-interactive[Classic String.Substring1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]

 下面的示例使用 <xref:System.String.Substring%2A> 方法将由 equals ( "=" 分隔的键/值对 ) 字符分隔开。

 [!code-csharp-interactive[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]

 <xref:System.String.IndexOf%2A>方法用于获取字符串中 equals 字符的位置。 对方法的调用 <xref:System.String.Substring(System.Int32%2CSystem.Int32)> 提取键名称，该键名称从字符串中的第一个字符开始，并针对对方法的调用返回的字符数进行扩展 <xref:System.String.IndexOf%2A> 。 然后，对方法的调用将 <xref:System.String.Substring(System.Int32)> 提取分配给该密钥的值。 它从 equals 字符之外的一个字符位置开始，并扩展到字符串的末尾。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 加 <paramref name="length" /> 指示不在此实例内的位置。

- 或 -

 <paramref name="startIndex" /> 或 <paramref name="length" /> 小于零。</exception>
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator" ExplicitInterfaceMemberName="System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Char) Implements IEnumerable(Of Char).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;char&gt; ^ System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;char&gt;::GetEnumerator;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;char&gt;&#xA;override this.System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;char&gt;" Usage="string.System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回循环访问当前 <see cref="T:System.String" /> 对象的枚举数。</summary>
        <returns>可用于循环访问当前 <see cref="T:System.String" /> 对象的强类型化枚举器。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此成员是显式接口成员的实现。 它只能在 <xref:System.String> 实例被强制转换为接口对象时使用 <xref:System.Collections.Generic.IEnumerable%601> 。 有关更多信息，请参见 <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> 方法。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IEnumerable.GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.System.Collections.IEnumerable.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="string.System.Collections.IEnumerable.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回循环访问当前 <see cref="T:System.String" /> 对象的枚举数。</summary>
        <returns>一个枚举器，可用于循环访问当前的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此成员是显式接口成员的实现。 它只能在 <xref:System.String> 实例被强制转换为 <xref:System.Collections.IEnumerable> 接口时使用。 有关更多信息，请参见 <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> 方法。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberSignature Language="F#" Value="abstract member System.IComparable.CompareTo : obj -&gt; int&#xA;override this.System.IComparable.CompareTo : obj -&gt; int" Usage="string.System.IComparable.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value">一个对象，其计算结果为 <see cref="T:System.String" />。</param>
        <summary>将此实例与指定的 <see cref="T:System.Object" /> 进行比较，并指示此实例在排序顺序中是位于指定的 <see cref="T:System.Object" /> 之前、之后还是与其出现在同一位置。</summary>
        <returns>一个 32 位带符号整数，该整数指示此实例在排序顺序中是位于 <paramref name="value" /> 参数之前、之后还是与其出现在同一位置。

<list type="table"><listheader><term>“值”</term><description>条件</description></listheader><item><term>小于零</term><description>此实例位于 <paramref name="value" /> 之前。</description></item><item><term>零</term><description>此实例在排序顺序中的位置与 <paramref name="value" /> 相同。</description></item><item><term>大于零</term><description>此实例位于 <paramref name="value" /> 之后，或 <paramref name="value" /> 为 <see langword="null" />。</description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

`value` 必须是一个 <xref:System.String> 对象。

> [!CAUTION]
> 此 <xref:System.String.CompareTo%2A> 方法主要用于排序或 alphabetizing 操作。 当方法调用的主要目的是确定两个字符串是否相等时，不应使用此方法。 若要确定两个字符串是否相等，请调用 <xref:System.String.Equals%2A> 方法。

此方法使用当前区域性执行区分大小写的 (区分大小写的) 比较。 有关 word、字符串和顺序排序的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 。

有关此方法的行为的详细信息，请参阅方法的 "备注" 部分 <xref:System.String.Compare(System.String%2CSystem.String)?displayProperty=nameWithType> 。

## Examples

下面的示例将 <xref:System.String.CompareTo%2A> 方法与一起使用 <xref:System.Object> 。 因为它尝试将实例与 <xref:System.String> 对象进行比较 `TestClass` ，所以方法会引发 <xref:System.ArgumentException> 。

[!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
[!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
[!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> 不是 <see cref="T:System.String" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.GetTypeCode : unit -&gt; TypeCode&#xA;override this.System.IConvertible.GetTypeCode : unit -&gt; TypeCode" Usage="string.System.IConvertible.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回 <see cref="T:System.String" /> 类的 <see cref="T:System.TypeCode" />。</summary>
        <returns>枚举常数 <see cref="F:System.TypeCode.String" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples

下面的示例显示了 <xref:System.TypeCode> 类型的枚举常数 <xref:System.String> 。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb" id="Snippet1":::

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToBoolean : IFormatProvider -&gt; bool&#xA;override this.System.IConvertible.ToBoolean : IFormatProvider -&gt; bool" Usage="string.System.IConvertible.ToBoolean provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">忽略此参数。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />。</summary>
        <returns>如果当前字符串的值为 <see langword="true" />，则为 <see cref="F:System.Boolean.TrueString" />；如果当前字符串的值为 <see langword="false" />，则为 <see cref="F:System.Boolean.FalseString" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此成员是显式接口成员的实现。 它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代方法是调用 <xref:System.Convert.ToBoolean(System.String)?displayProperty=nameWithType> 方法。

 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">当前字符串的值不为 <see cref="F:System.Boolean.TrueString" /> 或 <see cref="F:System.Boolean.FalseString" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToByte : IFormatProvider -&gt; byte&#xA;override this.System.IConvertible.ToByte : IFormatProvider -&gt; byte" Usage="string.System.IConvertible.ToByte provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个对象，提供区域性特定的格式设置信息。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />。</summary>
        <returns>当前 <see cref="T:System.String" /> 对象的转换值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此成员是显式接口成员的实现。 它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代方法是调用 <xref:System.Convert.ToByte(System.String%2CSystem.IFormatProvider)?displayProperty=nameWithType> 方法。

 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">无法分析当前 <see cref="T:System.String" /> 对象的值。</exception>
        <exception cref="T:System.OverflowException">当前 <see cref="T:System.String" /> 对象的值是一个大于 <see cref="F:System.Byte.MaxValue" /> 或小于 <see cref="F:System.Byte.MinValue" /> 的数字。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToChar : IFormatProvider -&gt; char&#xA;override this.System.IConvertible.ToChar : IFormatProvider -&gt; char" Usage="string.System.IConvertible.ToChar provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个对象，提供区域性特定的格式设置信息。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />。</summary>
        <returns>当前 <see cref="T:System.String" /> 对象中索引 0 处的字符。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此成员是显式接口成员的实现。 它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代方法是调用 <xref:System.Convert.ToChar(System.String%2CSystem.IFormatProvider)?displayProperty=nameWithType> 方法。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDateTime : IFormatProvider -&gt; DateTime&#xA;override this.System.IConvertible.ToDateTime : IFormatProvider -&gt; DateTime" Usage="string.System.IConvertible.ToDateTime provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个对象，提供区域性特定的格式设置信息。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />。</summary>
        <returns>当前 <see cref="T:System.String" /> 对象的转换值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此成员是显式接口成员的实现。 它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代方法是调用 <xref:System.Convert.ToDateTime(System.String%2CSystem.IFormatProvider)?displayProperty=nameWithType> 方法。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDecimal : IFormatProvider -&gt; decimal&#xA;override this.System.IConvertible.ToDecimal : IFormatProvider -&gt; decimal" Usage="string.System.IConvertible.ToDecimal provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个对象，提供区域性特定的格式设置信息。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />。</summary>
        <returns>当前 <see cref="T:System.String" /> 对象的转换值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此成员是显式接口成员的实现。 它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代方法是调用 <xref:System.Convert.ToDecimal(System.String%2CSystem.IFormatProvider)?displayProperty=nameWithType> 方法。

 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">无法分析当前 <see cref="T:System.String" /> 对象的值。</exception>
        <exception cref="T:System.OverflowException">当前 <see cref="T:System.String" /> 对象的值是一个小于 <see cref="F:System.Decimal.MinValue" /> 或大于 <see cref="F:System.Decimal.MaxValue" /> 的数字。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDouble : IFormatProvider -&gt; double&#xA;override this.System.IConvertible.ToDouble : IFormatProvider -&gt; double" Usage="string.System.IConvertible.ToDouble provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个对象，提供区域性特定的格式设置信息。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />。</summary>
        <returns>当前 <see cref="T:System.String" /> 对象的转换值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此成员是显式接口成员的实现。 它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代方法是调用 <xref:System.Convert.ToDouble(System.String%2CSystem.IFormatProvider)?displayProperty=nameWithType> 方法。

 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">无法分析当前 <see cref="T:System.String" /> 对象的值。</exception>
        <exception cref="T:System.OverflowException">当前 <see cref="T:System.String" /> 对象的值是一个小于 <see cref="F:System.Double.MinValue" /> 或大于 <see cref="F:System.Double.MaxValue" /> 的数字。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt16 : IFormatProvider -&gt; int16&#xA;override this.System.IConvertible.ToInt16 : IFormatProvider -&gt; int16" Usage="string.System.IConvertible.ToInt16 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个对象，提供区域性特定的格式设置信息。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />。</summary>
        <returns>当前 <see cref="T:System.String" /> 对象的转换值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此成员是显式接口成员的实现。 它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代方法是调用 <xref:System.Convert.ToInt16(System.String%2CSystem.IFormatProvider)?displayProperty=nameWithType> 方法。

 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">无法分析当前 <see cref="T:System.String" /> 对象的值。</exception>
        <exception cref="T:System.OverflowException">当前 <see cref="T:System.String" /> 对象的值是一个大于 <see cref="F:System.Int16.MaxValue" /> 或小于 <see cref="F:System.Int16.MinValue" /> 的数字。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt32 : IFormatProvider -&gt; int&#xA;override this.System.IConvertible.ToInt32 : IFormatProvider -&gt; int" Usage="string.System.IConvertible.ToInt32 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个对象，提供区域性特定的格式设置信息。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />。</summary>
        <returns>当前 <see cref="T:System.String" /> 对象的转换值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此成员是显式接口成员的实现。 它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代方法是调用 <xref:System.Convert.ToInt32(System.String%2CSystem.IFormatProvider)?displayProperty=nameWithType> 方法。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt64 : IFormatProvider -&gt; int64&#xA;override this.System.IConvertible.ToInt64 : IFormatProvider -&gt; int64" Usage="string.System.IConvertible.ToInt64 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个对象，提供区域性特定的格式设置信息。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />。</summary>
        <returns>当前 <see cref="T:System.String" /> 对象的转换值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此成员是显式接口成员的实现。 它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代方法是调用 <xref:System.Convert.ToInt64(System.String%2CSystem.IFormatProvider)?displayProperty=nameWithType> 方法。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToSByte : IFormatProvider -&gt; sbyte&#xA;override this.System.IConvertible.ToSByte : IFormatProvider -&gt; sbyte" Usage="string.System.IConvertible.ToSByte provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个对象，提供区域性特定的格式设置信息。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />。</summary>
        <returns>当前 <see cref="T:System.String" /> 对象的转换值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此成员是显式接口成员的实现。 它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代方法是调用 <xref:System.Convert.ToSByte(System.String%2CSystem.IFormatProvider)?displayProperty=nameWithType> 方法。

 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">无法分析当前 <see cref="T:System.String" /> 对象的值。</exception>
        <exception cref="T:System.OverflowException">当前 <see cref="T:System.String" /> 对象的值是一个大于 <see cref="F:System.SByte.MaxValue" /> 或小于 <see cref="F:System.SByte.MinValue" /> 的数字。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToSingle : IFormatProvider -&gt; single&#xA;override this.System.IConvertible.ToSingle : IFormatProvider -&gt; single" Usage="string.System.IConvertible.ToSingle provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个对象，提供区域性特定的格式设置信息。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />。</summary>
        <returns>当前 <see cref="T:System.String" /> 对象的转换值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此成员是显式接口成员的实现。 它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代方法是调用 <xref:System.Convert.ToSingle(System.String%2CSystem.IFormatProvider)?displayProperty=nameWithType> 方法。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToString : IFormatProvider -&gt; string&#xA;override this.System.IConvertible.ToString : IFormatProvider -&gt; string" Usage="string.System.IConvertible.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。

- 或 -

若为 <see langword="null" />，则使用当前区域性的格式设置约定。</param>
        <summary>有关此成员的说明，请参见 <see cref="T:System.IConvertible.ToString(System.IFormatProvider)" />。</summary>
        <returns>与此实例的值等效的 <see cref="T:System.String" /> 实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

此成员是显式接口成员的实现。 它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToType (type As Type, provider As IFormatProvider) As Object Implements IConvertible.ToType" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToType : Type * IFormatProvider -&gt; obj&#xA;override this.System.IConvertible.ToType : Type * IFormatProvider -&gt; obj" Usage="string.System.IConvertible.ToType (type, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">返回对象的类型。</param>
        <param name="provider">一个对象，提供区域性特定的格式设置信息。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />。</summary>
        <returns>当前 <see cref="T:System.String" /> 对象的转换值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此成员是显式接口成员的实现。 它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代方法是调用 <xref:System.Convert.ChangeType%2A> 方法。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidCastException">当前 <see cref="T:System.String" /> 对象的值不能转换为 <paramref name="type" /> 参数指定的类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt16 : IFormatProvider -&gt; uint16&#xA;override this.System.IConvertible.ToUInt16 : IFormatProvider -&gt; uint16" Usage="string.System.IConvertible.ToUInt16 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个对象，提供区域性特定的格式设置信息。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />。</summary>
        <returns>当前 <see cref="T:System.String" /> 对象的转换值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此成员是显式接口成员的实现。 它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代方法是调用 <xref:System.Convert.ToUInt16(System.String%2CSystem.IFormatProvider)?displayProperty=nameWithType> 方法。

 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">无法分析当前 <see cref="T:System.String" /> 对象的值。</exception>
        <exception cref="T:System.OverflowException">当前 <see cref="T:System.String" /> 对象的值是一个大于 <see cref="F:System.UInt16.MaxValue" /> 或小于 <see cref="F:System.UInt16.MinValue" /> 的数字。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt32 : IFormatProvider -&gt; uint32&#xA;override this.System.IConvertible.ToUInt32 : IFormatProvider -&gt; uint32" Usage="string.System.IConvertible.ToUInt32 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个对象，提供区域性特定的格式设置信息。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />。</summary>
        <returns>当前 <see cref="T:System.String" /> 对象的转换值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此成员是显式接口成员的实现。 它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代方法是调用 <xref:System.Convert.ToUInt32(System.String%2CSystem.IFormatProvider)?displayProperty=nameWithType> 方法。

 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">无法分析当前 <see cref="T:System.String" /> 对象的值。</exception>
        <exception cref="T:System.OverflowException">当前 <see cref="T:System.String" /> 对象的值是一个大于 <see cref="F:System.UInt32.MaxValue" /> 或小于 <see cref="F:System.UInt32.MinValue" /> 的数字。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt64 : IFormatProvider -&gt; uint64&#xA;override this.System.IConvertible.ToUInt64 : IFormatProvider -&gt; uint64" Usage="string.System.IConvertible.ToUInt64 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个对象，提供区域性特定的格式设置信息。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />。</summary>
        <returns>当前 <see cref="T:System.String" /> 对象的转换值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此成员是显式接口成员的实现。 它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代方法是调用 <xref:System.Convert.ToUInt64(System.String%2CSystem.IFormatProvider)?displayProperty=nameWithType> 方法。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToCharArray">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将此实例中的字符复制到 Unicode 字符数组。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray();" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : unit -&gt; char[]" Usage="string.ToCharArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将此实例中的字符复制到 Unicode 字符数组。</summary>
        <returns>元素为此实例的各字符的 Unicode 字符数组。 如果此实例是空字符串，则返回的数组为空且长度为零。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法将每个字符 (（即，每个对象都) 字符串中的每个对象）复制 <xref:System.Char> 到一个字符数组中。 复制的第一个字符位于返回的字符数组的索引零处;最后复制的字符位于索引 <xref:System.Array.Length%2A?displayProperty=nameWithType> -1 处。

 若要从字符数组中的字符创建字符串，请调用 <xref:System.String.%23ctor(System.Char%5B%5D)> 构造函数。

 若要创建包含字符串中已编码字符的字节数组，请实例化相应的 <xref:System.Text.Encoding> 对象并调用其 <xref:System.Text.Encoding.GetBytes(System.String)?displayProperty=nameWithType> 方法。 .NET 中可用的一些标准编码包括：

|编码|对象|
|--------------|------------|
|ASCII|<xref:System.Text.ASCIIEncoding>|
|UTF-7|<xref:System.Text.UTF7Encoding>|
|UTF-8|<xref:System.Text.UTF8Encoding>|
|UTF-16|<xref:System.Text.UnicodeEncoding>|
|UTF-32|<xref:System.Text.UTF32Encoding>|

 有关详细信息，请参阅 [.net 中的字符编码](/dotnet/standard/base-types/character-encoding)。

## Examples
 下面的示例调用 <xref:System.String.ToCharArray%2A> 方法将字符串中的字符提取到字符数组中。 然后，它显示数组中的原始字符串和元素。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray (startIndex As Integer, length As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : int * int -&gt; char[]" Usage="string.ToCharArray (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">此实例内子字符串的起始位置。</param>
        <param name="length">此实例内子字符串的长度。</param>
        <summary>将此实例中的指定子字符串内的字符复制到 Unicode 字符数组。</summary>
        <returns>元素为此实例中从字符位置 <paramref name="length" /> 开始的 <paramref name="startIndex" /> 字符数的 Unicode 字符数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法将一部分字符串中的字符复制到字符数组。 若要从字符数组的字符范围中创建字符串，请调用  <xref:System.String.%23ctor(System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32)> 构造函数。

 `startIndex`参数是从零开始的。 也就是说，字符串实例中第一个字符的索引为零。

 如果 `length` 为零，则返回的数组为空且长度为零。 如果此实例为 `null` 或空字符串 ( "" ) ，则返回的数组为空且长度为零。

 若要创建包含字符串的一部分中编码字符的字节数组，请实例化相应的 <xref:System.Text.Encoding> 对象并调用其 <xref:System.Text.Encoding.GetBytes(System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32)> 方法。 .NET 中可用的一些标准编码包括：

|编码|对象|
|--------------|------------|
|ASCII|<xref:System.Text.ASCIIEncoding>|
|UTF-7|<xref:System.Text.UTF7Encoding>|
|UTF-8|<xref:System.Text.UTF8Encoding>|
|UTF-16|<xref:System.Text.UnicodeEncoding>|
|UTF-32|<xref:System.Text.UTF32Encoding>|

 有关详细信息，请参阅 [.net 中的字符编码](/dotnet/standard/base-types/character-encoding)。

## Examples
 下面的示例将字符串中的子字符串转换为字符数组，然后枚举并显示该数组的元素。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 或 <paramref name="length" /> 小于零。

- 或 -

 <paramref name="startIndex" /> 加 <paramref name="length" /> 大于此实例的长度。</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回此字符串转换为小写形式的副本。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower();" />
      <MemberSignature Language="F#" Value="member this.ToLower : unit -&gt; string" Usage="string.ToLower " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此字符串转换为小写形式的副本。</summary>
        <returns>一个小写字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法将考虑当前区域性的大小写规则。

> [!NOTE]
> 此方法不会修改当前实例的值。 相反，它会返回一个新字符串，其中当前实例中的所有字符都转换为小写。

## <a name="security-considerations"></a>安全注意事项
 通过调用方法生成的大小写操作将 <xref:System.String.ToLower> 使用当前区域性的大小写约定。 如果需要操作系统标识符的小写或大写版本，如文件名、命名管道或注册表项，请使用 <xref:System.String.ToLowerInvariant%2A> 或 <xref:System.String.ToUpperInvariant%2A> 方法。 与方法不同，每个区域性 (生成相同的结果 <xref:System.String.ToLower> ，) 并更有效地执行。

## Examples
 下面的示例将几个大小写混合的字符串转换为小写。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>如 [使用字符串的最佳做法](/dotnet/standard/base-types/best-practices-strings)中所述，建议你避免调用替换默认值的字符串大小写方法，而是调用需要显式指定参数的方法。 若要使用当前区域性的大小写约定将字符转换为小写，请使用 <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> 其参数的值调用方法重载 <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> <paramref name="culture" /> 。</para></block>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo? culture);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToLower : System.Globalization.CultureInfo -&gt; string" Usage="string.ToLower culture" />
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="culture">一个对象，用于提供区域性特定的大小写规则。</param>
        <summary>根据指定区域性的大小写规则返回此字符串转换为小写形式的副本。</summary>
        <returns>当前字符串的等效小写形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 参数指定的区域性的大小写规则 `culture` 确定了字符串大小写的更改方式。

> [!NOTE]
> 此方法不会修改当前实例的值。 相反，它会返回一个新字符串，其中当前实例中的所有字符都转换为小写。

## <a name="security-considerations"></a>安全注意事项
 如果将方法传递 <xref:System.String.ToLower(System.Globalization.CultureInfo)> <xref:System.Globalization.CultureInfo> 到之外的对象 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> ，则大小写操作将考虑特定于区域性的规则。 如果需要操作系统标识符的小写或大写版本，如文件名、命名管道或注册表项，请使用 <xref:System.String.ToLowerInvariant%2A> 或 <xref:System.String.ToUpperInvariant%2A> 方法。 这会在每个区域性中产生相同的结果并更有效地执行。

## Examples
 下面的示例使用 English-United 状态和 Turkish-Turkey 区域性将大写字符的两个字符串转换为小写字符，然后比较小写字符串。 大写字符串完全相同，只是对于一个字符串中的每个 Unicode 大写字母 I 的每个匹配项，另一个字符串包含上面带点的拉丁文大写字母 I。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.ToUpper" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLowerInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLowerInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToLowerInvariant : unit -&gt; string" Usage="string.ToLowerInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此 <see cref="T:System.String" /> 对象的转换为小写形式的副本，返回时使用固定区域性的大小写规则。</summary>
        <returns>当前字符串的等效小写形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 固定区域性表示不区分区域性的区域性。 它与英语相关联，而不是与特定国家或地区相关联。 有关更多信息，请参见 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 属性。

 如果你的应用程序依赖于以可预测方式（不受当前区域性影响）更改的字符串，请使用 <xref:System.String.ToLowerInvariant%2A> 方法。 <xref:System.String.ToLowerInvariant%2A>方法等效于 `ToLower(CultureInfo.InvariantCulture)` 。 如果在用户界面控件中必须按可预测顺序显示字符串集合，则建议使用方法。

> [!NOTE]
> 此方法不会修改当前实例的值。 相反，它会返回一个新字符串，其中当前实例中的所有字符都转换为小写。

## <a name="security-considerations"></a>安全注意事项
 如果需要操作系统标识符的小写或大写版本，如文件名、命名管道或注册表项，请使用 <xref:System.String.ToLowerInvariant%2A> 或 <xref:System.String.ToUpperInvariant%2A> 方法。

## Examples
 下面的示例定义了一个字符串数组，其中包含多种语言的单个单词。 <xref:System.String.ToLowerInvariant%2A>方法用于使用每个单词的不区分大小写的版本填充并行数组的元素。 <xref:System.Array.Sort%60%602(%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D)?displayProperty=nameWithType>方法用于根据小写数组中元素的顺序对区分大小写的数组进行排序，以确保元素按与语言无关的顺序显示。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpperInvariant" />
        <altmember cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将此实例的值转换为 <see cref="T:System.String" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="string.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回 <see cref="T:System.String" /> 的此实例；不执行实际转换。</summary>
        <returns>当前的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 由于此方法只是返回未更改的当前字符串，因此不需要直接调用它。 它通常在复合格式设置操作中进行隐式调用，如示例所示。

## Examples
 下面的示例演示 <xref:System.String.ToString%2A> 方法。请注意，该示例不显式调用 <xref:System.String.ToString%2A> 方法。 相反，该方法由 [复合格式设置](/dotnet/standard/base-types/composite-formatting) 功能隐式调用。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Clone" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider? provider);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="string.ToString provider" />
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="provider">（保留）一个对象，用于提供区域性特定的格式设置信息。</param>
        <summary>返回 <see cref="T:System.String" /> 的此实例；不执行实际转换。</summary>
        <returns>当前的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `provider` 保留，并且当前不参与此操作。

 由于此方法只是返回未更改的当前字符串，因此不需要直接调用它。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回此字符串转换为大写形式的副本。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper();" />
      <MemberSignature Language="F#" Value="member this.ToUpper : unit -&gt; string" Usage="string.ToUpper " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此字符串转换为大写形式的副本。</summary>
        <returns>当前字符串的大写形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法使用当前区域性的大小写规则将当前实例中的每个字符转换为其大写等效项。 如果某个字符没有大写等效项，则在返回的字符串中包含不变的字符串。

> [!NOTE]
> 此方法不会修改当前实例的值。 相反，它会返回一个新字符串，其中当前实例中的所有字符都转换为大写形式。

 <xref:System.String.ToUpper%2A>方法通常用于将字符串转换为大写，以便可以在不区分大小写的比较中使用。 要执行不区分大小写的比较，更好的方法是调用具有参数的参数的字符串比较方法，此 <xref:System.StringComparison> 参数的值为 <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> 区分区域性、不区分大小写的比较。

## <a name="security-considerations"></a>安全注意事项
 通过调用方法生成的大小写操作将 <xref:System.String.ToUpper> 使用当前区域性的大小写约定。 如果需要操作系统标识符的小写或大写版本，如文件名、命名管道或注册表项，请使用 <xref:System.String.ToLowerInvariant%2A> 或 <xref:System.String.ToUpperInvariant%2A> 方法。 与方法不同，每个区域性 (生成相同的结果 <xref:System.String.ToUpper> ，) 并更有效地执行。

## Examples
 下面的示例调用 <xref:System.String.ToUpper%2A> 方法来转换包含基本拉丁语、拉丁语-1 补充和拉丁语扩展字符集中的每个字符的一系列单字符字符串。 然后，它会显示其大写字符与小写字符不同的每个字符串。

 [!code-cpp[System.String.ToUpper#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]

 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>如 [使用字符串的最佳做法](/dotnet/standard/base-types/best-practices-strings)中所述，建议你避免调用替换默认值的字符串大小写方法，而是调用需要显式指定参数的方法。 若要使用当前区域性的大小写约定将字符串转换为大写，请使用的 <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> 参数的值调用方法重载 <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> <paramref name="culture" /> 。</para></block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo? culture);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToUpper : System.Globalization.CultureInfo -&gt; string" Usage="string.ToUpper culture" />
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="culture">一个对象，用于提供区域性特定的大小写规则。</param>
        <summary>根据指定区域性的大小写规则返回此字符串转换为大写形式的副本。</summary>
        <returns>当前字符串的大写形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 由参数指定的区域性的大小写规则 `culture` 确定字符串大小写的更改方式。

> [!NOTE]
> 此方法不会修改当前实例的值。 相反，它会返回一个新字符串，其中当前实例中的所有字符都转换为大写形式。

## <a name="security-considerations"></a>安全注意事项
 如果将方法传递 <xref:System.String.ToUpper(System.Globalization.CultureInfo)> <xref:System.Globalization.CultureInfo> 到之外的对象 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> ，则大小写操作将考虑特定于区域性的规则。 如果需要操作系统标识符的小写或大写版本，如文件名、命名管道或注册表项，请使用 <xref:System.String.ToLowerInvariant%2A> 或 <xref:System.String.ToUpperInvariant%2A> 方法。 这会在每个区域性中产生相同的结果并更有效地执行。

## Examples
 下面的示例使用 English-United 状态和 Turkish-Turkey 区域性将小写字符字符串转换为大写字符的两个字符串，然后对大写字符串进行比较。 大写字符串完全相同，只是对于一个字符串中的每个 Unicode 大写字母 I 的每个匹配项，另一个字符串包含上面带点的拉丁文大写字母 I。

 [!code-csharp[string.toupper1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpperInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpperInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToUpperInvariant : unit -&gt; string" Usage="string.ToUpperInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此 <see cref="T:System.String" /> 对象的转换为大写形式的副本，返回时使用固定区域性的大小写规则。</summary>
        <returns>当前字符串的大写形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 固定区域性表示不区分区域性的区域性。 它与英语相关联，而不是与特定国家或地区相关联。 有关更多信息，请参见 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 属性。

 如果你的应用程序依赖于以可预测方式（不受当前区域性影响）更改的字符串，请使用 <xref:System.String.ToUpperInvariant%2A> 方法。 <xref:System.String.ToUpperInvariant%2A>方法等效于 `ToUpper(CultureInfo.InvariantCulture)` 。 如果在用户界面控件中必须按可预测顺序显示字符串集合，则建议使用方法。

> [!NOTE]
> 此方法不会修改当前实例的值。 相反，它会返回一个新字符串，其中当前实例中的所有字符都转换为大写形式。

## <a name="security-considerations"></a>安全注意事项
 如果需要操作系统标识符的小写或大写版本，如文件名、命名管道或注册表项，请使用 <xref:System.String.ToLowerInvariant%2A> 或 <xref:System.String.ToUpperInvariant%2A> 方法。

## Examples
 下面的示例定义了一个字符串数组，其中包含多种语言的单个单词。 <xref:System.String.ToUpperInvariant%2A>方法用于使用每个单词的不区分大小写的版本填充并行数组的元素。 <xref:System.Array.Sort%60%602(%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D)?displayProperty=nameWithType>方法用于根据大写数组中元素的顺序对区分大小写的数组进行排序，以确保元素按与语言无关的顺序显示。

 [!code-csharp[System.String.ToUpperInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Trim">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个新字符串，它相当于从当前字符串中删除了一组指定字符的所有前导匹配项和尾随匹配项。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim();" />
      <MemberSignature Language="F#" Value="member this.Trim : unit -&gt; string" Usage="string.Trim " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从当前字符串删除所有前导空白字符和尾随空白字符。</summary>
        <returns>从当前字符串的开头和结尾删除所有空白字符后剩余的字符串。 如果从当前实例无法删除字符，此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

`Trim`方法从当前字符串中删除所有前导和尾随空白字符。 遇到非空白字符时，每个前导和尾随修整操作都会停止。 例如，如果当前字符串为 "abc xyz"，则该 `Trim` 方法返回 "abc xyz"。 若要删除字符串中的单词之间的空白字符，请使用 [.Net 正则表达式](/dotnet/standard/base-types/regular-expressions)。

> [!NOTE]
> 如果该 `Trim` 方法从当前实例中移除所有字符，则此方法不会修改当前实例的值。 相反，它会返回一个新字符串，其中将删除当前实例中找到的所有前导和尾随空格字符。

如果当前字符串等于 <xref:System.String.Empty?displayProperty=nameWithtype> 或当前实例中的所有字符都包含空白字符，则该方法将返回 <xref:System.String.Empty?displayProperty=nameWithtype> 。

空白字符由 Unicode 标准定义。 `Trim`方法在将生成返回值的所有前导和尾随字符 `true` 传递给方法时，删除这些字符 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 。

## Examples

下面的示例使用方法在连接 <xref:System.String.Trim?displayProperty=nameWithType> 之前从用户输入的字符串中删除任何多余的空格。

[!code-cpp[System.String.Trim#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
[!code-csharp[System.String.Trim#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
[!code-vb[System.String.Trim#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]

          ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和早期版本维护此方法修整的空白字符的内部列表。 从开始 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] ，方法会剪裁所有 Unicode 空白字符， (也就是说，在将 <see langword="true" /> 其传递到方法) 时生成返回值的字符 <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> 。 由于此更改，和更 <see cref="M:System.String.Trim" /> 早版本中的方法将 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 删除两个字符，零宽度空间 (u + 200B) 和零宽度无间断空格 (U + FEFF) ，则 <see cref="M:System.String.Trim" /> [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 和更高版本中的方法不会删除。 此外， <see cref="M:System.String.Trim" /> [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 和更早版本中的方法不会剪裁三个 Unicode 空白字符：蒙古语元音分隔符 (u + 180E) 、窄的无中断空格 (u + 202F) 和中等数学空间 (u + 205F) 。</para></block>
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.Trim : char -&gt; string" Usage="string.Trim trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="trimChar">要删除的 Unicode 字符。</param>
        <summary>从当前字符串删除字符的所有前导实例和尾随实例。</summary>
        <returns>从当前字符串的开头和结尾删除 <paramref name="trimChar" /> 字符的所有实例后剩余的字符串。 如果从当前实例无法删除字符，此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

`Trim(System.Char)`方法从当前字符串中删除该字符的所有前导和尾随实例 `trimChar` 。 当遇到与不同的字符时，每个前导和尾随修整操作都会停止 `trimChar` 。 例如，如果 `trimChar` 为， `-` 并且当前字符串为 "---abc---xyz----"，则该 `Trim(System.Char)` 方法返回 "abc---xyz"。 若要删除字符串中的单词之间的字符，请使用 [.Net 正则表达式](/dotnet/standard/base-types/regular-expressions)。

> [!NOTE]
> 如果该 `Trim(System.Char)` 方法从当前实例中移除所有字符，则此方法不会修改当前实例的值。 相反，它会返回一个新字符串，其中将删除在 `trimChar` 当前实例中找到的所有前导和尾随字符。

如果当前字符串等于 <xref:System.String.Empty?displayProperty=nameWithtype> 或当前实例中的所有字符都包含 `trimChar` 字符，则该方法将返回 <xref:System.String.Empty?displayProperty=nameWithtype> 。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (params char[] trimChars);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.Trim : char[] -&gt; string" Usage="string.Trim trimChars" />
      <MemberSignature Language="C#" Value="public string Trim (params char[]? trimChars);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">要删除的 Unicode 字符的数组，或 <see langword="null" />。</param>
        <summary>从当前字符串删除数组中指定的一组字符的所有前导匹配项和尾随匹配项。</summary>
        <returns>从当前字符串的开头移除所出现的所有 <paramref name="trimChars" /> 参数中的字符后剩余的字符串。 如果 <paramref name="trimChars" /> 为 <see langword="null" /> 或空数组，则改为移除空白字符。 如果从当前实例无法删除字符，此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

`Trim(System.Char[])`方法从当前字符串中删除参数中的所有前导和尾随字符 `trimChars` 。 当遇到不在中的字符时，每个前导和尾随修整操作都会停止 `trimChars` 。 例如，如果当前字符串为 "123abc456xyz789" 并且 `trimChars` 包含从 "1" 到 "9" 的数字，则该 `Trim(System.Char[])` 方法将返回 "abc456xyz"。

> [!NOTE]
> 如果该 `Trim(System.Char[])` 方法从当前实例中移除所有字符，则此方法不会修改当前实例的值。 相反，它会返回一个新字符串，其中将删除在 `trimChars` 当前实例中找到的所有前导和尾随字符。

如果当前字符串等于 <xref:System.String.Empty?displayProperty=nameWithtype> 或当前实例中的所有字符都包含数组中的字符 `trimChars` ，则该方法将返回 <xref:System.String.Empty?displayProperty=nameWithtype> 。

如果 `trimChars` 为 `null` 或空数组，则此方法将删除在 `true` 将方法传递给方法时导致该方法返回的所有前导或尾随字符 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 。

## Examples

下面的示例使用 `Trim(System.Char[])` 方法从字符串中删除空格、星号 ( * ) 和撇号 ( ") 字符。

[!code-cpp[System.String.Trim#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
[!code-csharp-interactive[System.String.Trim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
[!code-vb[System.String.Trim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]

          ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本维护一个内部空白字符列表，如果 <paramref name="trimChars" /> 为或空数组，此方法将修整此列表 <see langword="null" /> 。 从开始 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] ，如果 <paramref name="trimChars" /> 为 <see langword="null" /> 或空数组，该方法将剪裁所有 Unicode 空白字符， (也就是说，在将 <see langword="true" /> 其传递到方法) 时生成返回值的字符 <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> 。 由于此更改，和更 <see cref="M:System.String.Trim" /> 早版本中的方法将 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 删除两个字符，零宽度空间 (u + 200B) 和零宽度无间断空格 (U + FEFF) ，则 <see cref="M:System.String.Trim" /> [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 和更高版本中的方法不会删除。 此外， <see cref="M:System.String.Trim" /> [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 和更早版本中的方法不会剪裁三个 Unicode 空白字符：蒙古语元音分隔符 (u + 180E) 、窄的无中断空格 (u + 202F) 和中等数学空间 (u + 205F) 。</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd();" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : unit -&gt; string" Usage="string.TrimEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从当前字符串删除所有尾随空白字符。</summary>
        <returns>从当前字符串的结尾删除所有空白字符后剩余的字符串。 如果从当前实例无法删除字符，此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

`TrimEnd`方法从当前字符串中删除所有尾随空格字符。 当在字符串末尾遇到第一个非空白字符时，剪裁操作将停止。 例如，如果当前字符串为 "abc xyz"，则该 `TrimEnd` 方法返回 "abc xyz"。

> [!NOTE]
> 如果该 `TrimEnd` 方法从当前实例中移除所有字符，则此方法不会修改当前实例的值。 相反，它会返回一个新字符串，其中所有尾随空格字符都从当前字符串中删除。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char -&gt; string" Usage="string.TrimEnd trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="trimChar">要删除的 Unicode 字符。</param>
        <summary>从当前字符串删除字符的所有尾随匹配项。</summary>
        <returns>从当前字符串的末尾删除所出现的所有 <paramref name="trimChar" /> 字符后剩余的字符串。 如果从当前实例无法删除字符，此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

`TrimEnd(System.Char)`方法从当前字符串中删除所有尾随 `trimChar` 字符。 当在字符串末尾遇到第一个不是的字符时，修整操作将停止 `trimChar` 。 例如，如果 `trimChar` 为， `-` 并且当前字符串为 "---abc---xyz----"，则该 `TrimEnd(System.Char)` 方法返回 "---abc---xyz"。

> [!NOTE]
> 如果该 `TrimEnd(System.Char)` 方法从当前实例中移除所有字符，则此方法不会修改当前实例的值。 相反，它会返回一个新字符串，其中所有尾随 `trimChar` 字符都从当前字符串中删除。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[] trimChars);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char[] -&gt; string" Usage="string.TrimEnd trimChars" />
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[]? trimChars);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">要删除的 Unicode 字符的数组，或 <see langword="null" />。</param>
        <summary>从当前字符串删除数组中指定的一组字符的所有尾随匹配项。</summary>
        <returns>从当前字符串的开头移除所出现的所有 <paramref name="trimChars" /> 参数中的字符后剩余的字符串。 如果 <paramref name="trimChars" /> 为 <see langword="null" /> 或空数组，则改为删除 Unicode 空白字符。 如果从当前实例无法删除字符，此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

`TrimEnd(System.Char[])`方法从当前字符串中删除参数中的所有尾随字符 `trimChars` 。 当在字符串末尾遇到不在中的第一个字符时，剪裁操作将停止 `trimChars` 。 例如，如果当前字符串为 "123abc456xyz789" 并且 `trimChars` 包含从 "1" 到 "9" 的数字，则该 `TrimEnd(System.Char[])` 方法将返回 "123abc456xyz"。

> [!NOTE]
> 如果该 `TrimEnd(System.Char[])` 方法从当前实例中移除所有字符，则此方法不会修改当前实例的值。 相反，它会返回一个新字符串，其中在中找到的所有尾随字符 `trimChars` 将从当前字符串中删除。

## Examples

下面的示例演示如何使用 `TrimEnd(System.Char[])` 方法从字符串末尾修整空格或标点符号。

[!code-csharp-interactive[System.String.TrimEnd#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
[!code-vb[System.String.TrimEnd#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]

          ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本维护一个内部空白字符列表，如果 <paramref name="trimChars" /> 为或空数组，此方法将修整此列表 <see langword="null" /> 。 从开始 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] ，如果 <paramref name="trimChars" /> 为 <see langword="null" /> 或空数组，该方法将剪裁所有 Unicode 空白字符， (也就是说，在将 <see langword="true" /> 其传递到方法) 时生成返回值的字符 <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> 。 由于此更改，和更 <see cref="M:System.String.Trim" /> 早版本中的方法将 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 删除两个字符，零宽度空间 (u + 200B) 和零宽度无间断空格 (U + FEFF) ，则 <see cref="M:System.String.Trim" /> [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 和更高版本中的方法不会删除。 此外， <see cref="M:System.String.Trim" /> [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 和更早版本中的方法不会剪裁三个 Unicode 空白字符：蒙古语元音分隔符 (u + 180E) 、窄的无中断空格 (u + 202F) 和中等数学空间 (u + 205F) 。</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart();" />
      <MemberSignature Language="F#" Value="member this.TrimStart : unit -&gt; string" Usage="string.TrimStart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从当前字符串删除所有前导空白字符。</summary>
        <returns>从当前字符串的开头删除所有空白字符后剩余的字符串。 如果从当前实例无法删除字符，此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

`TrimStart`方法从当前字符串中删除所有前导空白字符。 如果遇到非空白字符，剪裁操作将停止。 例如，如果当前字符串为 "abc xyz"，则该 `TrimStart` 方法返回 "abc xyz"。

> [!NOTE]
> 如果该 `TrimStart` 方法从当前实例中移除所有字符，则此方法不会修改当前实例的值。 相反，它会返回一个新字符串，其中将删除当前实例中找到的所有前导空格字符。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char -&gt; string" Usage="string.TrimStart trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="trimChar">要删除的 Unicode 字符。</param>
        <summary>删除当前字符串中的指定字符的所有前导匹配项。</summary>
        <returns>从当前字符串的开头删除所出现的所有 <paramref name="trimChar" /> 字符后剩余的字符串。 如果从当前实例无法删除字符，此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

`TrimStart(System.Char)`方法从当前字符串中删除所有前导 `trimChar` 字符。 当遇到不是的字符时，剪裁操作将停止 `trimChar` 。 例如，如果 `trimChar` 为， `-` 并且当前字符串为 "---abc---xyz----"，则该 `TrimStart(System.Char)` 方法返回 "abc---xyz----"。

> [!NOTE]
> 如果该 `TrimStart(System.Char)` 方法从当前实例中移除所有字符，则此方法不会修改当前实例的值。 相反，它会返回一个新字符串，其中将 `trimChar` 删除当前实例中找到的所有前导字符。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (params char[] trimChars);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char[] -&gt; string" Usage="string.TrimStart trimChars" />
      <MemberSignature Language="C#" Value="public string TrimStart (params char[]? trimChars);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">要删除的 Unicode 字符的数组，或 <see langword="null" />。</param>
        <summary>从当前字符串删除数组中指定的一组字符的所有前导匹配项。</summary>
        <returns>从当前字符串的开头移除所出现的所有 <paramref name="trimChars" /> 参数中的字符后剩余的字符串。 如果 <paramref name="trimChars" /> 为 <see langword="null" /> 或空数组，则改为移除空白字符。 如果从当前实例无法删除字符，此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

`TrimStart(System.Char[])`方法从当前字符串中删除参数中的所有前导字符 `trimChars` 。 当遇到不在中的字符时，剪裁操作将停止 `trimChars` 。 例如，如果当前字符串为 "123abc456xyz789" 并且 `trimChars` 包含从 "1" 到 "9" 的数字，则该 `TrimStart(System.Char[])` 方法将返回 "abc456xyz789"。

> [!NOTE]
> 如果该 `TrimStart(System.Char[])` 方法从当前实例中移除所有字符，则此方法不会修改当前实例的值。 相反，它会返回一个新字符串，其中将删除当前实例中找到的参数中的所有前导字符 `trimChars` 。

## Examples

下面的示例演示方法的基本功能 <xref:System.String.TrimStart%2A> ：

:::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs" id="Snippet1":::
:::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb" id="Snippet1":::

下面的示例使用 <xref:System.String.TrimStart%2A> 方法从源代码行中剪裁空格和注释字符。 `StripComments`方法包装对的调用 <xref:System.String.TrimStart%2A> ，并向其传递一个字符数组，该数组包含一个空格和注释字符，注释字符是 Visual Basic 中的撇号 ( ") ，后者是 c # 中的斜杠 (/) 。 在 <xref:System.String.TrimStart%2A> 计算字符串是否为注释时，还会调用方法来删除前导空格。

[!code-csharp[System.String.TrimStart#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
[!code-vb[System.String.TrimStart#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]

下面的示例演示对 `StripComments` 方法的调用。

[!code-csharp[System.String.TrimStart#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#3)]
[!code-vb[System.String.TrimStart#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#3)]

          ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本维护一个内部空白字符列表，如果 <paramref name="trimChars" /> 为或空数组，此方法将修整此列表 <see langword="null" /> 。 从开始 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] ，如果 <paramref name="trimChars" /> 为 <see langword="null" /> 或空数组，该方法将剪裁所有 Unicode 空白字符， (也就是说，在将 <see langword="true" /> 其传递到方法) 时生成返回值的字符 <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> 。 由于此更改，和更 <see cref="M:System.String.Trim" /> 早版本中的方法将 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 删除两个字符，零宽度空间 (u + 200B) 和零宽度无间断空格 (U + FEFF) ，则 <see cref="M:System.String.Trim" /> [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 和更高版本中的方法不会删除。 此外， <see cref="M:System.String.Trim" /> [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 和更早版本中的方法不会剪裁三个 Unicode 空白字符：蒙古语元音分隔符 (u + 180E) 、窄的无中断空格 (u + 202F) 和中等数学空间 (u + 205F) 。</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
  </Members>
</Type>
