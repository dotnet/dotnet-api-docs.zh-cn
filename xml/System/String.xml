<Type Name="String" FullName="System.String">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a0ae3d1fa6e9253548ee7ba3fb22c71e8addfcdd" /><Meta Name="ms.sourcegitcommit" Value="a8ca33e500a87229bed50d12e09b1347df519648" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="10/09/2020" /><Meta Name="ms.locfileid" Value="91922099" /></Metadata><TypeSignature Language="C#" Value="public sealed class String : IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface seq&lt;char&gt;&#xA;    interface IEnumerable&#xA;    interface IComparable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface IConvertible&#xA;    interface IEquatable&lt;string&gt;" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface seq&lt;char&gt;&#xA;    interface IEnumerable&#xA;    interface ICloneable&#xA;    interface IComparable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface IConvertible&#xA;    interface IEquatable&lt;string&gt;" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface seq&lt;char&gt;&#xA;    interface IEnumerable&#xA;    interface IComparable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface IConvertible&#xA;    interface IEquatable&lt;string&gt;&#xA;    interface ICloneable" FrameworkAlternate="netcore-2.0" />
  <TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IConvertible, System.Collections.IEnumerable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IConvertible" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IConvertible, IEnumerable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IConvertible, System::Collections::IEnumerable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IEnumerable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IComparable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEnumerable&#xA;    interface IEquatable&lt;string&gt;" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IEnumerable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEquatable&lt;string&gt;" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C#" Value="public sealed class String : IComparable, IComparable&lt;string&gt;, IEquatable&lt;string&gt;, System.Collections.IEnumerable" FrameworkAlternate="netstandard-1.0;netstandard-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit string extends System.Object implements class System.Collections.IEnumerable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IEquatable`1&lt;string&gt;" FrameworkAlternate="netstandard-1.0;netstandard-1.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements IComparable, IComparable(Of String), IEnumerable, IEquatable(Of String)" FrameworkAlternate="netstandard-1.0;netstandard-1.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : IComparable, IComparable&lt;System::String ^&gt;, IEquatable&lt;System::String ^&gt;, System::Collections::IEnumerable" FrameworkAlternate="netstandard-1.0;netstandard-1.1" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IEnumerable&#xA;    interface IComparable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface IEquatable&lt;string&gt;" FrameworkAlternate="netstandard-1.0;netstandard-1.1" />
  <TypeSignature Language="C#" Value="public sealed class String : IComparable, IComparable&lt;string&gt;, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" FrameworkAlternate="netstandard-1.2" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IEquatable`1&lt;string&gt;" FrameworkAlternate="netstandard-1.2" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements IComparable, IComparable(Of String), IEnumerable(Of Char), IEquatable(Of String)" FrameworkAlternate="netstandard-1.2" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : IComparable, IComparable&lt;System::String ^&gt;, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" FrameworkAlternate="netstandard-1.2" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface IEquatable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEnumerable" FrameworkAlternate="netstandard-1.2" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="3cd3e-101">将文本表示为 UTF-16 代码单元的序列。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-101">Represents text as a sequence of UTF-16 code units.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks

 <span data-ttu-id="3cd3e-102">字符串是用于表示文本的字符的有序集合。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-102">A string is a sequential collection of characters that is used to represent text.</span></span> <span data-ttu-id="3cd3e-103"><xref:System.String>对象是对象的有序集合 <xref:System.Char?displayProperty=nameWithType> ，表示字符串; <xref:System.Char?displayProperty=nameWithType> 对象对应于 utf-16 代码单元。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-103">A <xref:System.String> object is a sequential collection of <xref:System.Char?displayProperty=nameWithType> objects that represent a string; a <xref:System.Char?displayProperty=nameWithType> object corresponds to a UTF-16 code unit.</span></span> <span data-ttu-id="3cd3e-104">对象的值 <xref:System.String> 是对象的顺序集合的内容 <xref:System.Char?displayProperty=nameWithType> ，并且该值是不可变的 (也就是说，它是只读) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-104">The value of the <xref:System.String> object is the content of the sequential collection of <xref:System.Char?displayProperty=nameWithType> objects, and that value is immutable (that is, it is read-only).</span></span> <span data-ttu-id="3cd3e-105">有关字符串不可变性的详细信息，请参阅本主题后面的 "不 [可变性和 StringBuilder 类](#Immutability) " 一节。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-105">For more information about the immutability of strings, see the [Immutability and the StringBuilder class](#Immutability) section later in this topic.</span></span> <span data-ttu-id="3cd3e-106">内存中的对象的最大大小 <xref:System.String> 为2gb 或大约1000000000个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-106">The maximum size of a <xref:System.String> object in memory is 2GB, or about 1 billion characters.</span></span>

<span data-ttu-id="3cd3e-107">有关 Unicode、UTF-16、代码单位、代码点以及和类型的详细信息 <xref:System.Char> <xref:System.Text.Rune> ，请参阅 [.net 中的字符编码简介](/dotnet/standard/base-types/character-encoding-introduction)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-107">For more information about Unicode, UTF-16, code units, code points, and the <xref:System.Char> and <xref:System.Text.Rune> types, see [Introduction to character encoding in .NET](/dotnet/standard/base-types/character-encoding-introduction).</span></span>

 <span data-ttu-id="3cd3e-108">本部分内容：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-108">In this section:</span></span>

 <span data-ttu-id="3cd3e-109">[实例化字符串对象](#Instantiation)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-109">[Instantiate a String object](#Instantiation)</span></span>\
 <span data-ttu-id="3cd3e-110">[Char 对象和 Unicode 字符](#Characters)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-110">[Char objects and Unicode characters](#Characters)</span></span>\
 <span data-ttu-id="3cd3e-111">[字符串和 Unicode 标准](#Unicode)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-111">[Strings and The Unicode Standard](#Unicode)</span></span>\
 <span data-ttu-id="3cd3e-112">[字符串和嵌入的 null 字符](#EmbeddedNulls)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-112">[Strings and embedded null characters](#EmbeddedNulls)</span></span>\
 <span data-ttu-id="3cd3e-113">[字符串和索引](#Indexes)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-113">[Strings and indexes](#Indexes)</span></span>\
 <span data-ttu-id="3cd3e-114">[空字符串和空字符串](#Nulls)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-114">[Null strings and empty strings](#Nulls)</span></span>\
 <span data-ttu-id="3cd3e-115">[永久性和 StringBuilder 类](#Immutability)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-115">[Immutability and the StringBuilder class](#Immutability)</span></span>\
 <span data-ttu-id="3cd3e-116">[序号与区分区域性的操作](#CultureSensitive)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-116">[Ordinal vs. culture-sensitive operations](#CultureSensitive)</span></span>\
 <span data-ttu-id="3cd3e-117">[正](#Normalization)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-117">[Normalization](#Normalization)</span></span>\
 [<span data-ttu-id="3cd3e-118">按类别列出的字符串操作</span><span class="sxs-lookup"><span data-stu-id="3cd3e-118">String operations by category</span></span>](#ByCategory)

<a name="Instantiation"></a>
## <a name="instantiate-a-string-object"></a><span data-ttu-id="3cd3e-119">实例化字符串对象</span><span class="sxs-lookup"><span data-stu-id="3cd3e-119">Instantiate a String object</span></span>
 <span data-ttu-id="3cd3e-120">可以 <xref:System.String> 通过以下方式实例化对象：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-120">You can instantiate a <xref:System.String> object in the following ways:</span></span>

-   <span data-ttu-id="3cd3e-121">通过将字符串文本分配给 <xref:System.String> 变量。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-121">By assigning a string literal to a <xref:System.String> variable.</span></span> <span data-ttu-id="3cd3e-122">这是创建字符串时最常用的方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-122">This is the most commonly used method for creating a string.</span></span> <span data-ttu-id="3cd3e-123">下面的示例使用赋值创建几个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-123">The following example uses assignment to create several strings.</span></span> <span data-ttu-id="3cd3e-124">请注意，在 c # 中，因为反斜杠 (\\) 是转义字符，所以字符串中的文本反斜杠必须进行转义或整个字符串必须是 @-quoted 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-124">Note that in C#, because the backslash (\\) is an escape character, literal backslashes in a string must be escaped or the entire string must be @-quoted.</span></span>

     [!code-cpp[System.String.Class.Instantiate#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp-interactive[System.String.Class.Instantiate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]

-   <span data-ttu-id="3cd3e-125">通过调用 <xref:System.String> 类构造函数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-125">By calling a <xref:System.String> class constructor.</span></span> <span data-ttu-id="3cd3e-126">下面的示例通过调用多个类构造函数来实例化字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-126">The following example instantiates strings by calling several class constructors.</span></span> <span data-ttu-id="3cd3e-127">请注意，一些构造函数包含指向字符数组的指针或作为参数的带符号字节数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-127">Note that some of the constructors include pointers to character arrays or signed byte arrays as parameters.</span></span> <span data-ttu-id="3cd3e-128">Visual Basic 不支持对这些构造函数的调用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-128">Visual Basic does not support calls to these constructors.</span></span> <span data-ttu-id="3cd3e-129">有关构造函数的详细信息 <xref:System.String> ，请参阅 <xref:System.String.%23ctor%2A> 构造函数摘要。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-129">For detailed information about <xref:System.String> constructors, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>

     [!code-cpp[System.String.Class.Instantiate#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp[System.String.Class.Instantiate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]

-   <span data-ttu-id="3cd3e-130">通过使用 c # 中的字符串串联运算符 (+，并 Visual Basic) 中的 & 或 + 来创建来自 <xref:System.String> 实例和字符串文本的任意组合的单个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-130">By using the string concatenation operator (+ in C# and & or + in Visual Basic) to create a single string from any combination of <xref:System.String> instances and string literals.</span></span> <span data-ttu-id="3cd3e-131">下面的示例演示如何使用字符串连接运算符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-131">The following example illustrates the use of the string concatenation operator.</span></span>

     [!code-cpp[System.String.Class.Instantiate#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp-interactive[System.String.Class.Instantiate#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]

-   <span data-ttu-id="3cd3e-132">通过检索属性或调用返回字符串的方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-132">By retrieving a property or calling a method that returns a string.</span></span> <span data-ttu-id="3cd3e-133">下面的示例使用类的方法 <xref:System.String> 从较大的字符串中提取子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-133">The following example uses the methods of the <xref:System.String> class to extract a substring from a larger string.</span></span>

     [!code-cpp[System.String.Class.Instantiate#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp-interactive[System.String.Class.Instantiate#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]

-   <span data-ttu-id="3cd3e-134">通过调用格式设置方法，将值或对象转换为其字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-134">By calling a formatting method to convert a value or object to its string representation.</span></span> <span data-ttu-id="3cd3e-135">下面的示例使用 [复合格式设置](/dotnet/standard/base-types/composite-formatting) 功能将两个对象的字符串表示形式嵌入到一个字符串中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-135">The following example uses the [composite formatting](/dotnet/standard/base-types/composite-formatting) feature to embed the string representation of two objects into a string.</span></span>

     [!code-cpp[System.String.Class.Instantiate#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp[System.String.Class.Instantiate#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]

<a name="Characters"></a>
## <a name="char-objects-and-unicode-characters"></a><span data-ttu-id="3cd3e-136">Char 对象和 Unicode 字符</span><span class="sxs-lookup"><span data-stu-id="3cd3e-136">Char objects and Unicode characters</span></span>
 <span data-ttu-id="3cd3e-137">字符串中的每个字符都是由 Unicode 标量值（也称为 Unicode 码位）或序号 (数字) Unicode 字符的值来定义的。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-137">Each character in a string is defined by a Unicode scalar value, also called a Unicode code point or the ordinal (numeric) value of the Unicode character.</span></span> <span data-ttu-id="3cd3e-138">每个码位均使用 UTF-16 编码进行编码，并且编码的每个元素的数值均由一个 <xref:System.Char> 对象表示。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-138">Each code point is encoded by using UTF-16 encoding, and the numeric value of each element of the encoding is represented by a <xref:System.Char> object.</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-139">请注意，由于 <xref:System.String> 实例包含 utf-16 代码单元的有序集合，因此，可以创建一个不是格式正确的 <xref:System.String> Unicode 字符串的对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-139">Note that, because a <xref:System.String> instance consists of a sequential collection of UTF-16 code units, it is possible to create a <xref:System.String> object that is not a well-formed Unicode string.</span></span> <span data-ttu-id="3cd3e-140">例如，可以创建具有低代理项的字符串，而无需使用相应的高代理项。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-140">For example, it is possible to create a string that has a low surrogate without a corresponding high surrogate.</span></span> <span data-ttu-id="3cd3e-141">尽管某些方法（例如，命名空间中的编码和解码对象的方法） <xref:System.Text> 可能会执行检查以确保字符串的格式正确，但 <xref:System.String> 类成员不确保字符串格式正确。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-141">Although some methods, such as the methods of encoding and decoding objects in the <xref:System.Text> namespace, may performs checks to ensure that strings are well-formed, <xref:System.String> class members don't ensure that a string is well-formed.</span></span>

 <span data-ttu-id="3cd3e-142">单个 <xref:System.Char> 对象通常表示单个码位; 即，的数值 <xref:System.Char> 等于码位。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-142">A single <xref:System.Char> object usually represents a single code point; that is, the numeric value of the <xref:System.Char> equals the code point.</span></span> <span data-ttu-id="3cd3e-143">例如，字符 "a" 的码位为 U + 0061。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-143">For example, the code point for the character "a" is U+0061.</span></span> <span data-ttu-id="3cd3e-144">但是，码位可能要求多个编码元素 (多个 <xref:System.Char>) 的对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-144">However, a code point might require more than one encoded element (more than one <xref:System.Char> object).</span></span> <span data-ttu-id="3cd3e-145">Unicode 标准定义两种类型的字符，它们对应于多个 <xref:System.Char> 对象： graphemes，以及与 unicode 辅助平面中的字符相对应的 unicode 补充码位。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-145">The Unicode standard defines two types of characters that correspond to multiple <xref:System.Char> objects: graphemes, and Unicode supplementary code points that correspond to characters in the Unicode supplementary planes.</span></span>

-   <span data-ttu-id="3cd3e-146">字形由后跟一个或多个组合字符的基本字符表示。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-146">A grapheme is represented by a base character followed by one or more combining characters.</span></span> <span data-ttu-id="3cd3e-147">例如，字符ä由 <xref:System.Char> 其码位为 u + 0061 的对象后跟 <xref:System.Char> 其码位为 u + 0308 的对象表示。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-147">For example, the character ä is represented by a <xref:System.Char> object whose code point is U+0061 followed by a <xref:System.Char> object whose code point is U+0308.</span></span> <span data-ttu-id="3cd3e-148">此字符也可由 <xref:System.Char> 其码位为 U + 00E4 的单个对象定义。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-148">This character can also be defined by a single <xref:System.Char> object that has a code point of U+00E4.</span></span> <span data-ttu-id="3cd3e-149">如下面的示例所示，区分大小写的相等比较表明这两个表示形式相等，不过普通序号比较不是这样。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-149">As the following example shows, a culture-sensitive comparison for equality indicates that these two representations are equal, although an ordinary ordinal comparison does not.</span></span> <span data-ttu-id="3cd3e-150">但是，如果这两个字符串被规范化，则序号比较也指示它们相等。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-150">However, if the two strings are normalized, an ordinal comparison also indicates that they are equal.</span></span> <span data-ttu-id="3cd3e-151"> (有关规范化字符串的详细信息，请参阅 [规范化](#Normalization) 部分。 ) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-151">(For more information on normalizing strings, see the [Normalization](#Normalization) section.)</span></span>

     [!code-cpp[System.String.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]

-   <span data-ttu-id="3cd3e-152">Unicode 补充码位 (代理项对) 由一个对象表示，该 <xref:System.Char> 对象的代码点为高代理项，后跟一个 <xref:System.Char> 其代码点为低代理项的对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-152">A Unicode supplementary code point (a surrogate pair) is represented by a <xref:System.Char> object whose code point is a high surrogate followed by a <xref:System.Char> object whose code point is a low surrogate.</span></span> <span data-ttu-id="3cd3e-153">高代理项的代码单位范围是从 U + D800 到 U + DBFF。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-153">The code units of high surrogates range from U+D800 to U+DBFF.</span></span> <span data-ttu-id="3cd3e-154">低代理项的代码单位范围是从 U + DC00 到 U + DFFF。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-154">The code units of low surrogates range from U+DC00 to U+DFFF.</span></span> <span data-ttu-id="3cd3e-155">代理项对用于表示16个 Unicode 补充平面中的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-155">Surrogate pairs are used to represent characters in the 16 Unicode supplementary planes.</span></span> <span data-ttu-id="3cd3e-156">下面的示例创建一个代理项字符，并将其传递给 <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType> 方法，以确定它是否为代理项对。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-156">The following example creates a surrogate character and passes it to the <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType> method to determine whether it is a surrogate pair.</span></span>

     [!code-cpp[System.String.Class#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp-interactive[System.String.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]

<a name="Unicode"></a>
## <a name="strings-and-the-unicode-standard"></a><span data-ttu-id="3cd3e-157">字符串和 Unicode 标准</span><span class="sxs-lookup"><span data-stu-id="3cd3e-157">Strings and the Unicode Standard</span></span>
 <span data-ttu-id="3cd3e-158">字符串中的字符由与值对应的 UTF-16 编码的代码单位表示 <xref:System.Char> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-158">Characters in a string are represented by UTF-16 encoded code units, which correspond to <xref:System.Char> values.</span></span>

 <span data-ttu-id="3cd3e-159">字符串中的每个字符都具有关联的 Unicode 字符类别，该类别在 .NET 中由 <xref:System.Globalization.UnicodeCategory> 枚举表示。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-159">Each character in a string has an associated Unicode character category, which is represented in .NET by the <xref:System.Globalization.UnicodeCategory> enumeration.</span></span> <span data-ttu-id="3cd3e-160">可以通过调用方法来确定字符或代理项对的类别 <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-160">The category of a character or a surrogate pair can be determined by calling the <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> method.</span></span>

[!INCLUDE[character-categories](~/includes/unicode-categories.md)]

 <span data-ttu-id="3cd3e-161">此外，.NET 还支持基于 Unicode 标准的字符串比较和排序。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-161">In addition, .NET supports string comparison and sorting based on the Unicode standard.</span></span> <span data-ttu-id="3cd3e-162">在的 .NET Framework 版本中 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ，.NET Framework 维护其自己的字符串数据表。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-162">In versions of the .NET Framework through the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the .NET Framework maintains its own table of string data.</span></span> <span data-ttu-id="3cd3e-163">这也适用于从 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] Windows 7 上运行的开始的 .NET Framework 版本。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-163">This is also true of versions of the .NET Framework starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] running on Windows 7.</span></span> <span data-ttu-id="3cd3e-164">从在 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] Windows 8 及更高版本的 Windows 操作系统上运行的开始，运行时将字符串比较和排序操作委托给操作系统。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-164">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] running on Window 8 and later versions of the Windows operating system, the runtime delegates string comparison and sorting operations to the operating system.</span></span> <span data-ttu-id="3cd3e-165">在 .NET Core 中，字符串比较和排序信息由 Unicode 库的 [国际化组件](http://site.icu-project.org/) 提供。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-165">On .NET Core, string comparison and sorting information is provided by [International Components for Unicode](http://site.icu-project.org/) libraries.</span></span> <span data-ttu-id="3cd3e-166">下表列出了 .NET 版本以及 Unicode 标准的版本，这些版本的字符比较和排序基于这些版本。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-166">The following table lists the versions of .NET and the versions of the Unicode Standard on which character comparison and sorting are based.</span></span>

|<span data-ttu-id="3cd3e-167">.NET 版本</span><span class="sxs-lookup"><span data-stu-id="3cd3e-167">.NET version</span></span>|<span data-ttu-id="3cd3e-168">Unicode 标准版本</span><span class="sxs-lookup"><span data-stu-id="3cd3e-168">Version of the Unicode Standard</span></span>|
|----------------------------|-------------------------------------|
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[<span data-ttu-id="3cd3e-169">Unicode 标准，版本 4.0.0</span><span class="sxs-lookup"><span data-stu-id="3cd3e-169">The Unicode Standard, Version 4.0.0</span></span>](https://www.unicode.org/versions/Unicode4.0.0/)|
|<span data-ttu-id="3cd3e-170">.NET Framework 2.0</span><span class="sxs-lookup"><span data-stu-id="3cd3e-170">.NET Framework 2.0</span></span>|[<span data-ttu-id="3cd3e-171">Unicode 标准，版本 5.0.0</span><span class="sxs-lookup"><span data-stu-id="3cd3e-171">The Unicode Standard, Version 5.0.0</span></span>](https://www.unicode.org/versions/Unicode5.0.0)|
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[<span data-ttu-id="3cd3e-172">Unicode 标准，版本 5.0.0</span><span class="sxs-lookup"><span data-stu-id="3cd3e-172">The Unicode Standard, Version 5.0.0</span></span>](https://www.unicode.org/versions/Unicode5.0.0)|
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[<span data-ttu-id="3cd3e-173">Unicode 标准，版本 5.0.0</span><span class="sxs-lookup"><span data-stu-id="3cd3e-173">The Unicode Standard, Version 5.0.0</span></span>](https://www.unicode.org/versions/Unicode5.0.0)|
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] <span data-ttu-id="3cd3e-174">和更高版本的 Windows 7</span><span class="sxs-lookup"><span data-stu-id="3cd3e-174">and later on Windows 7</span></span>|[<span data-ttu-id="3cd3e-175">Unicode 标准，版本 5.0.0</span><span class="sxs-lookup"><span data-stu-id="3cd3e-175">The Unicode Standard, Version 5.0.0</span></span>](https://www.unicode.org/versions/Unicode5.0.0)|
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] <span data-ttu-id="3cd3e-176">Windows 8 及更高版本的 Windows 操作系统上和更高版本</span><span class="sxs-lookup"><span data-stu-id="3cd3e-176">and later on Windows 8 and later Windows operating systems</span></span>|[<span data-ttu-id="3cd3e-177">Unicode 标准，版本 6.3.0</span><span class="sxs-lookup"><span data-stu-id="3cd3e-177">The Unicode Standard, Version 6.3.0</span></span>](https://www.unicode.org/versions/Unicode6.3.0/)|
|<span data-ttu-id="3cd3e-178">.NET Core（所有版本）</span><span class="sxs-lookup"><span data-stu-id="3cd3e-178">.NET Core (all versions)</span></span>|<span data-ttu-id="3cd3e-179">取决于基础操作系统支持的 Unicode 标准版本。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-179">Depends on the version of the Unicode Standard supported by the underlying operating system.</span></span>|

<a name="EmbeddedNulls"></a>
## <a name="strings-and-embedded-null-characters"></a><span data-ttu-id="3cd3e-180">字符串和嵌入的 null 字符</span><span class="sxs-lookup"><span data-stu-id="3cd3e-180">Strings and embedded null characters</span></span>
 <span data-ttu-id="3cd3e-181">在 .NET 中， <xref:System.String> 对象可以包含嵌入的 null 字符，这些字符将作为字符串长度的一部分计数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-181">In .NET, a <xref:System.String> object can include embedded null characters, which count as a part of the string's length.</span></span> <span data-ttu-id="3cd3e-182">但是，在某些语言（如 C 和 c + +）中，空字符表示字符串的末尾;它不被视为字符串的一部分，并且不计入字符串长度中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-182">However, in some languages such as C and C++, a null character indicates the end of a string; it is not considered a part of the string and is not counted as part of the string's length.</span></span> <span data-ttu-id="3cd3e-183">这意味着，在应用于对象时，C 和 c + + 程序员或用 C 或 c + + 编写的库可能会导致字符串不一定有效 <xref:System.String> ：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-183">This means that the following common assumptions that C and C++ programmers or libraries written in C or C++ might make about strings are not necessarily valid when applied to <xref:System.String> objects:</span></span>

-   <span data-ttu-id="3cd3e-184">或函数返回的值 `strlen` `wcslen` 不一定相等 <xref:System.String.Length%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-184">The value returned by the `strlen` or `wcslen` functions does not necessarily equal <xref:System.String.Length%2A?displayProperty=nameWithType>.</span></span>

-   <span data-ttu-id="3cd3e-185">或函数创建的字符串 `strcpy_s` `wcscpy_s` 不一定与方法创建的字符串完全相同 <xref:System.String.Copy%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-185">The string created by the `strcpy_s` or `wcscpy_s` functions is not necessarily identical to the string created by the <xref:System.String.Copy%2A?displayProperty=nameWithType> method.</span></span>

 <span data-ttu-id="3cd3e-186">你应确保用于实例化对象的本机 C 和 c + + 代码 <xref:System.String> ，以及 <xref:System.String> 通过平台调用传递对象的代码，不会假定嵌入的 null 字符标记字符串的末尾。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-186">You should ensure that native C and C++ code that instantiates <xref:System.String> objects, and code that is passed <xref:System.String> objects through platform invoke, don't assume that an embedded null character marks the end of the string.</span></span>

 <span data-ttu-id="3cd3e-187">当对字符串进行排序时，字符串中嵌入的空字符的处理方式也会不同， (或在搜索字符串时) 与该字符串进行比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-187">Embedded null characters in a string are also treated differently when a string is sorted (or compared) and when a string is searched.</span></span> <span data-ttu-id="3cd3e-188">在两个字符串之间执行区分区域性的比较（包括使用固定区域性的比较）时，将忽略 Null 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-188">Null characters are ignored when performing culture-sensitive comparisons between two strings, including comparisons using the invariant culture.</span></span> <span data-ttu-id="3cd3e-189">它们仅被视为顺序比较或不区分大小写的序号比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-189">They are considered only for ordinal or case-insensitive ordinal comparisons.</span></span> <span data-ttu-id="3cd3e-190">另一方面，在使用、和等方法搜索字符串时，始终会考虑嵌入的 null 字符 <xref:System.String.Contains%2A> <xref:System.String.StartsWith%2A> <xref:System.String.IndexOf%2A> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-190">On the other hand, embedded null characters are always considered when searching a string with methods such as <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, and <xref:System.String.IndexOf%2A>.</span></span>

<a name="Indexes"></a>
## <a name="strings-and-indexes"></a><span data-ttu-id="3cd3e-191">字符串和索引</span><span class="sxs-lookup"><span data-stu-id="3cd3e-191">Strings and indexes</span></span>
 <span data-ttu-id="3cd3e-192">索引是 <xref:System.Char> 中 (不是 Unicode 字符) 的对象的位置 <xref:System.String> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-192">An index is the position of a <xref:System.Char> object (not a Unicode character) in a <xref:System.String>.</span></span> <span data-ttu-id="3cd3e-193">索引是从零开始的非负数字，从字符串中的第一个位置开始，即索引位置零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-193">An index is a zero-based, nonnegative number that starts from the first position in the string, which is index position zero.</span></span> <span data-ttu-id="3cd3e-194">许多搜索方法（如 <xref:System.String.IndexOf%2A> 和 <xref:System.String.LastIndexOf%2A> ）返回字符串实例中字符或子字符串的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-194">A number of search methods, such as <xref:System.String.IndexOf%2A> and <xref:System.String.LastIndexOf%2A>, return the index of a character or substring in the string instance.</span></span>

 <span data-ttu-id="3cd3e-195"><xref:System.String.Chars%2A>属性允许你 <xref:System.Char> 按对象在字符串中的索引位置访问各个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-195">The <xref:System.String.Chars%2A> property lets you access individual <xref:System.Char> objects by their index position in the string.</span></span> <span data-ttu-id="3cd3e-196">由于 <xref:System.String.Chars%2A> 属性是 (Visual Basic) 或 c # ) 中的索引器 (中的默认属性，因此可以 <xref:System.Char> 通过使用如下所示的代码，访问字符串中的各个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-196">Because the <xref:System.String.Chars%2A> property is the default property (in Visual Basic) or the indexer (in C#), you can access the individual <xref:System.Char> objects in a string by using code such as the following.</span></span> <span data-ttu-id="3cd3e-197">此代码将查找字符串中的空格或标点字符，以确定字符串包含的单词数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-197">This code looks for white space or punctuation characters in a string to determine how many words the string contains.</span></span>

 [!code-cpp[System.String.Class#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp-interactive[System.String.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]

 <span data-ttu-id="3cd3e-198">由于 <xref:System.String> 类实现 <xref:System.Collections.IEnumerable> 接口，因此还可以 <xref:System.Char> 使用构造来循环访问字符串中的对象 `foreach` ，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-198">Because the <xref:System.String> class implements the <xref:System.Collections.IEnumerable> interface, you can also iterate through the <xref:System.Char> objects in a string by using a `foreach` construct, as the following example shows.</span></span>

 [!code-cpp[System.String.Class#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp-interactive[System.String.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]

 <span data-ttu-id="3cd3e-199">连续索引值可能不对应于连续的 Unicode 字符，因为 Unicode 字符可能被编码为多个 <xref:System.Char> 对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-199">Consecutive index values might not correspond to consecutive Unicode characters, because a Unicode character might be encoded as more than one <xref:System.Char> object.</span></span> <span data-ttu-id="3cd3e-200">特别是，字符串可能包含多字符单元，这些文本由一个后跟一个或多个组合字符或代理项对的基本字符构成。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-200">In particular, a string may contain multi-character units of text that are formed by a base character followed by one or more combining characters or by surrogate pairs.</span></span> <span data-ttu-id="3cd3e-201">若要使用 Unicode 字符而不使用 <xref:System.Char> 对象，请使用 <xref:System.Globalization.StringInfo?displayProperty=nameWithType> 和 <xref:System.Globalization.TextElementEnumerator> 类，或者使用 <xref:System.String.EnumerateRunes%2A?displayProperty=nameWithType> 方法和 <xref:System.Text.Rune> 结构。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-201">To work with Unicode characters instead of <xref:System.Char> objects, use the <xref:System.Globalization.StringInfo?displayProperty=nameWithType> and <xref:System.Globalization.TextElementEnumerator> classes, or the <xref:System.String.EnumerateRunes%2A?displayProperty=nameWithType> method and the <xref:System.Text.Rune> struct.</span></span> <span data-ttu-id="3cd3e-202">下面的示例演示适用于对象的代码与 <xref:System.Char> 使用 Unicode 字符的代码之间的差异。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-202">The following example illustrates the difference between code that works with <xref:System.Char> objects and code that works with Unicode characters.</span></span> <span data-ttu-id="3cd3e-203">它比较句子的每个单词中的字符数或文本元素数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-203">It compares the number of characters or text elements in each word of a sentence.</span></span> <span data-ttu-id="3cd3e-204">该字符串包含后跟组合字符的基本字符的两个序列。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-204">The string includes two sequences of a base character followed by a combining character.</span></span>

 [!code-cpp[System.String.Class#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp-interactive[System.String.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]

 <span data-ttu-id="3cd3e-205">此示例通过使用 <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType> 方法和 <xref:System.Globalization.TextElementEnumerator> 类来枚举字符串中的所有文本元素，来处理文本元素。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-205">This example works with text elements by using the <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType> method and the <xref:System.Globalization.TextElementEnumerator> class to enumerate all the text elements in a string.</span></span> <span data-ttu-id="3cd3e-206">还可以通过调用方法来检索包含每个文本元素的起始索引的数组 <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-206">You can also retrieve an array that contains the starting index of each text element by calling the <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType> method.</span></span>

 <span data-ttu-id="3cd3e-207">有关使用文本单元而不是单个值的详细信息 <xref:System.Char> ，请参阅 [.net 中的字符编码简介](/dotnet/standard/base-types/character-encoding-introduction)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-207">For more information about working with units of text rather than individual <xref:System.Char> values, see [Introduction to character encoding in .NET](/dotnet/standard/base-types/character-encoding-introduction).</span></span>

<a name="Nulls"></a>
## <a name="null-strings-and-empty-strings"></a><span data-ttu-id="3cd3e-208">空字符串和空字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-208">Null strings and empty strings</span></span>
 <span data-ttu-id="3cd3e-209">已声明但尚未赋值的字符串为 `null` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-209">A string that has been declared but has not been assigned a value is `null`.</span></span> <span data-ttu-id="3cd3e-210">尝试对该字符串调用方法会引发 <xref:System.NullReferenceException> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-210">Attempting to call methods on that string throws a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="3cd3e-211">空字符串不同于空字符串，这是一个字符串，其值为 "" 或 <xref:System.String.Empty?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-211">A null string is different from an empty string, which is a string whose value is "" or <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3cd3e-212">在某些情况下，如果将 null 字符串或空字符串作为参数传递给方法调用，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-212">In some cases, passing either a null string or an empty string as an argument in a method call throws an exception.</span></span> <span data-ttu-id="3cd3e-213">例如，将空字符串传递给方法会 <xref:System.Int32.Parse%2A?displayProperty=nameWithType> 引发 <xref:System.ArgumentNullException> ，传递空字符串会引发 <xref:System.FormatException> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-213">For example, passing a null string to the <xref:System.Int32.Parse%2A?displayProperty=nameWithType> method throws an <xref:System.ArgumentNullException>, and passing an empty string throws a <xref:System.FormatException>.</span></span> <span data-ttu-id="3cd3e-214">在其他情况下，方法参数可以为 null 字符串或空字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-214">In other cases, a method argument can be either a null string or an empty string.</span></span> <span data-ttu-id="3cd3e-215">例如，如果您正在为 <xref:System.IFormattable> 某个类提供实现，则需要将空字符串和空字符串作为常规 ( "G" ) 格式说明符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-215">For example, if you are providing an <xref:System.IFormattable> implementation for a class, you want to equate both a null string and an empty string with the general ("G") format specifier.</span></span>

 <span data-ttu-id="3cd3e-216"><xref:System.String>类包含以下两个简便方法，使您能够测试字符串是否为 `null` 或为空：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-216">The <xref:System.String> class includes the following two convenience methods that enable you to test whether a string is `null` or empty:</span></span>

-   <span data-ttu-id="3cd3e-217"><xref:System.String.IsNullOrEmpty%2A>，指示字符串是 `null` 还是等于  <xref:System.String.Empty?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-217"><xref:System.String.IsNullOrEmpty%2A>, which indicates whether a string is either `null` or is equal to  <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3cd3e-218">此方法无需使用如下所示的代码：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-218">This method eliminates the need to use code such as the following:</span></span>

     [!code-cpp[System.String.Class.Null#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]

-   <span data-ttu-id="3cd3e-219"><xref:System.String.IsNullOrWhiteSpace%2A>，指示字符串是 `null` 、等于 <xref:System.String.Empty?displayProperty=nameWithType> 还是仅由空白字符组成。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-219"><xref:System.String.IsNullOrWhiteSpace%2A>, which indicates whether a string is `null`, equals <xref:System.String.Empty?displayProperty=nameWithType>, or consists exclusively of white-space characters.</span></span> <span data-ttu-id="3cd3e-220">此方法无需使用如下所示的代码：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-220">This method eliminates the need to use code such as the following:</span></span>

     [!code-cpp[System.String.Class.Null#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]

 <span data-ttu-id="3cd3e-221">下面的示例 <xref:System.String.IsNullOrEmpty%2A> 在 <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> 自定义类的实现中使用方法 `Temperature` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-221">The following example uses the <xref:System.String.IsNullOrEmpty%2A> method in the <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implementation of a custom `Temperature` class.</span></span> <span data-ttu-id="3cd3e-222">方法支持 "G"、"C"、"F" 和 "K" 格式字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-222">The method supports the "G", "C", "F", and "K" format strings.</span></span> <span data-ttu-id="3cd3e-223">如果将值为的空格式字符串或格式字符串 `null` 传递给方法，则将其值更改为 "G" 格式字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-223">If an empty format string or a format string whose value is `null` is passed to the method, its value is changed to the "G" format string.</span></span>

 [!code-cpp[System.String.Class.Null#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]

<a name="Immutability"></a>
## <a name="immutability-and-the-stringbuilder-class"></a><span data-ttu-id="3cd3e-224">永久性和 StringBuilder 类</span><span class="sxs-lookup"><span data-stu-id="3cd3e-224">Immutability and the StringBuilder class</span></span>
 <span data-ttu-id="3cd3e-225"><xref:System.String>对象被称为不可变 (只读) ，因为在创建后，不能修改它的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-225">A <xref:System.String> object is called immutable (read-only), because its value cannot be modified after it has been created.</span></span> <span data-ttu-id="3cd3e-226">用于修改对象的方法 <xref:System.String> 实际上会返回一个 <xref:System.String> 包含修改的新对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-226">Methods that appear to modify a <xref:System.String> object actually return a new <xref:System.String> object that contains the modification.</span></span>

 <span data-ttu-id="3cd3e-227">由于字符串是不可变的，因此，对显示为单个字符串的内容执行重复添加或删除操作的字符串操作例程可能会显著降低性能。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-227">Because strings are immutable, string manipulation routines that perform repeated additions or deletions to what appears to be a single string can exact a significant performance penalty.</span></span> <span data-ttu-id="3cd3e-228">例如，下面的代码使用随机数生成器在0x0001 到0x052F 范围内创建1000字符的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-228">For example, the following code uses a random number generator to create a string with 1000 characters in the range 0x0001 to 0x052F.</span></span> <span data-ttu-id="3cd3e-229">尽管代码显示使用字符串串联将新字符追加到名为的现有字符串，但 `str` 它实际上 <xref:System.String> 为每个串联操作创建了一个新的对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-229">Although the code appears to use string concatenation to append a new character to the existing string named `str`, it actually creates a new <xref:System.String> object for each concatenation operation.</span></span>

 [!code-cpp[System.String.Class#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]

 <span data-ttu-id="3cd3e-230"><xref:System.Text.StringBuilder> <xref:System.String> 对于对字符串的值进行多次更改的操作，可以使用类，而不是类。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-230">You can use the <xref:System.Text.StringBuilder> class instead of the <xref:System.String> class for operations that make multiple changes to the value of a string.</span></span> <span data-ttu-id="3cd3e-231">与类的实例不同 <xref:System.String> ， <xref:System.Text.StringBuilder> 对象是可变的; 当您连接、追加或删除字符串中的子字符串时，将对单个字符串执行这些操作。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-231">Unlike instances of the <xref:System.String> class, <xref:System.Text.StringBuilder> objects are mutable; when you concatenate, append, or delete substrings from a string, the operations are performed on a single string.</span></span> <span data-ttu-id="3cd3e-232">完成修改对象的值后 <xref:System.Text.StringBuilder> ，可以调用其 <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> 方法将其转换为字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-232">When you have finished modifying the value of a <xref:System.Text.StringBuilder> object, you can call its <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> method to convert it to a string.</span></span> <span data-ttu-id="3cd3e-233">下面的示例将替换 <xref:System.String> 前面的示例中使用的，以将范围中的1000个随机字符连接到0x0001，以使用对象进行 0x052F <xref:System.Text.StringBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-233">The following example replaces the <xref:System.String> used in the previous example to concatenate 1000 random characters in the range to  0x0001 to 0x052F with a <xref:System.Text.StringBuilder> object.</span></span>

 [!code-cpp[System.String.Class#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]

<a name="CultureSensitive"></a>
## <a name="ordinal-vs-culture-sensitive-operations"></a><span data-ttu-id="3cd3e-234">序号与区分区域性的操作</span><span class="sxs-lookup"><span data-stu-id="3cd3e-234">Ordinal vs. culture-sensitive operations</span></span>
 <span data-ttu-id="3cd3e-235">类的成员 <xref:System.String> 对对象执行序号或区分区域性的 (语言) 操作 <xref:System.String> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-235">Members of the <xref:System.String> class perform either ordinal or culture-sensitive (linguistic) operations on a <xref:System.String> object.</span></span> <span data-ttu-id="3cd3e-236">序号运算作用于每个对象的数值 <xref:System.Char> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-236">An ordinal operation acts on the numeric value of each <xref:System.Char> object.</span></span> <span data-ttu-id="3cd3e-237">区分区域性的操作将作用于对象的值 <xref:System.String> ，并考虑特定于区域性的大小写、排序、格式设置和分析规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-237">A culture-sensitive operation acts on the value of the <xref:System.String> object, and takes culture-specific casing, sorting, formatting, and parsing rules into account.</span></span> <span data-ttu-id="3cd3e-238">在显式声明的区域性或隐式当前区域性的上下文中执行区分区域性的操作。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-238">Culture-sensitive operations execute in the context of an explicitly declared culture or the implicit current culture.</span></span> <span data-ttu-id="3cd3e-239">当在同一字符串中执行两种类型的操作时，它们会产生不同的结果。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-239">The two kinds of operations can produce very different results when they are performed on the same string.</span></span>

<span data-ttu-id="3cd3e-240">.NET 还支持不区分区域性的语言字符串操作，方法是使用固定区域性 (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>) ，这是松散的，这是基于英语独立于区域的区域性设置的。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-240">.NET also supports culture-insensitive linguistic string operations by using the invariant culture (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>), which is loosely based on the culture settings of the English language independent of region.</span></span> <span data-ttu-id="3cd3e-241">不同于其他 <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> 设置，保证固定区域性的设置在一台计算机、系统、系统和 .net 版本之间保持一致。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-241">Unlike other <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> settings, the settings of the invariant culture are guaranteed to remain consistent on a single computer, from system to system, and across versions of .NET.</span></span> <span data-ttu-id="3cd3e-242">固定区域性可被视为一种黑色框，可确保在所有区域性中进行字符串比较和排序的稳定性。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-242">The invariant culture can be seen as a kind of black box that ensures stability of string comparisons and ordering across all cultures.</span></span>

> [!IMPORTANT]
>  <span data-ttu-id="3cd3e-243">如果你的应用程序对符号标识符（如文件名或命名管道）做出安全决策，或对保存的数据（例如 XML 文件中基于文本的数据）进行安全决策，则操作应使用序号比较，而不是区分区域性的比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-243">If your application makes a security decision about a symbolic identifier such as a file name or named pipe, or about persisted data such as the text-based data in an XML file, the operation should use an ordinal comparison instead of a culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-244">这是因为区分区域性的比较可能会产生不同的结果，具体取决于有效的区域性，而序号比较仅依赖于所比较字符的二进制值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-244">This is because a culture-sensitive comparison can yield different results depending on the culture in effect, whereas an ordinal comparison depends solely on the binary value of the compared characters.</span></span>

> [!IMPORTANT]
>  <span data-ttu-id="3cd3e-245">执行字符串操作的大多数方法都包含一个具有类型为的参数的重载 <xref:System.StringComparison> ，使您可以指定该方法是执行序号还是区分区域性的操作。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-245">Most methods that perform string operations include an overload that has a parameter of type <xref:System.StringComparison>, which enables you to specify whether the method performs an ordinal or culture-sensitive operation.</span></span> <span data-ttu-id="3cd3e-246">通常，应调用此重载，使方法调用的意图清晰明了。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-246">In general, you should call this overload to make the intent of your method call clear.</span></span> <span data-ttu-id="3cd3e-247">有关对字符串使用序号和区分区域性的操作的最佳实践和指南，请参阅 [使用字符串的最佳做法](/dotnet/standard/base-types/best-practices-strings)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-247">For best practices and guidance for using ordinal and culture-sensitive operations on strings, see [Best Practices for Using Strings](/dotnet/standard/base-types/best-practices-strings).</span></span>

 <span data-ttu-id="3cd3e-248">用于 [大小写](#casing)、 [分析和格式](#parsing)、 [比较和排序](#comparison)的操作以及 [相等性测试](#equality) 的操作可以是序号或区分区域性的。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-248">Operations for [casing](#casing), [parsing and formatting](#parsing), [comparison and sorting](#comparison), and [testing for equality](#equality) can be either ordinal or culture-sensitive.</span></span> <span data-ttu-id="3cd3e-249">以下各节介绍操作的每个类别。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-249">The following sections discuss each category of operation.</span></span>

> [!TIP]
>  <span data-ttu-id="3cd3e-250">应始终调用方法重载，使方法调用的意图清晰。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-250">You should always call a method overload that makes the intent of your method call clear.</span></span> <span data-ttu-id="3cd3e-251">例如， <xref:System.String.Compare%28System.String%2CSystem.String%29> 使用当前区域性的约定，而不是调用方法来对两个字符串执行区分区域性的比较，应使用 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> 参数的值调用方法 <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> `comparisonType` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-251">For example, instead of calling the <xref:System.String.Compare%28System.String%2CSystem.String%29> method to perform a culture-sensitive comparison of two strings by using the conventions of the current culture, you should call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method with a value of <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> for the `comparisonType` argument.</span></span> <span data-ttu-id="3cd3e-252">有关详细信息，请参阅[有关使用字符串的最佳实践](/dotnet/standard/base-types/best-practices-strings)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-252">For more information, see [Best Practices for Using Strings](/dotnet/standard/base-types/best-practices-strings).</span></span>

<span data-ttu-id="3cd3e-253">可以下载[排序权重表](https://www.microsoft.com/download/details.aspx?id=10921)，这是一组文本文件，其中包含有关 Windows 操作系统排序和比较操作中所使用的字符权重的信息，也可以下载[默认 Unicode 排序元素表](https://www.unicode.org/Public/UCA/latest/allkeys.txt)，这是适用于 Linux 和 macOS 的排序权重表。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-253">You can download the [Sorting Weight Tables](https://www.microsoft.com/download/details.aspx?id=10921), a set of text files that contain information on the character weights used in sorting and comparison operations for Windows operating systems, and the [Default Unicode Collation Element Table](https://www.unicode.org/Public/UCA/latest/allkeys.txt), the sort weight table for Linux and macOS.</span></span>

<a name="casing"></a>
### <a name="casing"></a><span data-ttu-id="3cd3e-254">大小写</span><span class="sxs-lookup"><span data-stu-id="3cd3e-254">Casing</span></span>
 <span data-ttu-id="3cd3e-255">大小写规则确定如何更改 Unicode 字符的大小写;例如，从小写到大写。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-255">Casing rules determine how to change the capitalization of a Unicode character; for example, from lowercase to uppercase.</span></span> <span data-ttu-id="3cd3e-256">通常，大小写操作在字符串比较之前执行。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-256">Often, a casing operation is performed before a string comparison.</span></span> <span data-ttu-id="3cd3e-257">例如，可能会将字符串转换为大写形式，以便可以将其与另一个大写字符串进行比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-257">For example, a string might be converted to uppercase so that it can be compared with another uppercase string.</span></span> <span data-ttu-id="3cd3e-258">可以通过调用或方法将字符串中的字符转换为小写 <xref:System.String.ToLower%2A> <xref:System.String.ToLowerInvariant%2A> ，并可以通过调用或方法将其转换为大写 <xref:System.String.ToUpper%2A> <xref:System.String.ToUpperInvariant%2A> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-258">You can convert the characters in a string to lowercase by calling the <xref:System.String.ToLower%2A> or <xref:System.String.ToLowerInvariant%2A> method, and you can convert them to uppercase by calling the <xref:System.String.ToUpper%2A> or <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="3cd3e-259">此外，还可以使用 <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> 方法将字符串转换为词首字母大写。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-259">In addition, you can use the <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> method to convert a string to title case.</span></span>

[!INCLUDE[platform-note](~/includes/c-and-posix-cultures.md)]

 <span data-ttu-id="3cd3e-260">大小写操作可以基于当前区域性的规则、指定的区域性或固定区域性。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-260">Casing operations can be based on the rules of the current culture, a specified culture, or the invariant culture.</span></span> <span data-ttu-id="3cd3e-261">由于大小写映射可能会因所使用的区域性而异，因此大小写操作的结果可能会因区域性而异。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-261">Because case mappings can vary depending on the culture used, the result of casing operations can vary based on culture.</span></span> <span data-ttu-id="3cd3e-262">大小写的实际差异为三种类型：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-262">The actual differences in casing are of three kinds:</span></span>

-   <span data-ttu-id="3cd3e-263">拉丁文大写字母 I (U + 0049) ，拉丁文小写字母 I (U + 0069) ，拉丁文大写字母 I 与上面的点 (U + 0130) ，以及拉丁文小写字母无点 I (U + 0131) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-263">Differences in the case mapping of LATIN CAPITAL LETTER I (U+0049), LATIN SMALL LETTER I (U+0069), LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130), and LATIN SMALL LETTER DOTLESS I (U+0131).</span></span> <span data-ttu-id="3cd3e-264">在 tr-TR (土耳其语 (土耳其) # A3 and az-AZ (阿塞拜疆，拉丁语) 文化，在 tr，az，and az-Latn 中立文化中，小写等效于拉丁大写字母 I 的小写字母无点 i，并且上面带有带点的大写等效字符 i。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-264">In the tr-TR (Turkish (Turkey)) and az-Latn-AZ (Azerbaijan, Latin) cultures, and in the tr, az, and az-Latn neutral cultures, the lowercase equivalent of LATIN CAPITAL LETTER I is LATIN SMALL LETTER DOTLESS I, and the uppercase equivalent of LATIN SMALL LETTER I is LATIN CAPITAL LETTER I WITH DOT ABOVE.</span></span> <span data-ttu-id="3cd3e-265">在所有其他区域性（包括固定区域性）中，拉丁文小写字母 I 和拉丁大写字母 I 是小写和大写等效项。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-265">In all other cultures, including the invariant culture, LATIN SMALL LETTER I and LATIN CAPITAL LETTER I are lowercase and uppercase equivalents.</span></span>

     <span data-ttu-id="3cd3e-266">下面的示例演示了在依赖于区分区域性的大小写比较的情况下，用于防止文件系统访问的字符串比较可能会失败。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-266">The following example demonstrates how a string comparison designed to prevent file system access can fail if it relies on a culture-sensitive casing comparison.</span></span> <span data-ttu-id="3cd3e-267"> (应使用固定区域性的大小写约定。 ) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-267">(The casing conventions of the invariant culture should have been used.)</span></span>

     [!code-csharp[System.String.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]

-   <span data-ttu-id="3cd3e-268">固定区域性与所有其他区域性之间的大小写映射差异。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-268">Differences in case mappings between the invariant culture and all other cultures.</span></span> <span data-ttu-id="3cd3e-269">在这些情况下，使用固定区域性的大小写规则将字符更改为大写或小写将返回相同的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-269">In these cases, using the casing rules of the invariant culture to change a character to uppercase or lowercase returns the same character.</span></span> <span data-ttu-id="3cd3e-270">对于所有其他区域性，它返回不同的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-270">For all other cultures, it returns a different character.</span></span> <span data-ttu-id="3cd3e-271">下表列出了一些受影响的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-271">Some of the affected characters are listed in the following table.</span></span>

    |<span data-ttu-id="3cd3e-272">字符</span><span class="sxs-lookup"><span data-stu-id="3cd3e-272">Character</span></span>|<span data-ttu-id="3cd3e-273">如果更改为</span><span class="sxs-lookup"><span data-stu-id="3cd3e-273">If changed to</span></span>|<span data-ttu-id="3cd3e-274">返回</span><span class="sxs-lookup"><span data-stu-id="3cd3e-274">Returns</span></span>|
    |---------------|-------------------|-------------|
    |<span data-ttu-id="3cd3e-275">微米符号 (U + 00B5) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-275">MICRON SIGN (U+00B5)</span></span>|<span data-ttu-id="3cd3e-276">大写</span><span class="sxs-lookup"><span data-stu-id="3cd3e-276">Uppercase</span></span>|<span data-ttu-id="3cd3e-277">希腊语大写字母 MU (U +-39C) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-277">GREEK CAPITAL LETTER MU (U+-39C)</span></span>|
    |<span data-ttu-id="3cd3e-278">拉丁文大写字母 I 与上点 (U + 0130) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-278">LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130)</span></span>|<span data-ttu-id="3cd3e-279">小写</span><span class="sxs-lookup"><span data-stu-id="3cd3e-279">Lowercase</span></span>|<span data-ttu-id="3cd3e-280">拉丁文小写字母 I (U + 0069) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-280">LATIN SMALL LETTER I (U+0069)</span></span>|
    |<span data-ttu-id="3cd3e-281">拉丁文小写字母无点 (U + 0131) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-281">LATIN SMALL LETTER DOTLESS I (U+0131)</span></span>|<span data-ttu-id="3cd3e-282">大写</span><span class="sxs-lookup"><span data-stu-id="3cd3e-282">Uppercase</span></span>|<span data-ttu-id="3cd3e-283">拉丁文大写字母 I (U + 0049) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-283">LATIN CAPITAL LETTER I (U+0049)</span></span>|
    |<span data-ttu-id="3cd3e-284">拉丁文小写字母长 S (U + 017F) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-284">LATIN SMALL LETTER LONG S (U+017F)</span></span>|<span data-ttu-id="3cd3e-285">大写</span><span class="sxs-lookup"><span data-stu-id="3cd3e-285">Uppercase</span></span>|<span data-ttu-id="3cd3e-286">拉丁文大写字母 S (U + 0053) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-286">LATIN CAPITAL LETTER S (U+0053)</span></span>|
    |<span data-ttu-id="3cd3e-287">拉丁文大写字母 D 与小写字母 Z 一起出现 (U + 01C5) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-287">LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON (U+01C5)</span></span>|<span data-ttu-id="3cd3e-288">小写</span><span class="sxs-lookup"><span data-stu-id="3cd3e-288">Lowercase</span></span>|<span data-ttu-id="3cd3e-289">拉丁文小写字母 DZ 与抑扬符 (U + 01C6) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-289">LATIN SMALL LETTER DZ WITH CARON (U+01C6)</span></span>|
    |<span data-ttu-id="3cd3e-290">结合希腊语 YPOGEGRAMMENI (U + 0345) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-290">COMBINING GREEK YPOGEGRAMMENI (U+0345)</span></span>|<span data-ttu-id="3cd3e-291">大写</span><span class="sxs-lookup"><span data-stu-id="3cd3e-291">Uppercase</span></span>|<span data-ttu-id="3cd3e-292">希腊语大写字母 IOTA (U + 0399) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-292">GREEK CAPITAL LETTER IOTA (U+0399)</span></span>|

-   <span data-ttu-id="3cd3e-293">ASCII 字符范围内两个字母混合大小写对的大小写差异。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-293">Differences in case mappings of two-letter mixed-case pairs in the ASCII character range.</span></span> <span data-ttu-id="3cd3e-294">在大多数区域性中，两字母混合大小写与等效的双字母大写或小写对相等。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-294">In most cultures, a two-letter mixed-case pair is equal to the equivalent two-letter uppercase or lowercase pair.</span></span> <span data-ttu-id="3cd3e-295">对于以下区域性中的以下两个字母对，这并不是这样，因为在每种情况下，它们将与二个连字符进行比较：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-295">This is not true for the following two-letter pairs in the following cultures, because in each case they are compared to a digraph:</span></span>

    -   <span data-ttu-id="3cd3e-296">hr-HR (克罗地亚语 (克罗地亚) # A3 区域性中的 "V6d-lj-h2e" 和 "nJ"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-296">"lJ" and "nJ" in the hr-HR (Croatian (Croatia)) culture.</span></span>

    -   <span data-ttu-id="3cd3e-297">cs-CZ 中的 "cH" (捷克 (捷克共和国) # A3 和 sk-SK (斯洛伐克语 (# A7 区域性。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-297">"cH" in the cs-CZ (Czech (Czech Republic)) and sk-SK (Slovak (Slovakia)) cultures.</span></span>

    -   <span data-ttu-id="3cd3e-298">da 中的 "aA"-深色 (丹麦 (丹麦) # A3 区域性。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-298">"aA" in the da-DK (Danish (Denmark)) culture.</span></span>

    -   <span data-ttu-id="3cd3e-299"> (匈牙利语 (匈牙利) # A3 区域性中的 "cS"、"dZ"、"dZS"、"nY"、"sZ"、"tY" 和 "zS"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-299">"cS", "dZ", "dZS", "nY", "sZ", "tY", and "zS" in the hu-HU (Hungarian (Hungary)) culture.</span></span>

    -   <span data-ttu-id="3cd3e-300">es ES_tradnl 中的 "cH" 和 "lL" (西班牙语 (西班牙，传统排序) # A3 区域性。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-300">"cH" and "lL" in the es-ES_tradnl (Spanish (Spain, Traditional Sort)) culture.</span></span>

    -   <span data-ttu-id="3cd3e-301">VN (越南语 (越南) # A3 区域性中的 "cH"、"gI"、"kH"、"nG" "nH"、"pH"、"qU"、"tH" 和 "tR"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-301">"cH", "gI", "kH", "nG" "nH", "pH", "qU', "tH", and "tR" in the vi-VN (Vietnamese (Vietnam)) culture.</span></span>

     <span data-ttu-id="3cd3e-302">但是，出现这种对等区分区域性的比较时可能会产生问题，因为这些对在固定字符串或标识符中不常见。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-302">However, it is unusual to encounter a situation in which a culture-sensitive comparison of these pairs creates problems, because these pairs are uncommon in fixed strings or identifiers.</span></span>

 <span data-ttu-id="3cd3e-303">下面的示例演示了在将字符串转换为大写时，区域性之间的大小写规则的一些差异。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-303">The following example illustrates some of the differences in casing rules between cultures when converting strings to uppercase.</span></span>

 [!code-cpp[System.String.Class#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]

<a name="parsing"></a>
### <a name="parsing-and-formatting"></a><span data-ttu-id="3cd3e-304">分析和格式化</span><span class="sxs-lookup"><span data-stu-id="3cd3e-304">Parsing and formatting</span></span>
 <span data-ttu-id="3cd3e-305">格式设置和分析是反向操作。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-305">Formatting and parsing are inverse operations.</span></span> <span data-ttu-id="3cd3e-306">格式设置规则确定如何将值（如日期和时间或数字）转换为其字符串表示形式，而分析规则确定如何将字符串表示形式转换为值（如日期和时间）。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-306">Formatting rules determine how to convert a value, such as a date and time or a number, to its string representation, whereas parsing rules determine how to convert a string representation to a value such as a date and time.</span></span> <span data-ttu-id="3cd3e-307">格式设置和分析规则都依赖于区域性约定。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-307">Both formatting and parsing rules are dependent on cultural conventions.</span></span> <span data-ttu-id="3cd3e-308">下面的示例说明了解释特定于区域性的日期字符串时可能出现的多义性。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-308">The following example illustrates the ambiguity that can arise when interpreting a culture-specific date string.</span></span> <span data-ttu-id="3cd3e-309">如果不知道用于生成日期字符串的区域性约定，则不可能知道03/01/2011、3/1/2011 和01/03/2011 是表示年1月 2011 3 日还是年3月 2011 1 日。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-309">Without knowing the conventions of the culture that was used to produce a date string, it is not possible to know whether 03/01/2011, 3/1/2011, and 01/03/2011 represent January 3, 2011 or March 1, 2011.</span></span>

 [!code-cpp[System.String.Class#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]

 <span data-ttu-id="3cd3e-310">同样，如下面的示例所示，单个字符串可以生成不同的日期，具体取决于在分析操作中使用约定的区域性。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-310">Similarly, as the following example shows, a single string can produce different dates depending on the culture whose conventions are used in the parsing operation.</span></span>

 [!code-cpp[System.String.Class#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]

<a name="comparison"></a>
### <a name="string-comparison-and-sorting"></a><span data-ttu-id="3cd3e-311">字符串比较和排序</span><span class="sxs-lookup"><span data-stu-id="3cd3e-311">String comparison and sorting</span></span>
 <span data-ttu-id="3cd3e-312">用于比较和排序字符串的约定因区域性而异。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-312">Conventions for comparing and sorting strings vary from culture to culture.</span></span> <span data-ttu-id="3cd3e-313">例如，排序顺序可能基于拼音或字符的直观表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-313">For example, the sort order may be based on phonetics or on the visual representation of characters.</span></span> <span data-ttu-id="3cd3e-314">在东亚语言中，按文字的笔画和部首对字符进行排序。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-314">In East Asian languages, characters are sorted by the stroke and radical of ideographs.</span></span> <span data-ttu-id="3cd3e-315">排序也取决于字母表使用的排序语言和区域性。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-315">Sorting also depends on the order languages and cultures use for the alphabet.</span></span> <span data-ttu-id="3cd3e-316">例如，丹麦语包含一个 "Æ" 字符，该字符在字母表中的 "Z" 之后排序。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-316">For example, the Danish language has an "Æ" character that it sorts after "Z" in the alphabet.</span></span> <span data-ttu-id="3cd3e-317">此外，比较可以区分大小写或不区分大小写，在某些情况下，大小写规则也会因区域性而异。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-317">In addition, comparisons can be case-sensitive or case-insensitive, and in some cases casing rules also differ by culture.</span></span> <span data-ttu-id="3cd3e-318">另一方面，序号比较在比较和排序字符串时使用字符串中各个字符的 Unicode 码位。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-318">Ordinal comparison, on the other hand, uses the Unicode code points of individual characters in a string when comparing and sorting strings.</span></span>

 <span data-ttu-id="3cd3e-319">排序规则确定 Unicode 字符的字母顺序，以及两个字符串之间的相互比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-319">Sort rules determine the alphabetic order of Unicode characters and how two strings compare to each other.</span></span> <span data-ttu-id="3cd3e-320">例如， <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> 方法基于参数比较两个字符串 <xref:System.StringComparison> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-320">For example, the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> method compares two strings based on the <xref:System.StringComparison> parameter.</span></span> <span data-ttu-id="3cd3e-321">如果参数值为 <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> ，则该方法执行使用当前区域性的约定的语言比较; 如果参数值为 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> ，则该方法执行序号比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-321">If the parameter value is <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, the method performs a linguistic comparison that uses the conventions of the current culture; if the parameter value is <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>, the method performs an ordinal comparison.</span></span> <span data-ttu-id="3cd3e-322">因此，正如下面的示例中所示，如果当前区域性为美国英语，则使用区分区域性的比较) 对方法的第一次调用会将 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> "a" (视为 "a"，但使用序号) 比较 (对同一方法的第二次调用会将 "a" 视为大于 "a"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-322">Consequently, as the following example shows, if the current culture is U.S. English, the first call to the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> method (using culture-sensitive comparison) considers "a" less than "A", but the second call to the same method (using ordinal comparison) considers "a" greater than "A".</span></span>

 [!code-cpp[System.String.Class#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]

 <span data-ttu-id="3cd3e-323">.NET 支持 word、string 和 ordinal 排序规则：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-323">.NET supports word, string, and ordinal sort rules:</span></span>

-   <span data-ttu-id="3cd3e-324">单词排序会对字符串执行区分区域性的比较，在这些字符串中，某些非字母数字的 Unicode 字符可能会分配有特殊的权重。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-324">A word sort performs a culture-sensitive comparison of strings in which certain nonalphanumeric Unicode characters might have special weights assigned to them.</span></span> <span data-ttu-id="3cd3e-325">例如，连字符 ( ) 可能会分配非常小的权重，以便在排序列表中彼此相邻显示 "合作比较" 和 "共同操作"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-325">For example, the hyphen (-) might have a very small weight assigned to it so that "coop" and "co-op" appear next to each other in a sorted list.</span></span> <span data-ttu-id="3cd3e-326">有关 <xref:System.String> 使用单词排序规则比较两个字符串的方法列表，请参阅 " [按类别列出的字符串操作](#ByCategory) " 部分。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-326">For a list of the <xref:System.String> methods that compare two strings using word sort rules, see the [String operations by category](#ByCategory) section.</span></span>

-   <span data-ttu-id="3cd3e-327">字符串排序还会执行区分区域性的比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-327">A string sort also performs a culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-328">它类似于单词排序，只不过没有特殊情况，所有非字母数字的符号都在所有字母数字 Unicode 字符之前。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-328">It is similar to a word sort, except that there are no special cases, and all nonalphanumeric symbols come before all alphanumeric Unicode characters.</span></span> <span data-ttu-id="3cd3e-329">可以使用字符串排序规则来比较两个字符串，方法是调用 <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> 具有参数的方法重载，该 `options` 参数提供值 <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-329">Two strings can be compared using string sort rules by calling the <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> method overloads that have an `options` parameter that is supplied a value of <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3cd3e-330">请注意，这是 .NET 提供的唯一方法，可使用字符串排序规则来比较两个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-330">Note that this is the only method that .NET provides to compare two strings using string sort rules.</span></span>

-   <span data-ttu-id="3cd3e-331">序号排序根据字符串中每个对象的数值来比较字符串 <xref:System.Char> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-331">An ordinal sort compares strings based on the numeric value of each <xref:System.Char> object in the string.</span></span> <span data-ttu-id="3cd3e-332">序号比较会自动区分大小写，因为字符的小写和大写版本具有不同的码位。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-332">An ordinal comparison is automatically case-sensitive because the lowercase and uppercase versions of a character have different code points.</span></span> <span data-ttu-id="3cd3e-333">但是，如果 case 不重要，则可以指定忽略大小写的序号比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-333">However, if case is not important, you can specify an ordinal comparison that ignores case.</span></span> <span data-ttu-id="3cd3e-334">这等效于使用固定区域性将字符串转换为大写，然后对结果执行序号比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-334">This is equivalent to converting the string to uppercase by using the invariant culture and then performing an ordinal comparison on the result.</span></span> <span data-ttu-id="3cd3e-335">有关 <xref:System.String> 使用序号排序规则比较两个字符串的方法的列表，请参阅 [按类别列出的字符串操作](#ByCategory) 部分。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-335">For a list of the <xref:System.String> methods that compare two strings using ordinal sort rules, see the [String operations by category](#ByCategory) section.</span></span>

 <span data-ttu-id="3cd3e-336">区分区域性的比较是显式或隐式使用 <xref:System.Globalization.CultureInfo> 对象（包括属性指定的固定区域性）的任何比较 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-336">A culture-sensitive comparison is any comparison that explicitly or implicitly uses a <xref:System.Globalization.CultureInfo> object, including the invariant culture that is specified by the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="3cd3e-337">隐式区域性为当前区域性，由 <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> 和 <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> 属性指定。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-337">The implicit culture is the current culture, which is specified by the <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> properties.</span></span> <span data-ttu-id="3cd3e-338">字母字符的排序顺序有相当大的变化形式 (即， <xref:System.Char.IsLetter%2A?displayProperty=nameWithType> 属性 `true`) 跨区域性返回的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-338">There is considerable variation in the sort order of alphabetic characters (that is, characters for which the <xref:System.Char.IsLetter%2A?displayProperty=nameWithType> property returns `true`) across cultures.</span></span> <span data-ttu-id="3cd3e-339">您可以通过 <xref:System.Globalization.CultureInfo> 向字符串比较方法（如）提供对象来指定使用特定区域性约定的区分区域性的比较 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-339">You can specify a culture-sensitive comparison that uses the conventions of a specific culture by supplying a <xref:System.Globalization.CultureInfo> object to a string comparison method such as <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>.</span></span> <span data-ttu-id="3cd3e-340">您可以通过将 <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> 、或 <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> 除或之外的任何枚举成员提供 <xref:System.Globalization.CompareOptions> <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> 给方法的适当重载 <xref:System.String.Compare%2A> ，来指定使用当前区域性的约定的区分区域性的比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-340">You can specify a culture-sensitive comparison that uses the conventions of the current culture by supplying <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, or any member of the <xref:System.Globalization.CompareOptions> enumeration other than <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> or <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> to an appropriate overload of the <xref:System.String.Compare%2A> method.</span></span> <span data-ttu-id="3cd3e-341">通常，区分区域性的比较适用于排序，而序号比较不是。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-341">A culture-sensitive comparison is generally appropriate for sorting whereas an ordinal comparison is not.</span></span> <span data-ttu-id="3cd3e-342">序号比较通常适用于确定两个字符串是否相等 (也就是说，确定标识) 而不区分区域性的比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-342">An ordinal comparison is generally appropriate for determining whether two strings are equal (that is, for determining identity) whereas a culture-sensitive comparison is not.</span></span>

 <span data-ttu-id="3cd3e-343">下面的示例阐释区分区域性和顺序比较之间的差异。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-343">The following example illustrates the difference between culture-sensitive and ordinal comparison.</span></span> <span data-ttu-id="3cd3e-344">该示例计算三个字符串： "Apple"、"Æble" 和 "AEble"，使用序号比较以及 "" 和 "en-us" 区域性的约定 (其中每个都是调用方法时的默认区域性 <xref:System.String.Compare%2A>) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-344">The example evaluates three strings, "Apple", "Æble", and "AEble", using ordinal comparison and the conventions of the da-DK and en-US cultures (each of which is the default culture at the time the <xref:System.String.Compare%2A> method is called).</span></span> <span data-ttu-id="3cd3e-345">由于丹麦语将字符 "Æ" 视为单个字母，并在字母表中的 "Z" 后对其进行排序，因此字符串 "Æble" 大于 "Apple"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-345">Because the Danish language treats the character "Æ" as an individual letter and sorts it after "Z" in the alphabet, the string "Æble" is greater than "Apple".</span></span> <span data-ttu-id="3cd3e-346">但是，"Æble" 不会视为等效于 "AEble"，因此 "Æble" 还会大于 "AEble"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-346">However, "Æble" is not considered equivalent to "AEble", so "Æble" is also greater than "AEble".</span></span> <span data-ttu-id="3cd3e-347">En-us 区域性不包含字母 "Æ"，而是将其视为等效于 "AE"，这说明 "Æble" 小于 "Apple" 但等于 "AEble" 的原因。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-347">The en-US culture doesn't include the letter"Æ" but treats it as equivalent to "AE", which explains why  "Æble" is less than "Apple" but equal to "AEble".</span></span> <span data-ttu-id="3cd3e-348">另一方面，序号比较会将 "Apple" 视为小于 "Æble"，将 "Æble" 视为大于 "AEble"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-348">Ordinal comparison, on the other hand, considers "Apple" to be less than "Æble", and "Æble" to be greater than "AEble".</span></span>

 [!code-csharp[System.String.Class#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]

 <span data-ttu-id="3cd3e-349">使用以下一般准则来选择适当的排序或字符串比较方法：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-349">Use the following general guidelines to choose an appropriate sorting or string comparison method:</span></span>

-   <span data-ttu-id="3cd3e-350">如果希望根据用户的区域性对字符串进行排序，则应根据当前区域性的约定对它们进行排序。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-350">If you want the strings to be ordered based on the user's culture, you should order them based on the conventions of the current culture.</span></span> <span data-ttu-id="3cd3e-351">如果用户的区域性发生更改，则排序字符串的顺序也会相应地发生更改。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-351">If the user's culture changes, the order of sorted strings will also change accordingly.</span></span> <span data-ttu-id="3cd3e-352">例如，同义词库应用程序应始终基于用户的区域性对单词进行排序。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-352">For example, a thesaurus application should always sort words based on the user's culture.</span></span>

-   <span data-ttu-id="3cd3e-353">如果希望根据特定区域性的约定对字符串进行排序，则应通过将 <xref:System.Globalization.CultureInfo> 表示该区域性的对象提供给比较方法进行排序。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-353">If you want the strings to be ordered based on the conventions of a specific culture, you should order them by supplying a <xref:System.Globalization.CultureInfo> object that represents that culture to a comparison method.</span></span> <span data-ttu-id="3cd3e-354">例如，在旨在向学生讲授特定语言的应用程序中，你希望根据使用该语言的某个区域性的约定对字符串进行排序。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-354">For example, in an application designed to teach students a particular language, you want strings to be ordered based on the conventions of one of the cultures that speaks that language.</span></span>

-   <span data-ttu-id="3cd3e-355">如果希望字符串顺序在不同的区域性中保持不变，则应根据固定区域性的约定或使用序号比较对它们进行排序。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-355">If you want the order of strings to remain unchanged across cultures, you should order them based on the conventions of the invariant culture or use an ordinal comparison.</span></span> <span data-ttu-id="3cd3e-356">例如，使用序号排序来组织文件、进程、互斥体或命名管道的名称。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-356">For example, you would use an ordinal sort to organize the names of files, processes, mutexes, or named pipes.</span></span>

-   <span data-ttu-id="3cd3e-357">对于涉及安全决策的比较 (例如用户名是否有效) ，应始终通过调用方法的重载来执行顺序相等性测试 <xref:System.String.Equals%2A> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-357">For a comparison that involves a security decision (such as whether a username is valid), you should always perform an ordinal test for equality by calling an overload of the <xref:System.String.Equals%2A> method.</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-358">字符串比较中使用的区分区域性的排序和大小写规则取决于 .NET 的版本。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-358">The culture-sensitive sorting and casing rules used in string comparison depend on the version of the .NET.</span></span> <span data-ttu-id="3cd3e-359">在操作系统上运行的 .NET Framework 4.5 及更高版本中 [!INCLUDE[win8](~/includes/win8-md.md)] ，排序、大小写、规范化和 unicode 字符信息符合 unicode 6.0 标准。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-359">In the .NET Framework 4.5 and later versions running on the [!INCLUDE[win8](~/includes/win8-md.md)] operating system, sorting, casing, normalization, and Unicode character information conforms to the Unicode 6.0 standard.</span></span> <span data-ttu-id="3cd3e-360">在其他 Windows 操作系统上，它符合 Unicode 5.0 标准。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-360">On other Windows operating systems, it conforms to the Unicode 5.0 standard.</span></span> <span data-ttu-id="3cd3e-361">在 .NET Core 上，它依赖于基础操作系统支持的 Unicode 标准版本。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-361">On .NET Core, it depends on the version of the Unicode Standard supported by the underlying operating system.</span></span>

 <span data-ttu-id="3cd3e-362">有关 word、字符串和顺序排序规则的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 主题。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-362">For more information about word, string, and ordinal sort rules, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> topic.</span></span> <span data-ttu-id="3cd3e-363">有关何时使用每个规则的其他建议，请参阅 [使用字符串的最佳做法](/dotnet/standard/base-types/best-practices-strings)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-363">For additional recommendations on when to use each rule, see [Best Practices for Using Strings](/dotnet/standard/base-types/best-practices-strings).</span></span>

 <span data-ttu-id="3cd3e-364">通常，您不会直接调用字符串比较方法（如） <xref:System.String.Compare%2A> 来确定字符串的排序顺序。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-364">Ordinarily, you don't call string comparison methods such as <xref:System.String.Compare%2A> directly to determine the sort order of strings.</span></span> <span data-ttu-id="3cd3e-365">相反，通过排序方法（如或）调用比较 <xref:System.Array.Sort%2A?displayProperty=nameWithType> 方法 <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-365">Instead, comparison methods are called by sorting methods such as <xref:System.Array.Sort%2A?displayProperty=nameWithType> or <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3cd3e-366">下面的示例使用当前区域性执行四个不同的排序操作 (单词排序、使用固定区域性进行排序、序号排序和使用固定区域性的字符串排序) 而无需显式调用字符串比较方法，尽管它们确实指定了要使用的比较类型。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-366">The following example performs four different sorting operations (word sort using the current culture, word sort using the invariant culture, ordinal sort, and string sort using the invariant culture) without explicitly calling a string comparison method, although they do specify the type of comparison to use.</span></span> <span data-ttu-id="3cd3e-367">请注意，每种类型的排序在其数组中生成唯一的字符串排序。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-367">Note that each type of sort produces a unique ordering of strings in its array.</span></span>

 [!code-cpp[System.String.Class#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]

> [!TIP]
>  <span data-ttu-id="3cd3e-368">在内部，.NET 使用排序键来支持区分区域性的字符串比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-368">Internally, .NET uses sort keys to support culturally sensitive string comparison.</span></span> <span data-ttu-id="3cd3e-369">对于字符串中的每个字符，都赋予若干类排序权重，包括字母、大小写和变音符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-369">Each character in a string is given several categories of sort weights, including alphabetic, case, and diacritic.</span></span> <span data-ttu-id="3cd3e-370">由类表示的排序关键字 <xref:System.Globalization.SortKey> 为特定字符串提供了这些权重的存储库。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-370">A sort key, represented by the <xref:System.Globalization.SortKey> class, provides a repository of these weights for a particular string.</span></span> <span data-ttu-id="3cd3e-371">如果你的应用程序对相同的一组字符串执行大量搜索或排序操作，则可以通过为其使用的所有字符串生成和存储排序关键字来提高其性能。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-371">If your app performs a large number of searching or sorting operations on the same set of strings, you can improve its performance by generating and storing sort keys for all the strings that it uses.</span></span> <span data-ttu-id="3cd3e-372">需要进行排序或比较操作时，请使用排序关键字而不是字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-372">When a sort or comparison operation is required, you use the sort keys instead of the strings.</span></span> <span data-ttu-id="3cd3e-373">有关更多信息，请参见 <xref:System.Globalization.SortKey> 类。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-373">For more information, see the <xref:System.Globalization.SortKey> class.</span></span>

 <span data-ttu-id="3cd3e-374">如果未指定字符串比较约定，将对 <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> 字符串执行区分区域性、区分大小写的排序等方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-374">If you don't specify a string comparison convention, sorting methods such as <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> perform a culture-sensitive, case-sensitive sort on strings.</span></span> <span data-ttu-id="3cd3e-375">下面的示例演示更改当前区域性如何影响数组中已排序字符串的顺序。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-375">The following example illustrates how changing the current culture affects the order of sorted strings in an array.</span></span> <span data-ttu-id="3cd3e-376">它创建一个包含三个字符串的数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-376">It creates an array of three strings.</span></span> <span data-ttu-id="3cd3e-377">首先，它将 `System.Threading.Thread.CurrentThread.CurrentCulture` 属性设置为 en-US，并调用 <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-377">First, it sets the `System.Threading.Thread.CurrentThread.CurrentCulture` property to en-US and calls the <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3cd3e-378">生成的排序顺序基于英语 (美国) 区域性的排序约定。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-378">The resulting sort order is based on sorting conventions for the English (United States) culture.</span></span> <span data-ttu-id="3cd3e-379">接着，此示例将 `System.Threading.Thread.CurrentThread.CurrentCulture` 属性设置为 da-DK 并再次调用 <xref:System.Array.Sort%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-379">Next, the example sets the `System.Threading.Thread.CurrentThread.CurrentCulture` property to da-DK and calls the <xref:System.Array.Sort%2A?displayProperty=nameWithType> method again.</span></span> <span data-ttu-id="3cd3e-380">请注意，最终排序顺序与使用 en-US 时的结果不一样，因为这次使用的是针对丹麦语（丹麦）的排序约定。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-380">Notice how the resulting sort order differs from the en-US results because it uses the sorting conventions for Danish (Denmark).</span></span>

 [!code-csharp[Conceptual.Strings.Comparing#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]

> [!WARNING]
>  <span data-ttu-id="3cd3e-381">如果比较字符串的主要目的是确定它们是否相等，应调用 <xref:System.String.Equals%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-381">If your primary purpose in comparing strings is to determine whether they are equal, you should call the <xref:System.String.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3cd3e-382">通常，应使用 <xref:System.String.Equals%2A> 来执行序号比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-382">Typically, you should use <xref:System.String.Equals%2A> to perform an ordinal comparison.</span></span> <span data-ttu-id="3cd3e-383"><xref:System.String.Compare%2A?displayProperty=nameWithType>方法主要用于对字符串进行排序。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-383">The <xref:System.String.Compare%2A?displayProperty=nameWithType> method is intended primarily to sort strings.</span></span>

 <span data-ttu-id="3cd3e-384">字符串搜索方法（如 <xref:System.String.StartsWith%2A?displayProperty=nameWithType> 和 <xref:System.String.IndexOf%2A?displayProperty=nameWithType> ）也可以执行区分区域性或序号字符串比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-384">String search methods, such as <xref:System.String.StartsWith%2A?displayProperty=nameWithType> and <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, also can perform culture-sensitive or ordinal string comparisons.</span></span> <span data-ttu-id="3cd3e-385">下面的示例使用方法说明了序号和区分区域性的比较之间的差异 <xref:System.String.IndexOf%2A> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-385">The following example illustrates the differences between ordinal and culture-sensitive comparisons using the <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="3cd3e-386">区分区域性的搜索，其中，当前区域性为英语 (美国) 将子字符串 "oe" 与连字 "–" 相匹配。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-386">A culture-sensitive search in which the current culture is English (United States) considers the substring "oe" to match the ligature "œ".</span></span> <span data-ttu-id="3cd3e-387">由于软连字符 (U + 00AD) 是宽度为零的字符，因此搜索会将软连字符视为等效于 <xref:System.String.Empty?displayProperty=nameWithtype> 并在字符串的开头找到匹配项。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-387">Because a soft hyphen (U+00AD) is a zero-width character, the search treats the soft hyphen as equivalent to <xref:System.String.Empty?displayProperty=nameWithtype> and finds a match at the beginning of the string.</span></span> <span data-ttu-id="3cd3e-388">另一方面，序号搜索在任一情况下都找不到匹配项。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-388">An ordinal search, on the other hand, does not find a match in either case.</span></span>

 [!code-cpp[System.String.Class#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]

### <a name="searching-strings"></a><span data-ttu-id="3cd3e-389">搜索字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-389">Searching Strings</span></span>
 <span data-ttu-id="3cd3e-390">字符串搜索方法（如 <xref:System.String.StartsWith%2A?displayProperty=nameWithType> 和 <xref:System.String.IndexOf%2A?displayProperty=nameWithType> ）也可以执行区分区域性或序号的字符串比较，以确定是否在指定字符串中找到了字符或子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-390">String search methods, such as <xref:System.String.StartsWith%2A?displayProperty=nameWithType> and <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, also can perform culture-sensitive or ordinal string comparisons to determine whether a character or substring is found in a specified string.</span></span>

 <span data-ttu-id="3cd3e-391">类中搜索单独字符的搜索方法（如 <xref:System.String> <xref:System.String.IndexOf%2A> 方法）或一组字符（如方法）中的一种搜索方法 <xref:System.String.IndexOfAny%2A> 都执行序号搜索。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-391">The search methods in the <xref:System.String> class that search for an individual character, such as the <xref:System.String.IndexOf%2A> method, or one of a set of characters,   such as the <xref:System.String.IndexOfAny%2A> method, all perform an ordinal search.</span></span> <span data-ttu-id="3cd3e-392">若要对字符执行区分区域性的搜索，必须调用 <xref:System.Globalization.CompareInfo> 方法，如 <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> 或 <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-392">To perform a culture-sensitive search for a character, you must call a <xref:System.Globalization.CompareInfo> method such as <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> or <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3cd3e-393">请注意，使用序号和区分区域性的比较搜索字符的结果可能会有很大的不同。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-393">Note that the results of searching for a character using ordinal and culture-sensitive comparison can be very different.</span></span> <span data-ttu-id="3cd3e-394">例如，搜索预构成 Unicode 字符（如连字 "Æ" (U + 00C6) ）可能会以正确的顺序（例如 "AE" (U + 041U + 0045) ）匹配其任何组件的出现位置，具体取决于区域性。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-394">For example, a search for a precomposed Unicode character such as the ligature "Æ" (U+00C6) might match any occurrence of its components in the correct sequence, such as "AE" (U+041U+0045), depending on the culture.</span></span> <span data-ttu-id="3cd3e-395">下面的示例演示了在 <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> 搜索单个字符时和方法之间的差异。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-395">The following example illustrates the difference between the <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> and <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> methods when searching for an individual character.</span></span> <span data-ttu-id="3cd3e-396">使用 en-us 区域性约定时，在字符串 "高空" 中找到连字 "æ" (U + 00E6) ，但不能在使用 da-深色区域性或执行序号比较时使用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-396">The ligature "æ" (U+00E6) is found in the string "aerial" when using the conventions of the en-US culture, but not when using the conventions of the da-DK culture or when performing an ordinal comparison.</span></span>

 [!code-csharp[System.String.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]

 <span data-ttu-id="3cd3e-397">另一方面， <xref:System.String> 搜索字符串（而不是字符）的类方法执行区分区域性的搜索（如果搜索选项未由类型的参数显式指定） <xref:System.StringComparison> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-397">On the other hand, <xref:System.String> class methods that search for a string rather than a character perform a culture-sensitive search if search options are not explicitly specified by a parameter of type <xref:System.StringComparison>.</span></span> <span data-ttu-id="3cd3e-398">唯一的例外是 <xref:System.String.Contains%2A> ，它执行序号搜索。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-398">The sole exception is <xref:System.String.Contains%2A>, which performs an ordinal search.</span></span>

<a name="equality"></a>
### <a name="testing-for-equality"></a><span data-ttu-id="3cd3e-399">测试是否相等</span><span class="sxs-lookup"><span data-stu-id="3cd3e-399">Testing for equality</span></span>
 <span data-ttu-id="3cd3e-400">使用 <xref:System.String.Compare%2A?displayProperty=nameWithType> 方法来确定两个字符串在排序顺序中的关系。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-400">Use the <xref:System.String.Compare%2A?displayProperty=nameWithType> method to determine the relationship of two strings in the sort order.</span></span> <span data-ttu-id="3cd3e-401">通常，这是一个区分区域性的操作。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-401">Typically, this is a culture-sensitive operation.</span></span> <span data-ttu-id="3cd3e-402">与此相反，请调用 <xref:System.String.Equals%2A?displayProperty=nameWithType> 方法来测试是否相等。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-402">In contrast, call the <xref:System.String.Equals%2A?displayProperty=nameWithType> method to test for equality.</span></span> <span data-ttu-id="3cd3e-403">由于测试相等性通常会将用户输入与某个已知的字符串（如有效用户名、密码或文件系统路径）进行比较，因此通常为序号运算。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-403">Because the test for equality usually compares user input with some known string, such as a valid user name, a password, or a file system path, it is typically an ordinal operation.</span></span>

> [!WARNING]
>  <span data-ttu-id="3cd3e-404">可以通过调用方法来测试相等性 <xref:System.String.Compare%2A?displayProperty=nameWithType> ，并确定返回值是否为零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-404">It is possible to test for equality by calling the <xref:System.String.Compare%2A?displayProperty=nameWithType> method and determining whether the return value is zero.</span></span> <span data-ttu-id="3cd3e-405">但是，不建议使用这种做法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-405">However, this practice is not recommended.</span></span> <span data-ttu-id="3cd3e-406">若要确定两个字符串是否相等，应调用方法的重载之一 <xref:System.String.Equals%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-406">To determine whether two strings are equal, you should call one of the overloads of the <xref:System.String.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3cd3e-407">要调用的首选重载是实例 <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> 方法或静态 <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> 方法，因为这两个方法都包含 <xref:System.StringComparison?displayProperty=nameWithType> 显式指定比较类型的参数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-407">The preferred overload to call is either the instance <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> method or the static <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, because both methods include a <xref:System.StringComparison?displayProperty=nameWithType> parameter that explicitly specifies the type of comparison.</span></span>

 <span data-ttu-id="3cd3e-408">下面的示例说明了在应改用序号时执行区分区域性比较是否相等的危险。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-408">The following example illustrates the danger of performing a culture-sensitive comparison for equality when an ordinal one should be used instead.</span></span> <span data-ttu-id="3cd3e-409">在这种情况下，代码的目的是禁止从以 "FILE://" 或 "file://" 开头的 url 进行文件系统访问，方法是对 URL 开头使用字符串 "FILE://" 执行不区分大小写的比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-409">In this case, the intent of the code is to prohibit file system access from URLs that begin with "FILE://" or "file://" by performing a case-insensitive comparison of the beginning of a URL with the string "FILE://".</span></span> <span data-ttu-id="3cd3e-410">但是，如果在以 "file://" 开头的 URL 上使用土耳其语 (土耳其) 区域性来执行区分区域性的比较，则相等比较将失败，因为土耳其语大写字母等效于小写的 "i"，而不是 "i"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-410">However, if a culture-sensitive comparison is performed using the Turkish (Turkey) culture on a URL that begins with "file://", the comparison for equality fails, because the Turkish uppercase equivalent of the lowercase "i" is "İ" instead of "I".</span></span> <span data-ttu-id="3cd3e-411">因此，无意允许文件系统访问。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-411">As a result, file system access is inadvertently permitted.</span></span> <span data-ttu-id="3cd3e-412">另一方面，如果执行了序号比较，则相等比较将成功，并且拒绝文件系统访问。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-412">On the other hand, if an ordinal comparison is performed, the comparison for equality succeeds, and file system access is denied.</span></span>

 [!code-cpp[System.String.Class#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]

<a name="Normalization"></a>
## <a name="normalization"></a><span data-ttu-id="3cd3e-413">规范化</span><span class="sxs-lookup"><span data-stu-id="3cd3e-413">Normalization</span></span>
 <span data-ttu-id="3cd3e-414">某些 Unicode 字符具有多个表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-414">Some Unicode characters have multiple representations.</span></span> <span data-ttu-id="3cd3e-415">例如，以下任何代码点都可以表示字母 "ắ"：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-415">For example, any of the following code points can represent the letter "ắ":</span></span>

-   <span data-ttu-id="3cd3e-416">U + 1EAF</span><span class="sxs-lookup"><span data-stu-id="3cd3e-416">U+1EAF</span></span>

-   <span data-ttu-id="3cd3e-417">U + 0103 U + 0301</span><span class="sxs-lookup"><span data-stu-id="3cd3e-417">U+0103 U+0301</span></span>

-   <span data-ttu-id="3cd3e-418">U + 0061 U + 0306 U + 0301</span><span class="sxs-lookup"><span data-stu-id="3cd3e-418">U+0061 U+0306 U+0301</span></span>

 <span data-ttu-id="3cd3e-419">单个字符的多个表示形式使得搜索、排序、匹配和其他字符串操作复杂化。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-419">Multiple representations for a single character complicate searching, sorting, matching, and other string operations.</span></span>

 <span data-ttu-id="3cd3e-420">Unicode 标准定义了一个名为规范化的进程，该进程为其任何等效的二进制表示形式返回 Unicode 字符的一个二进制表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-420">The Unicode standard defines a process called normalization that returns one binary representation of a Unicode character for any of its equivalent binary representations.</span></span> <span data-ttu-id="3cd3e-421">规范化可以使用多种算法，这些算法采用不同的规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-421">Normalization can use several algorithms, called normalization forms, that follow different rules.</span></span> <span data-ttu-id="3cd3e-422">.NET 支持 Unicode 范式 C、D、GLM-KC-QNW 和 KD。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-422">.NET supports Unicode normalization forms C, D, KC, and KD.</span></span> <span data-ttu-id="3cd3e-423">将字符串规范化为同一范式后，可以使用序号比较对它们进行比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-423">When strings have been normalized to the same normalization form, they can be compared by using ordinal comparison.</span></span>

 <span data-ttu-id="3cd3e-424">序号比较是 <xref:System.Char> 每个字符串中相应对象的 Unicode 标量值的二进制比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-424">An ordinal comparison is a binary comparison of the Unicode scalar value of corresponding <xref:System.Char> objects in each string.</span></span> <span data-ttu-id="3cd3e-425"><xref:System.String>类包括多个可执行序号比较的方法，其中包括：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-425">The <xref:System.String> class includes a number of methods that can perform an ordinal comparison, including the following:</span></span>

-   <span data-ttu-id="3cd3e-426">包含参数的、、、、 <xref:System.String.Compare%2A> <xref:System.String.Equals%2A> <xref:System.String.StartsWith%2A>  <xref:System.String.EndsWith%2A> <xref:System.String.IndexOf%2A> 和 <xref:System.String.LastIndexOf%2A> 方法 <xref:System.StringComparison> 的任何重载。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-426">Any overload of the <xref:System.String.Compare%2A>, <xref:System.String.Equals%2A>, <xref:System.String.StartsWith%2A>,  <xref:System.String.EndsWith%2A>, <xref:System.String.IndexOf%2A>, and <xref:System.String.LastIndexOf%2A> methods that includes a <xref:System.StringComparison> parameter.</span></span> <span data-ttu-id="3cd3e-427">如果 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 为此参数提供或的值，则方法会执行序号比较 <xref:System.StringComparison.OrdinalIgnoreCase> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-427">The method performs an ordinal comparison if you supply a value of <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase> for this parameter.</span></span>

-   <span data-ttu-id="3cd3e-428">方法的重载 <xref:System.String.CompareOrdinal%2A> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-428">The overloads of the <xref:System.String.CompareOrdinal%2A> method.</span></span>

-   <span data-ttu-id="3cd3e-429">默认情况下使用序号比较的方法，例如 <xref:System.String.Contains%2A> 、 <xref:System.String.Replace%2A> 和 <xref:System.String.Split%2A> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-429">Methods that use ordinal comparison by default, such as <xref:System.String.Contains%2A>, <xref:System.String.Replace%2A>, and <xref:System.String.Split%2A>.</span></span>

-   <span data-ttu-id="3cd3e-430"><xref:System.Char>在字符串实例中搜索值或数组中元素的方法 <xref:System.Char> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-430">Methods that search for a <xref:System.Char> value or for the elements in a <xref:System.Char> array in a string instance.</span></span> <span data-ttu-id="3cd3e-431">此类方法包括 <xref:System.String.IndexOf%28System.Char%29> 和 <xref:System.String.Split%28System.Char%5B%5D%29> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-431">Such methods include <xref:System.String.IndexOf%28System.Char%29> and <xref:System.String.Split%28System.Char%5B%5D%29>.</span></span>

 <span data-ttu-id="3cd3e-432">可以通过调用方法来确定字符串是否规范化为范式 C <xref:System.String.IsNormalized?displayProperty=nameWithType> ，也可以调用 <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType> 方法来确定字符串是否规范化为指定的范式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-432">You can determine whether a string is normalized to normalization form C by calling the <xref:System.String.IsNormalized?displayProperty=nameWithType> method, or you can call the <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType> method to determine whether a string is normalized to a specified normalization form.</span></span> <span data-ttu-id="3cd3e-433">还可以调用方法将 <xref:System.String.Normalize?displayProperty=nameWithType> 字符串转换为范式 C，也可以调用 <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType> 方法将字符串转换为指定的范式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-433">You can also call the <xref:System.String.Normalize?displayProperty=nameWithType> method to convert a string to normalization form C, or you can call the <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType> method to convert a string to a specified normalization form.</span></span> <span data-ttu-id="3cd3e-434">有关规范化和比较字符串的分步信息，请参阅 <xref:System.String.Normalize> 和 <xref:System.String.Normalize%28System.Text.NormalizationForm%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-434">For step-by-step information about normalizing and comparing strings, see the <xref:System.String.Normalize> and <xref:System.String.Normalize%28System.Text.NormalizationForm%29> methods.</span></span>

 <span data-ttu-id="3cd3e-435">以下简单示例演示了字符串规范化。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-435">The following simple example illustrates string normalization.</span></span> <span data-ttu-id="3cd3e-436">它在三个不同的字符串中以三种不同的方式定义字母 "ố"，并使用相等的序号比较来确定每个字符串与其他两个字符串不同。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-436">It defines the letter "ố" in three different ways in three different strings, and uses an ordinal comparison for equality to determine that each string differs from the other two strings.</span></span> <span data-ttu-id="3cd3e-437">然后，它将每个字符串转换为支持的范式，并再次对每个字符串采用指定范式的序号比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-437">It then converts each string to the supported normalization forms, and again performs an ordinal comparison of each string in a specified normalization form.</span></span> <span data-ttu-id="3cd3e-438">在每种情况下，第二个相等测试会显示字符串是否相等。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-438">In each case, the second test for equality shows that the strings are equal.</span></span>

 [!code-cpp[System.String.Class#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]

 <span data-ttu-id="3cd3e-439">有关规范化和范式的详细信息，请参阅 <xref:System.Text.NormalizationForm?displayProperty=nameWithType> ，以及 [Unicode 标准附录 #15：](https://unicode.org/reports/tr15/) unicode.org 网站上的 Unicode 范式和 [规范化常见问题解答](https://www.unicode.org/faq/normalization.html) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-439">For more information about normalization and normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>, as well as [Unicode Standard Annex #15: Unicode Normalization Forms](https://unicode.org/reports/tr15/) and the [Normalization FAQ](https://www.unicode.org/faq/normalization.html) on the unicode.org website.</span></span>

<a name="ByCategory"></a>
## <a name="string-operations-by-category"></a><span data-ttu-id="3cd3e-440">按类别列出的字符串操作</span><span class="sxs-lookup"><span data-stu-id="3cd3e-440">String operations by category</span></span>
 <span data-ttu-id="3cd3e-441">此 <xref:System.String> 类提供了成员，用于比较字符串，测试字符串是否相等，查找字符串中的字符或子字符串，修改字符串，从字符串中提取子字符串，组合字符串，格式化值，复制字符串，以及规范化字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-441">The <xref:System.String> class provides members for comparing strings, testing strings for equality, finding characters or substrings in a string, modifying a string, extracting substrings from a string, combining strings, formatting values, copying a string, and normalizing a string.</span></span>

### <a name="comparing-strings"></a><span data-ttu-id="3cd3e-442">比较字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-442">Comparing strings</span></span>
 <span data-ttu-id="3cd3e-443">您可以通过使用以下方法来比较字符串，以确定它们在排序顺序中的相对位置 <xref:System.String> ：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-443">You can compare strings to determine their relative position in the sort order by using the following <xref:System.String> methods:</span></span>

-   <span data-ttu-id="3cd3e-444"><xref:System.String.Compare%2A> 返回一个整数，该整数指示在排序顺序中一个字符串与另一个字符串的关系。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-444"><xref:System.String.Compare%2A> returns an integer that indicates the relationship of one string to a second string in the sort order.</span></span>

-   <span data-ttu-id="3cd3e-445"><xref:System.String.CompareOrdinal%2A> 返回一个整数，该整数指示一个字符串与另一个字符串的关系是否基于其码位的比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-445"><xref:System.String.CompareOrdinal%2A> returns an integer that indicates the relationship of one string to a second string based on a comparison of their code points.</span></span>

-   <span data-ttu-id="3cd3e-446"><xref:System.String.CompareTo%2A> 返回一个整数，该整数指示当前字符串实例与排序顺序中的第二个字符串之间的关系。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-446"><xref:System.String.CompareTo%2A> returns an integer that indicates the relationship of the current string instance to a second string in the sort order.</span></span> <span data-ttu-id="3cd3e-447"><xref:System.String.CompareTo%28System.String%29>方法 <xref:System.IComparable> 为类提供和 <xref:System.IComparable%601> 实现 <xref:System.String> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-447">The <xref:System.String.CompareTo%28System.String%29> method provides the <xref:System.IComparable> and <xref:System.IComparable%601> implementations for the <xref:System.String> class.</span></span>

### <a name="testing-strings-for-equality"></a><span data-ttu-id="3cd3e-448">测试字符串是否相等</span><span class="sxs-lookup"><span data-stu-id="3cd3e-448">Testing strings for equality</span></span>
 <span data-ttu-id="3cd3e-449">调用 <xref:System.String.Equals%2A> 方法来确定两个字符串是否相等。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-449">You call the <xref:System.String.Equals%2A> method to determine whether two strings are equal.</span></span> <span data-ttu-id="3cd3e-450">实例 <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> 和静态 <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> 重载使你能够指定比较是区分区域性还是序号，以及是否考虑或忽略大小写。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-450">The instance <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> and the static <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> overloads let you specify whether the comparison is culture-sensitive or ordinal, and whether case is considered or ignored.</span></span> <span data-ttu-id="3cd3e-451">大多数相等测试都是序号，并且确定对系统资源的访问权限的相等性比较 (如文件系统对象) 应始终为序号。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-451">Most tests for equality are ordinal, and comparisons for equality that determine access to a system resource (such as a file system object) should always be ordinal.</span></span>

### <a name="finding-characters-in-a-string"></a><span data-ttu-id="3cd3e-452">查找字符串中的字符</span><span class="sxs-lookup"><span data-stu-id="3cd3e-452">Finding characters in a string</span></span>
 <span data-ttu-id="3cd3e-453"><xref:System.String>类包含两种搜索方法：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-453">The <xref:System.String> class includes two kinds of search methods:</span></span>

-   <span data-ttu-id="3cd3e-454">返回一个 <xref:System.Boolean> 值以指示特定子字符串是否出现在字符串实例中的方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-454">Methods that return a <xref:System.Boolean> value to indicate whether a particular substring is present in a string instance.</span></span> <span data-ttu-id="3cd3e-455">其中包括 <xref:System.String.Contains%2A> 、 <xref:System.String.EndsWith%2A> 和 <xref:System.String.StartsWith%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-455">These include the <xref:System.String.Contains%2A>, <xref:System.String.EndsWith%2A>, and <xref:System.String.StartsWith%2A> methods.</span></span>

-   <span data-ttu-id="3cd3e-456">指示字符串实例中子字符串的起始位置的方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-456">Methods that indicate the starting position of a substring in a string instance.</span></span> <span data-ttu-id="3cd3e-457">其中包括 <xref:System.String.IndexOf%2A> 、 <xref:System.String.IndexOfAny%2A> 、 <xref:System.String.LastIndexOf%2A> 和 <xref:System.String.LastIndexOfAny%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-457">These include the <xref:System.String.IndexOf%2A>, <xref:System.String.IndexOfAny%2A>, <xref:System.String.LastIndexOf%2A>, and <xref:System.String.LastIndexOfAny%2A> methods.</span></span>

> [!WARNING]
>  <span data-ttu-id="3cd3e-458">如果要在字符串中搜索特定模式而不是特定子字符串，应使用正则表达式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-458">If you want to search a string for a particular pattern rather than a specific substring, you should use regular expressions.</span></span> <span data-ttu-id="3cd3e-459">有关详细信息，请参阅 [.Net 正则表达式](/dotnet/standard/base-types/regular-expressions)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-459">For more information, see [.NET Regular Expressions](/dotnet/standard/base-types/regular-expressions).</span></span>

### <a name="modifying-a-string"></a><span data-ttu-id="3cd3e-460">修改字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-460">Modifying a string</span></span>
 <span data-ttu-id="3cd3e-461"><xref:System.String>类包括以下用于修改字符串值的方法：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-461">The <xref:System.String> class includes the following methods that appear to modify the value of a string:</span></span>

-   <span data-ttu-id="3cd3e-462"><xref:System.String.Insert%2A> 将字符串插入到当前 <xref:System.String> 实例中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-462"><xref:System.String.Insert%2A> inserts a string into the current <xref:System.String> instance.</span></span>

-   <span data-ttu-id="3cd3e-463"><xref:System.String.PadLeft%2A> 在字符串的开头插入一个或多个指定字符的匹配项。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-463"><xref:System.String.PadLeft%2A> inserts one or more occurrences of a specified character at the beginning of a string.</span></span>

-   <span data-ttu-id="3cd3e-464"><xref:System.String.PadRight%2A> 在字符串的末尾插入指定字符的一个或多个匹配项。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-464"><xref:System.String.PadRight%2A> inserts one or more occurrences of a specified character at the end of a string.</span></span>

-   <span data-ttu-id="3cd3e-465"><xref:System.String.Remove%2A> 删除当前实例中的子字符串 <xref:System.String> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-465"><xref:System.String.Remove%2A> deletes a substring from the current <xref:System.String> instance.</span></span>

-   <span data-ttu-id="3cd3e-466"><xref:System.String.Replace%2A> 将子字符串替换为当前实例中的另一个子字符串 <xref:System.String> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-466"><xref:System.String.Replace%2A> replaces a substring with another substring in the current <xref:System.String> instance.</span></span>

-   <span data-ttu-id="3cd3e-467"><xref:System.String.ToLower%2A><xref:System.String.ToLowerInvariant%2A>将字符串中的所有字符转换为小写。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-467"><xref:System.String.ToLower%2A> and <xref:System.String.ToLowerInvariant%2A> convert all the characters in a string to lowercase.</span></span>

-   <span data-ttu-id="3cd3e-468"><xref:System.String.ToUpper%2A><xref:System.String.ToUpperInvariant%2A>将字符串中的所有字符转换为大写。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-468"><xref:System.String.ToUpper%2A> and <xref:System.String.ToUpperInvariant%2A> convert all the characters in a string to uppercase.</span></span>

-   <span data-ttu-id="3cd3e-469"><xref:System.String.Trim%2A> 删除字符串开头和结尾的所有匹配项。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-469"><xref:System.String.Trim%2A> removes all occurrences of a character from the beginning and end of a string.</span></span>

-   <span data-ttu-id="3cd3e-470"><xref:System.String.TrimEnd%2A> 删除字符串末尾的所有匹配项。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-470"><xref:System.String.TrimEnd%2A> removes all occurrences of a character from the end of a string.</span></span>

-   <span data-ttu-id="3cd3e-471"><xref:System.String.TrimStart%2A> 从字符串的开头移除字符的所有匹配项。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-471"><xref:System.String.TrimStart%2A> removes all occurrences of a character from the beginning of a string.</span></span>

> [!IMPORTANT]
>  <span data-ttu-id="3cd3e-472">所有字符串修改方法都将返回新的 <xref:System.String> 对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-472">All string modification methods return a new <xref:System.String> object.</span></span> <span data-ttu-id="3cd3e-473">它们不会修改当前实例的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-473">They don't modify the value of the current instance.</span></span>

### <a name="extracting-substrings-from-a-string"></a><span data-ttu-id="3cd3e-474">从字符串中提取子字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-474">Extracting substrings from a string</span></span>
 <span data-ttu-id="3cd3e-475"><xref:System.String.Split%2A?displayProperty=nameWithType>方法将单个字符串分隔为多个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-475">The <xref:System.String.Split%2A?displayProperty=nameWithType> method separates a single string into multiple strings.</span></span> <span data-ttu-id="3cd3e-476">利用方法的重载，可以指定多个分隔符，确定该方法所提取的子字符串的最大数目，并确定空字符串 (如果分隔符相邻) 会包含在返回的字符串中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-476">Overloads of the method allow you to specify multiple delimiters, to determine the maximum number of substrings that the method extracts, and to determine whether empty strings (which occur when delimiters are adjacent) are included among the returned strings.</span></span>

### <a name="combining-strings"></a><span data-ttu-id="3cd3e-477">组合字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-477">Combining strings</span></span>
 <span data-ttu-id="3cd3e-478">以下 <xref:System.String> 方法可用于字符串串联：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-478">The following <xref:System.String> methods can be used for string concatenation:</span></span>

-   <span data-ttu-id="3cd3e-479"><xref:System.String.Concat%2A> 将一个或多个子字符串合并为一个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-479"><xref:System.String.Concat%2A> combines one or more substrings into a single string.</span></span>

-   <span data-ttu-id="3cd3e-480"><xref:System.String.Join%2A> 将一个或多个子字符串连接到单个元素，并在每个子字符串之间添加分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-480"><xref:System.String.Join%2A> concatenates one or more substrings into a single element and adds a separator between each substring.</span></span>

### <a name="formatting-values"></a><span data-ttu-id="3cd3e-481">格式设置值</span><span class="sxs-lookup"><span data-stu-id="3cd3e-481">Formatting values</span></span>
 <span data-ttu-id="3cd3e-482"><xref:System.String.Format%2A?displayProperty=nameWithType>方法使用复合格式设置功能将字符串中的一个或多个占位符替换为一些对象或值的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-482">The <xref:System.String.Format%2A?displayProperty=nameWithType> method uses the composite formatting feature to replace one or more placeholders in a string with the string representation of some object or value.</span></span> <span data-ttu-id="3cd3e-483"><xref:System.String.Format%2A>方法通常用于执行以下操作：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-483">The <xref:System.String.Format%2A> method is often used to do the following:</span></span>

-   <span data-ttu-id="3cd3e-484">在字符串中嵌入数值的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-484">To embed the string representation of a numeric value in a string.</span></span>

-   <span data-ttu-id="3cd3e-485">在字符串中嵌入日期和时间值的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-485">To embed the string representation of a date and time value in a string.</span></span>

-   <span data-ttu-id="3cd3e-486">在字符串中嵌入枚举值的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-486">To embed the string representation of an enumeration value in a string.</span></span>

-   <span data-ttu-id="3cd3e-487">在字符串中嵌入支持接口的某些对象的字符串表示形式 <xref:System.IFormattable> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-487">To embed the string representation of some object that supports the <xref:System.IFormattable> interface in a string.</span></span>

-   <span data-ttu-id="3cd3e-488">如果为，则在较大字符串中右对齐或左对齐字段中的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-488">To right-justify or left-justify a substring in a field within a larger string.</span></span>

 <span data-ttu-id="3cd3e-489">有关格式化操作和示例的详细信息，请参阅 " <xref:System.String.Format%2A> 重载摘要"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-489">For detailed information about formatting operations and examples, see the <xref:System.String.Format%2A> overload summary.</span></span>

### <a name="copying-a-string"></a><span data-ttu-id="3cd3e-490">复制字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-490">Copying a string</span></span>
 <span data-ttu-id="3cd3e-491">您可以调用以下 <xref:System.String> 方法来创建字符串的副本：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-491">You can call the following <xref:System.String> methods to make a copy of a string:</span></span>

-   <span data-ttu-id="3cd3e-492"><xref:System.String.Clone%2A> 返回对现有对象的引用 <xref:System.String> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-492"><xref:System.String.Clone%2A> returns a reference to an existing <xref:System.String> object.</span></span>

-   <span data-ttu-id="3cd3e-493"><xref:System.String.Copy%2A> 创建现有字符串的副本。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-493"><xref:System.String.Copy%2A> creates a copy of an existing string.</span></span>

-   <span data-ttu-id="3cd3e-494"><xref:System.String.CopyTo%2A> 将部分字符串复制到字符数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-494"><xref:System.String.CopyTo%2A> copies a portion of a string to a character array.</span></span>

### <a name="normalizing-a-string"></a><span data-ttu-id="3cd3e-495">将字符串规范化</span><span class="sxs-lookup"><span data-stu-id="3cd3e-495">Normalizing a string</span></span>
 <span data-ttu-id="3cd3e-496">在 Unicode 中，单个字符可以有多个码位。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-496">In Unicode, a single character can have multiple code points.</span></span> <span data-ttu-id="3cd3e-497">规范化将这些等效字符转换为相同的二进制表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-497">Normalization converts these equivalent characters into the same binary representation.</span></span> <span data-ttu-id="3cd3e-498"><xref:System.String.Normalize%2A?displayProperty=nameWithType>方法执行规范化， <xref:System.String.IsNormalized%2A?displayProperty=nameWithType> 方法确定字符串是否规范化。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-498">The <xref:System.String.Normalize%2A?displayProperty=nameWithType> method performs the normalization, and the <xref:System.String.IsNormalized%2A?displayProperty=nameWithType> method determines whether a string is normalized.</span></span>

 <span data-ttu-id="3cd3e-499">有关详细信息和示例，请参阅本主题前面的 [规范化](#Normalization) 部分。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-499">For more information and an example, see the [Normalization](#Normalization) section earlier in this topic.</span></span>

 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://www.microsoft.com/download/details.aspx?id=10921"><span data-ttu-id="3cd3e-500">为 Windows 操作系统排序权重表</span><span class="sxs-lookup"><span data-stu-id="3cd3e-500">Sorting Weight Tables for Windows operating systems</span></span></related>
    <related type="ExternalDocumentation" href="https://www.unicode.org/Public/UCA/latest/allkeys.txt"><span data-ttu-id="3cd3e-501">适用于 Linux 和 macOS 的默认 Unicode 排序规则元素表</span><span class="sxs-lookup"><span data-stu-id="3cd3e-501">Default Unicode Collation Element Table, for Linux and macOS</span></span></related>
    <threadsafe><span data-ttu-id="3cd3e-502">此类型是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-502">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.ICloneable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Text.StringBuilder" />
    <altmember cref="T:System.Globalization.CultureInfo" />
    <related type="Article" href="/dotnet/standard/base-types/formatting-types"><span data-ttu-id="3cd3e-503">设置 .NET 中类型的格式</span><span class="sxs-lookup"><span data-stu-id="3cd3e-503">Formatting Types in .NET</span></span></related>
    <related type="Article" href="/dotnet/standard/base-types/best-practices-strings"><span data-ttu-id="3cd3e-504">有关使用 .NET 中字符串的最佳做法</span><span class="sxs-lookup"><span data-stu-id="3cd3e-504">Best Practices for Using Strings in .NET</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3cd3e-505">初始化 <see cref="T:System.String" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-505">Initializes a new instance of the <see cref="T:System.String" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
<span data-ttu-id="3cd3e-506">本部分内容：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-506">In this section:</span></span>

<span data-ttu-id="3cd3e-507">[重载的构造函数语法](#Syntax)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-507">[Overloaded constructor syntax](#Syntax)</span></span>\
<span data-ttu-id="3cd3e-508">[Parameters](#Params)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-508">[Parameters](#Params)</span></span>\
<span data-ttu-id="3cd3e-509">[不同](#Exceptions)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-509">[Exceptions](#Exceptions)</span></span>\
<span data-ttu-id="3cd3e-510">[我要调用哪种方法？](#Tasks)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-510">[Which method do I call?](#Tasks)</span></span>\
<span data-ttu-id="3cd3e-511">[创建字符串](#Creating_Strings)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-511">[Creating strings](#Creating_Strings)</span></span>\
[<span data-ttu-id="3cd3e-512">处理重复的字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-512">Handle repetitive strings</span></span>](#Repetitive)

<span data-ttu-id="3cd3e-513">实例化字符串示例：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-513">Examples of instantiating strings:</span></span>

<span data-ttu-id="3cd3e-514">[使用字符串赋值](#Ctor1_Example)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-514">[Use string assignment](#Ctor1_Example)</span></span>\
<span data-ttu-id="3cd3e-515">[使用字符数组](#Ctor2_Example)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-515">[Use a character array](#Ctor2_Example)</span></span>\
<span data-ttu-id="3cd3e-516">[使用字符数组的一部分并重复使用单个字符](#Ctor3_Example)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-516">[Use a portion of a character array and repeating a single character](#Ctor3_Example)</span></span>\
<span data-ttu-id="3cd3e-517">[使用指向字符数组的指针](#Ctor4_Example)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-517">[Use a pointer to a character array](#Ctor4_Example)</span></span>\
<span data-ttu-id="3cd3e-518">[使用指针和数组的范围](#Ctor5_Example)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-518">[Use  a pointer and a range of an array](#Ctor5_Example)</span></span>\
[<span data-ttu-id="3cd3e-519">使用带符号字节数组的指针</span><span class="sxs-lookup"><span data-stu-id="3cd3e-519">Use a pointer to a signed byte array</span></span>](#Ctor6_Example)

<a name="Syntax"></a>
## <a name="overloaded-constructor-syntax"></a><span data-ttu-id="3cd3e-520">重载的构造函数语法</span><span class="sxs-lookup"><span data-stu-id="3cd3e-520">Overloaded constructor syntax</span></span>
 <span data-ttu-id="3cd3e-521">字符串构造函数分为两类：不带指针参数的类，以及带有指针参数的构造函数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-521">String constructors fall into two categories: those without pointer parameters, and those with pointer parameters.</span></span> <span data-ttu-id="3cd3e-522">使用指针的构造函数不符合 CLS。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-522">The constructors that use pointers are not CLS-compliant.</span></span> <span data-ttu-id="3cd3e-523">此外，Visual Basic 不支持使用指针，并且 c # 要求使用指针的代码在不安全的上下文中运行。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-523">In addition, Visual Basic does not support the use of pointers, and C# requires code that uses pointers to run in an unsafe context.</span></span> <span data-ttu-id="3cd3e-524">有关详细信息，请参阅 [unsafe](/dotnet/csharp/language-reference/keywords/unsafe)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-524">For more information, see [unsafe](/dotnet/csharp/language-reference/keywords/unsafe).</span></span>

 <span data-ttu-id="3cd3e-525">有关选择重载的其他指导，请参阅 [应该调用哪种方法？](#Tasks)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-525">For additional guidance on choosing an overload, see [Which method do I call?](#Tasks)</span></span>

 <span data-ttu-id="3cd3e-526">`String(Char[] value)` 将新实例初始化为由 Unicode 字符数组指示的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-526">`String(Char[] value)` Initializes the new instance to the value indicated by an array of Unicode characters.</span></span> <span data-ttu-id="3cd3e-527">此构造函数将 Unicode 字符复制 ([示例](#Ctor2_Example)) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-527">This constructor copies Unicode characters([example](#Ctor2_Example)).</span></span>

 <span data-ttu-id="3cd3e-528">`String(Char[] value, Int32 startIndex, Int32 length)` 将新实例初始化为由 Unicode 字符数组指示的值、该数组内的起始字符位置和长度 ([示例](#Ctor3_Example)) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-528">`String(Char[] value, Int32 startIndex, Int32 length)` Initializes the new instance to the value indicated by an array of Unicode characters, a starting character position within that array, and a length ([example](#Ctor3_Example)).</span></span>

 <span data-ttu-id="3cd3e-529">`String(Char c, Int32 count)` 将新的实例初始化为指定 Unicode 字符指示的值， ([示例](#Ctor3_Example)) 重复指定的次数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-529">`String(Char c, Int32 count)` Initializes the new instance to the value indicated by a specified Unicode character repeated a specified number of times ([example](#Ctor3_Example)).</span></span>

 <span data-ttu-id="3cd3e-530">`String(char* value)`\*\* (不符合 CLS) \*\*将新的实例初始化为由指向 Unicode 字符数组的指针指示的值，该数组由 null 字符 (U + 0000 或 "\ 0" ) 终止。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-530">`String(char* value)` **(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of Unicode characters that is terminated by a null character (U+0000 or '\0').</span></span> <span data-ttu-id="3cd3e-531"> ([示例](#Ctor4_Example)) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-531">([example](#Ctor4_Example)).</span></span>

 <span data-ttu-id="3cd3e-532">权限： <xref:System.Security.SecurityCriticalAttribute> 需要直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-532">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="3cd3e-533">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-533">This member cannot be used by partially trusted or transparent code.</span></span>

 <span data-ttu-id="3cd3e-534">`String(char* value, Int32 startIndex, Int32 length)`\*\* (不符合 CLS) \*\*将新的实例初始化为由指向 Unicode 字符数组的指针、该数组内的起始字符位置和一个长度指示的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-534">`String(char* value, Int32 startIndex, Int32 length)` **(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of Unicode characters, a starting character position within that array, and a length.</span></span> <span data-ttu-id="3cd3e-535">构造函数从 `value` 索引处开始复制 Unicode 字符 `startIndex` ，并在索引-1 处结束， `startIndex`  +  `length` ([示例](#Ctor5_Example)) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-535">The constructor copies the Unicode characters from `value` starting at index `startIndex` and ending at index `startIndex` + `length` - 1 ([example](#Ctor5_Example)).</span></span>

 <span data-ttu-id="3cd3e-536">权限： <xref:System.Security.SecurityCriticalAttribute> 需要直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-536">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="3cd3e-537">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-537">This member cannot be used by partially trusted or transparent code.</span></span>

 <span data-ttu-id="3cd3e-538">`String(SByte* value)`\*\* (不符合 CLS) \*\*将新的实例初始化为由指向8位有符号整数数组的指针指示的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-538">`String(SByte* value)` **(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers.</span></span> <span data-ttu-id="3cd3e-539">假定数组表示使用当前系统代码页编码的字符串 (即) 指定的编码 <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-539">The array is assumed to represent a string encoded using the current system code page (that is, the encoding specified by <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>).</span></span> <span data-ttu-id="3cd3e-540">构造函数将处理从 `value` 指针指定的位置开始的字符，直到到达 (0x00)  ([示例](#Ctor6_Example)) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-540">The constructor processes characters from `value` starting from the location specified by the pointer until a null character (0x00) is reached ([example](#Ctor6_Example)).</span></span>

 <span data-ttu-id="3cd3e-541">权限： <xref:System.Security.SecurityCriticalAttribute> 需要直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-541">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="3cd3e-542">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-542">This member cannot be used by partially trusted or transparent code.</span></span>

 <span data-ttu-id="3cd3e-543">`String(SByte* value, Int32 startIndex, Int32 length)`\*\* (不符合 CLS) \*\*将新实例初始化为由指向8位有符号整数数组的指针、该数组内的起始位置和一个长度指示的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-543">`String(SByte* value, Int32 startIndex, Int32 length)` **(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers, a starting position within that array, and a length.</span></span>  <span data-ttu-id="3cd3e-544">假定数组表示使用当前系统代码页编码的字符串 (即) 指定的编码 <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-544">The array is assumed to represent a string encoded using the current system code page (that is, the encoding specified by <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>).</span></span> <span data-ttu-id="3cd3e-545">构造函数从开始 `startIndex` ，到 `startIndex`  +  `length` -1 ([示例](#Ctor6_Example)) 的值处理字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-545">The constructor processes characters from value starting at `startIndex` and ending at `startIndex` + `length` - 1 ([example](#Ctor6_Example)).</span></span>

 <span data-ttu-id="3cd3e-546">权限： <xref:System.Security.SecurityCriticalAttribute> 需要直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-546">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="3cd3e-547">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-547">This member cannot be used by partially trusted or transparent code.</span></span>

 <span data-ttu-id="3cd3e-548">`String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)`\*\* (不符合 CLS) \*\*将新实例初始化为由指向8位有符号整数数组的指针、该数组内的起始位置、长度和对象指示的值 <xref:System.Text.Encoding> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-548">`String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)` **(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers, a starting position within that array, a length, and an <xref:System.Text.Encoding> object.</span></span>

 <span data-ttu-id="3cd3e-549">权限： <xref:System.Security.SecurityCriticalAttribute> 需要直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-549">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="3cd3e-550">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-550">This member cannot be used by partially trusted or transparent code.</span></span>

<a name="Params"></a>
## <a name="parameters"></a><span data-ttu-id="3cd3e-551">参数</span><span class="sxs-lookup"><span data-stu-id="3cd3e-551">Parameters</span></span>
 <span data-ttu-id="3cd3e-552">下面是 <xref:System.String> 不包含指针参数的构造函数所使用的参数的完整列表。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-552">Here is a complete list of parameters used by <xref:System.String> constructors that don't include a pointer parameter.</span></span> <span data-ttu-id="3cd3e-553">对于每个重载使用的参数，请参阅上述重载语法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-553">For the parameters used by each overload, see the overload syntax above.</span></span>

|<span data-ttu-id="3cd3e-554">参数</span><span class="sxs-lookup"><span data-stu-id="3cd3e-554">Parameter</span></span>|<span data-ttu-id="3cd3e-555">类型</span><span class="sxs-lookup"><span data-stu-id="3cd3e-555">Type</span></span>|<span data-ttu-id="3cd3e-556">描述</span><span class="sxs-lookup"><span data-stu-id="3cd3e-556">Description</span></span>|
|---------------|----------|-----------------|
|`value`|<span data-ttu-id="3cd3e-557"><xref:System.Char>[]</span><span class="sxs-lookup"><span data-stu-id="3cd3e-557"><xref:System.Char>[]</span></span>|<span data-ttu-id="3cd3e-558">Unicode 字符的数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-558">An array of Unicode characters.</span></span>|
|`c`|<xref:System.Char>|<span data-ttu-id="3cd3e-559">一个 Unicode 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-559">A Unicode character.</span></span>|
|`startIndex`|<xref:System.Int32>|<span data-ttu-id="3cd3e-560">`value`新字符串中第一个字符的起始位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-560">The starting position in `value` of the first character in the new string.</span></span><br /><br /> <span data-ttu-id="3cd3e-561">默认值：0</span><span class="sxs-lookup"><span data-stu-id="3cd3e-561">Default value: 0</span></span>|
|`length`|<xref:System.Int32>|<span data-ttu-id="3cd3e-562">要包含在新字符串中的中的字符数 `value` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-562">The number of characters in `value` to include in the new string.</span></span><br /><br /> <span data-ttu-id="3cd3e-563">默认值：30<xref:System.Array.Length%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="3cd3e-563">Default value: <xref:System.Array.Length%2A?displayProperty=nameWithType></span></span>|
|`count`|<xref:System.Int32>|<span data-ttu-id="3cd3e-564">`c`在新字符串中重复字符的次数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-564">The number of times the character `c` is repeated in the new string.</span></span> <span data-ttu-id="3cd3e-565">如果 `count` 为零，则新对象的值为 <xref:System.String.Empty?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-565">If `count` is zero, the value of the new object is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>|

 <span data-ttu-id="3cd3e-566">下面是 <xref:System.String> 包含指针参数的构造函数所使用的参数的完整列表。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-566">Here is a complete list of parameters used by <xref:System.String> constructors that include a pointer parameter.</span></span> <span data-ttu-id="3cd3e-567">对于每个重载使用的参数，请参阅上述重载语法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-567">For the parameters used by each overload, see the overload syntax above.</span></span>

|<span data-ttu-id="3cd3e-568">参数</span><span class="sxs-lookup"><span data-stu-id="3cd3e-568">Parameter</span></span>|<span data-ttu-id="3cd3e-569">类型</span><span class="sxs-lookup"><span data-stu-id="3cd3e-569">Type</span></span>|<span data-ttu-id="3cd3e-570">描述</span><span class="sxs-lookup"><span data-stu-id="3cd3e-570">Description</span></span>|
|---------------|----------|-----------------|
|`value`|<xref:System.Char>*<br /><br /> <span data-ttu-id="3cd3e-571">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-571">-or-</span></span><br /><br /> <xref:System.SByte>\*|<span data-ttu-id="3cd3e-572">指向以 null 结尾的 Unicode 字符数组的指针或一个8位有符号整数数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-572">A pointer to a null-terminated array of Unicode characters or an array of 8-bit signed integers.</span></span> <span data-ttu-id="3cd3e-573">如果 `value` 为 `null` 或空数组，则新字符串的值为 <xref:System.String.Empty?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-573">If `value` is `null` or an empty array, the value of the new string is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>|
|`startIndex`|<xref:System.Int32>|<span data-ttu-id="3cd3e-574">数组元素的索引，该元素定义新字符串中的第一个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-574">The index of the array element that defines the first character in the new string.</span></span><br /><br /> <span data-ttu-id="3cd3e-575">默认值：0</span><span class="sxs-lookup"><span data-stu-id="3cd3e-575">Default value: 0</span></span>|
|`length`|<xref:System.Int32>|<span data-ttu-id="3cd3e-576">用于创建新字符串的数组元素的数目。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-576">The number of array elements to use to create the new string.</span></span> <span data-ttu-id="3cd3e-577">如果 length 为零，则构造函数将创建一个值为的字符串 <xref:System.String.Empty?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-577">If length is zero, the constructor creates a string whose value is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span><br /><br /> <span data-ttu-id="3cd3e-578">默认值：30<xref:System.Array.Length%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="3cd3e-578">Default value: <xref:System.Array.Length%2A?displayProperty=nameWithType></span></span>|
|`enc`|<xref:System.Text.Encoding>|<span data-ttu-id="3cd3e-579">一个对象，该对象指定如何对 `value` 数组进行编码。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-579">An object that specifies how the `value` array is encoded.</span></span><br /><br /> <span data-ttu-id="3cd3e-580">默认值： <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> ，或系统的当前 ANSI 代码页</span><span class="sxs-lookup"><span data-stu-id="3cd3e-580">Default value: <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>, or the system's current ANSI code page</span></span>|

<a name="Exceptions"></a>
## <a name="exceptions"></a><span data-ttu-id="3cd3e-581">例外</span><span class="sxs-lookup"><span data-stu-id="3cd3e-581">Exceptions</span></span>
 <span data-ttu-id="3cd3e-582">下面是不包含指针参数的构造函数引发的异常列表。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-582">Here's a list of exceptions thrown by constructors that don't include pointer parameters.</span></span>

|<span data-ttu-id="3cd3e-583">异常</span><span class="sxs-lookup"><span data-stu-id="3cd3e-583">Exception</span></span>|<span data-ttu-id="3cd3e-584">条件</span><span class="sxs-lookup"><span data-stu-id="3cd3e-584">Condition</span></span>|<span data-ttu-id="3cd3e-585">引发者</span><span class="sxs-lookup"><span data-stu-id="3cd3e-585">Thrown by</span></span>|
|---------------|---------------|---------------|
|<xref:System.ArgumentNullException>|<span data-ttu-id="3cd3e-586">`value` 为 `null`。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-586">`value` is `null`.</span></span>|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|
|<xref:System.ArgumentOutOfRangeException>|<span data-ttu-id="3cd3e-587">`startIndex`、 `length` 或 `count` 小于零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-587">`startIndex`,`length`, or `count` is less than zero.</span></span><br /><br /> <span data-ttu-id="3cd3e-588">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-588">-or-</span></span><br /><br /> <span data-ttu-id="3cd3e-589">`startIndex` 与 `length` 的和大于 `value` 中的元素数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-589">The sum of `startIndex` and `length` is greater than the number of elements in `value`.</span></span><br /><br /> <span data-ttu-id="3cd3e-590">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-590">-or-</span></span><br /><br /> <span data-ttu-id="3cd3e-591">`count` 小于零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-591">`count` is less than zero.</span></span>|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|

 <span data-ttu-id="3cd3e-592">下面是包含指针参数的构造函数引发的异常列表。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-592">Here's a list of exceptions thrown by constructors that include pointer parameters.</span></span>

|<span data-ttu-id="3cd3e-593">异常</span><span class="sxs-lookup"><span data-stu-id="3cd3e-593">Exception</span></span>|<span data-ttu-id="3cd3e-594">条件</span><span class="sxs-lookup"><span data-stu-id="3cd3e-594">Condition</span></span>|<span data-ttu-id="3cd3e-595">引发者</span><span class="sxs-lookup"><span data-stu-id="3cd3e-595">Thrown by</span></span>|
|---------------|---------------|---------------|
|<xref:System.ArgumentException>|<span data-ttu-id="3cd3e-596">`value` 指定包含无效 Unicode 字符的数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-596">`value` specifies an array that contains an invalid Unicode character.</span></span><br /><br /> <span data-ttu-id="3cd3e-597">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-597">-or-</span></span><br /><br /> <span data-ttu-id="3cd3e-598">`value`或 `value`  +  `startIndex` 指定的地址小于64k。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-598">`value` or `value` + `startIndex` specifies an address that is less than 64K.</span></span><br /><br /> <span data-ttu-id="3cd3e-599">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-599">-or-</span></span><br /><br /> <span data-ttu-id="3cd3e-600"><xref:System.String>无法从字节数组初始化新的实例， `value` 因为不 `value` 使用默认代码页编码。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-600">A new <xref:System.String> instance could not be initialized from the `value` byte array because `value` does not use the default code page encoding.</span></span>|<span data-ttu-id="3cd3e-601">带有指针的所有构造函数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-601">All constructors with pointers.</span></span>|
|<xref:System.ArgumentNullException>|<span data-ttu-id="3cd3e-602">`value` 为 null。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-602">`value` is null.</span></span>|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|
|<xref:System.ArgumentOutOfRangeException>|<span data-ttu-id="3cd3e-603">当前进程不具有对所有通过地址访问的字符的读取访问权限。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-603">The current process does not have read access to all the addressed characters.</span></span><br /><br /> <span data-ttu-id="3cd3e-604">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-604">-or-</span></span><br /><br /> <span data-ttu-id="3cd3e-605">`startIndex` 或 `length` 小于零，`value` + `startIndex` 导致指针溢出，或者当前进程不具有对所有寻址字符的读取访问权限。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-605">`startIndex` or `length` is less than zero, `value` + `startIndex` cause a pointer overflow, or the current process does not have read access to all the addressed characters.</span></span><br /><br /> <span data-ttu-id="3cd3e-606">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-606">-or-</span></span><br /><br /> <span data-ttu-id="3cd3e-607">新字符串的长度太大，无法分配。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-607">The length of the new string is too large to allocate.</span></span>|<span data-ttu-id="3cd3e-608">带有指针的所有构造函数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-608">All constructors with pointers.</span></span>|
|<xref:System.AccessViolationException>|<span data-ttu-id="3cd3e-609">`value`，或 `value`  +  `startIndex`  +  `length` 为-1，则指定无效的地址。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-609">`value`, or `value` + `startIndex` + `length` - 1, specifies an invalid address.</span></span>|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|

<a name="Tasks"></a>
## <a name="which-method-do-i-call"></a><span data-ttu-id="3cd3e-610">我要调用哪种方法？</span><span class="sxs-lookup"><span data-stu-id="3cd3e-610">Which method do I call?</span></span>

|<span data-ttu-id="3cd3e-611">功能</span><span class="sxs-lookup"><span data-stu-id="3cd3e-611">To</span></span>|<span data-ttu-id="3cd3e-612">调用或使用</span><span class="sxs-lookup"><span data-stu-id="3cd3e-612">Call or use</span></span>|
|--------|-----------------|
|<span data-ttu-id="3cd3e-613">创建一个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-613">Create a string.</span></span>|<span data-ttu-id="3cd3e-614">从字符串文字或现有字符串赋值 ([示例](#Ctor1_Example)) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-614">Assignment from a string literal or an existing string ([example](#Ctor1_Example))</span></span>|
|<span data-ttu-id="3cd3e-615">从整个字符数组创建字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-615">Create a string from an entire character array.</span></span>|<span data-ttu-id="3cd3e-616"><xref:System.String.%23ctor%28System.Char%5B%5D%29> ([示例](#Ctor2_Example)) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-616"><xref:System.String.%23ctor%28System.Char%5B%5D%29> ([example](#Ctor2_Example))</span></span>|
|<span data-ttu-id="3cd3e-617">从字符数组的一部分创建字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-617">Create a string from a portion of a character array.</span></span>|<span data-ttu-id="3cd3e-618"><xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([示例](#Ctor3_Example)) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-618"><xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([example](#Ctor3_Example))</span></span>|
|<span data-ttu-id="3cd3e-619">创建多次重复相同字符的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-619">Create a string that repeats the same character multiple times.</span></span>|<span data-ttu-id="3cd3e-620"><xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([示例](#Ctor3_Example)) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-620"><xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([example](#Ctor3_Example))</span></span>|
|<span data-ttu-id="3cd3e-621">从指向 Unicode 或宽字符数组的指针创建一个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-621">Create a string from a pointer to a Unicode or wide character array.</span></span>|<xref:System.String.%23ctor%28System.Char%2A%29>|
|<span data-ttu-id="3cd3e-622">使用其指针从 Unicode 或宽字符数组的一部分创建字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-622">Create a string from a portion of a Unicode or wide character array by using its pointer.</span></span>|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|
|<span data-ttu-id="3cd3e-623">创建 c + + 数组中的字符串 `char` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-623">Create a string from a C++ `char` array.</span></span>|<span data-ttu-id="3cd3e-624"><xref:System.String.%23ctor%28System.SByte%2A%29>，<xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29></span><span class="sxs-lookup"><span data-stu-id="3cd3e-624"><xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29></span></span><br /><br /> <span data-ttu-id="3cd3e-625">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-625">-or-</span></span><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|
|<span data-ttu-id="3cd3e-626">从 ASCII 字符创建一个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-626">Create a string from ASCII characters.</span></span>|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=nameWithType>|

<a name="Creating_Strings"></a>
## <a name="create-strings"></a><span data-ttu-id="3cd3e-627">创建字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-627">Create strings</span></span>
 <span data-ttu-id="3cd3e-628">以编程方式创建字符串时最常用的方法是简单赋值，如 [本示例](#Ctor1_Example)中所示。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-628">The most commonly used technique for creating strings programmatically is simple assignment, as illustrated in [this example](#Ctor1_Example).</span></span> <span data-ttu-id="3cd3e-629"><xref:System.String>类还包括四种类型的构造函数重载，可用于从以下值创建字符串：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-629">The <xref:System.String> class also includes four types of constructor overloads that let you create strings from the following values:</span></span>

-   <span data-ttu-id="3cd3e-630">从字符数组 (由 UTF-16 编码的字符组成的数组) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-630">From a character array (an array of UTF-16-encoded characters).</span></span> <span data-ttu-id="3cd3e-631">您可以 <xref:System.String> 从整个数组或其中某个部分的字符创建新的对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-631">You can create a new <xref:System.String> object from the characters in the entire array or a portion of it.</span></span> <span data-ttu-id="3cd3e-632"><xref:System.String.%23ctor%28System.Char%5B%5D%29>构造函数将数组中的所有字符复制到新字符串中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-632">The <xref:System.String.%23ctor%28System.Char%5B%5D%29> constructor copies all the characters in the array to the new string.</span></span> <span data-ttu-id="3cd3e-633"><xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>构造函数将索引中的字符复制 `startIndex` 到索引 `startIndex`  +  `length` -1 到新的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-633">The <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor copies the characters from index `startIndex` to index `startIndex` + `length` - 1 to the new string.</span></span> <span data-ttu-id="3cd3e-634">如果 `length` 为零，则新字符串的值为 <xref:System.String.Empty?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-634">If `length` is zero, the value of the new string is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

     <span data-ttu-id="3cd3e-635">如果你的代码重复实例化具有相同值的字符串，则可以使用创建字符串的替代方法来提高应用程序性能。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-635">If your code repeatedly instantiates strings that have the same value, you can improve application performance by using an alternate means of creating strings.</span></span> <span data-ttu-id="3cd3e-636">有关详细信息，请参阅 [处理重复的字符串](#Repetitive)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-636">For more information, see [Handling repetitive strings](#Repetitive).</span></span>

-   <span data-ttu-id="3cd3e-637">使用构造函数从零次、一次或多次重复的单个字符 <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-637">From a single character that is duplicated zero, one, or more times, by using the <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> constructor.</span></span> <span data-ttu-id="3cd3e-638">如果 `count` 为零，则新字符串的值为 <xref:System.String.Empty?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-638">If `count` is zero, the value of the new string is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

-   <span data-ttu-id="3cd3e-639">通过使用 <xref:System.String.%23ctor%28System.Char%2A%29> 或构造函数从指向以 null 结尾的字符数组的指针 <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-639">From a pointer to a null-terminated character array, by using the <xref:System.String.%23ctor%28System.Char%2A%29> or <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> constructor.</span></span> <span data-ttu-id="3cd3e-640">整个数组或指定范围可用于初始化字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-640">Either the entire array or a specified range can be used to initialize the string.</span></span> <span data-ttu-id="3cd3e-641">构造函数从指定的指针或从指定的指针加上 `startIndex` 并继续到数组的末尾或为字符复制一系列 Unicode 字符 `length` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-641">The constructor copies a sequence of Unicode characters starting from the specified pointer or from the specified pointer plus `startIndex` and continuing to the end of the array or for `length` characters.</span></span> <span data-ttu-id="3cd3e-642">如果 `value` 为 null 指针或 `length` 为零，则构造函数将创建一个值为的字符串 <xref:System.String.Empty?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-642">If `value` is a null pointer or `length` is zero, the constructor creates a string whose value is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3cd3e-643">如果复制操作继续到数组末尾，并且数组不是以 null 终止的，则构造函数行为与系统相关。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-643">If the copy operation proceeds to the end of the array and the array is not null-terminated, the constructor behavior is system-dependent.</span></span> <span data-ttu-id="3cd3e-644">这种情况可能导致访问冲突。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-644">Such a condition might cause an access violation.</span></span>

     <span data-ttu-id="3cd3e-645">如果数组包含任何嵌入的 null 字符 (U + 0000 或 "\ 0" ) 并且 <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> 调用了重载，则字符串实例将包含包含 `length` 任何嵌入的 null 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-645">If the array contains any embedded null characters (U+0000 or '\0') and the <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> overload is called, the string instance contains `length` characters including any embedded nulls.</span></span> <span data-ttu-id="3cd3e-646">下面的示例演示在将包含两个 null 字符的数组的指针传递到方法时会发生的情况 <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-646">The following example shows what happens when a pointer to an array of 10 elements that includes two null characters is passed to the <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="3cd3e-647">由于地址是数组的开头，数组中的所有元素都将添加到字符串，因此构造函数将实例化包含10个字符的字符串，包括两个嵌入的 null。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-647">Because the address is the beginning of the array and all elements in the array are to be added to the string, the constructor instantiates a string with ten characters, including two embedded nulls.</span></span> <span data-ttu-id="3cd3e-648">另一方面，如果将同一个数组传递给 <xref:System.String.%23ctor%28System.Char%2A%29> 构造函数，则结果是一个四个字符的字符串，该字符串不包含第一个 null 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-648">On the other hand, if the same array is passed to the <xref:System.String.%23ctor%28System.Char%2A%29> constructor, the result is a four-character string that does not include the first null character.</span></span>

     [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
     [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]

     <span data-ttu-id="3cd3e-649">数组必须包含 Unicode 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-649">The array must contain Unicode characters.</span></span> <span data-ttu-id="3cd3e-650">在 c + + 中，这意味着必须将字符数组定义为 managed <xref:System.Char> [] 类型或非托管 `wchar_t` [] 类型。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-650">In C++, this means that the character array must be defined either as the managed <xref:System.Char>[] type or the unmanaged`wchar_t`[] type.</span></span>

     <span data-ttu-id="3cd3e-651">如果 <xref:System.String.%23ctor%28System.Char%2A%29> 调用了重载，且数组不是以 null 结尾的，或者如果 <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> 调用了重载，并且 `startIndex`  +  `length` -1 包括的范围超出了为字符序列分配的内存，则构造函数的行为将与系统相关，并可能会发生访问冲突。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-651">If the <xref:System.String.%23ctor%28System.Char%2A%29> overload is called and the array is not null-terminated, or if the <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> overload is called and `startIndex` + `length`-1 includes a range that is outside the memory allocated for the sequence of characters, the behavior of the constructor is system-dependent, and an access violation may occur.</span></span>

-   <span data-ttu-id="3cd3e-652">从指向有符号字节数组的指针。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-652">From a pointer to a signed byte array.</span></span> <span data-ttu-id="3cd3e-653">整个数组或指定范围可用于初始化字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-653">Either the entire array or a specified range can be used to initialize the string.</span></span> <span data-ttu-id="3cd3e-654">可以使用默认代码页编码来解释字节序列，也可以在构造函数调用中指定编码。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-654">The sequence of bytes can be interpreted by using the default code page encoding, or an encoding can be specified in the constructor call.</span></span> <span data-ttu-id="3cd3e-655">如果构造函数尝试从整个数组中实例化不是以 null 结尾的字符串，或者从 `value`  +  `startIndex` -1 到-1 的数组范围超出了为 `value`  +  `startIndex`  +  `length` 数组分配的内存，则此构造函数的行为与系统相关，并可能会发生访问冲突。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-655">If the constructor tries to instantiate a string from an entire array that is not null-terminated, or if the range of the array from `value` + `startIndex` to `value` + `startIndex` + `length` -1 is outside of the memory allocated for the array, the behavior of this constructor is system-dependent, and an access violation may occur.</span></span>

     <span data-ttu-id="3cd3e-656">这三个构造函数将有符号字节数组作为参数，主要用于将 c + + `char` 数组转换为字符串，如以下示例中所示：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-656">The three constructors that include a signed byte array as a parameter are designed primarily to convert a C++ `char` array to a string, as shown in this example:</span></span>

     [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]

     <span data-ttu-id="3cd3e-657">如果数组包含任何 null 字符 ( "\ 0" ) 或值为0的字节 <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> ，并且调用了重载，则字符串实例将包含 `length` 任何嵌入的 null 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-657">If the array contains any null characters ('\0') or bytes whose value is 0 and the <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> overload is called, the string instance contains `length` characters including any embedded nulls.</span></span> <span data-ttu-id="3cd3e-658">下面的示例演示在将包含两个 null 字符的数组的指针传递到方法时会发生的情况 <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-658">The following example shows what happens when a pointer to an array of 10 elements that includes two null characters is passed to the <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="3cd3e-659">由于地址是数组的开头，数组中的所有元素都将添加到字符串，因此构造函数将实例化包含10个字符的字符串，包括两个嵌入的 null。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-659">Because the address is the beginning of the array and all elements in the array are to be added to the string, the constructor instantiates a string with ten characters, including two embedded nulls.</span></span> <span data-ttu-id="3cd3e-660">另一方面，如果将同一个数组传递给 <xref:System.String.%23ctor%28System.SByte%2A%29> 构造函数，则结果是一个四个字符的字符串，该字符串不包含第一个 null 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-660">On the other hand, if the same array is passed to the <xref:System.String.%23ctor%28System.SByte%2A%29> constructor, the result is a four-character string that does not include the first null character.</span></span>

     [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
     [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]

     <span data-ttu-id="3cd3e-661">由于 <xref:System.String.%23ctor%28System.SByte%2A%29> 和 <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> 构造函数 `value` 使用默认的 ANSI 代码页进行解释，因此，使用相同的字节数组调用这些构造函数可能会在不同系统上创建具有不同值的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-661">Because the <xref:System.String.%23ctor%28System.SByte%2A%29> and <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> constructors interpret `value` by using the default ANSI code page, calling these constructors with identical byte arrays may create strings that have different values on different systems.</span></span>

<a name="Repetitive"></a>
## <a name="handle-repetitive-strings"></a><span data-ttu-id="3cd3e-662">处理重复的字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-662">Handle repetitive strings</span></span>
 <span data-ttu-id="3cd3e-663">分析或解码文本流的应用通常使用 <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 构造函数或方法将 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 字符序列转换为字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-663">Apps that parse or decode streams of text often use the <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor or the <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to convert sequences of characters into a string.</span></span> <span data-ttu-id="3cd3e-664">重复创建具有相同值的新字符串，而不是创建和重用一个字符串会浪费内存。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-664">Repeatedly creating new strings with the same value instead of creating and reusing one string wastes memory.</span></span> <span data-ttu-id="3cd3e-665">如果您可能会通过调用构造函数反复创建相同的字符串值 <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ，即使您事先事先不知道这些相同的字符串值，也可以改用查找表。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-665">If you are likely to create the same string value repeatedly by calling the <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor, even if you don't know in advance what those identical string values may be, you can use a lookup table instead.</span></span>

 <span data-ttu-id="3cd3e-666">例如，假设您从包含 XML 标记和特性的文件中读取和分析字符流。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-666">For example, suppose you read and parse a stream of characters from a file that contains XML tags and attributes.</span></span> <span data-ttu-id="3cd3e-667">分析流时，会反复遇到某些标记 (即具有符号表示) 的字符序列。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-667">When you parse the stream, you repeatedly encounter certain tokens (that is, sequences of characters that have a symbolic meaning).</span></span> <span data-ttu-id="3cd3e-668">与字符串 "0"、"1"、"true" 和 "false" 等效的标记可能经常出现在 XML 流中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-668">Tokens equivalent to the strings "0", "1", "true", and "false" are likely to occur frequently in an XML stream.</span></span>

 <span data-ttu-id="3cd3e-669">你可以创建一个 <xref:System.Xml.NameTable?displayProperty=nameWithType> 对象来保存通常出现的字符串，而不是将每个标记转换为一个新字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-669">Instead of converting each token into a new string, you can create a <xref:System.Xml.NameTable?displayProperty=nameWithType> object to hold commonly occurring strings.</span></span> <span data-ttu-id="3cd3e-670"><xref:System.Xml.NameTable>对象可提高性能，因为它检索存储的字符串，而不分配临时内存。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-670">The <xref:System.Xml.NameTable> object improves performance, because it retrieves stored strings without allocating temporary memory.</span></span> <span data-ttu-id="3cd3e-671">如果遇到标记，请使用 <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 方法从表中检索标记。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-671">When you encounter a token, use the <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to retrieve the token from the table.</span></span> <span data-ttu-id="3cd3e-672">如果标记存在，则方法返回相应的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-672">If the token exists, the method returns the corresponding string.</span></span> <span data-ttu-id="3cd3e-673">如果该标记不存在，请使用 <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 方法将该标记插入到表中，并获取相应的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-673">If the token does not exist, use the <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to insert the token into the table and to get the corresponding string.</span></span>

<a name="Ctor1_Example"></a>
## <a name="example-1-use-string-assignment"></a><span data-ttu-id="3cd3e-674">示例1：使用字符串赋值</span><span class="sxs-lookup"><span data-stu-id="3cd3e-674">Example 1: Use string assignment</span></span>
 <span data-ttu-id="3cd3e-675">下面的示例通过为字符串赋值来创建一个新字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-675">The following example creates a new string by assigning it a string literal.</span></span> <span data-ttu-id="3cd3e-676">它通过将第一个字符串的值分配给它来创建第二个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-676">It creates a second string by assigning the value of the first string to it.</span></span> <span data-ttu-id="3cd3e-677">这是实例化新对象的两种最常用的方法 <xref:System.String> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-677">These are the two most common ways to instantiate a new <xref:System.String> object.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb" id="Snippet1":::

<a name="Ctor2_Example"></a>
## <a name="example-2-use-a-character-array"></a><span data-ttu-id="3cd3e-678">示例2：使用字符数组</span><span class="sxs-lookup"><span data-stu-id="3cd3e-678">Example 2: Use a character array</span></span>
 <span data-ttu-id="3cd3e-679">下面的示例演示如何 <xref:System.String> 从字符数组创建新的对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-679">The following example demonstrates how to create a new <xref:System.String> object from a character array.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb" id="Snippet1":::

<a name="Ctor3_Example"></a>
## <a name="example-3-use-a-portion-of-a-character-array-and-repeating-a-single-character"></a><span data-ttu-id="3cd3e-680">示例3：使用字符数组的一部分并重复单个字符</span><span class="sxs-lookup"><span data-stu-id="3cd3e-680">Example 3: Use a portion of a character array and repeating a single character</span></span>
 <span data-ttu-id="3cd3e-681">下面的示例演示如何 <xref:System.String> 从字符数组的一部分创建一个新的对象，以及如何创建一个新的 <xref:System.String> 对象，该对象包含单个字符的多个匹配项。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-681">The following example demonstrates how to create a new <xref:System.String> object from a portion of a character array, and how to create a new <xref:System.String> object that contains multiple occurrences of a single character.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp" id="Snippet3":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs" interactive="try-dotnet-method" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb" id="Snippet3":::

<a name="Ctor4_Example"></a>
## <a name="example-4-use-a-pointer-to-a-character-array"></a><span data-ttu-id="3cd3e-682">示例4：使用指向字符数组的指针</span><span class="sxs-lookup"><span data-stu-id="3cd3e-682">Example 4: Use a pointer to a character array</span></span>
 <span data-ttu-id="3cd3e-683">下面的示例演示如何 <xref:System.String> 从指向字符数组的指针创建新的对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-683">The following example demonstrates how to create a new <xref:System.String> object from a pointer to an array of characters.</span></span> <span data-ttu-id="3cd3e-684">必须使用编译器开关编译 c # 示例 `/unsafe` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-684">The C# example must be compiled by using the `/unsafe` compiler switch.</span></span>

 [!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
 [!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]

<a name="Ctor5_Example"></a>
## <a name="example-5-instantiate-a-string-from-a-pointer-and-a-range-of-an-array"></a><span data-ttu-id="3cd3e-685">示例5：从指针和数组的范围实例化字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-685">Example 5: Instantiate a string from a pointer and a range of an array</span></span>
 <span data-ttu-id="3cd3e-686">下面的示例检查某个字符数组的元素中是否有句点或感叹号。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-686">The following example examines the elements of a character array for either a period or an exclamation point.</span></span> <span data-ttu-id="3cd3e-687">如果找到了一个字符串，则会从该标点符号前面的数组中的字符实例化一个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-687">If one is found, it instantiates a string from the characters in the array that precede the punctuation symbol.</span></span> <span data-ttu-id="3cd3e-688">如果不是，则会实例化包含数组全部内容的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-688">If not, it instantiates a string with the entire contents of the array.</span></span> <span data-ttu-id="3cd3e-689">必须使用编译器开关编译 c # 示例 `/unsafe` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-689">The C# example must be compiled using the `/unsafe` compiler switch.</span></span>

 [!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
 [!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]

<a name="Ctor6_Example"></a>
## <a name="example-6-instantiate-a-string-from-a-pointer-to-a-signed-byte-array"></a><span data-ttu-id="3cd3e-690">示例6：从指向有符号字节数组的指针实例化字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-690">Example 6: Instantiate a string from a pointer to a signed byte array</span></span>
 <span data-ttu-id="3cd3e-691">下面的示例演示如何 <xref:System.String> 使用构造函数创建类的实例 <xref:System.String.%23ctor%28System.SByte%2A%29> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-691">The following example demonstrates how you can create an instance of the <xref:System.String> class with the <xref:System.String.%23ctor%28System.SByte%2A%29> constructor.</span></span>

 [!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
 [!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-692">指向以 null 终止的 Unicode 字符数组的指针。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-692">A pointer to a null-terminated array of Unicode characters.</span></span></param>
        <summary><span data-ttu-id="3cd3e-693">将 <see cref="T:System.String" /> 类的新实例初始化为由指向 Unicode 字符数组的指定指针指示的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-693">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of Unicode characters.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
>  <span data-ttu-id="3cd3e-694">有关此和其他构造函数重载的示例和综合使用信息 `String` ，请参阅 <xref:System.String.%23ctor%2A> 构造函数摘要。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-694">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-695">当前进程不具有对所有通过地址访问的字符的读取访问权限。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-695">The current process does not have read access to all the addressed characters.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-696"><paramref name="value" /> 指定的数组包含无效的 Unicode 字符，或 <paramref name="value" /> 指定的地址小于 64000。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-696"><paramref name="value" /> specifies an array that contains an invalid Unicode character, or <paramref name="value" /> specifies an address less than 64000.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new string : char[] -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-697">Unicode 字符的数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-697">An array of Unicode characters.</span></span></param>
        <summary><span data-ttu-id="3cd3e-698">将 <see cref="T:System.String" /> 类的新实例初始化为指定字符数组中指示的 Unicode 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-698">Initializes a new instance of the <see cref="T:System.String" /> class to the Unicode characters indicated in the specified character array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
>  <span data-ttu-id="3cd3e-699">有关此和其他构造函数重载的示例和综合使用信息 `String` ，请参阅 <xref:System.String.%23ctor%2A> 构造函数摘要。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-699">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="new string : ReadOnlySpan&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-700">Unicode 字符的只读范围。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-700">A read-only span of Unicode characters.</span></span></param>
        <summary><span data-ttu-id="3cd3e-701">将 <see cref="T:System.String" /> 类的新实例初始化为指定只读范围中指示的 Unicode 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-701">Initializes a new instance of the <see cref="T:System.String" /> class to the Unicode characters indicated in the specified read-only span.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-702">一个指针，指向以 null 结尾的 8 位带符号整数数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-702">A pointer to a null-terminated array of 8-bit signed integers.</span></span> <span data-ttu-id="3cd3e-703">使用当前系统代码页编码（即由 <see cref="P:System.Text.Encoding.Default" /> 指定的编码）来解释整数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-703">The integers are interpreted using the current system code page encoding (that is, the encoding specified by <see cref="P:System.Text.Encoding.Default" />).</span></span></param>
        <summary><span data-ttu-id="3cd3e-704">将 <see cref="T:System.String" /> 类的新实例初始化为由指向 8 位有符号整数数组的指针指示的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-704">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a pointer to an array of 8-bit signed integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
>  <span data-ttu-id="3cd3e-705">有关此和其他构造函数重载的示例和综合使用信息 `String` ，请参阅 <xref:System.String.%23ctor%2A> 构造函数摘要。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-705">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-706"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-706"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-707">如果 <paramref name="value" /> 采用 ANSI 进行编码，那么无法使用 <paramref name="value" /> 初始化 <see cref="T:System.String" /> 的新实例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-707">A new instance of <see cref="T:System.String" /> could not be initialized using <paramref name="value" />, assuming <paramref name="value" /> is encoded in ANSI.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-708">要初始化的新字符串的长度（该长度由 <paramref name="value" /> 的 null 终止字符确定）太大，无法分配。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-708">The length of the new string to initialize, which is determined by the null termination character of <paramref name="value" />, is too large to allocate.</span></span></exception>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="3cd3e-709"><paramref name="value" /> 指定的地址无效。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-709"><paramref name="value" /> specifies an invalid address.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As Char, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char c, int count);" />
      <MemberSignature Language="F#" Value="new string : char * int -&gt; string" Usage="new System.string (c, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c"><span data-ttu-id="3cd3e-710">一个 Unicode 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-710">A Unicode character.</span></span></param>
        <param name="count"><span data-ttu-id="3cd3e-711"><paramref name="c" /> 出现的次数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-711">The number of times <paramref name="c" /> occurs.</span></span></param>
        <summary><span data-ttu-id="3cd3e-712">将 <see cref="T:System.String" /> 类的新实例初始化为由重复指定次数的指定 Unicode 字符指示的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-712">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified Unicode character repeated a specified number of times.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
>  <span data-ttu-id="3cd3e-713">有关此和其他构造函数重载的示例和综合使用信息 `String` ，请参阅 <xref:System.String.%23ctor%2A> 构造函数摘要。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-713">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-714"><paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-714"><paramref name="count" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-715">指向 Unicode 字符数组的指针。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-715">A pointer to an array of Unicode characters.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3cd3e-716"><paramref name="value" /> 内的起始位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-716">The starting position within <paramref name="value" />.</span></span></param>
        <param name="length"><span data-ttu-id="3cd3e-717">要使用的 <paramref name="value" /> 内的字符数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-717">The number of characters within <paramref name="value" /> to use.</span></span></param>
        <summary><span data-ttu-id="3cd3e-718">将 <see cref="T:System.String" /> 类的新实例初始化为由指向 Unicode 字符数组的指定指针指示的值、该数组内的起始字符位置和一个长度指示的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-718">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of Unicode characters, a starting character position within that array, and a length.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
>  <span data-ttu-id="3cd3e-719">有关此和其他构造函数重载的示例和综合使用信息 `String` ，请参阅 <xref:System.String.%23ctor%2A> 构造函数摘要。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-719">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-720"><paramref name="startIndex" /> 或 <paramref name="length" /> 小于零，<paramref name="value" /> + <paramref name="startIndex" /> 导致指针溢出，或者当前进程不具有对所有寻址字符的读取访问权限。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-720"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero, <paramref name="value" /> + <paramref name="startIndex" /> cause a pointer overflow, or the current process does not have read access to all the addressed characters.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-721"><paramref name="value" /> 指定的数组包含无效的 Unicode 字符，或 <paramref name="value" /> + <paramref name="startIndex" /> 指定的地址小于 64000。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-721"><paramref name="value" /> specifies an array that contains an invalid Unicode character, or <paramref name="value" /> + <paramref name="startIndex" /> specifies an address less than 64000.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : char[] * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-722">Unicode 字符的数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-722">An array of Unicode characters.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3cd3e-723"><paramref name="value" /> 内的起始位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-723">The starting position within <paramref name="value" />.</span></span></param>
        <param name="length"><span data-ttu-id="3cd3e-724">要使用的 <paramref name="value" /> 内的字符数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-724">The number of characters within <paramref name="value" /> to use.</span></span></param>
        <summary><span data-ttu-id="3cd3e-725">将 <see cref="T:System.String" /> 类的新实例初始化为由 Unicode 字符数组、该数组内的起始字符位置和一个长度指示的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-725">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by an array of Unicode characters, a starting character position within that array, and a length.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
>  <span data-ttu-id="3cd3e-726">有关此和其他构造函数重载的示例和综合使用信息 `String` ，请参阅 <xref:System.String.%23ctor%2A> 构造函数摘要。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-726">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-727"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-727"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-728"><paramref name="startIndex" /> 或 <paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-728"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span>

<span data-ttu-id="3cd3e-729">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-729">-or-</span></span>

<span data-ttu-id="3cd3e-730"><paramref name="startIndex" /> 与 <paramref name="length" /> 的和大于 <paramref name="value" /> 中的元素数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-730">The sum of <paramref name="startIndex" /> and <paramref name="length" /> is greater than the number of elements in <paramref name="value" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-731">指向 8 位带符号整数数组的指针。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-731">A pointer to an array of 8-bit signed integers.</span></span> <span data-ttu-id="3cd3e-732">使用当前系统代码页编码（即由 <see cref="P:System.Text.Encoding.Default" /> 指定的编码）来解释整数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-732">The integers are interpreted using the current system code page encoding (that is, the encoding specified by <see cref="P:System.Text.Encoding.Default" />).</span></span></param>
        <param name="startIndex"><span data-ttu-id="3cd3e-733"><paramref name="value" /> 内的起始位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-733">The starting position within <paramref name="value" />.</span></span></param>
        <param name="length"><span data-ttu-id="3cd3e-734">要使用的 <paramref name="value" /> 内的字符数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-734">The number of characters within <paramref name="value" /> to use.</span></span></param>
        <summary><span data-ttu-id="3cd3e-735">将 <see cref="T:System.String" /> 类的新实例初始化为由指向 8 位有符号整数数组的指定指针、该数组内的起始位置和一个长度指示的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-735">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of 8-bit signed integers, a starting position within that array, and a length.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
>  <span data-ttu-id="3cd3e-736">有关此和其他构造函数重载的示例和综合使用信息 `String` ，请参阅 <xref:System.String.%23ctor%2A> 构造函数摘要。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-736">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-737"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-737"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-738"><paramref name="startIndex" /> 或 <paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-738"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span>

<span data-ttu-id="3cd3e-739">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-739">-or-</span></span>

<span data-ttu-id="3cd3e-740">由 <paramref name="value" /> + <paramref name="startIndex" /> 指定的地址对于当前平台而言太大；也就是说，此地址计算溢出。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-740">The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is too large for the current platform; that is, the address calculation overflowed.</span></span>

<span data-ttu-id="3cd3e-741">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-741">-or-</span></span>

<span data-ttu-id="3cd3e-742">要初始化的新字符串的长度太大，无法分配。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-742">The length of the new string to initialize is too large to allocate.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-743">由 <paramref name="value" /> + <paramref name="startIndex" /> 指定的地址小于 64K。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-743">The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is less than 64K.</span></span>

<span data-ttu-id="3cd3e-744">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-744">-or-</span></span>

<span data-ttu-id="3cd3e-745">如果 <paramref name="value" /> 采用 ANSI 进行编码，那么无法使用 <paramref name="value" /> 初始化 <see cref="T:System.String" /> 的新实例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-745">A new instance of <see cref="T:System.String" /> could not be initialized using <paramref name="value" />, assuming <paramref name="value" /> is encoded in ANSI.</span></span></exception>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="3cd3e-746"><paramref name="value" />、<paramref name="startIndex" /> 和 <paramref name="length" /> 共同指定的地址无效。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-746"><paramref name="value" />, <paramref name="startIndex" />, and <paramref name="length" /> collectively specify an invalid address.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding? enc);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length, System::Text::Encoding ^ enc);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int * System.Text.Encoding -&gt; string" Usage="new System.string (value, startIndex, length, enc)" />
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="enc" Type="System.Text.Encoding" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-747">指向 8 位带符号整数数组的指针。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-747">A pointer to an array of 8-bit signed integers.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3cd3e-748"><paramref name="value" /> 内的起始位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-748">The starting position within <paramref name="value" />.</span></span></param>
        <param name="length"><span data-ttu-id="3cd3e-749">要使用的 <paramref name="value" /> 内的字符数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-749">The number of characters within <paramref name="value" /> to use.</span></span></param>
        <param name="enc"><span data-ttu-id="3cd3e-750">一个对象，用于指定如何对 <paramref name="value" /> 所引用的数组进行编码。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-750">An object that specifies how the array referenced by <paramref name="value" /> is encoded.</span></span> <span data-ttu-id="3cd3e-751">如果 <paramref name="enc" /> 为 <see langword="null" />，则假定以 ANSI 编码。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-751">If <paramref name="enc" /> is <see langword="null" />, ANSI encoding is assumed.</span></span></param>
        <summary><span data-ttu-id="3cd3e-752">将 <see cref="T:System.String" /> 的新实例初始化为由指向 8 位有符号整数数组的指定指针、该数组内的起始位置、长度以及 <see cref="T:System.Text.Encoding" /> 对象指示的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-752">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of 8-bit signed integers, a starting position within that array, a length, and an <see cref="T:System.Text.Encoding" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
>  <span data-ttu-id="3cd3e-753">有关此和其他构造函数重载的示例和综合使用信息 `String` ，请参阅 <xref:System.String.%23ctor%2A> 构造函数摘要。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-753">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-754"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-754"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-755"><paramref name="startIndex" /> 或 <paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-755"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span>

<span data-ttu-id="3cd3e-756">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-756">-or-</span></span>

<span data-ttu-id="3cd3e-757">由 <paramref name="value" /> + <paramref name="startIndex" /> 指定的地址对于当前平台而言太大；也就是说，此地址计算溢出。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-757">The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is too large for the current platform; that is, the address calculation overflowed.</span></span>

<span data-ttu-id="3cd3e-758">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-758">-or-</span></span>

<span data-ttu-id="3cd3e-759">要初始化的新字符串的长度太大，无法分配。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-759">The length of the new string to initialize is too large to allocate.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-760">由 <paramref name="value" /> + <paramref name="startIndex" /> 指定的地址小于 64K。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-760">The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is less than 64K.</span></span>

<span data-ttu-id="3cd3e-761">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-761">-or-</span></span>

<span data-ttu-id="3cd3e-762">如果 <paramref name="value" /> 按照指定的 <paramref name="enc" /> 进行编码，那么无法使用 <paramref name="value" /> 初始化 <see cref="T:System.String" /> 的新实例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-762">A new instance of <see cref="T:System.String" /> could not be initialized using <paramref name="value" />, assuming <paramref name="value" /> is encoded as specified by <paramref name="enc" />.</span></span></exception>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="3cd3e-763"><paramref name="value" />、<paramref name="startIndex" /> 和 <paramref name="length" /> 共同指定的地址无效。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-763"><paramref name="value" />, <paramref name="startIndex" />, and <paramref name="length" /> collectively specify an invalid address.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="3cd3e-764">当前的字符串中的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-764">A position in the current string.</span></span></param>
        <summary><span data-ttu-id="3cd3e-765">获取当前 <see cref="T:System.Char" /> 对象中位于指定位置的 <see cref="T:System.String" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-765">Gets the <see cref="T:System.Char" /> object at a specified position in the current <see cref="T:System.String" /> object.</span></span></summary>
        <value><span data-ttu-id="3cd3e-766">位于 <paramref name="index" /> 位置的对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-766">The object at position <paramref name="index" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-767">`index`参数是从零开始的。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-767">The `index` parameter is zero-based.</span></span>

 <span data-ttu-id="3cd3e-768">此属性返回 <xref:System.Char> 参数所指定位置处的对象 `index` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-768">This property returns the <xref:System.Char> object at the position specified by the `index` parameter.</span></span> <span data-ttu-id="3cd3e-769">但是，Unicode 字符可能由多个表示 <xref:System.Char> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-769">However, a Unicode character might be represented by more than one <xref:System.Char>.</span></span> <span data-ttu-id="3cd3e-770">使用 <xref:System.Globalization.StringInfo?displayProperty=nameWithType> 类来处理 Unicode 字符，而不是 <xref:System.Char> 对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-770">Use the <xref:System.Globalization.StringInfo?displayProperty=nameWithType> class to work with Unicode characters instead of <xref:System.Char> objects.</span></span> <span data-ttu-id="3cd3e-771">有关详细信息，请参阅类概述中的 "Char 对象和 Unicode 字符" 一节 <xref:System.String> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-771">For more information, see the "Char Objects and Unicode Characters" section in the <xref:System.String> class overview.</span></span>

 <span data-ttu-id="3cd3e-772">在 c # 中， <xref:System.String.Chars%2A> 属性是一个索引器。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-772">In C#, the <xref:System.String.Chars%2A> property is an indexer.</span></span> <span data-ttu-id="3cd3e-773">在 Visual Basic 中，这是类的默认属性 <xref:System.String> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-773">In Visual Basic, it is the default property of the <xref:System.String> class.</span></span> <span data-ttu-id="3cd3e-774"><xref:System.Char>可以使用如下代码访问字符串中的每个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-774">Each <xref:System.Char> object in the string can be accessed by using code such as the following.</span></span>
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb" id="Snippet1":::


 
## Examples
 <span data-ttu-id="3cd3e-775">下面的示例演示如何在例程中使用此索引器来验证字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-775">The following example demonstrates how you can use this indexer in a routine to validate a string.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="3cd3e-776"><paramref name="index" /> 大于或等于此对象的长度或小于零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-776"><paramref name="index" /> is greater than or equal to the length of this object or less than zero.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.GetEnumerator" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="string.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3cd3e-777">返回对此 <see cref="T:System.String" />实例的引用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-777">Returns a reference to this instance of <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-778">此 <see cref="T:System.String" /> 实例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-778">This instance of <see cref="T:System.String" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-779">返回值不是此实例的独立副本;它只是相同数据的另一个视图。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-779">The return value is not an independent copy of this instance; it is simply another view of the same data.</span></span> <span data-ttu-id="3cd3e-780">使用 <xref:System.String.Copy%2A> 或 <xref:System.String.CopyTo%2A> 方法来创建一个 <xref:System.String> 与此实例具有相同值的单独对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-780">Use the <xref:System.String.Copy%2A> or <xref:System.String.CopyTo%2A> method to create a separate <xref:System.String> object with the same value as this instance.</span></span>

 <span data-ttu-id="3cd3e-781">因为 <xref:System.String.Clone%2A> 方法只是返回现有的字符串实例，所以很少需要直接调用它。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-781">Because the <xref:System.String.Clone%2A> method simply returns the existing string instance, there is little reason to call it directly.</span></span>

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Copy(System.String)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3cd3e-782">比较两个指定的 <see cref="T:System.String" /> 对象，并返回一个指示二者在排序顺序中的相对位置的整数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-782">Compares two specified <see cref="T:System.String" /> objects and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-783"><xref:System.String.Compare%2A> 方法的所有重载返回一个 32 位有符号整数，指示两个比较数之间的词法关系。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-783">All overloads of the <xref:System.String.Compare%2A> method return a 32-bit signed integer indicating the lexical relationship between the two comparands.</span></span>

|<span data-ttu-id="3cd3e-784">“值”</span><span class="sxs-lookup"><span data-stu-id="3cd3e-784">Value</span></span>|<span data-ttu-id="3cd3e-785">条件</span><span class="sxs-lookup"><span data-stu-id="3cd3e-785">Condition</span></span>|
|-----------|---------------|
|<span data-ttu-id="3cd3e-786">小于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-786">Less than zero</span></span>|<span data-ttu-id="3cd3e-787">在排序顺序中，第一个子字符串在第二个子字符串之前。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-787">The first substring precedes the second substring in the sort order.</span></span>|
|<span data-ttu-id="3cd3e-788">零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-788">Zero</span></span>|<span data-ttu-id="3cd3e-789">子字符串在排序顺序中出现的位置相同或 `length` 为零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-789">The substrings occur in the same position in the sort order, or `length` is zero.</span></span>|
|<span data-ttu-id="3cd3e-790">大于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-790">Greater than zero</span></span>|<span data-ttu-id="3cd3e-791">第一个子字符串在排序顺序中后跟第二个子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-791">The first substring follows the second substring in the sort order.</span></span>|

> [!WARNING]
>  <span data-ttu-id="3cd3e-792">应尽可能调用 <xref:System.String.Compare%2A> 包含参数的方法的重载 <xref:System.StringComparison> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-792">Whenever possible, you should call an overload of the <xref:System.String.Compare%2A> method that includes a <xref:System.StringComparison> parameter.</span></span> <span data-ttu-id="3cd3e-793">有关详细信息，请参阅[有关使用字符串的最佳实践](/dotnet/standard/base-types/best-practices-strings)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-793">For more information, see [Best Practices for Using Strings](/dotnet/standard/base-types/best-practices-strings).</span></span>

 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/base-types/best-practices-strings"><span data-ttu-id="3cd3e-794">有关使用 .NET 中字符串的最佳做法</span><span class="sxs-lookup"><span data-stu-id="3cd3e-794">Best Practices for Using Strings in .NET</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string -&gt; int" Usage="System.string.Compare (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="3cd3e-795">要比较的第一个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-795">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="3cd3e-796">要比较的第二个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-796">The second string to compare.</span></span></param>
        <summary><span data-ttu-id="3cd3e-797">比较两个指定的 <see cref="T:System.String" /> 对象，并返回一个指示二者在排序顺序中的相对位置的整数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-797">Compares two specified <see cref="T:System.String" /> objects and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-798">一个 32 位带符号整数，指示两个比较数之间的词法关系。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-798">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>

 <list type="table"><listheader><term> <span data-ttu-id="3cd3e-799">“值”</span><span class="sxs-lookup"><span data-stu-id="3cd3e-799">Value</span></span>

 </term><description> <span data-ttu-id="3cd3e-800">条件</span><span class="sxs-lookup"><span data-stu-id="3cd3e-800">Condition</span></span>

 </description></listheader><item><term> <span data-ttu-id="3cd3e-801">小于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-801">Less than zero</span></span>

 </term><description><span data-ttu-id="3cd3e-802"><paramref name="strA" /> 在排序顺序中位于 <paramref name="strB" /> 之前。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-802"><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.</span></span>

 </description></item><item><term> <span data-ttu-id="3cd3e-803">零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-803">Zero</span></span>

 </term><description><span data-ttu-id="3cd3e-804"><paramref name="strA" /> 与 <paramref name="strB" /> 在排序顺序中出现的位置相同。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-804"><paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.</span></span>

 </description></item><item><term> <span data-ttu-id="3cd3e-805">大于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-805">Greater than zero</span></span>

 </term><description><span data-ttu-id="3cd3e-806"><paramref name="strA" /> 在排序顺序中位于 <paramref name="strB" /> 之后。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-806"><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.</span></span>

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-807">比较使用当前区域性来获取特定于区域性的信息，如大小写规则和单个字符的字母顺序。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-807">The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="3cd3e-808">例如，区域性可以指定将某些字符组合视为单个字符，或以特定方式比较大写和小写字符，或字符的排序顺序取决于其前面或后面的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-808">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>

 <span data-ttu-id="3cd3e-809">使用字词排序规则执行比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-809">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="3cd3e-810">有关 word、字符串和顺序排序的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-810">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>

> [!WARNING]
>  <span data-ttu-id="3cd3e-811">在比较字符串时，应调用 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> 方法，这要求您显式指定方法使用的字符串比较的类型。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-811">When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses.</span></span> <span data-ttu-id="3cd3e-812">有关详细信息，请参阅[有关使用字符串的最佳实践](/dotnet/standard/base-types/best-practices-strings)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-812">For more information, see [Best Practices for Using Strings](/dotnet/standard/base-types/best-practices-strings).</span></span>

 <span data-ttu-id="3cd3e-813">其中一个或两个比较字可以为 `null` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-813">One or both comparands can be `null`.</span></span> <span data-ttu-id="3cd3e-814">按照定义，包含空字符串 ( "" ) 中的任何字符串都会比较大于 null 引用;和两个 null 引用的比较结果相等。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-814">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>

 <span data-ttu-id="3cd3e-815">当发现不相等或已比较两个字符串时，将终止比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-815">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="3cd3e-816">但是，如果两个字符串的比较结果等于一个字符串的末尾，而另一个字符串还剩个字符，则包含剩余字符的字符串将被视为更大的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-816">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="3cd3e-817">返回值是执行的最后一次比较的结果。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-817">The return value is the result of the last comparison performed.</span></span>

 <span data-ttu-id="3cd3e-818">当比较受区域性特定的大小写规则影响时，可能会出现意外的结果。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-818">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="3cd3e-819">例如，在土耳其语中，以下示例产生了错误的结果，因为土耳其语中的文件系统不会将语言大小写规则用于 "file" 中的字母 "i"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-819">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>

 [!code-cpp[System.String.Compare#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]

 <span data-ttu-id="3cd3e-820">使用序号比较将路径名称与 "file" 进行比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-820">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="3cd3e-821">要执行此操作，正确的代码如下所示：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-821">The correct code to do this is as follows:</span></span>

 [!code-cpp[System.String.Compare#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]



## Examples
 <span data-ttu-id="3cd3e-822">下面的示例调用 <xref:System.String.Compare%28System.String%2CSystem.String%29> 方法来比较三组字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-822">The following example calls the <xref:System.String.Compare%28System.String%2CSystem.String%29> method to compare three sets of strings.</span></span>

 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp-interactive[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]

 <span data-ttu-id="3cd3e-823">在下面的示例中， `ReverseStringComparer` 类演示了如何用方法来计算两个字符串 <xref:System.String.Compare%2A> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-823">In the following example, the `ReverseStringComparer` class demonstrates how you can evaluate two strings with the <xref:System.String.Compare%2A> method.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp" id="Snippet7":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs" interactive="try-dotnet" id="Snippet7":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb" id="Snippet7":::

 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-824">字符集包括可忽略字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-824">Character sets include ignorable characters.</span></span> <span data-ttu-id="3cd3e-825"><see cref="M:System.String.Compare(System.String,System.String)" />当方法执行区分区域性的比较时，它不会考虑此类字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-825">The <see cref="M:System.String.Compare(System.String,System.String)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-826">例如，如果以下代码在 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 或更高版本上运行，则使用软连字符将 "动物" 与 "动物" 的 "动物" 比较（使用 "ani"） (或 U + 00AD) 指示这两个字符串是等效的。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-826">For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a culture-sensitive comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</span></span>

<span data-ttu-id="3cd3e-827">[！ code-csharp[system.web. 比较 # 21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare21.cs#21)][！ code-vb[system.web. 比较 # 21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare21.vb#21)]</span><span class="sxs-lookup"><span data-stu-id="3cd3e-827">[!code-csharp[System.String.Compare#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare21.cs#21)] [!code-vb[System.String.Compare#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare21.vb#21)]</span></span>

<span data-ttu-id="3cd3e-828">若要在字符串比较中识别可忽略字符，请调用 <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> 方法，并 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 为参数提供或的值 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> `comparisonType` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-828">To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method and supply a value of either <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the `comparisonType` parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="3cd3e-829">要比较的第一个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-829">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="3cd3e-830">要比较的第二个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-830">The second string to compare.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="3cd3e-831">若要在比较过程中忽略大小写，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-831"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="3cd3e-832">比较两个指定的 <see cref="T:System.String" /> 对象（其中忽略或考虑其大小写），并返回一个整数，指示二者在排序顺序中的相对位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-832">Compares two specified <see cref="T:System.String" /> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-833">一个 32 位带符号整数，指示两个比较数之间的词法关系。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-833">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>

 <list type="table"><listheader><term> <span data-ttu-id="3cd3e-834">“值”</span><span class="sxs-lookup"><span data-stu-id="3cd3e-834">Value</span></span>

 </term><description> <span data-ttu-id="3cd3e-835">条件</span><span class="sxs-lookup"><span data-stu-id="3cd3e-835">Condition</span></span>

 </description></listheader><item><term> <span data-ttu-id="3cd3e-836">小于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-836">Less than zero</span></span>

 </term><description><span data-ttu-id="3cd3e-837"><paramref name="strA" /> 在排序顺序中位于 <paramref name="strB" /> 之前。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-837"><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.</span></span>

 </description></item><item><term> <span data-ttu-id="3cd3e-838">零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-838">Zero</span></span>

 </term><description><span data-ttu-id="3cd3e-839"><paramref name="strA" /> 与 <paramref name="strB" /> 在排序顺序中出现的位置相同。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-839"><paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.</span></span>

 </description></item><item><term> <span data-ttu-id="3cd3e-840">大于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-840">Greater than zero</span></span>

 </term><description><span data-ttu-id="3cd3e-841"><paramref name="strA" /> 在排序顺序中位于 <paramref name="strB" /> 之后。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-841"><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.</span></span>

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-842">比较使用当前区域性来获取特定于区域性的信息，如大小写规则和单个字符的字母顺序。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-842">The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="3cd3e-843">例如，区域性可以指定将某些字符组合视为单个字符，或以特定方式比较大写和小写字符，或字符的排序顺序取决于其前面或后面的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-843">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>

 <span data-ttu-id="3cd3e-844">使用字词排序规则执行比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-844">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="3cd3e-845">有关 word、字符串和顺序排序的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-845">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>

> [!WARNING]
>  <span data-ttu-id="3cd3e-846">在比较字符串时，应调用 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> 方法，这要求您显式指定方法使用的字符串比较的类型。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-846">When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses.</span></span> <span data-ttu-id="3cd3e-847">有关详细信息，请参阅[有关使用字符串的最佳实践](/dotnet/standard/base-types/best-practices-strings)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-847">For more information, see [Best Practices for Using Strings](/dotnet/standard/base-types/best-practices-strings).</span></span>

 <span data-ttu-id="3cd3e-848">其中一个或两个比较字可以为 `null` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-848">One or both comparands can be `null`.</span></span> <span data-ttu-id="3cd3e-849">按照定义，包含空字符串 ( "" ) 中的任何字符串都会比较大于 null 引用;和两个 null 引用的比较结果相等。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-849">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>

 <span data-ttu-id="3cd3e-850">当发现不相等或已比较两个字符串时，将终止比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-850">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="3cd3e-851">但是，如果两个字符串的比较结果等于一个字符串的末尾，而另一个字符串还剩个字符，则包含剩余字符的字符串将被视为更大的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-851">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="3cd3e-852">返回值是执行的最后一次比较的结果。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-852">The return value is the result of the last comparison performed.</span></span>

 <span data-ttu-id="3cd3e-853">当比较受区域性特定的大小写规则影响时，可能会出现意外的结果。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-853">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="3cd3e-854">例如，在土耳其语中，以下示例产生了错误的结果，因为土耳其语中的文件系统不会将语言大小写规则用于 "file" 中的字母 "i"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-854">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>

 [!code-cpp[System.String.Compare#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]

 <span data-ttu-id="3cd3e-855">使用序号比较将路径名称与 "file" 进行比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-855">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="3cd3e-856">要执行此操作，正确的代码如下所示：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-856">The correct code to do this is as follows:</span></span>

 [!code-cpp[System.String.Compare#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]



## Examples
 <span data-ttu-id="3cd3e-857">下面的示例演示 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29> 方法等效于在 <xref:System.String.ToUpper%2A> <xref:System.String.ToLower%2A> 比较字符串时使用或。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-857">The following example demonstrates that the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29> method is equivalent to using <xref:System.String.ToUpper%2A> or <xref:System.String.ToLower%2A> when comparing strings.</span></span>

 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp-interactive[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]

 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-858">字符集包括可忽略字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-858">Character sets include ignorable characters.</span></span> <span data-ttu-id="3cd3e-859"><see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" />当方法执行区分区域性的比较时，它不会考虑此类字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-859">The <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-860">例如，如果以下代码在 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 或更高版本上运行，则使用软连字符的 "动物" (区分区域性、不区分大小写的 "动物" 或 U + 00AD) 指示这两个字符串是等效的。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-860">For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a culture-sensitive, case-insensitive comparison of "animal" with "Ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</span></span>

<span data-ttu-id="3cd3e-861">[！ code-csharp[system.web. 比较 # 22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare22.cs#22)][！ code-vb[system.web. 比较 # 22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare22.vb#22)]</span><span class="sxs-lookup"><span data-stu-id="3cd3e-861">[!code-csharp[System.String.Compare#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare22.cs#22)] [!code-vb[System.String.Compare#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare22.vb#22)]</span></span>

<span data-ttu-id="3cd3e-862">若要在字符串比较中识别可忽略字符，请调用 <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> 方法，并 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 为参数提供或的值 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> <paramref name="comparisonType" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-862">To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method and supply a value of either <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * StringComparison -&gt; int" Usage="System.string.Compare (strA, strB, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="3cd3e-863">要比较的第一个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-863">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="3cd3e-864">要比较的第二个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-864">The second string to compare.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="3cd3e-865">一个枚举值，用于指定比较中要使用的规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-865">One of the enumeration values that specifies the rules to use in the comparison.</span></span></param>
        <summary><span data-ttu-id="3cd3e-866">使用指定的规则比较两个指定的 <see cref="T:System.String" /> 对象，并返回一个整数，指示二者在排序顺序中的相对位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-866">Compares two specified <see cref="T:System.String" /> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-867">一个 32 位带符号整数，指示两个比较数之间的词法关系。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-867">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>

 <list type="table"><listheader><term> <span data-ttu-id="3cd3e-868">“值”</span><span class="sxs-lookup"><span data-stu-id="3cd3e-868">Value</span></span>

 </term><description> <span data-ttu-id="3cd3e-869">条件</span><span class="sxs-lookup"><span data-stu-id="3cd3e-869">Condition</span></span>

 </description></listheader><item><term> <span data-ttu-id="3cd3e-870">小于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-870">Less than zero</span></span>

 </term><description><span data-ttu-id="3cd3e-871"><paramref name="strA" /> 在排序顺序中位于 <paramref name="strB" /> 之前。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-871"><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.</span></span>

 </description></item><item><term> <span data-ttu-id="3cd3e-872">零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-872">Zero</span></span>

 </term><description><span data-ttu-id="3cd3e-873"><paramref name="strA" /> 与 <paramref name="strB" /> 在排序顺序中的位置相同。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-873"><paramref name="strA" /> is in the same position as <paramref name="strB" /> in the sort order.</span></span>

 </description></item><item><term> <span data-ttu-id="3cd3e-874">大于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-874">Greater than zero</span></span>

 </term><description><span data-ttu-id="3cd3e-875"><paramref name="strA" /> 在排序顺序中位于 <paramref name="strB" /> 之后。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-875"><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.</span></span>

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-876">`comparisonType`参数指示比较应使用当前的或固定的区域性，是接受还是忽略比较规则的大小写，还是使用 word (区分区域性的) 或序号 (不区分区域性的) 排序规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-876">The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the comparands, or use word (culture-sensitive) or ordinal (culture-insensitive) sort rules.</span></span>

 <span data-ttu-id="3cd3e-877">其中一个或两个比较字可以为 `null` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-877">One or both comparands can be `null`.</span></span> <span data-ttu-id="3cd3e-878">按照定义，包含空字符串 ( "" ) 中的任何字符串都会比较大于 null 引用;和两个 null 引用的比较结果相等。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-878">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>

 <span data-ttu-id="3cd3e-879">当发现不相等或已比较两个字符串时，将终止比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-879">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="3cd3e-880">但是，如果两个字符串的比较结果等于一个字符串的末尾，而另一个字符串还剩个字符，则包含剩余字符的字符串将被视为更大的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-880">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with remaining characters is considered greater.</span></span> <span data-ttu-id="3cd3e-881">返回值是执行的最后一次比较的结果。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-881">The return value is the result of the last comparison performed.</span></span>

 <span data-ttu-id="3cd3e-882">当比较受区域性特定的大小写规则影响时，可能会出现意外的结果。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-882">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="3cd3e-883">例如，在土耳其语中，以下示例产生了错误的结果，因为土耳其语中的文件系统不会将语言大小写规则用于 "file" 中的字母 "i"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-883">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>

 [!code-cpp[System.String.Compare#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]

 <span data-ttu-id="3cd3e-884">使用序号比较将路径名称与 "file" 进行比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-884">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="3cd3e-885">要执行此操作，正确的代码如下所示：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-885">The correct code to do this is as follows:</span></span>

 [!code-cpp[System.String.Compare#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]



## Examples
 <span data-ttu-id="3cd3e-886">下面的示例比较字母 "I" 的三个版本。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-886">The following example compares three versions of the letter "I".</span></span> <span data-ttu-id="3cd3e-887">结果受区域性选择的影响，是否忽略大小写，以及是否执行序号比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-887">The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</span></span>

 [!code-cpp[System.String.CompareCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-888"><paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-888"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3cd3e-889">不支持 <see cref="T:System.StringComparison" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-889"><see cref="T:System.StringComparison" /> is not supported.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-890">字符集包括可忽略字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-890">Character sets include ignorable characters.</span></span> <span data-ttu-id="3cd3e-891"><see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" />当方法执行区分区域性的比较时，它不会考虑此类字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-891">The <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-892">若要在比较中识别可忽略字符，请 <see cref="F:System.StringComparison.Ordinal" /> 为参数提供值或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> <paramref name="comparisonType" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-892">To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="3cd3e-893">要比较的第一个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-893">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="3cd3e-894">要比较的第二个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-894">The second string to compare.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="3cd3e-895">若要在比较过程中忽略大小写，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-895"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <param name="culture"><span data-ttu-id="3cd3e-896">一个对象，提供区域性特定的比较信息。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-896">An object that supplies culture-specific comparison information.</span></span></param>
        <summary><span data-ttu-id="3cd3e-897">比较两个指定的 <see cref="T:System.String" /> 对象（其中忽略或考虑其大小写，并使用区域性特定的信息干预比较），并返回一个整数，指示二者在排序顺序中的相对位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-897">Compares two specified <see cref="T:System.String" /> objects, ignoring or honoring their case, and using culture-specific information to influence the comparison, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-898">一个 32 位带符号整数，指示两个比较数之间的词法关系。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-898">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>

 <list type="table"><listheader><term> <span data-ttu-id="3cd3e-899">“值”</span><span class="sxs-lookup"><span data-stu-id="3cd3e-899">Value</span></span>

 </term><description> <span data-ttu-id="3cd3e-900">条件</span><span class="sxs-lookup"><span data-stu-id="3cd3e-900">Condition</span></span>

 </description></listheader><item><term> <span data-ttu-id="3cd3e-901">小于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-901">Less than zero</span></span>

 </term><description><span data-ttu-id="3cd3e-902"><paramref name="strA" /> 在排序顺序中位于 <paramref name="strB" /> 之前。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-902"><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.</span></span>

 </description></item><item><term> <span data-ttu-id="3cd3e-903">零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-903">Zero</span></span>

 </term><description><span data-ttu-id="3cd3e-904"><paramref name="strA" /> 与 <paramref name="strB" /> 在排序顺序中出现的位置相同。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-904"><paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.</span></span>

 </description></item><item><term> <span data-ttu-id="3cd3e-905">大于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-905">Greater than zero</span></span>

 </term><description><span data-ttu-id="3cd3e-906"><paramref name="strA" /> 在排序顺序中位于 <paramref name="strB" /> 之后。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-906"><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.</span></span>

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-907">该比较使用 `culture` 参数获取特定于区域性的信息，如大小写规则和单个字符的字母顺序。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-907">The comparison uses the `culture` parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="3cd3e-908">例如，区域性可以指定将某些字符组合视为单个字符，或以特定方式比较大写和小写字符，或字符的排序顺序取决于其前面或后面的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-908">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>

 <span data-ttu-id="3cd3e-909">使用字词排序规则执行比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-909">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="3cd3e-910">有关 word、字符串和顺序排序的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-910">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="3cd3e-911">其中一个或两个比较字可以为 `null` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-911">One or both comparands can be `null`.</span></span> <span data-ttu-id="3cd3e-912">按照定义，包含空字符串 ( "" ) 中的任何字符串都会比较大于 null 引用;和两个 null 引用的比较结果相等。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-912">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>

 <span data-ttu-id="3cd3e-913">当发现不相等或已比较两个字符串时，将终止比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-913">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="3cd3e-914">但是，如果两个字符串的比较结果等于一个字符串的末尾，而另一个字符串还剩个字符，则包含剩余字符的字符串将被视为更大的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-914">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="3cd3e-915">返回值是执行的最后一次比较的结果。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-915">The return value is the result of the last comparison performed.</span></span>

 <span data-ttu-id="3cd3e-916">当比较受区域性特定的大小写规则影响时，可能会出现意外的结果。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-916">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="3cd3e-917">例如，在土耳其语中，以下示例产生了错误的结果，因为土耳其语中的文件系统不会将语言大小写规则用于 "file" 中的字母 "i"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-917">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>

 [!code-cpp[System.String.Compare#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]

 <span data-ttu-id="3cd3e-918">使用序号比较将路径名称与 "file" 进行比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-918">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="3cd3e-919">要执行此操作，正确的代码如下所示：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-919">The correct code to do this is as follows:</span></span>

 [!code-cpp[System.String.Compare#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]



## Examples
 <span data-ttu-id="3cd3e-920">下面的示例演示区域性如何影响比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-920">The following example demonstrates how culture can affect a comparison.</span></span> <span data-ttu-id="3cd3e-921">在捷克语-捷克语，"ch" 是大于 "d" 的单个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-921">In Czech - Czech Republic culture, "ch" is a single character that is greater than "d".</span></span> <span data-ttu-id="3cd3e-922">但是，在英语美国区域性中，"ch" 包含两个字符，"c" 小于 "d"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-922">However, in English - United States culture, "ch" consists of two characters, and "c" is less than "d".</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-923"><paramref name="culture" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-923"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-924">字符集包括可忽略字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-924">Character sets include ignorable characters.</span></span> <span data-ttu-id="3cd3e-925"><see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />当方法执行区分区域性的比较时，它不会考虑此类字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-925">The <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-926">例如，如果以下代码在 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 或更高版本上运行，在使用软连字符的情况下，不区分大小写的 "动物" (使用软连字符，或使用固定区域性的 U + 00AD) ，则指示这两个字符串是等效的。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-926">For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a case-insensitive comparison of "animal" with "Ani-mal" (using a soft hyphen, or U+00AD) using the invariant culture indicates that the two strings are equivalent.</span></span>

<span data-ttu-id="3cd3e-927">[！ code-csharp[system.web. 比较 # 23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare23.cs#23)][！ code-vb[system.string. 比较 # 23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare23.vb#23)]</span><span class="sxs-lookup"><span data-stu-id="3cd3e-927">[!code-csharp[System.String.Compare#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare23.cs#23)] [!code-vb[System.String.Compare#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare23.vb#23)]</span></span>

<span data-ttu-id="3cd3e-928">若要在字符串比较中识别可忽略字符，请调用 <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> 方法，并 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 为参数提供或的值 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> <paramref name="options" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-928">To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method and supply a value of either <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, strB, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="3cd3e-929">要比较的第一个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-929">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="3cd3e-930">要比较的第二个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-930">The second string to compare.</span></span></param>
        <param name="culture"><span data-ttu-id="3cd3e-931">提供区域性特定的比较信息的区域性。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-931">The culture that supplies culture-specific comparison information.</span></span></param>
        <param name="options"><span data-ttu-id="3cd3e-932">要在执行比较时使用的选项（如忽略大小写或符号）。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-932">Options to use when performing the comparison (such as ignoring case or symbols).</span></span></param>
        <summary><span data-ttu-id="3cd3e-933">对两个指定的 <see cref="T:System.String" /> 对象进行比较，使用指定的比较选项和区域性特定的信息来影响比较，并返回一个整数，该整数指示这两个字符串在排序顺序中的关系。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-933">Compares two specified <see cref="T:System.String" /> objects using the specified comparison options and culture-specific information to influence the comparison, and returns an integer that indicates the relationship of the two strings to each other in the sort order.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-934">一个 32 位带符号整数，该整数指示 <paramref name="strA" /> 与 <paramref name="strB" /> 之间的词法关系，如下表所示</span><span class="sxs-lookup"><span data-stu-id="3cd3e-934">A 32-bit signed integer that indicates the lexical relationship between <paramref name="strA" /> and <paramref name="strB" />, as shown in the following table</span></span>

 <list type="table"><listheader><term> <span data-ttu-id="3cd3e-935">“值”</span><span class="sxs-lookup"><span data-stu-id="3cd3e-935">Value</span></span>

 </term><description> <span data-ttu-id="3cd3e-936">条件</span><span class="sxs-lookup"><span data-stu-id="3cd3e-936">Condition</span></span>

 </description></listheader><item><term> <span data-ttu-id="3cd3e-937">小于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-937">Less than zero</span></span>

 </term><description><span data-ttu-id="3cd3e-938"><paramref name="strA" /> 在排序顺序中位于 <paramref name="strB" /> 之前。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-938"><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.</span></span>

 </description></item><item><term> <span data-ttu-id="3cd3e-939">零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-939">Zero</span></span>

 </term><description><span data-ttu-id="3cd3e-940"><paramref name="strA" /> 与 <paramref name="strB" /> 在排序顺序中出现的位置相同。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-940"><paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.</span></span>

 </description></item><item><term> <span data-ttu-id="3cd3e-941">大于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-941">Greater than zero</span></span>

 </term><description><span data-ttu-id="3cd3e-942"><paramref name="strA" /> 在排序顺序中位于 <paramref name="strB" /> 之后。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-942"><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.</span></span>

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-943">该比较使用 `culture` 参数获取特定于区域性的信息，如大小写规则和单个字符的字母顺序。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-943">The comparison uses the `culture` parameter to obtain culture-specific information, such as casing rules and the alphabetical order of individual characters.</span></span> <span data-ttu-id="3cd3e-944">例如，特定的区域性可以指定将某些字符组合视为单个字符、以特定方式进行比较的大写和小写字符，或字符的排序顺序取决于其前面或后面的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-944">For example, a particular culture could specify that certain combinations of characters be treated as a single character, that uppercase and lowercase characters be compared in a particular way, or that the sort order of a character depends on the characters that precede or follow it.</span></span>

> [!CAUTION]
>  <span data-ttu-id="3cd3e-945">此 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> 方法主要用于排序或 alphabetizing 操作。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-945">The <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> method is designed primarily for use in sorting or alphabetizing operations.</span></span> <span data-ttu-id="3cd3e-946">当方法调用的主要目的是确定两个字符串是否等效时，不应使用此方法，即，当方法调用的目的是测试零) 的返回值时 (。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-946">It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent (that is, when the purpose of the method call is to test for a return value of zero).</span></span> <span data-ttu-id="3cd3e-947">若要确定两个字符串是否相等，请调用 <xref:System.String.Equals%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-947">To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.</span></span>

 <span data-ttu-id="3cd3e-948">可以通过参数进一步指定比较，该 `options` 参数由一个或多个枚举成员组成 <xref:System.Globalization.CompareOptions> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-948">The comparison can be further specified by the `options` parameter, which consists of one or more members of the <xref:System.Globalization.CompareOptions> enumeration.</span></span> <span data-ttu-id="3cd3e-949">但是，由于此方法的目的是执行区分区域性的字符串比较， <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> 因此和 <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> 值不起作用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-949">However, because the purpose of this method is to conduct a culture-sensitive string comparison, the <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> and <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> values have no effect.</span></span>

 <span data-ttu-id="3cd3e-950">两者或两个比较字都可以 `null` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-950">Either or both comparands can be `null`.</span></span> <span data-ttu-id="3cd3e-951">按照定义，任何字符串（包括 <xref:System.String.Empty?displayProperty=nameWithType> 、）比较大于 null 引用，而两个 null 引用的比较结果相等。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-951">By definition, any string, including <xref:System.String.Empty?displayProperty=nameWithType>, compares greater than a null reference, and two null references compare equal to each other.</span></span>

 <span data-ttu-id="3cd3e-952">当发现不相等或已比较两个字符串时，将终止比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-952">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="3cd3e-953">但是，如果两个字符串的比较结果与一个字符串的末尾相等，而另一个字符串还剩个字符，则将剩余字符视为更大的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-953">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with the remaining characters is considered greater.</span></span>



## Examples
 <span data-ttu-id="3cd3e-954">下面的示例以三种不同的方式对两个字符串进行比较：对 en-us 区域性使用语言比较;对于 en-us 区域性，使用区分语言区分大小写的比较;和使用序号比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-954">The following example compares two strings in three different ways: Use linguistic comparison for the en-US culture; using linguistic case-sensitive comparison for the en-US culture; and using an ordinal comparison.</span></span> <span data-ttu-id="3cd3e-955">它说明了这三种比较方法如何产生三个不同的结果。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-955">It illustrates how the three methods of comparison produce three different results.</span></span>

 [!code-cpp[System.String.Compare#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-956"><paramref name="options" /> 不是 <see cref="T:System.Globalization.CompareOptions" /> 值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-956"><paramref name="options" /> is not a <see cref="T:System.Globalization.CompareOptions" /> value.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-957"><paramref name="culture" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-957"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-958">字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-958">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-959"><see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />当方法执行区分区域性的比较时，它不会考虑此类字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-959">The <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-960">若要在比较中识别可忽略字符，请 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 为参数提供值或 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> <paramref name="options" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-960">To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</span></span></para></block>
        <altmember cref="Overload:System.String.CompareOrdinal" />
        <altmember cref="Overload:System.String.CompareTo" />
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="3cd3e-961">要在比较中使用的第一个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-961">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="3cd3e-962"><paramref name="strA" /> 中子字符串的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-962">The position of the substring within <paramref name="strA" />.</span></span></param>
        <param name="strB"><span data-ttu-id="3cd3e-963">要在比较中使用的第二个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-963">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="3cd3e-964"><paramref name="strB" /> 中子字符串的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-964">The position of the substring within <paramref name="strB" />.</span></span></param>
        <param name="length"><span data-ttu-id="3cd3e-965">要比较的子字符串中字符的最大数量。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-965">The maximum number of characters in the substrings to compare.</span></span></param>
        <summary><span data-ttu-id="3cd3e-966">比较两个指定的 <see cref="T:System.String" /> 对象的子字符串，并返回一个指示二者在排序顺序中的相对位置的整数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-966">Compares substrings of two specified <see cref="T:System.String" /> objects and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-967">一个 32 位有符号整数，指示两个比较数之间的词法关系。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-967">A 32-bit signed integer indicating the lexical relationship between the two comparands.</span></span>

 <list type="table"><listheader><term> <span data-ttu-id="3cd3e-968">“值”</span><span class="sxs-lookup"><span data-stu-id="3cd3e-968">Value</span></span>

 </term><description> <span data-ttu-id="3cd3e-969">条件</span><span class="sxs-lookup"><span data-stu-id="3cd3e-969">Condition</span></span>

 </description></listheader><item><term> <span data-ttu-id="3cd3e-970">小于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-970">Less than zero</span></span>

 </term><description> <span data-ttu-id="3cd3e-971"><paramref name="strA" /> 中的子字符串在排序顺序中位于 <paramref name="strB" /> 中的子字符串之前。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-971">The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.</span></span>

 </description></item><item><term> <span data-ttu-id="3cd3e-972">零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-972">Zero</span></span>

 </term><description> <span data-ttu-id="3cd3e-973">子字符串在排序顺序中出现的位置相同或 <paramref name="length" /> 为零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-973">The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.</span></span>

 </description></item><item><term> <span data-ttu-id="3cd3e-974">大于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-974">Greater than zero</span></span>

 </term><description> <span data-ttu-id="3cd3e-975"><paramref name="strA" /> 中的子字符串在排序顺序中位于 <paramref name="strB" /> 中的子字符串之后。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-975">The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.</span></span>

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-976">要比较的子字符串 `strA` 在 `indexA` 和中的开始 `strB` 处 `indexB` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-976">The substrings to compare start in `strA` at `indexA` and in `strB` at `indexB`.</span></span> <span data-ttu-id="3cd3e-977">`indexA`和 `indexB` 都是从零开始的; 即，和中的第一个字符位于 `strA` `strB` 位置零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-977">Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero.</span></span> <span data-ttu-id="3cd3e-978">第一个子字符串的长度等于 `strA` 减号 `indexA` 加1的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-978">The length of the first substring is equal to the length of `strA` minus `indexA` plus one.</span></span> <span data-ttu-id="3cd3e-979">第二个子字符串的长度等于 `strB` 减号 `indexB` 加1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-979">The length of the second substring is equal to the length of `strB` minus `indexB` plus one.</span></span>

 <span data-ttu-id="3cd3e-980">要比较的字符数是两个子字符串的长度中较小的一个和 `length` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-980">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="3cd3e-981">`indexA`、 `indexB` 和 `length` 参数必须为非负。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-981">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>

 <span data-ttu-id="3cd3e-982">比较使用当前区域性来获取特定于区域性的信息，如大小写规则和单个字符的字母顺序。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-982">The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="3cd3e-983">例如，区域性可以指定将某些字符组合视为单个字符，或以特定方式比较大写和小写字符，或字符的排序顺序取决于其前面或后面的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-983">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>

 <span data-ttu-id="3cd3e-984">使用字词排序规则执行比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-984">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="3cd3e-985">有关 word、字符串和顺序排序的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-985">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>

> [!WARNING]
>  <span data-ttu-id="3cd3e-986">在比较字符串时，应调用 <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> 方法，这要求您显式指定方法使用的字符串比较的类型。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-986">When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses.</span></span> <span data-ttu-id="3cd3e-987">有关详细信息，请参阅[有关使用字符串的最佳实践](/dotnet/standard/base-types/best-practices-strings)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-987">For more information, see [Best Practices for Using Strings](/dotnet/standard/base-types/best-practices-strings).</span></span>

 <span data-ttu-id="3cd3e-988">其中一个或两个比较字可以为 `null` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-988">One or both comparands can be `null`.</span></span> <span data-ttu-id="3cd3e-989">按照定义，包含空字符串 ( "" ) 中的任何字符串都会比较大于 null 引用;和两个 null 引用的比较结果相等。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-989">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>

 <span data-ttu-id="3cd3e-990">当发现不相等或比较两个子字符串时，将终止比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-990">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="3cd3e-991">但是，如果两个字符串的比较结果等于一个字符串的末尾，而另一个字符串还剩个字符，则包含剩余字符的字符串将被视为更大的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-991">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="3cd3e-992">返回值是执行的最后一次比较的结果。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-992">The return value is the result of the last comparison performed.</span></span>

 <span data-ttu-id="3cd3e-993">当比较受区域性特定的大小写规则影响时，可能会出现意外的结果。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-993">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="3cd3e-994">例如，在土耳其语中，以下示例产生了错误的结果，因为土耳其语中的文件系统不会将语言大小写规则用于 "file" 中的字母 "i"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-994">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>

 [!code-cpp[System.String.Compare#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]

 <span data-ttu-id="3cd3e-995">使用序号比较将路径名称与 "file" 进行比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-995">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="3cd3e-996">要执行此操作，正确的代码如下所示：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-996">The correct code to do this is as follows:</span></span>

 [!code-cpp[System.String.Compare#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]



## Examples
 <span data-ttu-id="3cd3e-997">下面的示例比较两个子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-997">The following example compares two substrings.</span></span>

 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp-interactive[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-998"><paramref name="indexA" /> 大于 <paramref name="strA" />.<see cref="P:System.String.Length" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-998"><paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span></span>

<span data-ttu-id="3cd3e-999">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-999">-or-</span></span>

 <span data-ttu-id="3cd3e-1000"><paramref name="indexB" /> 大于 <paramref name="strB" />.<see cref="P:System.String.Length" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1000"><paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span></span>

<span data-ttu-id="3cd3e-1001">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1001">-or-</span></span>

 <span data-ttu-id="3cd3e-1002"><paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1002"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span>

<span data-ttu-id="3cd3e-1003">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1003">-or-</span></span>

<span data-ttu-id="3cd3e-1004"><paramref name="indexA" /> 或 <paramref name="indexB" /> 为 <see langword="null" />，并且 <paramref name="length" /> 大于零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1004">Either <paramref name="indexA" /> or <paramref name="indexB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-1005">字符集包括可忽略字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1005">Character sets include ignorable characters.</span></span> <span data-ttu-id="3cd3e-1006">此 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> 方法在执行语言或区分区域性的比较时不考虑这些字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1006">The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-1007">若要在比较中识别可忽略字符，请调用 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> 方法，并为 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 参数提供值或 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> <paramref name="comparisonType" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1007">To recognize ignorable characters in your comparison, call the <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> method and supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="3cd3e-1008">要在比较中使用的第一个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1008">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="3cd3e-1009"><paramref name="strA" /> 中子字符串的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1009">The position of the substring within <paramref name="strA" />.</span></span></param>
        <param name="strB"><span data-ttu-id="3cd3e-1010">要在比较中使用的第二个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1010">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="3cd3e-1011"><paramref name="strB" /> 中子字符串的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1011">The position of the substring within <paramref name="strB" />.</span></span></param>
        <param name="length"><span data-ttu-id="3cd3e-1012">要比较的子字符串中字符的最大数量。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1012">The maximum number of characters in the substrings to compare.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="3cd3e-1013">若要在比较过程中忽略大小写，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1013"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1014">比较两个指定的 <see cref="T:System.String" /> 对象的子字符串（忽略或考虑其大小写），并返回一个整数，指示二者在排序顺序中的相对位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1014">Compares substrings of two specified <see cref="T:System.String" /> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1015">一个 32 位带符号整数，指示两个比较数之间的词法关系。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1015">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>

 <list type="table"><listheader><term> <span data-ttu-id="3cd3e-1016">“值”</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1016">Value</span></span>

 </term><description> <span data-ttu-id="3cd3e-1017">条件</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1017">Condition</span></span>

 </description></listheader><item><term> <span data-ttu-id="3cd3e-1018">小于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1018">Less than zero</span></span>

 </term><description> <span data-ttu-id="3cd3e-1019"><paramref name="strA" /> 中的子字符串在排序顺序中位于 <paramref name="strB" /> 中的子字符串之前。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1019">The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.</span></span>

 </description></item><item><term> <span data-ttu-id="3cd3e-1020">零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1020">Zero</span></span>

 </term><description> <span data-ttu-id="3cd3e-1021">子字符串在排序顺序中出现的位置相同或 <paramref name="length" /> 为零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1021">The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.</span></span>

 </description></item><item><term> <span data-ttu-id="3cd3e-1022">大于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1022">Greater than zero</span></span>

 </term><description> <span data-ttu-id="3cd3e-1023"><paramref name="strA" /> 中的子字符串在排序顺序中位于 <paramref name="strB" /> 中的子字符串之后。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1023">The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.</span></span>

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1024">要比较的子字符串在中的开始 `strA` `indexA` ，位于中 `strB` `indexB` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1024">The substrings to compare start in `strA` at `indexA`, and in `strB` at `indexB`.</span></span> <span data-ttu-id="3cd3e-1025">`indexA`和 `indexB` 都是从零开始的; 即，和中的第一个字符位于 `strA` `strB` 位置零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1025">Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero.</span></span> <span data-ttu-id="3cd3e-1026">第一个子字符串的长度等于 `strA` 减号 `indexA` 加1的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1026">The length of the first substring is equal to the length of `strA` minus `indexA` plus one.</span></span> <span data-ttu-id="3cd3e-1027">第二个子字符串的长度等于 `strB` 减号 `indexB` 加1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1027">The length of the second substring is equal to the length of `strB` minus `indexB` plus one.</span></span>

 <span data-ttu-id="3cd3e-1028">要比较的字符数是两个子字符串的长度中较小的一个和 `length` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1028">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="3cd3e-1029">`indexA`、 `indexB` 和 `length` 参数必须为非负。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1029">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>

 <span data-ttu-id="3cd3e-1030">比较使用当前区域性来获取特定于区域性的信息，如大小写规则和单个字符的字母顺序。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1030">The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="3cd3e-1031">例如，区域性可以指定将某些字符组合视为单个字符，或以特定方式比较大写和小写字符，或字符的排序顺序取决于其前面或后面的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1031">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>

 <span data-ttu-id="3cd3e-1032">使用字词排序规则执行比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1032">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="3cd3e-1033">有关 word、字符串和顺序排序的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1033">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>

> [!WARNING]
>  <span data-ttu-id="3cd3e-1034">在比较字符串时，应调用 <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> 方法，这要求您显式指定方法使用的字符串比较的类型。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1034">When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses.</span></span> <span data-ttu-id="3cd3e-1035">有关详细信息，请参阅[有关使用字符串的最佳实践](/dotnet/standard/base-types/best-practices-strings)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1035">For more information, see [Best Practices for Using Strings](/dotnet/standard/base-types/best-practices-strings).</span></span>

 <span data-ttu-id="3cd3e-1036">其中一个或两个比较字可以为 `null` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1036">One or both comparands can be `null`.</span></span> <span data-ttu-id="3cd3e-1037">按照定义，包含空字符串 ( "" ) 中的任何字符串都会比较大于 null 引用;和两个 null 引用的比较结果相等。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1037">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>

 <span data-ttu-id="3cd3e-1038">当发现不相等或比较两个子字符串时，将终止比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1038">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="3cd3e-1039">但是，如果两个字符串的比较结果等于一个字符串的末尾，而另一个字符串还剩个字符，则包含剩余字符的字符串将被视为更大的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1039">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="3cd3e-1040">返回值是执行的最后一次比较的结果。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1040">The return value is the result of the last comparison performed.</span></span>

 <span data-ttu-id="3cd3e-1041">当比较受区域性特定的大小写规则影响时，可能会出现意外的结果。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1041">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="3cd3e-1042">例如，在土耳其语中，以下示例产生了错误的结果，因为土耳其语中的文件系统不会将语言大小写规则用于 "file" 中的字母 "i"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1042">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>

 [!code-cpp[System.String.Compare#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]

 <span data-ttu-id="3cd3e-1043">路径名称需要按固定方式进行比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1043">The path name needs to be compared in an invariant manner.</span></span> <span data-ttu-id="3cd3e-1044">要执行此操作，正确的代码如下所示。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1044">The correct code to do this is as follows.</span></span>

 [!code-cpp[System.String.Compare#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]



## Examples
 <span data-ttu-id="3cd3e-1045">下面的示例对两个仅大小写不同的子字符串执行两次比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1045">The following example performs two comparisons of two substrings that only differ in case.</span></span> <span data-ttu-id="3cd3e-1046">第一个比较忽略大小写，第二个比较考虑用例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1046">The first comparison ignores case and the second comparison considers case.</span></span>

 [!code-cpp[string.compare4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp-interactive[string.compare4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-1047"><paramref name="indexA" /> 大于 <paramref name="strA" />.<see cref="P:System.String.Length" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1047"><paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span></span>

<span data-ttu-id="3cd3e-1048">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1048">-or-</span></span>

 <span data-ttu-id="3cd3e-1049"><paramref name="indexB" /> 大于 <paramref name="strB" />.<see cref="P:System.String.Length" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1049"><paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span></span>

<span data-ttu-id="3cd3e-1050">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1050">-or-</span></span>

 <span data-ttu-id="3cd3e-1051"><paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1051"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span>

<span data-ttu-id="3cd3e-1052">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1052">-or-</span></span>

<span data-ttu-id="3cd3e-1053"><paramref name="indexA" /> 或 <paramref name="indexB" /> 为 <see langword="null" />，并且 <paramref name="length" /> 大于零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1053">Either <paramref name="indexA" /> or <paramref name="indexB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-1054">字符集包括可忽略字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1054">Character sets include ignorable characters.</span></span> <span data-ttu-id="3cd3e-1055">此 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> 方法在执行语言或区分区域性的比较时不考虑这些字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1055">The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-1056">若要在比较中识别可忽略字符，请调用 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> 方法，并为 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 参数提供值或 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> <paramref name="comparisonType" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1056">To recognize ignorable characters in your comparison, call the <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> method and supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * StringComparison -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="5" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="3cd3e-1057">要在比较中使用的第一个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1057">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="3cd3e-1058"><paramref name="strA" /> 中子字符串的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1058">The position of the substring within <paramref name="strA" />.</span></span></param>
        <param name="strB"><span data-ttu-id="3cd3e-1059">要在比较中使用的第二个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1059">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="3cd3e-1060"><paramref name="strB" /> 中子字符串的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1060">The position of the substring within <paramref name="strB" />.</span></span></param>
        <param name="length"><span data-ttu-id="3cd3e-1061">要比较的子字符串中字符的最大数量。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1061">The maximum number of characters in the substrings to compare.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="3cd3e-1062">一个枚举值，用于指定比较中要使用的规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1062">One of the enumeration values that specifies the rules to use in the comparison.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1063">使用指定的规则比较两个指定的 <see cref="T:System.String" /> 对象的子字符串，并返回一个整数，指示二者在排序顺序中的相对位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1063">Compares substrings of two specified <see cref="T:System.String" /> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1064">一个 32 位带符号整数，指示两个比较数之间的词法关系。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1064">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>

 <list type="table"><listheader><term> <span data-ttu-id="3cd3e-1065">“值”</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1065">Value</span></span>

 </term><description> <span data-ttu-id="3cd3e-1066">条件</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1066">Condition</span></span>

 </description></listheader><item><term> <span data-ttu-id="3cd3e-1067">小于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1067">Less than zero</span></span>

 </term><description> <span data-ttu-id="3cd3e-1068"><paramref name="strA" /> 中的子字符串在排序顺序中位于 <paramref name="strB" /> 中的子字符串之前。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1068">The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.</span></span>

 </description></item><item><term> <span data-ttu-id="3cd3e-1069">零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1069">Zero</span></span>

 </term><description> <span data-ttu-id="3cd3e-1070">子字符串在排序顺序中出现的位置相同，或 <paramref name="length" /> 参数为零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1070">The substrings occur in the same position in the sort order, or the <paramref name="length" /> parameter is zero.</span></span>

 </description></item><item><term> <span data-ttu-id="3cd3e-1071">大于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1071">Greater than zero</span></span>

 </term><description> <span data-ttu-id="3cd3e-1072"><paramref name="strA" /> 中的子字符串在排序顺序中位于 <paramref name="strB" /> 中的子字符串之后。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1072">The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.</span></span>

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1073">要比较的子字符串 `strA` 在 `indexA` 和中的开始 `strB` 处 `indexB` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1073">The substrings to compare start in `strA` at `indexA` and in `strB` at `indexB`.</span></span> <span data-ttu-id="3cd3e-1074">`indexA`和 `indexB` 都是从零开始的; 即，和中的第一个字符位于 `strA` `strB` 位置零，而不是位置1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1074">Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero, not position one.</span></span> <span data-ttu-id="3cd3e-1075">第一个子字符串的长度等于 `strA` 减号 `indexA` 加1的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1075">The length of the first substring is equal to the length of `strA` minus `indexA` plus one.</span></span> <span data-ttu-id="3cd3e-1076">第二个子字符串的长度等于 `strB` 减号 `indexB` 加1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1076">The length of the second substring is equal to the length of `strB` minus `indexB` plus one.</span></span>

 <span data-ttu-id="3cd3e-1077">要比较的字符数是两个子字符串的长度中较小的一个和 `length` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1077">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="3cd3e-1078">`indexA`、 `indexB` 和 `length` 参数必须为非负。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1078">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>

 <span data-ttu-id="3cd3e-1079">`comparisonType`参数指示比较应使用当前的或固定的区域性，是接受还是忽略比较规则的大小写，还是使用 word (区分区域性的) 或序号 (不区分区域性的) 排序规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1079">The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the comparands, or use word (culture-sensitive) or ordinal (culture-insensitive) sort rules.</span></span>

 <span data-ttu-id="3cd3e-1080">其中一个或两个比较字可以为 `null` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1080">One or both comparands can be `null`.</span></span> <span data-ttu-id="3cd3e-1081">按照定义，包含空字符串 ( "" ) 中的任何字符串都会比较大于 null 引用;和两个 null 引用的比较结果相等。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1081">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>

 <span data-ttu-id="3cd3e-1082">当发现不相等或比较两个子字符串时，将终止比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1082">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="3cd3e-1083">但是，如果两个字符串的比较结果等于一个字符串的末尾，而另一个字符串还剩个字符，则包含剩余字符的字符串将被视为更大的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1083">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with remaining characters is considered greater.</span></span> <span data-ttu-id="3cd3e-1084">返回值是执行的最后一次比较的结果。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1084">The return value is the result of the last comparison performed.</span></span>

 <span data-ttu-id="3cd3e-1085">当比较受区域性特定的大小写规则影响时，可能会出现意外的结果。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1085">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="3cd3e-1086">例如，在土耳其语中，以下示例产生了错误的结果，因为土耳其语中的文件系统不会将语言大小写规则用于 "file" 中的字母 "i"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1086">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>

 [!code-cpp[System.String.Compare#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]

 <span data-ttu-id="3cd3e-1087">使用序号比较将路径名称与 "file" 进行比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1087">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="3cd3e-1088">要执行此操作，正确的代码如下所示：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1088">The correct code to do this is as follows:</span></span>

 [!code-cpp[System.String.Compare#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]



## Examples
 <span data-ttu-id="3cd3e-1089">下面的示例比较两个子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1089">The following example compares two substrings.</span></span>

 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp-interactive[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-1090"><paramref name="indexA" /> 大于 <paramref name="strA" />.<see cref="P:System.String.Length" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1090"><paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span></span>

<span data-ttu-id="3cd3e-1091">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1091">-or-</span></span>

 <span data-ttu-id="3cd3e-1092"><paramref name="indexB" /> 大于 <paramref name="strB" />.<see cref="P:System.String.Length" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1092"><paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span></span>

<span data-ttu-id="3cd3e-1093">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1093">-or-</span></span>

 <span data-ttu-id="3cd3e-1094"><paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1094"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span>

<span data-ttu-id="3cd3e-1095">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1095">-or-</span></span>

<span data-ttu-id="3cd3e-1096"><paramref name="indexA" /> 或 <paramref name="indexB" /> 为 <see langword="null" />，并且 <paramref name="length" /> 大于零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1096">Either <paramref name="indexA" /> or <paramref name="indexB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-1097"><paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1097"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-1098">字符集包括可忽略字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1098">Character sets include ignorable characters.</span></span> <span data-ttu-id="3cd3e-1099">此 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> 方法在执行语言或区分区域性的比较时不考虑这些字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1099">The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-1100">若要在比较中识别可忽略字符，请 <see cref="F:System.StringComparison.Ordinal" /> 为参数提供值或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> <paramref name="comparisonType" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1100">To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="3cd3e-1101">要在比较中使用的第一个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1101">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="3cd3e-1102"><paramref name="strA" /> 中子字符串的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1102">The position of the substring within <paramref name="strA" />.</span></span></param>
        <param name="strB"><span data-ttu-id="3cd3e-1103">要在比较中使用的第二个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1103">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="3cd3e-1104"><paramref name="strB" /> 中子字符串的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1104">The position of the substring within <paramref name="strB" />.</span></span></param>
        <param name="length"><span data-ttu-id="3cd3e-1105">要比较的子字符串中字符的最大数量。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1105">The maximum number of characters in the substrings to compare.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="3cd3e-1106">若要在比较过程中忽略大小写，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1106"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <param name="culture"><span data-ttu-id="3cd3e-1107">一个对象，提供区域性特定的比较信息。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1107">An object that supplies culture-specific comparison information.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1108">比较两个指定的 <see cref="T:System.String" /> 对象（其中忽略或考虑其大小写，并使用区域性特定的信息干预比较），并返回一个整数，指示二者在排序顺序中的相对位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1108">Compares substrings of two specified <see cref="T:System.String" /> objects, ignoring or honoring their case and using culture-specific information to influence the comparison, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1109">一个整数，指示两个比较字之间的词法关系。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1109">An integer that indicates the lexical relationship between the two comparands.</span></span>

 <list type="table"><listheader><term> <span data-ttu-id="3cd3e-1110">“值”</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1110">Value</span></span>

 </term><description> <span data-ttu-id="3cd3e-1111">条件</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1111">Condition</span></span>

 </description></listheader><item><term> <span data-ttu-id="3cd3e-1112">小于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1112">Less than zero</span></span>

 </term><description> <span data-ttu-id="3cd3e-1113"><paramref name="strA" /> 中的子字符串在排序顺序中位于 <paramref name="strB" /> 中的子字符串之前。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1113">The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.</span></span>

 </description></item><item><term> <span data-ttu-id="3cd3e-1114">零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1114">Zero</span></span>

 </term><description> <span data-ttu-id="3cd3e-1115">子字符串在排序顺序中出现的位置相同或 <paramref name="length" /> 为零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1115">The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.</span></span>

 </description></item><item><term> <span data-ttu-id="3cd3e-1116">大于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1116">Greater than zero</span></span>

 </term><description> <span data-ttu-id="3cd3e-1117"><paramref name="strA" /> 中的子字符串在排序顺序中位于 <paramref name="strB" /> 中的子字符串之后。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1117">The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.</span></span>

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1118">要比较的子字符串在中的开始 `strA` `indexA` ，位于中 `strB` `indexB` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1118">The substrings to compare start in `strA` at `indexA`, and in `strB` at `indexB`.</span></span> <span data-ttu-id="3cd3e-1119">`indexA`和 `indexB` 都是从零开始的; 即，和中的第一个字符位于 `strA` `strB` 位置零，而不是位置1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1119">Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero, not position one.</span></span> <span data-ttu-id="3cd3e-1120">第一个子字符串的长度等于 `strA` 减号 `indexA` 加1的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1120">The length of the first substring is equal to the length of `strA` minus `indexA` plus one.</span></span> <span data-ttu-id="3cd3e-1121">第二个子字符串的长度等于 `strB` 减号 `indexB` 加1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1121">The length of the second substring is equal to the length of `strB` minus `indexB` plus one.</span></span>

 <span data-ttu-id="3cd3e-1122">要比较的字符数是两个子字符串的长度中较小的一个和 `length` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1122">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="3cd3e-1123">`indexA`、 `indexB` 和 `length` 参数必须为非负。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1123">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>

 <span data-ttu-id="3cd3e-1124">该比较使用 `culture` 参数获取特定于区域性的信息，如大小写规则和单个字符的字母顺序。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1124">The comparison uses the `culture` parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="3cd3e-1125">例如，区域性可以指定将某些字符组合视为单个字符，或以特定方式比较大写和小写字符，或字符的排序顺序取决于其前面或后面的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1125">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>

 <span data-ttu-id="3cd3e-1126">使用字词排序规则执行比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1126">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="3cd3e-1127">有关 word、字符串和顺序排序的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1127">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="3cd3e-1128">其中一个或两个比较字可以为 `null` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1128">One or both comparands can be `null`.</span></span> <span data-ttu-id="3cd3e-1129">按照定义，包含空字符串 ( "" ) 中的任何字符串都会比较大于 null 引用;和两个 null 引用的比较结果相等。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1129">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>

 <span data-ttu-id="3cd3e-1130">当发现不相等或比较两个子字符串时，将终止比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1130">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="3cd3e-1131">但是，如果两个字符串的比较结果等于一个字符串的末尾，而另一个字符串还剩个字符，则包含剩余字符的字符串将被视为更大的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1131">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="3cd3e-1132">返回值是执行的最后一次比较的结果。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1132">The return value is the result of the last comparison performed.</span></span>

 <span data-ttu-id="3cd3e-1133">当比较受区域性特定的大小写规则影响时，可能会出现意外的结果。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1133">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="3cd3e-1134">例如，在土耳其语中，以下示例产生了错误的结果，因为土耳其语中的文件系统不会将语言大小写规则用于 "file" 中的字母 "i"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1134">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>

 [!code-cpp[System.String.Compare#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]

 <span data-ttu-id="3cd3e-1135">使用序号比较将路径名称与 "file" 进行比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1135">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="3cd3e-1136">要执行此操作，正确的代码如下所示：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1136">The correct code to do this is as follows:</span></span>

 [!code-cpp[System.String.Compare#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]



## Examples
 <span data-ttu-id="3cd3e-1137">下面的示例使用不同的区域性比较两个子字符串，并忽略子字符串的大小写。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1137">The following example compares two substrings using different cultures and ignoring the case of the substrings.</span></span> <span data-ttu-id="3cd3e-1138">区域性的选择会影响字母 "I" 的比较方式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1138">The choice of culture affects how the letter "I" is compared.</span></span>

 [!code-cpp[string.compare5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-1139"><paramref name="indexA" /> 大于 <paramref name="strA" />.<see cref="P:System.String.Length" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1139"><paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span></span>

<span data-ttu-id="3cd3e-1140">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1140">-or-</span></span>

 <span data-ttu-id="3cd3e-1141"><paramref name="indexB" /> 大于 <paramref name="strB" />.<see cref="P:System.String.Length" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1141"><paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span></span>

<span data-ttu-id="3cd3e-1142">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1142">-or-</span></span>

 <span data-ttu-id="3cd3e-1143"><paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1143"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span>

<span data-ttu-id="3cd3e-1144">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1144">-or-</span></span>

<span data-ttu-id="3cd3e-1145"><paramref name="strA" /> 或 <paramref name="strB" /> 为 <see langword="null" />，并且 <paramref name="length" /> 大于零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1145">Either <paramref name="strA" /> or <paramref name="strB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-1146"><paramref name="culture" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1146"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-1147">字符集包括可忽略字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1147">Character sets include ignorable characters.</span></span> <span data-ttu-id="3cd3e-1148">此 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> 方法在执行语言或区分区域性的比较时不考虑这些字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1148">The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-1149">若要在比较中识别可忽略字符，请调用 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> 方法，并为 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 参数提供值或 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> <paramref name="options" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1149">To recognize ignorable characters in your comparison, call the <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method and supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="3cd3e-1150">要在比较中使用的第一个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1150">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="3cd3e-1151"><paramref name="strA" /> 中子字符串开始的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1151">The starting position of the substring within <paramref name="strA" />.</span></span></param>
        <param name="strB"><span data-ttu-id="3cd3e-1152">要在比较中使用的第二个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1152">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="3cd3e-1153"><paramref name="strB" /> 中子字符串开始的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1153">The starting position of the substring within <paramref name="strB" />.</span></span></param>
        <param name="length"><span data-ttu-id="3cd3e-1154">要比较的子字符串中字符的最大数量。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1154">The maximum number of characters in the substrings to compare.</span></span></param>
        <param name="culture"><span data-ttu-id="3cd3e-1155">一个对象，提供区域性特定的比较信息。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1155">An object that supplies culture-specific comparison information.</span></span></param>
        <param name="options"><span data-ttu-id="3cd3e-1156">要在执行比较时使用的选项（如忽略大小写或符号）。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1156">Options to use when performing the comparison (such as ignoring case or symbols).</span></span></param>
        <summary><span data-ttu-id="3cd3e-1157">对两个指定 <see cref="T:System.String" /> 对象的子字符串进行比较，使用指定的比较选项和区域性特定的信息来影响比较，并返回一个整数，该整数指示这两个子字符串在排序顺序中的关系。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1157">Compares substrings of two specified <see cref="T:System.String" /> objects using the specified comparison options and culture-specific information to influence the comparison, and returns an integer that indicates the relationship of the two substrings to each other in the sort order.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1158">一个整数，该整数用于指示两个子字符串之间的词法关系，如下表所示。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1158">An integer that indicates the lexical relationship between the two substrings, as shown in the following table.</span></span>

 <list type="table"><listheader><term> <span data-ttu-id="3cd3e-1159">“值”</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1159">Value</span></span>

 </term><description> <span data-ttu-id="3cd3e-1160">条件</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1160">Condition</span></span>

 </description></listheader><item><term> <span data-ttu-id="3cd3e-1161">小于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1161">Less than zero</span></span>

 </term><description> <span data-ttu-id="3cd3e-1162"><paramref name="strA" /> 中的子字符串在排序顺序中位于 <paramref name="strB" /> 中的子字符串之前。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1162">The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.</span></span>

 </description></item><item><term> <span data-ttu-id="3cd3e-1163">零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1163">Zero</span></span>

 </term><description> <span data-ttu-id="3cd3e-1164">子字符串在排序顺序中出现的位置相同或 <paramref name="length" /> 为零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1164">The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.</span></span>

 </description></item><item><term> <span data-ttu-id="3cd3e-1165">大于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1165">Greater than zero</span></span>

 </term><description> <span data-ttu-id="3cd3e-1166"><paramref name="strA" /> 中的子字符串在排序顺序中位于 <paramref name="strB" /> 中的子字符串之后。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1166">The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.</span></span>

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1167">要比较的子字符串的起始 `strA` 位置 `indexA` 和位置 `strB` `indexB` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1167">The substrings to compare start in `strA` at position `indexA` and in `strB` at position `indexB`.</span></span> <span data-ttu-id="3cd3e-1168">第一个子字符串的长度是减号的长度 `strA` `indexA` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1168">The length of the first substring is the length of `strA` minus `indexA`.</span></span> <span data-ttu-id="3cd3e-1169">第二个子字符串的长度是减号的 `strB` 长度 `indexB` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1169">The length of the second substring is the length of `strB` minus `indexB`.</span></span>

 <span data-ttu-id="3cd3e-1170">要比较的字符数是两个子字符串的长度中较小的一个和 `length` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1170">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="3cd3e-1171">`indexA`、 `indexB` 和 `length` 参数必须为非负。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1171">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>

 <span data-ttu-id="3cd3e-1172">该比较使用 `culture` 参数获取特定于区域性的信息，如大小写规则和单个字符的字母顺序。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1172">The comparison uses the `culture` parameter to obtain culture-specific information, such as casing rules and the alphabetical order of individual characters.</span></span> <span data-ttu-id="3cd3e-1173">例如，特定的区域性可以指定将某些字符组合视为单个字符、以特定方式进行比较的大写和小写字符，或字符的排序顺序取决于其前面或后面的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1173">For example, a particular culture could specify that certain combinations of characters be treated as a single character, that uppercase and lowercase characters be compared in a particular way, or that the sort order of a character depends on the characters that precede or follow it.</span></span>

> [!CAUTION]
>  <span data-ttu-id="3cd3e-1174">此 <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> 方法主要用于排序或 alphabetizing 操作。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1174">The <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> method is designed primarily for use in sorting or alphabetizing operations.</span></span> <span data-ttu-id="3cd3e-1175">当方法调用的主要目的是确定两个子字符串是否等效时，不应使用此方法，即，当方法调用的目的是测试零) 的返回值时 (。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1175">It should not be used when the primary purpose of the method call is to determine whether two substrings are equivalent (that is, when the purpose of the method call is to test for a return value of zero).</span></span> <span data-ttu-id="3cd3e-1176">若要确定两个字符串是否相等，请调用 <xref:System.String.Equals%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1176">To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.</span></span>

 <span data-ttu-id="3cd3e-1177">`strA`和均 `strB` 可为 `null` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1177">One or both of `strA` and `strB` can be `null`.</span></span> <span data-ttu-id="3cd3e-1178">按照定义，任何字符串（包括 <xref:System.String.Empty?displayProperty=nameWithType> 、）比较大于 null 引用，而两个 null 引用的比较结果相等。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1178">By definition, any string, including <xref:System.String.Empty?displayProperty=nameWithType>, compares greater than a null reference, and two null references compare equal to each other.</span></span>

 <span data-ttu-id="3cd3e-1179">可以通过参数进一步指定比较，该 `options` 参数由一个或多个枚举成员组成 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1179">The comparison can be further specified by the `options` parameter, which consists of one or more members of the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="3cd3e-1180">但是，由于此方法的目的是执行区分区域性的字符串比较， <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> 因此和 <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> 值不起作用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1180">However, because the purpose of this method is to conduct a culture-sensitive string comparison, the <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> and <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> values have no effect.</span></span>

 <span data-ttu-id="3cd3e-1181">当发现不相等或比较两个子字符串时，将终止比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1181">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="3cd3e-1182">但是，如果两个字符串的比较结果与一个字符串的末尾相等，而另一个字符串还剩个字符，则将剩余字符视为更大的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1182">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with the remaining characters is considered greater.</span></span> <span data-ttu-id="3cd3e-1183">返回值是执行的最后一次比较的结果。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1183">The return value is the result of the last comparison performed.</span></span>



## Examples
 <span data-ttu-id="3cd3e-1184">下面的示例使用 <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> 方法来比较两个人员的姓氏。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1184">The following example uses the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> method to compare the last names of two people.</span></span> <span data-ttu-id="3cd3e-1185">然后，它按字母顺序列出。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1185">It then lists them in alphabetical order.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-1186"><paramref name="options" /> 不是 <see cref="T:System.Globalization.CompareOptions" /> 值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1186"><paramref name="options" /> is not a <see cref="T:System.Globalization.CompareOptions" /> value.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-1187"><paramref name="indexA" /> 大于 <paramref name="strA" /><see langword=".Length" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1187"><paramref name="indexA" /> is greater than <paramref name="strA" /><see langword=".Length" />.</span></span>

<span data-ttu-id="3cd3e-1188">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1188">-or-</span></span>

 <span data-ttu-id="3cd3e-1189"><paramref name="indexB" /> 大于 <paramref name="strB" /><see langword=".Length" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1189"><paramref name="indexB" /> is greater than <paramref name="strB" /><see langword=".Length" />.</span></span>

<span data-ttu-id="3cd3e-1190">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1190">-or-</span></span>

 <span data-ttu-id="3cd3e-1191"><paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1191"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span>

<span data-ttu-id="3cd3e-1192">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1192">-or-</span></span>

<span data-ttu-id="3cd3e-1193"><paramref name="strA" /> 或 <paramref name="strB" /> 为 <see langword="null" />，并且 <paramref name="length" /> 大于零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1193">Either <paramref name="strA" /> or <paramref name="strB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-1194"><paramref name="culture" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1194"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-1195">字符集包括可忽略字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1195">Character sets include ignorable characters.</span></span> <span data-ttu-id="3cd3e-1196">此 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> 方法在执行语言或区分区域性的比较时不考虑这些字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1196">The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-1197">若要在比较中识别可忽略字符，请 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 为参数提供值或 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> <paramref name="options" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1197">To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</span></span></para></block>
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareOrdinal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3cd3e-1198">通过计算每个字符串中相应 <see cref="T:System.String" /> 对象的数值来比较两个 <see cref="T:System.Char" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1198">Compares two <see cref="T:System.String" /> objects by evaluating the numeric values of the corresponding <see cref="T:System.Char" /> objects in each string.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * string -&gt; int" Usage="System.string.CompareOrdinal (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="3cd3e-1199">要比较的第一个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1199">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="3cd3e-1200">要比较的第二个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1200">The second string to compare.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1201">通过计算每个字符串中相应 <see cref="T:System.String" /> 对象的数值来比较两个指定的 <see cref="T:System.Char" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1201">Compares two specified <see cref="T:System.String" /> objects by evaluating the numeric values of the corresponding <see cref="T:System.Char" /> objects in each string.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1202">一个整数，指示两个比较字之间的词法关系。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1202">An integer that indicates the lexical relationship between the two comparands.</span></span>

 <list type="table"><listheader><term> <span data-ttu-id="3cd3e-1203">“值”</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1203">Value</span></span>

 </term><description> <span data-ttu-id="3cd3e-1204">条件</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1204">Condition</span></span>

 </description></listheader><item><term> <span data-ttu-id="3cd3e-1205">小于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1205">Less than zero</span></span>

 </term><description><span data-ttu-id="3cd3e-1206"><paramref name="strA" /> 小于 <paramref name="strB" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1206"><paramref name="strA" /> is less than <paramref name="strB" />.</span></span>

 </description></item><item><term> <span data-ttu-id="3cd3e-1207">零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1207">Zero</span></span>

 </term><description><span data-ttu-id="3cd3e-1208"><paramref name="strA" /> 与 <paramref name="strB" /> 相等。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1208"><paramref name="strA" /> and <paramref name="strB" /> are equal.</span></span>

 </description></item><item><term> <span data-ttu-id="3cd3e-1209">大于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1209">Greater than zero</span></span>

 </term><description><span data-ttu-id="3cd3e-1210"><paramref name="strA" /> 大于 <paramref name="strB" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1210"><paramref name="strA" /> is greater than <paramref name="strB" />.</span></span>

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1211">此方法使用序号排序规则执行区分大小写的比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1211">This method performs a case-sensitive comparison using ordinal sort rules.</span></span> <span data-ttu-id="3cd3e-1212">有关 word、字符串和顺序排序的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1212">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3cd3e-1213">若要使用序号排序规则执行不区分大小写的比较，请调用 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> 方法，并将 `comparisonType` 参数设置为 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1213">To perform a case-insensitive comparison using ordinal sort rules, call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method with the `comparisonType` argument set to <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="3cd3e-1214">由于 <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> 是静态方法，因此 `strA` `strB` 可以是 `null` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1214">Because <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> is a static method, `strA` and `strB` can be `null`.</span></span> <span data-ttu-id="3cd3e-1215">如果这两个值都为 `null` ，则该方法将返回 0 (零) ，这指示 `strA` 和 `strB` 相等。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1215">If both values are `null`, the method returns 0 (zero), which indicates that `strA` and `strB` are equal.</span></span> <span data-ttu-id="3cd3e-1216">如果只有一个值为 `null` ，则该方法会将非 null 值视为更大的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1216">If only one of the values is `null`, the method considers the non-null value to be greater.</span></span>



## Examples
 <span data-ttu-id="3cd3e-1217">下面的示例对两个仅大小写不同的字符串执行和序号比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1217">The following example performs and ordinal comparison of two strings that only differ in case.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * int * string * int * int -&gt; int" Usage="System.string.CompareOrdinal (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="3cd3e-1218">要在比较中使用的第一个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1218">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="3cd3e-1219"><paramref name="strA" /> 中子字符串的起始索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1219">The starting index of the substring in <paramref name="strA" />.</span></span></param>
        <param name="strB"><span data-ttu-id="3cd3e-1220">要在比较中使用的第二个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1220">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="3cd3e-1221"><paramref name="strB" /> 中子字符串的起始索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1221">The starting index of the substring in <paramref name="strB" />.</span></span></param>
        <param name="length"><span data-ttu-id="3cd3e-1222">要比较的子字符串中字符的最大数量。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1222">The maximum number of characters in the substrings to compare.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1223">通过计算每个子字符串中相应 <see cref="T:System.String" /> 对象的数值来比较两个指定的 <see cref="T:System.Char" /> 对象的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1223">Compares substrings of two specified <see cref="T:System.String" /> objects by evaluating the numeric values of the corresponding <see cref="T:System.Char" /> objects in each substring.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1224">一个 32 位带符号整数，指示两个比较数之间的词法关系。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1224">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>

 <list type="table"><listheader><term> <span data-ttu-id="3cd3e-1225">“值”</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1225">Value</span></span>

 </term><description> <span data-ttu-id="3cd3e-1226">条件</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1226">Condition</span></span>

 </description></listheader><item><term> <span data-ttu-id="3cd3e-1227">小于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1227">Less than zero</span></span>

 </term><description> <span data-ttu-id="3cd3e-1228"><paramref name="strA" /> 中的子字符串小于 <paramref name="strB" /> 中的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1228">The substring in <paramref name="strA" /> is less than the substring in <paramref name="strB" />.</span></span>

 </description></item><item><term> <span data-ttu-id="3cd3e-1229">零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1229">Zero</span></span>

 </term><description> <span data-ttu-id="3cd3e-1230">子字符串相等，或者 <paramref name="length" /> 为零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1230">The substrings are equal, or <paramref name="length" /> is zero.</span></span>

 </description></item><item><term> <span data-ttu-id="3cd3e-1231">大于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1231">Greater than zero</span></span>

 </term><description> <span data-ttu-id="3cd3e-1232"><paramref name="strA" /> 中的子字符串大于 <paramref name="strB" /> 中的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1232">The substring in <paramref name="strA" /> is greater than the substring in <paramref name="strB" />.</span></span>

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1233">`indexA`、 `indexB` 和 `length` 参数必须为非负。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1233">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>

 <span data-ttu-id="3cd3e-1234">比较的字符数是较小的长度 `strA` `indexA` ，长度 `strB` 小于 `indexB` 或等于 `length` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1234">The number of characters compared is the lesser of the length of `strA` less `indexA`, the length of `strB` less `indexB`, and `length`.</span></span>

 <span data-ttu-id="3cd3e-1235">此方法使用序号排序规则执行区分大小写的比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1235">This method performs a case-sensitive comparison using ordinal sort rules.</span></span> <span data-ttu-id="3cd3e-1236">有关 word、字符串和顺序排序的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1236">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3cd3e-1237">若要使用序号排序规则执行不区分大小写的比较，请调用 <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> 方法，并将 `comparisonType` 参数设置为 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1237">To perform a case-insensitive comparison using ordinal sort rules, call the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> method with the `comparisonType` argument set to <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="3cd3e-1238">由于 <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> 是静态方法，因此 `strA` `strB` 可以是 `null` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1238">Because <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> is a static method, `strA` and `strB` can be `null`.</span></span> <span data-ttu-id="3cd3e-1239">如果这两个值都为 `null` ，则该方法将返回 0 (零) ，这指示 `strA` 和 `strB` 相等。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1239">If both values are `null`, the method returns 0 (zero), which indicates that `strA` and `strB` are equal.</span></span> <span data-ttu-id="3cd3e-1240">如果只有一个值为 `null` ，则该方法会将非 null 值视为更大的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1240">If only one of the values is `null`, the method considers the non-null value to be greater.</span></span>



## Examples
 <span data-ttu-id="3cd3e-1241">下面的示例演示 <xref:System.String.CompareOrdinal%2A> 并 <xref:System.String.Compare%2A> 使用不同的排序顺序。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1241">This following example demonstrates that <xref:System.String.CompareOrdinal%2A> and <xref:System.String.Compare%2A> use different sort orders.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-1242"><paramref name="strA" /> 不为 <see langword="null" /> ，且 <paramref name="indexA" /> 大于 <paramref name="strA" />.<see cref="P:System.String.Length" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1242"><paramref name="strA" /> is not <see langword="null" /> and <paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span></span>

<span data-ttu-id="3cd3e-1243">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1243">-or-</span></span>

 <span data-ttu-id="3cd3e-1244"><paramref name="strB" /> 不为 <see langword="null" /> ，且 <paramref name="indexB" /> 大于 <paramref name="strB" />.<see cref="P:System.String.Length" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1244"><paramref name="strB" /> is not <see langword="null" /> and <paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span></span>

<span data-ttu-id="3cd3e-1245">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1245">-or-</span></span>

 <span data-ttu-id="3cd3e-1246"><paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1246"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span></exception>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3cd3e-1247">将此实例与指定对象或 <see cref="T:System.String" /> 进行比较，并返回一个整数，该整数指示此实例在排序顺序中是位于指定对象或 <see cref="T:System.String" /> 之前、之后还是与其出现在同一位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1247">Compares this instance with a specified object or <see cref="T:System.String" /> and returns an integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified object or <see cref="T:System.String" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1248">此方法的两个重载都 <xref:System.String.CompareTo%2A> 执行区分区域性和区分大小写的比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1248">Both overloads of the <xref:System.String.CompareTo%2A> method perform culture-sensitive and case-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-1249">不能使用此方法来执行不区分区域性或序号比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1249">You cannot use this method to perform culture-insensitive or ordinal comparisons.</span></span> <span data-ttu-id="3cd3e-1250">为实现代码清晰度，建议你避免方法， <xref:System.String.CompareTo%2A> 并改为调用 <xref:System.String.Compare%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1250">For code clarity, we recommend that you avoid the <xref:System.String.CompareTo%2A> method and call the <xref:System.String.Compare%2A> method instead.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="string.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-1251">一个对象，其计算结果为 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1251">An object that evaluates to a <see cref="T:System.String" />.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1252">将此实例与指定的 <see cref="T:System.Object" /> 进行比较，并指示此实例在排序顺序中是位于指定的 <see cref="T:System.Object" /> 之前、之后还是与其出现在同一位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1252">Compares this instance with a specified <see cref="T:System.Object" /> and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <see cref="T:System.Object" />.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1253">一个 32 位带符号整数，该整数指示此实例在排序顺序中是位于 <paramref name="value" /> 参数之前、之后还是与其出现在同一位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1253">A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <paramref name="value" /> parameter.</span></span>

 <list type="table"><listheader><term> <span data-ttu-id="3cd3e-1254">“值”</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1254">Value</span></span>

 </term><description> <span data-ttu-id="3cd3e-1255">条件</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1255">Condition</span></span>

 </description></listheader><item><term> <span data-ttu-id="3cd3e-1256">小于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1256">Less than zero</span></span>

 </term><description> <span data-ttu-id="3cd3e-1257">此实例位于 <paramref name="value" /> 之前。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1257">This instance precedes <paramref name="value" />.</span></span>

 </description></item><item><term> <span data-ttu-id="3cd3e-1258">零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1258">Zero</span></span>

 </term><description> <span data-ttu-id="3cd3e-1259">此实例在排序顺序中的位置与 <paramref name="value" /> 相同。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1259">This instance has the same position in the sort order as <paramref name="value" />.</span></span>

 </description></item><item><term> <span data-ttu-id="3cd3e-1260">大于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1260">Greater than zero</span></span>

 </term><description> <span data-ttu-id="3cd3e-1261">此实例位于 <paramref name="value" /> 之后。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1261">This instance follows <paramref name="value" />.</span></span>

<span data-ttu-id="3cd3e-1262">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1262">-or-</span></span>

 <span data-ttu-id="3cd3e-1263"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1263"><paramref name="value" /> is <see langword="null" />.</span></span>

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1264">`value` 必须是一个 <xref:System.String> 对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1264">`value` must be a <xref:System.String> object.</span></span>

> [!CAUTION]
>  <span data-ttu-id="3cd3e-1265">此 <xref:System.String.CompareTo%2A> 方法主要用于排序或 alphabetizing 操作。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1265">The <xref:System.String.CompareTo%2A> method was designed primarily for use in sorting or alphabetizing operations.</span></span> <span data-ttu-id="3cd3e-1266">当方法调用的主要目的是确定两个字符串是否相等时，不应使用此方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1266">It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent.</span></span> <span data-ttu-id="3cd3e-1267">若要确定两个字符串是否相等，请调用 <xref:System.String.Equals%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1267">To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.</span></span>

 <span data-ttu-id="3cd3e-1268">此方法使用当前区域性执行区分大小写的 (区分大小写的) 比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1268">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span> <span data-ttu-id="3cd3e-1269">有关 word、字符串和顺序排序的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1269">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="3cd3e-1270">有关此方法的行为的详细信息，请参阅方法的 "备注" 部分 <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1270">For more information about the behavior of this method, see the Remarks section of the <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> method.</span></span>



## Examples
 <span data-ttu-id="3cd3e-1271">下面的示例将 <xref:System.String.CompareTo%2A> 方法与一起使用 <xref:System.Object> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1271">The following example uses the <xref:System.String.CompareTo%2A> method with an <xref:System.Object>.</span></span> <span data-ttu-id="3cd3e-1272">因为它尝试将实例与 <xref:System.String> 对象进行比较 `TestClass` ，所以方法会引发 <xref:System.ArgumentException> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1272">Because it attempts to compare a <xref:System.String> instance to a `TestClass` object, the method throws an <xref:System.ArgumentException>.</span></span>

 [!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-1273"><paramref name="value" /> 不是 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1273"><paramref name="value" /> is not a <see cref="T:System.String" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-1274">字符集包括可忽略字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1274">Character sets include ignorable characters.</span></span> <span data-ttu-id="3cd3e-1275"><see cref="M:System.String.CompareTo(System.Object)" />当方法执行区分区域性的比较时，它不会考虑此类字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1275">The <see cref="M:System.String.CompareTo(System.Object)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-1276">例如，如果以下代码在 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 或更高版本上运行，则使用软连字符将 "动物" 与 ("00AD" 进行比较，或使用 U +) 指示这两个字符串是等效的。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1276">For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</span></span>

<span data-ttu-id="3cd3e-1277">[！ code-csharp[CompareTo # 1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)][！ code-vb[CompareTo # 1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)]</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1277">[!code-csharp[System.String.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)] [!code-vb[System.String.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)]</span></span>

<span data-ttu-id="3cd3e-1278">若要在字符串比较中识别可忽略字符，请调用 <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1278">To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> method.</span></span></para></block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::String ^ strB);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : string -&gt; int&#xA;override this.CompareTo : string -&gt; int" Usage="string.CompareTo strB" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(string strB) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::String ^ strB);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="member this.CompareTo : string -&gt; int" Usage="string.CompareTo strB" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB"><span data-ttu-id="3cd3e-1279">要与此实例进行比较的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1279">The string to compare with this instance.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1280">将此实例与指定的 <see cref="T:System.String" /> 对象进行比较，并指示此实例在排序顺序中是位于指定的字符串之前、之后还是与其出现在同一位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1280">Compares this instance with a specified <see cref="T:System.String" /> object and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified string.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1281">一个 32 位带符号整数，该整数指示此实例在排序顺序中是位于 <paramref name="strB" /> 参数之前、之后还是与其出现在同一位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1281">A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <paramref name="strB" /> parameter.</span></span>

 <list type="table"><listheader><term> <span data-ttu-id="3cd3e-1282">“值”</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1282">Value</span></span>

 </term><description> <span data-ttu-id="3cd3e-1283">条件</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1283">Condition</span></span>

 </description></listheader><item><term> <span data-ttu-id="3cd3e-1284">小于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1284">Less than zero</span></span>

 </term><description> <span data-ttu-id="3cd3e-1285">此实例位于 <paramref name="strB" /> 之前。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1285">This instance precedes <paramref name="strB" />.</span></span>

 </description></item><item><term> <span data-ttu-id="3cd3e-1286">零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1286">Zero</span></span>

 </term><description> <span data-ttu-id="3cd3e-1287">此实例在排序顺序中的位置与 <paramref name="strB" /> 相同。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1287">This instance has the same position in the sort order as <paramref name="strB" />.</span></span>

 </description></item><item><term> <span data-ttu-id="3cd3e-1288">大于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1288">Greater than zero</span></span>

 </term><description> <span data-ttu-id="3cd3e-1289">此实例位于 <paramref name="strB" /> 之后。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1289">This instance follows <paramref name="strB" />.</span></span>

<span data-ttu-id="3cd3e-1290">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1290">-or-</span></span>

 <span data-ttu-id="3cd3e-1291"><paramref name="strB" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1291"><paramref name="strB" /> is <see langword="null" />.</span></span>

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1292">此方法使用当前区域性执行区分大小写的 (区分大小写的) 比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1292">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span> <span data-ttu-id="3cd3e-1293">有关 word、字符串和顺序排序的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1293">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>

> [!CAUTION]
>  <span data-ttu-id="3cd3e-1294">此 <xref:System.String.CompareTo%2A> 方法主要用于排序或 alphabetizing 操作。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1294">The <xref:System.String.CompareTo%2A> method was designed primarily for use in sorting or alphabetizing operations.</span></span> <span data-ttu-id="3cd3e-1295">当方法调用的主要目的是确定两个字符串是否相等时，不应使用此方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1295">It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent.</span></span> <span data-ttu-id="3cd3e-1296">若要确定两个字符串是否相等，请调用 <xref:System.String.Equals%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1296">To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.</span></span>

 <span data-ttu-id="3cd3e-1297">有关此方法的行为的详细信息，请参阅方法的 "备注" 部分 <xref:System.String.Compare%28System.String%2CSystem.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1297">For more information about the behavior of this method, see the Remarks section of the <xref:System.String.Compare%28System.String%2CSystem.String%29> method.</span></span>

 <span data-ttu-id="3cd3e-1298">此方法实现 <xref:System.IComparable%601?displayProperty=nameWithType> 接口，且执行方式略优于 <xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType> 方法，因为它不必确定 `strB` 自变量是否为必须进行装箱的可变值类型，并且无需将其参数从转换 <xref:System.Object> 为 <xref:System.String> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1298">This method implements the <xref:System.IComparable%601?displayProperty=nameWithType> interface and performs slightly better than the <xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType> method, because it does not have to determine whether the `strB` argument is a mutable value type that must be boxed, and it does not have to cast its parameter from an <xref:System.Object> to a <xref:System.String>.</span></span>



## Examples
 <span data-ttu-id="3cd3e-1299">下面的示例使用 <xref:System.String.CompareTo%2A> 方法将当前字符串实例与另一个字符串进行比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1299">The following example uses the <xref:System.String.CompareTo%2A> method to compare the current string instance with another string.</span></span>

 [!code-cpp[stringcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]

 <span data-ttu-id="3cd3e-1300">下面的示例演示了多个值和引用类型的 CompareTo 方法的泛型和非泛型版本。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1300">The following example demonstrates generic and non-generic versions of the CompareTo method for several value and reference types.</span></span>

 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]

 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-1301">字符集包括可忽略字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1301">Character sets include ignorable characters.</span></span> <span data-ttu-id="3cd3e-1302"><see cref="M:System.String.CompareTo(System.String)" />当方法执行区分区域性的比较时，它不会考虑此类字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1302">The <see cref="M:System.String.CompareTo(System.String)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-1303">例如，如果以下代码在 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 或更高版本上运行，则使用软连字符将 "动物" 与 ("00AD" 进行比较，或使用 U +) 指示这两个字符串是等效的。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1303">For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</span></span>

<span data-ttu-id="3cd3e-1304">[！ code-csharp[CompareTo # 2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)][！ code-vb[CompareTo # 2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)]</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1304">[!code-csharp[System.String.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)] [!code-vb[System.String.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)]</span></span>

<span data-ttu-id="3cd3e-1305">若要在字符串比较中识别可忽略字符，请调用 <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1305">To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> method.</span></span></para></block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3cd3e-1306">连接 <see cref="T:System.String" /> 的一个或多个实例，或 <see cref="T:System.String" /> 的一个或多个实例的值的 <see cref="T:System.Object" /> 表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1306">Concatenates one or more instances of <see cref="T:System.String" />, or the <see cref="T:System.String" /> representations of the values of one or more instances of <see cref="T:System.Object" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

> [!NOTE]
>  <span data-ttu-id="3cd3e-1307">你还可以使用语言的字符串串联运算符（如 `+` c # 中的）， `&` 或 `+` 在 Visual Basic 中连接字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1307">You can also use your language's string concatenation operator, such as `+` in C#, or `&` and `+` in Visual Basic, to concatenate strings.</span></span> <span data-ttu-id="3cd3e-1308">这两个编译器都将串连运算符转换为对的重载之一的调用 `String.Concat` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1308">Both compilers translate the concatenation operator into a call to one of the overloads of `String.Concat`.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;string&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt;? values);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="values"><span data-ttu-id="3cd3e-1309">一个集合对象，该对象实现 <see cref="T:System.Collections.Generic.IEnumerable`1" />，且其泛型类型参数为 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1309">A collection object that implements <see cref="T:System.Collections.Generic.IEnumerable`1" /> and whose generic type argument is <see cref="T:System.String" />.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1310">串联类型为 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 的 <see cref="T:System.String" /> 构造集合的成员。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1310">Concatenates the members of a constructed <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection of type <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1311"><paramref name="values" /> 中的串联字符串；如果 <paramref name="values" /> 为空 <see langword="IEnumerable(Of String)" />，则为 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1311">The concatenated strings in <paramref name="values" />, or <see cref="F:System.String.Empty" /> if <paramref name="values" /> is an empty <see langword="IEnumerable(Of String)" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1312">此方法连接中的每个对象 `values` ; 它不添加任何分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1312">The method concatenates each object in `values`; it does not add any delimiters.</span></span> <span data-ttu-id="3cd3e-1313">若要指定每个成员之间的分隔符 `values` ，请调用 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1313">To specify a delimiter between each member of `values`, call the <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method.</span></span>

 <span data-ttu-id="3cd3e-1314"><xref:System.String.Empty?displayProperty=nameWithtype>字符串用于替换中的任何 null 元素 `values` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1314">An <xref:System.String.Empty?displayProperty=nameWithtype> string is used in place of any null element in `values`.</span></span>

 <span data-ttu-id="3cd3e-1315">如果 `values` ，则为 `IEnumerable(Of String)`，则此方法返回 <xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1315">If `values` is an empty `IEnumerable(Of String)`, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3cd3e-1316">如果 `values` 为 `null` ，则该方法将引发 <xref:System.ArgumentNullException> 异常。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1316">If `values` is `null`, the method throws an <xref:System.ArgumentNullException> exception.</span></span>

 <span data-ttu-id="3cd3e-1317"><xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 是一种简便方法，使您可以连接集合中的每个元素， `IEnumerable(Of String)` 而无需先将元素转换为字符串数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1317"><xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> is a convenience method that lets you concatenate each element in an `IEnumerable(Of String)` collection without first converting the elements to a string array.</span></span> <span data-ttu-id="3cd3e-1318">它对于 Language-Integrated 查询 (LINQ) 查询表达式特别有用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1318">It is particularly useful with Language-Integrated Query (LINQ) query expressions.</span></span> <span data-ttu-id="3cd3e-1319">下面的示例将 `List(Of String)` 包含字母表的大写或小写字母的对象传递给 lambda 表达式，该表达式选择等于或大于特定字母 (的字母，在本例中为 "M" ) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1319">The following example passes a `List(Of String)` object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is "M").</span></span> <span data-ttu-id="3cd3e-1320">`IEnumerable(Of String)`方法返回的集合 <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> 传递给 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 方法，以单个字符串的形式显示结果。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1320">The `IEnumerable(Of String)` collection that is returned by the <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> method is passed to the <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method to display the result as a single string.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb" id="Snippet3":::

## Examples
 <span data-ttu-id="3cd3e-1321">下面的示例使用埃拉托色 of 尼斯筛法算法来计算小于或等于100的质数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1321">The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</span></span> <span data-ttu-id="3cd3e-1322">它将结果分配给 <xref:System.Collections.Generic.List%601> 类型的对象，然后将该对象 <xref:System.String> 传递给 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1322">It assigns the result to a <xref:System.Collections.Generic.List%601> object of type <xref:System.String>, which it then passes to the <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb" id="Snippet2":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-1323"><paramref name="values" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1323"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Concat : obj -&gt; string" Usage="System.string.Concat arg0" />
      <MemberSignature Language="C#" Value="public static string Concat (object? arg0);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="3cd3e-1324">要表示的对象，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1324">The object to represent, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1325">创建指定对象的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1325">Creates the string  representation of a specified object.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1326"><paramref name="arg0" /> 的值的字符串表示形式，如果 <see cref="F:System.String.Empty" /> 为 <paramref name="arg0" />，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1326">The string representation of the value of <paramref name="arg0" />, or <see cref="F:System.String.Empty" /> if <paramref name="arg0" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1327"><xref:System.String.Concat%28System.Object%29>方法 `arg0` 通过调用其无参数的方法将表示为字符串 `ToString` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1327">The <xref:System.String.Concat%28System.Object%29> method represents `arg0` as a string by calling its parameterless `ToString` method.</span></span>



## Examples
 <span data-ttu-id="3cd3e-1328">下面的示例演示 <xref:System.String.Concat%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1328">The following example demonstrates the <xref:System.String.Concat%2A> method.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params object[] args);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Concat : obj[] -&gt; string" Usage="System.string.Concat args" />
      <MemberSignature Language="C#" Value="public static string Concat (params object[]? args);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args"><span data-ttu-id="3cd3e-1329">一个对象数组，其中包含要连接的元素。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1329">An object array that contains the elements to concatenate.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1330">连接指定 <see cref="T:System.Object" /> 数组中的元素的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1330">Concatenates the string representations of the elements in a specified <see cref="T:System.Object" /> array.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1331"><paramref name="args" /> 中元素的值的串联字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1331">The concatenated string representations of the values of the elements in <paramref name="args" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1332">方法 `args` 通过调用该对象的无参数方法来连接中的每个对象，而不 `ToString` 会添加任何分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1332">The method concatenates each object in `args` by calling the parameterless `ToString` method of that object; it does not add any delimiters.</span></span>

 <span data-ttu-id="3cd3e-1333"><xref:System.String.Empty?displayProperty=nameWithType> 用于替代数组中的任何 null 对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1333"><xref:System.String.Empty?displayProperty=nameWithType> is used in place of any null object in the array.</span></span>



## Examples
 <span data-ttu-id="3cd3e-1334">下面的示例演示如何将方法用于 <xref:System.String.Concat%2A> <xref:System.Object> 数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1334">The following example demonstrates the use of the <xref:System.String.Concat%2A> method with an <xref:System.Object> array.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-1335"><paramref name="args" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1335"><paramref name="args" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="3cd3e-1336">内存不足。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1336">Out of memory.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-1337">C + + 代码不会调用此方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1337">This method is not called by C++ code.</span></span> <span data-ttu-id="3cd3e-1338">C + + 编译器解析对 <see cref="Overload:System.String.Concat" /> 的调用，该调用具有四个或更多对象参数作为对的调用 <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1338">The C++ compiler resolves calls to <see cref="Overload:System.String.Concat" /> that have four or more object parameters as a call to <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />.</span></span></para></block>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params string[] values);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray values As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : string[] -&gt; string" Usage="System.string.Concat values" />
      <MemberSignature Language="C#" Value="public static string Concat (params string[]? values);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values"><span data-ttu-id="3cd3e-1339">字符串实例的数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1339">An array of string instances.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1340">连接指定的 <see cref="T:System.String" /> 数组的元素。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1340">Concatenates the elements of a specified <see cref="T:System.String" /> array.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1341"><paramref name="values" /> 的串联元素。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1341">The concatenated elements of <paramref name="values" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1342">此方法连接中的每个对象 `values` ; 它不添加任何分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1342">The method concatenates each object in `values`; it does not add any delimiters.</span></span>

 <span data-ttu-id="3cd3e-1343"><xref:System.String.Empty?displayProperty=nameWithtype>字符串用于替代数组中的任何 null 对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1343">An <xref:System.String.Empty?displayProperty=nameWithtype> string is used in place of any null object in the array.</span></span>



## Examples
 <span data-ttu-id="3cd3e-1344">下面的示例演示如何将方法用于 <xref:System.String.Concat%2A> <xref:System.String> 数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1344">The following example demonstrates the use of the <xref:System.String.Concat%2A> method with a <xref:System.String> array.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-1345"><paramref name="values" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1345"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="3cd3e-1346">内存不足。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1346">Out of memory.</span></span></exception>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1)" />
      <MemberSignature Language="C#" Value="public static string? Concat (object arg0, object arg1);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="3cd3e-1347">要连接的第一个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1347">The first object to concatenate.</span></span></param>
        <param name="arg1"><span data-ttu-id="3cd3e-1348">要连接的第二个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1348">The second object to concatenate.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1349">连接两个指定对象的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1349">Concatenates the string representations of two specified objects.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1350"><paramref name="arg0" /> 和 <paramref name="arg1" /> 的值的串联字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1350">The concatenated string representations of the values of <paramref name="arg0" /> and <paramref name="arg1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1351">方法 `arg0` `arg1` 通过调用和的无参数方法连接和，而 `ToString` `arg0` `arg1` 不添加任何分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1351">The method concatenates `arg0` and `arg1` by calling the parameterless `ToString` method of `arg0` and `arg1`; it does not add any delimiters.</span></span>

 <span data-ttu-id="3cd3e-1352"><xref:System.String.Empty?displayProperty=nameWithType> 用于替代任何空参数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1352"><xref:System.String.Empty?displayProperty=nameWithType> is used in place of any null argument.</span></span>

 <span data-ttu-id="3cd3e-1353">如果任何一个参数为数组引用，则该方法将连接一个表示该数组的字符串，而不是它的成员 (例如 "System.string []" ) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1353">If either of the arguments is an array reference, the method concatenates a string representing that array, instead of its members (for example, "System.String[]").</span></span>



## Examples
 <span data-ttu-id="3cd3e-1354">下面的示例演示 <xref:System.String.Concat%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1354">The following example demonstrates the <xref:System.String.Concat%2A> method.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string? Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="str0"><span data-ttu-id="3cd3e-1355">要连接的第一个只读字符范围。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1355">The first read-only character span to concatenate.</span></span></param>
        <param name="str1"><span data-ttu-id="3cd3e-1356">要连接的第二个只读字符范围。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1356">The second read-only character span to concatenate.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1357">连接两个指定的只读字符范围的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1357">Concatenates the string representations of two specified read-only character spans.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1358"><paramref name="str0" /> 和 <paramref name="str1" /> 的值的串联字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1358">The concatenated string representations of the values of <paramref name="str0" /> and <paramref name="str1" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberSignature Language="C#" Value="public static string? Concat (string str0, string str1);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0"><span data-ttu-id="3cd3e-1359">要串联的第一个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1359">The first string to concatenate.</span></span></param>
        <param name="str1"><span data-ttu-id="3cd3e-1360">要串联的第二个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1360">The second string to concatenate.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1361">连接 <see cref="T:System.String" /> 的两个指定实例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1361">Concatenates two specified instances of <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1362"><paramref name="str0" /> 和 <paramref name="str1" /> 的串联。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1362">The concatenation of <paramref name="str0" /> and <paramref name="str1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1363">方法连接 `str0` 和 `str1` ; 它不添加任何分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1363">The method concatenates `str0` and `str1`; it does not add any delimiters.</span></span>

 <span data-ttu-id="3cd3e-1364"><xref:System.String.Empty?displayProperty=nameWithtype>字符串用于替代任何空参数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1364">An <xref:System.String.Empty?displayProperty=nameWithtype> string is used in place of any null argument.</span></span>

## Examples
 <span data-ttu-id="3cd3e-1365">下面的示例将用户的名字、中间名和姓氏连接起来。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1365">The following example concatenates a person's first, middle, and last name.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2)" />
      <MemberSignature Language="C#" Value="public static string? Concat (object arg0, object arg1, object arg2);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="3cd3e-1366">要连接的第一个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1366">The first object to concatenate.</span></span></param>
        <param name="arg1"><span data-ttu-id="3cd3e-1367">要连接的第二个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1367">The second object to concatenate.</span></span></param>
        <param name="arg2"><span data-ttu-id="3cd3e-1368">要连接的第三个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1368">The third object to concatenate.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1369">连接三个指定对象的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1369">Concatenates the string representations of three specified objects.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1370"><paramref name="arg0" />、<paramref name="arg1" /> 和 <paramref name="arg2" /> 的值的串联字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1370">The concatenated string representations of the values of <paramref name="arg0" />, <paramref name="arg1" />, and <paramref name="arg2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1371">方法 `arg0` `arg1` `arg2` 通过调用每个对象的无参数方法连接、和，而 `ToString` 不添加任何分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1371">The method concatenates `arg0`, `arg1`, and `arg2` by calling the parameterless `ToString` method of each object; it does not add any delimiters.</span></span>

 <span data-ttu-id="3cd3e-1372"><xref:System.String.Empty?displayProperty=nameWithType> 用于替代任何空参数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1372"><xref:System.String.Empty?displayProperty=nameWithType> is used in place of any null argument.</span></span>



## Examples
 <span data-ttu-id="3cd3e-1373">下面的示例演示 <xref:System.String.Concat%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1373">The following example demonstrates the <xref:System.String.Concat%2A> method.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string? Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1, valuetype System.ReadOnlySpan`1&lt;char&gt; str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char), str2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="str2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="str0"><span data-ttu-id="3cd3e-1374">要连接的第一个只读字符范围。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1374">The first read-only character span to concatenate.</span></span></param>
        <param name="str1"><span data-ttu-id="3cd3e-1375">要连接的第二个只读字符范围。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1375">The second read-only character span to concatenate.</span></span></param>
        <param name="str2"><span data-ttu-id="3cd3e-1376">要连接的第三个只读字符范围。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1376">The third read-only character span to concatenate.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1377">连接三个指定的只读字符范围的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1377">Concatenates the string representations of three specified read-only character spans.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1378"><paramref name="str0" />、<paramref name="str1" /> 和 <paramref name="str2" /> 的值的已连接字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1378">The concatenated string representations of the values of <paramref name="str0" />, <paramref name="str1" /> and <paramref name="str2" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberSignature Language="C#" Value="public static string? Concat (string str0, string str1, string str2);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0"><span data-ttu-id="3cd3e-1379">要串联的第一个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1379">The first string to concatenate.</span></span></param>
        <param name="str1"><span data-ttu-id="3cd3e-1380">要串联的第二个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1380">The second string to concatenate.</span></span></param>
        <param name="str2"><span data-ttu-id="3cd3e-1381">要比较的第三个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1381">The third string to concatenate.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1382">连接 <see cref="T:System.String" /> 的三个指定实例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1382">Concatenates three specified instances of <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1383"><paramref name="str0" />、<paramref name="str1" /> 和 <paramref name="str2" /> 的串联。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1383">The concatenation of <paramref name="str0" />, <paramref name="str1" />, and <paramref name="str2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1384">方法连接 `str0` 、和，而 `str1` `str2` 不添加任何分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1384">The method concatenates `str0`, `str1`, and `str2`; it does not add any delimiters.</span></span>

## Examples
 <span data-ttu-id="3cd3e-1385">下面的示例使用 <xref:System.String.Concat%2A> 方法连接三个字符串并显示结果。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1385">The following example uses the <xref:System.String.Concat%2A> method to concatenate three strings and displays the result.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp" id="Snippet6":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs" interactive="try-dotnet" id="Snippet6":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb" id="Snippet6":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg3" Type="System.Object" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="3cd3e-1386">要连接的第一个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1386">The first object to concatenate.</span></span></param>
        <param name="arg1"><span data-ttu-id="3cd3e-1387">要连接的第二个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1387">The second object to concatenate.</span></span></param>
        <param name="arg2"><span data-ttu-id="3cd3e-1388">要连接的第三个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1388">The third object to concatenate.</span></span></param>
        <param name="arg3"><span data-ttu-id="3cd3e-1389">要连接的第四个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1389">The fourth object to concatenate.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1390">将四个指定对象的字符串表示形式与可选变量长度参数列表中指定的任何对象串联起来。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1390">Concatenates the string representations of four specified objects and any objects specified in an optional variable length parameter list.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1391">参数列表中的每个值的连接字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1391">The concatenated string representation of each value in the parameter list.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
>  <span data-ttu-id="3cd3e-1392">此 API 不符合 CLS。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1392">This API is not CLS-compliant.</span></span> <span data-ttu-id="3cd3e-1393">符合 CLS 的替代方法是 <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1393">The CLS-compliant alternative is <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3cd3e-1394">C # 和 Visual Basic 编译器会自动将对此方法的调用解析为对的调用 <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1394">The C# and Visual Basic compilers automatically resolve a call to this method as a call to <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="3cd3e-1395">方法通过调用其无参数方法连接参数列表中的每个对象，而不 `ToString` 会添加任何分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1395">The method concatenates each object in the parameter list by calling its parameterless `ToString` method; it does not add any delimiters.</span></span>

 <span data-ttu-id="3cd3e-1396"><xref:System.String.Empty?displayProperty=nameWithType> 用于替代任何空参数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1396"><xref:System.String.Empty?displayProperty=nameWithType> is used in place of any null argument.</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-1397">方法的最后一个参数  <xref:System.String.Concat%2A> 是要连接的一个或多个附加对象的以逗号分隔的可选列表。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1397">The last parameter of the  <xref:System.String.Concat%2A> method is an optional comma-delimited list of one or more additional objects to concatenate.</span></span>



## Examples
 <span data-ttu-id="3cd3e-1398">下面的示例演示 <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> 如何使用方法连接变量参数的列表。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1398">The following example illustrates the use of the <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> method to concatenate a list of variable parameters.</span></span> <span data-ttu-id="3cd3e-1399">在这种情况下，将调用方法并带有九个参数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1399">In this case, the method is called with nine parameters.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-1400">此方法使用关键字进行标记 <see langword="vararg" /> ，这意味着它支持数量可变的参数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1400">This method is marked with the <see langword="vararg" /> keyword, which means that it supports a variable number of parameters.</span></span> <span data-ttu-id="3cd3e-1401">可以从 Visual C++ 调用方法，但不能从 c # 或 Visual Basic 代码中调用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1401">The method can be called from Visual C++, but it cannot be called from C# or Visual Basic code.</span></span> <span data-ttu-id="3cd3e-1402">C # 和 Visual Basic 编译器将调用解析为对的调用 <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> <see cref="M:System.String.Concat(System.Object[])" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1402">The C# and Visual Basic compilers resolve calls to <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> as calls to <see cref="M:System.String.Concat(System.Object[])" />.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string? Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2, ReadOnlySpan&lt;char&gt; str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1, valuetype System.ReadOnlySpan`1&lt;char&gt; str2, valuetype System.ReadOnlySpan`1&lt;char&gt; str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char), str2 As ReadOnlySpan(Of Char), str3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2, ReadOnlySpan&lt;char&gt; str3);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="str2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="str3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="str0"><span data-ttu-id="3cd3e-1403">要连接的第一个只读字符范围。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1403">The first read-only character span to concatenate.</span></span></param>
        <param name="str1"><span data-ttu-id="3cd3e-1404">要连接的第二个只读字符范围。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1404">The second read-only character span to concatenate.</span></span></param>
        <param name="str2"><span data-ttu-id="3cd3e-1405">要连接的第三个只读字符范围。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1405">The third read-only character span to concatenate.</span></span></param>
        <param name="str3"><span data-ttu-id="3cd3e-1406">要连接的第四个只读字符范围。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1406">The fourth read-only character span to concatenate.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1407">连接四个指定的只读字符范围的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1407">Concatenates the string representations of four specified read-only character spans.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1408"><paramref name="str0" />、<paramref name="str1" />、<paramref name="str2" /> 和 <paramref name="str3" /> 的值的已连接字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1408">The concatenated string representations of the values of <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" /> and <paramref name="str3" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String, str3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2, System::String ^ str3);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberSignature Language="C#" Value="public static string? Concat (string str0, string str1, string str2, string str3);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0"><span data-ttu-id="3cd3e-1409">要串联的第一个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1409">The first string to concatenate.</span></span></param>
        <param name="str1"><span data-ttu-id="3cd3e-1410">要串联的第二个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1410">The second string to concatenate.</span></span></param>
        <param name="str2"><span data-ttu-id="3cd3e-1411">要比较的第三个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1411">The third string to concatenate.</span></span></param>
        <param name="str3"><span data-ttu-id="3cd3e-1412">要比较的第四个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1412">The fourth string to concatenate.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1413">连接 <see cref="T:System.String" /> 的四个指定实例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1413">Concatenates four specified instances of <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1414"><paramref name="str0" />、<paramref name="str1" />、<paramref name="str2" /> 和 <paramref name="str3" /> 的串联。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1414">The concatenation of <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" />, and <paramref name="str3" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1415">方法会连接 `str0` 、 `str1` 、 `str2` 和， `str3` 但不会添加任何分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1415">The method concatenates `str0`, `str1`, `str2`, and `str3`; it does not add any delimiters.</span></span>

## Examples
 <span data-ttu-id="3cd3e-1416">下面的示例定义一个包含四个字母的单词的数组，并将其各个字母存储到字符串数组中，以便对它们进行编码。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1416">The following example defines an array of four-letter words and stores their individual letters to a string array in order to scramble them.</span></span> <span data-ttu-id="3cd3e-1417">然后，它会调用 <xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> 方法来重新组合打乱的单词。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1417">It then calls the <xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> method to reassemble the scrambled words.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat(Of T) (values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;'T&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3cd3e-1418"><paramref name="values" /> 成员的类型。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1418">The type of the members of <paramref name="values" />.</span></span></typeparam>
        <param name="values"><span data-ttu-id="3cd3e-1419">一个实现 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 接口的集合对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1419">A collection object that implements the <see cref="T:System.Collections.Generic.IEnumerable`1" /> interface.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1420">串联 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 实现的成员。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1420">Concatenates the members of an <see cref="T:System.Collections.Generic.IEnumerable`1" /> implementation.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1421"><paramref name="values" /> 中的串联成员。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1421">The concatenated members in <paramref name="values" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1422">此方法连接中的每个对象 `values` ; 它不添加任何分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1422">The method concatenates each object in `values`; it does not add any delimiters.</span></span>

 <span data-ttu-id="3cd3e-1423"><xref:System.String.Empty?displayProperty=nameWithtype>字符串用于替代任何空参数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1423">An <xref:System.String.Empty?displayProperty=nameWithtype> string is used in place of any null argument.</span></span>

 <span data-ttu-id="3cd3e-1424"><xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> 是一种简便方法，使您可以连接集合中的每个元素， <xref:System.Collections.Generic.IEnumerable%601> 而无需先将元素转换为字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1424"><xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> is a convenience method that lets you concatenate each element in an <xref:System.Collections.Generic.IEnumerable%601> collection without first converting the elements to strings.</span></span> <span data-ttu-id="3cd3e-1425">如示例所示，它对于 Language-Integrated 查询 (LINQ) 查询表达式特别有用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1425">It is particularly useful with Language-Integrated Query (LINQ) query expressions, as the example illustrates.</span></span> <span data-ttu-id="3cd3e-1426">集合中每个对象的字符串表示形式 <xref:System.Collections.Generic.IEnumerable%601> 都是通过调用该对象的 `ToString` 方法派生的。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1426">The string representation of each object in the <xref:System.Collections.Generic.IEnumerable%601> collection is derived by calling that object's `ToString` method.</span></span>



## Examples
 <span data-ttu-id="3cd3e-1427">下面的示例定义了一个非常简单的 `Animal` 类，其中包含动物的名称及其所属的顺序。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1427">The following example defines a very simple `Animal` class that contains the name of an animal and the order to which it belongs.</span></span> <span data-ttu-id="3cd3e-1428">然后，它定义一个 <xref:System.Collections.Generic.List%601> 对象，该对象包含多个 `Animal` 对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1428">It then defines a <xref:System.Collections.Generic.List%601> object to contain a number of `Animal` objects.</span></span> <span data-ttu-id="3cd3e-1429"><xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>调用扩展方法以提取 `Animal` 其 `Order` 属性等于 "啮齿类" 的对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1429">The <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> extension method is called to extract the `Animal` objects whose `Order` property equals "Rodent".</span></span> <span data-ttu-id="3cd3e-1430">结果传递给 <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> 方法并显示到控制台。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1430">The result is passed to the <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> method and displayed to the console.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs" interactive="try-dotnet" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb" id="Snippet4":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-1431"><paramref name="values" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1431"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value);" />
      <MemberSignature Language="F#" Value="member this.Contains : char -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-1432">要查找的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1432">The character to seek.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1433">返回一个值，该值指示指定的字符是否出现在此字符串中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1433">Returns a value indicating whether a specified character occurs within this string.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1434">如果 <paramref name="value" /> 参数在此字符串中出现，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1434"><see langword="true" /> if the <paramref name="value" /> parameter occurs within this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1435">此方法执行 (区分大小写和不区分区域性的) 比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1435">This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Contains : string -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-1436">要搜寻的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1436">The string to seek.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1437">返回一个值，该值指示指定的子串是否出现在此字符串中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1437">Returns a value indicating whether a specified substring occurs within this string.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1438">如果 <see langword="true" /> 参数出现在此字符串中，或者 <paramref name="value" /> 为空字符串 ("")，则为 <paramref name="value" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1438"><see langword="true" /> if the <paramref name="value" /> parameter occurs within this string, or if <paramref name="value" /> is the empty string (""); otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1439">此方法执行 (区分大小写和不区分区域性的) 比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1439">This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span> <span data-ttu-id="3cd3e-1440">搜索从该字符串的第一个字符位置开始，并继续到最后一个字符的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1440">The search begins at the first character position of this string and continues through the last character position.</span></span>

 <span data-ttu-id="3cd3e-1441">**仅 .NET Framework**：若要通过使用序号 (比较以外的其他内容（如区分区域性的比较）或不区分大小写的序号比较) 来确定字符串是否包含指定的子字符串，可以创建自定义方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1441">**.NET Framework only**: To determine whether a string contains a specified substring by using something other than ordinal comparison (such as culture-sensitive comparison, or ordinal case-insensitive comparison), you can create a custom method.</span></span> <span data-ttu-id="3cd3e-1442">下面的示例阐释了这种方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1442">The following example illustrates one such approach.</span></span> <span data-ttu-id="3cd3e-1443">它定义了一个 <xref:System.String> 扩展方法，该方法包含一个 <xref:System.StringComparison> 参数，并指示当使用指定的字符串比较形式时，字符串是否包含子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1443">It defines a <xref:System.String> extension method  that includes a <xref:System.StringComparison> parameter and indicates whether a string contains a substring when using the specified form of string comparison.</span></span>

 [!code-csharp[System.String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)]
 [!code-vb[System.String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)]

 <span data-ttu-id="3cd3e-1444">下面的示例在 `Contains` 使用序号比较和不区分大小写的序号比较时调用扩展方法来确定字符串中是否找到了子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1444">The following example then calls the `Contains` extension method to determine whether a substring is found in a string when using ordinal comparison and case-insensitive ordinal comparison.</span></span>

 [!code-csharp[System.String.Contains#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]

 <span data-ttu-id="3cd3e-1445">如果对子字符串 `value` 在当前实例中的位置感兴趣，则可以调用 <xref:System.String.IndexOf%2A> 方法来获取其第一次出现的起始位置，也可以调用 <xref:System.String.LastIndexOf%2A> 方法来获取其最后一个匹配项的起始位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1445">If you are interested in the position of the substring `value` in the current instance, you can call the <xref:System.String.IndexOf%2A> method to get the starting position of its first occurrence, or you can call the <xref:System.String.LastIndexOf%2A> method to get the starting position of its last occurrence.</span></span> <span data-ttu-id="3cd3e-1446"><xref:System.String.IndexOf%28System.String%29>如果在字符串实例中找到子字符串，则该示例包括对方法的调用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1446">The example includes a call to the <xref:System.String.IndexOf%28System.String%29> method if a substring is found in a string instance.</span></span>



## Examples
 <span data-ttu-id="3cd3e-1447">下面的示例确定字符串 "fox" 是否为熟悉的引号的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1447">The following example determines whether the string "fox" is a substring of a familiar quotation.</span></span> <span data-ttu-id="3cd3e-1448">如果在字符串中找到 "fox"，则它还会显示其起始位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1448">If "fox" is found in the string, it also displays its starting position.</span></span>

 [!code-cpp[String.Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp-interactive[String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-1449"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1449"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : char * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-1450">要查找的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1450">The character to seek.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="3cd3e-1451">一个枚举值，用于指定比较中要使用的规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1451">One of the enumeration values that specifies the rules to use in the comparison.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1452">使用指定的比较规则返回一个值，该值指示指定的字符是否出现在此字符串中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1452">Returns a value indicating whether a specified character occurs within this string, using the specified comparison rules.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1453">如果 <paramref name="value" /> 参数在此字符串中出现，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1453"><see langword="true" /> if the <paramref name="value" /> parameter occurs within this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : string * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-1454">要搜寻的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1454">The string to seek.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="3cd3e-1455">一个枚举值，用于指定比较中要使用的规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1455">One of the enumeration values that specifies the rules to use in the comparison.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1456">使用指定的比较规则返回一个值，该值指示指定的字符串是否出现在此字符串中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1456">Returns a value indicating whether a specified string occurs within this string, using the specified comparison rules.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1457">如果 <see langword="true" /> 参数出现在此字符串中，或者 <paramref name="value" /> 为空字符串 ("")，则为 <paramref name="value" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1457"><see langword="true" /> if the <paramref name="value" /> parameter occurs within this string, or if <paramref name="value" /> is the empty string (""); otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Copy (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Copy(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Copy : string -&gt; string" Usage="System.string.Copy str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1">
          <AttributeName Language="C#">[System.Obsolete("This API should not be used to create mutable strings. See https://go.microsoft.com/fwlink/?linkid=2084035 for alternatives.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("This API should not be used to create mutable strings. See https://go.microsoft.com/fwlink/?linkid=2084035 for alternatives.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="str"><span data-ttu-id="3cd3e-1458">要复制的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1458">The string to copy.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1459">创建一个与指定的 <see cref="T:System.String" /> 具有相同值的 <see cref="T:System.String" /> 的新实例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1459">Creates a new instance of <see cref="T:System.String" /> with the same value as a specified <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1460">值与 <paramref name="str" /> 相同的新字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1460">A new string with the same value as <paramref name="str" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3cd3e-1461">`Copy`方法返回一个 <xref:System.String> 对象，该对象与原始字符串具有相同的值，但表示不同的对象引用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1461">The `Copy` method returns a <xref:System.String> object that has the same value as the original string but represents a different object reference.</span></span> <span data-ttu-id="3cd3e-1462">这不同于赋值操作，后者将现有字符串引用分配给其他对象变量。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1462">It differs from an assignment operation, which assigns an existing string reference to an additional object variable.</span></span>

> [!IMPORTANT]
>  <span data-ttu-id="3cd3e-1463">从 .NET Core 3.0 开始，此方法已过时。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1463">Starting with .NET Core 3.0, this method is obsolete.</span></span> <span data-ttu-id="3cd3e-1464">但是，我们不建议在任何 .NET 实现中使用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1464">However, we do not recommend its use in any .NET implementation.</span></span> <span data-ttu-id="3cd3e-1465">特别是，由于 .NET Core 3.0 中的字符串暂存发生了更改，因此，在某些情况下，该 `Copy` 方法将不会创建新的字符串，而只会返回对现有暂存字符串的引用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1465">In particular, because of changes in string interning in .NET Core 3.0, in some cases the `Copy` method will not create a new string but will simply return a reference to an existing interned string.</span></span>

<span data-ttu-id="3cd3e-1466">根据要调用方法的原因 `Copy` ，有多种方法可供选择：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1466">Depending on Why you want to call the `Copy` method, there are a number of alternatives:</span></span>

- <span data-ttu-id="3cd3e-1467">如果希望在修改字符串的操作中使用不同的字符串实例，请使用原始字符串实例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1467">If you want a different string instance to use in an operation that modifies the string, use the original string instance.</span></span> <span data-ttu-id="3cd3e-1468">因为字符串是不可变的，所以字符串操作会创建一个新的字符串实例，而原始字符串不受影响。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1468">Because strings are immutable, the string operation creates a new string instance, and the original string remains unaffected.</span></span> <span data-ttu-id="3cd3e-1469">在这种情况下，不应将新字符串引用分配给原始字符串变量。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1469">In this case, you should not assign the new string reference to the original string variable.</span></span> <span data-ttu-id="3cd3e-1470">下面的示例进行了这方面的演示。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1470">The following example provides an illustration.</span></span>

  [!code-csharp[Performing a string operation](~/samples/snippets/csharp/api/system/string/copy/program.cs#1)]
  [!code-vb[Performing a string operation](~/samples/snippets/visualbasic/api/system/string/copy/program.vb#1)]

   <span data-ttu-id="3cd3e-1471">在这种情况下，在 `Copy` 调用方法之前调用方法以创建新字符串会 <xref:System.String.Substring%2A> 创建一个新的字符串实例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1471">In this case, calling the `Copy` method to create a new string before calling the <xref:System.String.Substring%2A> method unnecessarily creates a new string instance.</span></span>

- <span data-ttu-id="3cd3e-1472">如果要创建具有与原始字符串相同的内容的可变缓冲区，请调用 <xref:System.String.ToCharArray%2A?displayProperty=nameWithType> 或 <xref:System.Text.StringBuilder.%23ctor(System.String)?displayProperty=nameWithType> 构造函数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1472">If you want to create a mutable buffer with the same contents as the original string, call the <xref:System.String.ToCharArray%2A?displayProperty=nameWithType> or <xref:System.Text.StringBuilder.%23ctor(System.String)?displayProperty=nameWithType> constructor.</span></span> <span data-ttu-id="3cd3e-1473">例如：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1473">For example:</span></span>

  [!code-csharp[Performing a string operation](~/samples/snippets/csharp/api/system/string/copy/program.cs#2)]
  [!code-vb[Performing a string operation](~/samples/snippets/visualbasic/api/system/string/copy/program.vb#2)]

- <span data-ttu-id="3cd3e-1474">如果要创建字符串的可变副本以便可以使用不安全代码修改字符串内容，请使用 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1474">If you want to create a mutable copy of the string so that you can use unsafe code to modify the string contents, use <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3cd3e-1475">下面的示例使用 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> 方法获取指向非托管内存中复制字符串的位置的指针，将字符串中每个字符的 Unicode 码位递增一，并将生成的字符串复制回托管字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1475">The following example uses the <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> method to get a pointer to the location of an copied string in unmanaged memory, increments the Unicode code point of each character in the string by one, and copies the resulting string back to a managed string.</span></span>

  [!code-csharp[Performing a string operation](~/samples/snippets/csharp/api/system/string/copy/program.cs#3)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-1476"><paramref name="str" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1476"><paramref name="str" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="string.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex"><span data-ttu-id="3cd3e-1477">要复制的此实例中第一个字符的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1477">The index of the first character in this instance to copy.</span></span></param>
        <param name="destination"><span data-ttu-id="3cd3e-1478">此实例中的字符所复制到的 Unicode 字符数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1478">An array of Unicode characters to which characters in this instance are copied.</span></span></param>
        <param name="destinationIndex"><span data-ttu-id="3cd3e-1479"><paramref name="destination" /> 中的索引，在此处开始复制操作。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1479">The index in <paramref name="destination" /> at which the copy operation begins.</span></span></param>
        <param name="count"><span data-ttu-id="3cd3e-1480">此实例中要复制到 <paramref name="destination" /> 的字符数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1480">The number of characters in this instance to copy to <paramref name="destination" />.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1481">将指定数目的字符从此实例中的指定位置复制到 Unicode 字符数组中的指定位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1481">Copies a specified number of characters from a specified position in this instance to a specified position in an array of Unicode characters.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1482">此方法将 `count` 字符从此 `sourceIndex` 实例的位置复制到 `destinationIndex` 字符数组的位置 `destination` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1482">This method copies `count` characters from the `sourceIndex` position of this instance to the `destinationIndex` position of `destination` character array.</span></span> <span data-ttu-id="3cd3e-1483">此方法不调整 `destination` 字符数组的大小; 它必须具有足够数量的元素来容纳复制的字符或方法引发 <xref:System.ArgumentOutOfRangeException> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1483">This method does not resize the `destination` character array; it must have a sufficient number of elements to accommodate the copied characters or the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span>

 <span data-ttu-id="3cd3e-1484">`sourceIndex` 和 `destinationIndex` 是从零开始的。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1484">`sourceIndex` and `destinationIndex` are zero-based.</span></span>



## Examples
 <span data-ttu-id="3cd3e-1485">下面的示例演示 <xref:System.String.CopyTo%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1485">The following example demonstrates the <xref:System.String.CopyTo%2A> method.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-1486"><paramref name="destination" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1486"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-1487"><paramref name="sourceIndex" />、<paramref name="destinationIndex" /> 或 <paramref name="count" /> 为负</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1487"><paramref name="sourceIndex" />, <paramref name="destinationIndex" />, or <paramref name="count" /> is negative</span></span>

<span data-ttu-id="3cd3e-1488">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1488">-or-</span></span>

 <span data-ttu-id="3cd3e-1489"><paramref name="sourceIndex" /> 不标识当前实例中的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1489"><paramref name="sourceIndex" /> does not identify a position in the current instance.</span></span>

<span data-ttu-id="3cd3e-1490">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1490">-or-</span></span>

 <span data-ttu-id="3cd3e-1491"><paramref name="destinationIndex" /> 不标识 <paramref name="destination" /> 数组中的有效索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1491"><paramref name="destinationIndex" /> does not identify a valid index in the <paramref name="destination" /> array.</span></span>

<span data-ttu-id="3cd3e-1492">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1492">-or-</span></span>

 <span data-ttu-id="3cd3e-1493"><paramref name="count" /> 大于从 <paramref name="sourceIndex" /> 到此实例末尾的子字符串的长度</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1493"><paramref name="count" /> is greater than the length of the substring from <paramref name="sourceIndex" /> to the end of this instance</span></span>

<span data-ttu-id="3cd3e-1494">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1494">-or-</span></span>

 <span data-ttu-id="3cd3e-1495"><paramref name="count" /> 大于从 <paramref name="destinationIndex" /> 到 <paramref name="destination" /> 数组末尾的子数组的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1495"><paramref name="count" /> is greater than the length of the subarray from <paramref name="destinationIndex" /> to the end of the <paramref name="destination" /> array.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Create&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static string Create&lt;TState&gt; (int length, TState state, System.Buffers.SpanAction&lt;char,TState&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Create&lt;TState&gt;(int32 length, !!TState state, class System.Buffers.SpanAction`2&lt;char, !!TState&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Create``1(System.Int32,``0,System.Buffers.SpanAction{System.Char,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of TState) (length As Integer, state As TState, action As SpanAction(Of Char, TState)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static System::String ^ Create(int length, TState state, System::Buffers::SpanAction&lt;char, TState&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member Create : int * 'State * System.Buffers.SpanAction&lt;char, 'State&gt; -&gt; string" Usage="System.string.Create (length, state, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="action" Type="System.Buffers.SpanAction&lt;System.Char,TState&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="TState"><span data-ttu-id="3cd3e-1496">要传递到的元素的类型 <paramref name="action" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1496">The type of the element to pass to <paramref name="action" />.</span></span></typeparam>
        <param name="length"><span data-ttu-id="3cd3e-1497">要创建的字符串的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1497">The length of the string to create.</span></span></param>
        <param name="state"><span data-ttu-id="3cd3e-1498">要传递给 <paramref name="action" /> 的元素。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1498">The element to pass to <paramref name="action" />.</span></span></param>
        <param name="action"><span data-ttu-id="3cd3e-1499">用于初始化字符串的回叫。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1499">A callback to initialize the string.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1500">创建一个具有特定长度的新字符串，并在创建后使用指定的回叫对其进行初始化。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1500">Creates a new string with a specific length and initializes it after creation by using the specified callback.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1501">创建的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1501">The created string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks
<span data-ttu-id="3cd3e-1502">传递给的目标跨度的初始内容未 `action` 定义。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1502">The initial content of the destination span passed to `action` is undefined.</span></span> <span data-ttu-id="3cd3e-1503">因此，委托负责确保已分配范围的每个元素。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1503">Therefore, it is the delegate's responsibility to ensure that every element of the span is assigned.</span></span> <span data-ttu-id="3cd3e-1504">否则，结果字符串可能包含随机字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1504">Otherwise, the resulting string could contain random characters.</span></span>
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ Empty;" />
      <MemberSignature Language="F#" Value=" staticval mutable Empty : string" Usage="System.string.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3cd3e-1505">表示空字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1505">Represents the empty string.</span></span> <span data-ttu-id="3cd3e-1506">此字段为只读。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1506">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1507">此字段的值是长度为零的字符串 ""。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1507">The value of this field is the zero-length string, "".</span></span>

 <span data-ttu-id="3cd3e-1508">在应用程序代码中，此字段最常用于赋值，以将字符串变量初始化为空字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1508">In application code, this field is most commonly used in assignments to initialize a string variable to an empty string.</span></span> <span data-ttu-id="3cd3e-1509">若要测试字符串的值是否为 `null` 或 <xref:System.String.Empty?displayProperty=nameWithType> ，请使用 <xref:System.String.IsNullOrEmpty%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1509">To test whether the value of a string is either `null` or <xref:System.String.Empty?displayProperty=nameWithType>, use the <xref:System.String.IsNullOrEmpty%2A> method.</span></span>

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="EndsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3cd3e-1510">确定此字符串实例的结尾是否与指定的字符串匹配。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1510">Determines whether the end of this string instance matches a specified string.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As Char) As Boolean" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(char value);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndsWith : char -&gt; bool" Usage="string.EndsWith value" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-1511">要与此实例末尾的字符进行比较的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1511">The character to compare to the character at the end of this instance.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1512">确定此字符串实例的结尾是否与指定的字符匹配。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1512">Determines whether the end of this string instance matches the specified character.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1513">如果 <see langword="true" /> 与此实例的末尾匹配，则为 <paramref name="value" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1513"><see langword="true" /> if <paramref name="value" /> matches the end of this instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3cd3e-1514">此方法使用当前区域性执行区分大小写和区分区域性的比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1514">This method performs a case-sensitive and culture-sensitive comparison using the current culture.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-1515">要与此实例末尾的子字符串进行比较的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1515">The string to compare to the substring at the end of this instance.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1516">确定此字符串实例的结尾是否与指定的字符串匹配。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1516">Determines whether the end of this string instance matches the specified string.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1517">如果 <see langword="true" /> 与此实例的末尾匹配，则为 <paramref name="value" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1517"><see langword="true" /> if <paramref name="value" /> matches the end of this instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1518">此方法 `value` 与此实例末尾的子字符串进行比较，其长度与相同 `value` ，并返回一个指示是否相等的指示。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1518">This method compares `value` to the substring at the end of this instance that is the same length as `value`, and returns an indication whether they are equal.</span></span> <span data-ttu-id="3cd3e-1519">若要相等， `value` 必须是对此实例的引用，或与此实例的末尾匹配。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1519">To be equal, `value` must be a reference to this same instance or match the end of this instance.</span></span>

 <span data-ttu-id="3cd3e-1520">此方法使用当前区域性执行区分大小写的 (区分大小写的) 比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1520">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span>



## Examples
 <span data-ttu-id="3cd3e-1521">下面的示例指示数组中的每个字符串是否以句点结束， ( "。) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1521">The following example indicates whether each string in an array ends with a period (".").</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb" id="Snippet1":::

 <span data-ttu-id="3cd3e-1522">下面的示例定义了一个 `StripEndTags` 方法，该方法使用 <xref:System.String.EndsWith%28System.String%29> 方法从行的末尾删除 HTML 结束标记。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1522">The following example defines a `StripEndTags` method that uses the <xref:System.String.EndsWith%28System.String%29> method to remove HTML end tags from the end of a line.</span></span> <span data-ttu-id="3cd3e-1523">请注意，将  `StripEndTags` 以递归方式调用方法，以确保删除行末尾处的多个 HTML 结束标记。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1523">Note that the  `StripEndTags` method is called recursively to ensure that multiple HTML end tags at the end of the line are removed.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-1524"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1524"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-1525">如 [使用字符串的最佳做法](/dotnet/standard/base-types/best-practices-strings)中所述，建议你避免调用替换默认值的字符串比较方法，并改为调用需要显式指定参数的方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1525">As explained in [Best Practices for Using Strings](/dotnet/standard/base-types/best-practices-strings), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="3cd3e-1526">若要通过使用当前区域性的字符串比较规则来确定某个字符串是否以特定子字符串结束，请使用 <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> 其参数的值调用方法重载 <see cref="F:System.StringComparison.CurrentCulture" /> <paramref name="comparisonType" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1526">To determine whether a string ends with a particular substring by using the string comparison rules of the current culture, call the <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="M:System.String.StartsWith(System.String)" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * StringComparison -&gt; bool" Usage="string.EndsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-1527">要与此实例末尾的子字符串进行比较的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1527">The string to compare to the substring at the end of this instance.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="3cd3e-1528">枚举值之一，用于确定如何比较此字符串与 <paramref name="value" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1528">One of the enumeration values that determines how this string and <paramref name="value" /> are compared.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1529">确定使用指定的比较选项进行比较时此字符串实例的结尾是否与指定的字符串匹配。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1529">Determines whether the end of this string instance matches the specified string when compared using the specified comparison option.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1530">如果 <see langword="true" /> 参数与此字符串的末尾匹配，则为 <paramref name="value" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1530"><see langword="true" /> if the <paramref name="value" /> parameter matches the end of this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1531"><xref:System.String.EndsWith%2A>方法将 `value` 参数与此字符串末尾的子字符串进行比较，并返回一个值，该值指示它们是否相等。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1531">The <xref:System.String.EndsWith%2A> method compares the `value` parameter to the substring at the end of this string and returns a value that indicates whether they are equal.</span></span> <span data-ttu-id="3cd3e-1532">若要相等， `value` 必须是对此同一个字符串的引用，必须为空字符串 ( "" ) ，或者必须与此字符串的末尾匹配。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1532">To be equal, `value` must be a reference to this same string, must be the empty string (""), or must match the end of this string.</span></span> <span data-ttu-id="3cd3e-1533">方法所执行的比较的类型 <xref:System.String.EndsWith%2A> 取决于参数的值 `comparisonType` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1533">The type of comparison performed by the <xref:System.String.EndsWith%2A> method depends on the value of the `comparisonType` parameter.</span></span>



## Examples
 <span data-ttu-id="3cd3e-1534">下面的示例确定字符串是否以特定子字符串结束。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1534">The following example determines whether a string ends with a particular substring.</span></span> <span data-ttu-id="3cd3e-1535">结果受区域性选择的影响，是否忽略大小写，以及是否执行序号比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1535">The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-1536"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1536"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-1537"><paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1537"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo? culture);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.EndsWith (value, ignoreCase, culture)" />
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-1538">要与此实例末尾的子字符串进行比较的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1538">The string to compare to the substring at the end of this instance.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="3cd3e-1539">若要在比较过程中忽略大小写，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1539"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <param name="culture"><span data-ttu-id="3cd3e-1540">确定如何对此实例与 <paramref name="value" /> 进行比较的区域性信息。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1540">Cultural information that determines how this instance and <paramref name="value" /> are compared.</span></span> <span data-ttu-id="3cd3e-1541">如果 <paramref name="culture" /> 为 <see langword="null" />，则使用当前区域性。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1541">If <paramref name="culture" /> is <see langword="null" />, the current culture is used.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1542">确定在使用指定的区域性进行比较时此字符串实例的结尾是否与指定的字符串匹配。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1542">Determines whether the end of this string instance matches the specified string when compared using the specified culture.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1543">如果 <see langword="true" /> 参数与此字符串的末尾匹配，则为 <paramref name="value" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1543"><see langword="true" /> if the <paramref name="value" /> parameter matches the end of this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1544">此方法将 `value` 参数与此字符串末尾与相同的子字符串进行比较 `value` ，并返回一个值，该值指示它们是否相等。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1544">This method compares the `value` parameter to the substring at the end of this string that is the same length as `value`, and returns a value that indicates whether they are equal.</span></span> <span data-ttu-id="3cd3e-1545">若要相等， `value` 必须是对此同一个实例的引用，或与此字符串的末尾匹配。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1545">To be equal, `value` must be a reference to this same instance or match the end of this string.</span></span>

 <span data-ttu-id="3cd3e-1546">此方法使用指定的大小写和区域性执行 word (区分区域性的) 比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1546">This method performs a word (culture-sensitive) comparison using the specified casing and culture.</span></span>



## Examples
 <span data-ttu-id="3cd3e-1547">下面的示例确定字符串是否出现在另一个字符串的末尾。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1547">The following example determines whether a string occurs at the end of another string.</span></span> <span data-ttu-id="3cd3e-1548"><xref:System.String.EndsWith%2A>方法使用区分大小写、不区分大小写和影响搜索结果的不同区域性多次调用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1548">The <xref:System.String.EndsWith%2A> method is called several times using case sensitivity, case insensitivity, and different cultures that influence the results of the search.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-1549"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1549"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateRunes">
      <MemberSignature Language="C#" Value="public System.Text.StringRuneEnumerator EnumerateRunes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.StringRuneEnumerator EnumerateRunes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EnumerateRunes" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateRunes () As StringRuneEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringRuneEnumerator EnumerateRunes();" />
      <MemberSignature Language="F#" Value="member this.EnumerateRunes : unit -&gt; System.Text.StringRuneEnumerator" Usage="string.EnumerateRunes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringRuneEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3cd3e-1550">从此字符串返回 <see cref="T:System.Text.Rune" /> 的枚举。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1550">Returns an enumeration of <see cref="T:System.Text.Rune" /> from this string.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1551">一个字符串 Rune 枚举器。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1551">A string rune enumerator.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

### Remarks

<span data-ttu-id="3cd3e-1552">无效的序列在枚举中表示 <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1552">Invalid sequences are represented in the enumeration by <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType>.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3cd3e-1553">确定两个 <see cref="T:System.String" /> 对象是否具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1553">Determines whether two <see cref="T:System.String" /> objects have the same value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="string.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="3cd3e-1554">要与此实例进行比较的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1554">The string to compare to this instance.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1555">确定此实例是否与指定的对象（也必须是 <see cref="T:System.String" /> 对象）具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1555">Determines whether this instance and a specified object, which must also be a <see cref="T:System.String" /> object, have the same value.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1556">如果 <see langword="true" /> 是一个 <paramref name="obj" /> 且其值与此实例相等，则为 <see cref="T:System.String" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1556"><see langword="true" /> if <paramref name="obj" /> is a <see cref="T:System.String" /> and its value is the same as this instance; otherwise, <see langword="false" />.</span></span>  <span data-ttu-id="3cd3e-1557">如果 <paramref name="obj" /> 为 <see langword="null" />，则此方法返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1557">If <paramref name="obj" /> is <see langword="null" />, the method returns <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1558">此方法执行 (区分大小写和不区分区域性的) 比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1558">This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>



## Examples
 <span data-ttu-id="3cd3e-1559">下面的示例演示 <xref:System.String.Equals%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1559">The following example demonstrates the <xref:System.String.Equals%2A> method.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::String ^ value);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.Equals : string -&gt; bool" Usage="string.Equals value" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-1560">要与此实例进行比较的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1560">The string to compare to this instance.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1561">确定此实例是否与另一个指定的 <see cref="T:System.String" /> 对象具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1561">Determines whether this instance and another specified <see cref="T:System.String" /> object have the same value.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1562">如果 <see langword="true" /> 参数的值与此实例的值相同，则为 <paramref name="value" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1562"><see langword="true" /> if the value of the <paramref name="value" /> parameter is the same as the value of this instance; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="3cd3e-1563">如果 <paramref name="value" /> 为 <see langword="null" />，则此方法返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1563">If <paramref name="value" /> is <see langword="null" />, the method returns <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1564">此方法执行 (区分大小写和不区分区域性的) 比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1564">This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>



## Examples
 <span data-ttu-id="3cd3e-1565">下面的示例演示 <xref:System.String.Equals%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1565">The following example demonstrates the <xref:System.String.Equals%2A> method.</span></span> <span data-ttu-id="3cd3e-1566">它将标题-大写字母 "File" 与等效的单词、其小写等效项、大写等效项以及包含拉丁文小写字母无点的单词（I (U + 0131) 而不是拉丁小写字母 I (U + 0069) 进行比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1566">It compares the title-cased word "File" with an equivalent word, its lowercase equivalent, its uppercase equivalent, and a word that contains LATIN SMALL LETTER DOTLESS I (U+0131) instead of LATIN SMALL LETTER I (U+0069).</span></span> <span data-ttu-id="3cd3e-1567">由于 <xref:System.String.Equals%28System.String%29> 方法执行序号比较，因此只有与相同单词的比较返回 `true` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1567">Because the <xref:System.String.Equals%28System.String%29> method performs an ordinal comparison, only the comparison with an identical word returns `true`.</span></span>

 [!code-csharp[System.String.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string -&gt; bool" Usage="System.string.Equals (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="3cd3e-1568">要比较的第一个字符串，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1568">The first string to compare, or <see langword="null" />.</span></span></param>
        <param name="b"><span data-ttu-id="3cd3e-1569">要比较的第二个字符串，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1569">The second string to compare, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1570">确定两个指定的 <see cref="T:System.String" /> 对象是否具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1570">Determines whether two specified <see cref="T:System.String" /> objects have the same value.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1571">如果 <see langword="true" /> 的值与 <paramref name="a" /> 的值相同，则为 <paramref name="b" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1571"><see langword="true" /> if the value of <paramref name="a" /> is the same as the value of <paramref name="b" />; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="3cd3e-1572">如果 <paramref name="a" /> 和 <paramref name="b" /> 均为 <see langword="null" />，此方法将返回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1572">If both <paramref name="a" /> and <paramref name="b" /> are <see langword="null" />, the method returns <see langword="true" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1573">此方法执行 (区分大小写和不区分区域性的) 比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1573">This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>



## Examples
 <span data-ttu-id="3cd3e-1574">下面的示例演示 <xref:System.String.Equals%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1574">The following example demonstrates the <xref:System.String.Equals%2A> method.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.Equals : string * StringComparison -&gt; bool" Usage="string.Equals (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-1575">要与此实例进行比较的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1575">The string to compare to this instance.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="3cd3e-1576">枚举值之一，用于指定如何比较字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1576">One of the enumeration values that specifies how the strings will be compared.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1577">确定此字符串是否与另一个指定的 <see cref="T:System.String" /> 对象具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1577">Determines whether this string and a specified <see cref="T:System.String" /> object have the same value.</span></span> <span data-ttu-id="3cd3e-1578">参数指定区域性、大小写以及比较所用的排序规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1578">A parameter specifies the culture, case, and sort rules used in the comparison.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1579">如果 <see langword="true" /> 参数的值与此字符串相同，则为 <paramref name="value" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1579"><see langword="true" /> if the value of the <paramref name="value" /> parameter is the same as this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1580">`comparisonType`参数指示比较是否应使用当前或固定的区域性，以服从或忽略所比较的两个字符串的大小写，或使用 word 或序号排序规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1580">The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.</span></span>



## Examples
 <span data-ttu-id="3cd3e-1581">下面的示例创建一个字符串数组，该数组由大写的 "I"、小写 "i" 和无点 "ı" 组成。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1581">The following example creates a string array that consists of an uppercase "I", a lowercase "i", and a dotless "ı".</span></span> <span data-ttu-id="3cd3e-1582">然后，它调用 <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> 方法，通过使用每个可能的枚举值对它们进行比较 <xref:System.StringComparison> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1582">It then calls the <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> method to compare them by using each possible <xref:System.StringComparison> enumeration value.</span></span>

 [!code-csharp[System.String.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]

 <span data-ttu-id="3cd3e-1583">下面的示例通过使用枚举的每个成员来比较四组单词 <xref:System.StringComparison> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1583">The following example compares four sets of words by using each member of the <xref:System.StringComparison> enumeration.</span></span>  <span data-ttu-id="3cd3e-1584">这种比较使用英语 (美国) 和萨米语 (高瑞典) 文化的约定。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1584">The comparisons use the conventions of the English (United States) and Sami (Upper Sweden) cultures.</span></span> <span data-ttu-id="3cd3e-1585">请注意，在 en-us 区域性中，字符串 "encyclopædia" 和 "encyclopaedia" 被视为等效，而不是在北瑞典 (北瑞典) 文化中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1585">Note that the strings "encyclopædia" and "encyclopaedia" are considered equivalent in the en-US culture but not in the Sami (Northern Sweden) culture.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs" interactive="try-dotnet" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb" id="Snippet4":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-1586"><paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1586"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string * StringComparison -&gt; bool" Usage="System.string.Equals (a, b, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="b" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="3cd3e-1587">要比较的第一个字符串，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1587">The first string to compare, or <see langword="null" />.</span></span></param>
        <param name="b"><span data-ttu-id="3cd3e-1588">要比较的第二个字符串，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1588">The second string to compare, or <see langword="null" />.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="3cd3e-1589">枚举值之一，用于指定比较的规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1589">One of the enumeration values that specifies the rules for the comparison.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1590">确定两个指定的 <see cref="T:System.String" /> 对象是否具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1590">Determines whether two specified <see cref="T:System.String" /> objects have the same value.</span></span> <span data-ttu-id="3cd3e-1591">参数指定区域性、大小写以及比较所用的排序规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1591">A parameter specifies the culture, case, and sort rules used in the comparison.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1592">如果 <see langword="true" /> 参数的值与 <paramref name="a" /> 参数的值相同，则为 <paramref name="b" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1592"><see langword="true" /> if the value of the <paramref name="a" /> parameter is equal to the value of the <paramref name="b" /> parameter; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1593">`comparisonType`参数指示比较是否应使用当前或固定的区域性，以服从或忽略所比较的两个字符串的大小写，或使用 word 或序号排序规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1593">The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.</span></span>



## Examples
 <span data-ttu-id="3cd3e-1594">下面的示例通过使用枚举的每个成员来比较四组单词 <xref:System.StringComparison> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1594">The following example compares four sets of words by using each member of the <xref:System.StringComparison> enumeration.</span></span>  <span data-ttu-id="3cd3e-1595">这种比较使用英语 (美国) 和萨米语 (高瑞典) 文化的约定。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1595">The comparisons use the conventions of the English (United States) and Sami (Upper Sweden) cultures.</span></span> <span data-ttu-id="3cd3e-1596">请注意，在 en-us 区域性中，字符串 "encyclopædia" 和 "encyclopaedia" 被视为等效，而不是在北瑞典 (北瑞典) 文化中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1596">Note that the strings "encyclopædia" and "encyclopaedia" are considered equivalent in the en-US culture but not in the Sami (Northern Sweden) culture.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb" id="Snippet3":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-1597"><paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1597"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3cd3e-1598">将对象的值转换为基于指定格式的字符串，并将其插入到另一个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1598">Converts the value of objects to strings based on the formats specified and inserts them into another string.</span></span>

<span data-ttu-id="3cd3e-1599">如果不熟悉 `String.Format` 方法，请参阅 [String.Format 方法入门](#Starting)一节来进行快速了解。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1599">If you are new to the `String.Format` method, see the [Get started with the String.Format method](#Starting) section for a quick overview.</span></span>

<span data-ttu-id="3cd3e-1600">有关 `String.Format` 方法的常规文档，请参阅[备注](#remarks-top)部分。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1600">See the [Remarks](#remarks-top) section for general documentation for the `String.Format` method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

<a name="remarks-top"></a>
## Remarks

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)]

 <span data-ttu-id="3cd3e-1601">本部分内容：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1601">In this section:</span></span>

 <span data-ttu-id="3cd3e-1602">[开始处理字符串。格式方法](#Starting)[我要调用哪个方法？](#FTaskList)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1602">[Get started with the String.Format method](#Starting) [Which method do I call?](#FTaskList)</span></span>
 <span data-ttu-id="3cd3e-1603">[格式方法 brief Brief](#Format_Brief) [格式项](#FormatItem)[如何设置参数](#HowFormatted)的格式设置[格式项具有相同的索引](#SameIndex)[格式设置和区域性](#Format_Culture)[自定义格式设置操作](#Format_Custom)[字符串。格式 Q &](#QA)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1603">[The Format method in brief](#Format_Brief) [The Format item](#FormatItem) [How arguments are formatted](#HowFormatted) [Format items that have the same index](#SameIndex) [Formatting and culture](#Format_Culture) [Custom formatting operations](#Format_Custom) [String.Format Q & A](#QA)</span></span>

<a name="Starting"></a>
## <a name="get-started-with-the-stringformat-method"></a><span data-ttu-id="3cd3e-1604">开始处理字符串. 格式方法</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1604">Get started with the String.Format method</span></span>
 <span data-ttu-id="3cd3e-1605"><xref:System.String.Format%2A?displayProperty=nameWithType>如果需要将对象、变量或表达式的值插入到另一个字符串，请使用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1605">Use <xref:System.String.Format%2A?displayProperty=nameWithType> if you need to insert the value of an object, variable, or expression into another string.</span></span> <span data-ttu-id="3cd3e-1606">例如，可以将值的值插入 <xref:System.Decimal> 字符串中，以单个字符串的形式向用户显示该值：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1606">For example, you can insert the value of a <xref:System.Decimal> value into a string to display it to the user as a single string:</span></span>

 [!code-cpp[System.String.Format#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp-interactive[System.String.Format#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]

 <span data-ttu-id="3cd3e-1607">您可以控制该值的格式：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1607">And you can control that value's formatting:</span></span>

 [!code-cpp[System.String.Format#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp[System.String.Format#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]

 <span data-ttu-id="3cd3e-1608">除了格式设置，还可以控制对齐方式和间距。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1608">Besides formatting, you can also control alignment and spacing.</span></span>

 ### <a name="insert-a-string"></a><span data-ttu-id="3cd3e-1609">插入字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1609">Insert a string</span></span>

 <span data-ttu-id="3cd3e-1610"><xref:System.String.Format%2A?displayProperty=nameWithType> 以格式字符串开头，后跟一个或多个将转换为字符串并在格式字符串中的指定位置插入的对象或表达式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1610"><xref:System.String.Format%2A?displayProperty=nameWithType> starts with a format string, followed by one or more objects or expressions that will be converted to strings and inserted at a specified place in the format string.</span></span> <span data-ttu-id="3cd3e-1611">例如：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1611">For example:</span></span>

 [!code-cpp[System.String.Format#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp-interactive[System.String.Format#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]

 <span data-ttu-id="3cd3e-1612">`{0}`格式字符串中的是格式项。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1612">The `{0}` in the format string is a format item.</span></span> <span data-ttu-id="3cd3e-1613">`0` 对象的索引，该对象的字符串值将在该位置插入。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1613">`0` is the index of the object whose string value will be inserted at that position.</span></span> <span data-ttu-id="3cd3e-1614"> (索引从0开始 ) 。如果要插入的对象不是字符串，则调用它的方法将其 `ToString` 转换为一个字符串，然后再将其插入到结果字符串中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1614">(Indexes start at 0.) If the object to be inserted is not a string, its `ToString` method is called to convert it to one before inserting it in the result string.</span></span>

 <span data-ttu-id="3cd3e-1615">下面是使用两个格式项和对象列表中的两个对象的另一个示例：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1615">Here's another example that uses two format items and two objects in the object list:</span></span>

 [!code-cpp[System.String.Format#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp[System.String.Format#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]

 <span data-ttu-id="3cd3e-1616">只要每个格式项的索引在对象列表中都有匹配的对象，就可以拥有任意数量的格式项以及对象列表中的任意多个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1616">You can have as many format items and as many objects in the object list as you want, as long as the index of every format item has a matching object in the object list.</span></span> <span data-ttu-id="3cd3e-1617">您也不必担心您调用的是哪个重载;编译器将为您选择合适的一个。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1617">You also don't have to worry about which overload you call; the compiler will select the appropriate one for you.</span></span>

 ### <a name="control-formatting"></a><span data-ttu-id="3cd3e-1618">控件格式设置</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1618">Control formatting</span></span>
 <span data-ttu-id="3cd3e-1619">可以在格式项中的索引后跟格式字符串，以控制如何设置对象的格式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1619">You can follow the index in a format item with a format string to control how an object is formatted.</span></span> <span data-ttu-id="3cd3e-1620">例如， `{0:d}` 将 "d" 格式字符串应用于对象列表中的第一个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1620">For example, `{0:d}` applies the "d" format string to the first object in the object list.</span></span> <span data-ttu-id="3cd3e-1621">下面是一个包含单个对象和两个格式项的示例：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1621">Here is an example with a single object and two format items:</span></span>

 [!code-cpp[System.String.Format#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp[System.String.Format#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]

 <span data-ttu-id="3cd3e-1622">许多类型都支持格式字符串，其中[包括标准和](/dotnet/standard/base-types/standard-numeric-format-strings)[自](/dotnet/standard/base-types/custom-numeric-format-strings)定义格式字符串 (的所有数字类型) [、标准和](/dotnet/standard/base-types/standard-date-and-time-format-strings)自[定义格式字符串](/dotnet/standard/base-types/custom-date-and-time-format-strings))  (的所有日期和时间均[为标准和](/dotnet/standard/base-types/standard-timespan-format-strings)自[定义](/dotnet/standard/base-types/custom-timespan-format-strings)格式字符串 (、所有枚举类型[枚举类型](/dotnet/standard/base-types/enumeration-format-strings)以及[guid](xref:System.Guid.ToString(System.String))。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1622">A number of types support format strings, including all numeric types (both [standard](/dotnet/standard/base-types/standard-numeric-format-strings) and [custom](/dotnet/standard/base-types/custom-numeric-format-strings) format strings), all dates and times (both [standard](/dotnet/standard/base-types/standard-date-and-time-format-strings) and [custom](/dotnet/standard/base-types/custom-date-and-time-format-strings) format strings) and time intervals (both [standard](/dotnet/standard/base-types/standard-timespan-format-strings) and [custom](/dotnet/standard/base-types/custom-timespan-format-strings) format strings), all enumeration types [enumeration types](/dotnet/standard/base-types/enumeration-format-strings), and [GUIDs](xref:System.Guid.ToString(System.String)).</span></span> <span data-ttu-id="3cd3e-1623">您还可以将对格式字符串的支持添加到您自己的类型中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1623">You can also add support for format strings to your own types.</span></span>

 ### <a name="control-spacing"></a><span data-ttu-id="3cd3e-1624">控件间距</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1624">Control spacing</span></span>
 <span data-ttu-id="3cd3e-1625">您可以通过使用诸如的语法（ `{0,12}` 插入12个字符的字符串）来定义插入到结果字符串中的字符串的宽度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1625">You can define the width of the string that is inserted into the result string by using syntax such as `{0,12}`, which inserts a 12-character string.</span></span> <span data-ttu-id="3cd3e-1626">在这种情况下，第一个对象的字符串表示形式在12个字符的字段中右对齐。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1626">In this case, the string representation of the first object is right-aligned in the 12-character field.</span></span>  <span data-ttu-id="3cd3e-1627"> (如果第一个对象的字符串表示形式的长度超过12个字符，则将忽略首选字段宽度，并将整个字符串插入到结果字符串中。 ) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-1627">(If the string representation of the first object is more than 12 characters in length, though, the preferred field width is ignored, and the entire string is inserted into the result string.)</span></span>

 <span data-ttu-id="3cd3e-1628">下面的示例定义了一个包含字符串 "Year" 和一些年份字符串的6字符字段，以及一个包含字符串 "人口" 和一些人口数据的15个字符的字段。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1628">The following example defines a 6-character field to hold the string "Year" and some year strings, as well as an 15-character field to hold the string "Population" and some population data.</span></span> <span data-ttu-id="3cd3e-1629">请注意，字符在字段中右对齐。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1629">Note that the characters are right-aligned in the field.</span></span>

 [!code-cpp[System.String.Format#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp[System.String.Format#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting3.cs#33)]
 [!code-vb[System.String.Format#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]

 ### <a name="control-alignment"></a><span data-ttu-id="3cd3e-1630">控件对齐</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1630">Control alignment</span></span>
 <span data-ttu-id="3cd3e-1631">默认情况下，如果指定字段宽度，则字符串在其字段内右对齐。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1631">By default, strings are right-aligned within their field if you specify a field width.</span></span> <span data-ttu-id="3cd3e-1632">若要在字段中左对齐字符串，请在字段宽度前面加上负号，如 `{0,-12}` 定义12个字符左对齐字段。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1632">To left-align strings in a field, you preface the field width with a negative sign, such as `{0,-12}` to define a 12-character left-aligned field.</span></span>

 <span data-ttu-id="3cd3e-1633">下面的示例与上一个示例类似，不同之处在于它会将标签和数据保持一致。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1633">The following example is similar to the previous one, except that it left-aligns both labels and data.</span></span>

 [!code-cpp[System.String.Format#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp[System.String.Format#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]

 <span data-ttu-id="3cd3e-1634"><xref:System.String.Format%2A?displayProperty=nameWithType> 使用复合格式设置功能。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1634"><xref:System.String.Format%2A?displayProperty=nameWithType> makes use of the composite formatting feature.</span></span> <span data-ttu-id="3cd3e-1635">有关更多信息，请参见[复合格式设置](/dotnet/standard/base-types/composite-formatting)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1635">For more information, see [Composite Formatting](/dotnet/standard/base-types/composite-formatting).</span></span>

<a name="FTaskList"></a>
## <a name="which-method-do-i-call"></a><span data-ttu-id="3cd3e-1636">我要调用哪种方法？</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1636">Which method do I call?</span></span>

|<span data-ttu-id="3cd3e-1637">功能</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1637">To</span></span>|<span data-ttu-id="3cd3e-1638">调用</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1638">Call</span></span>|
|--------|----------|
|<span data-ttu-id="3cd3e-1639">使用当前区域性的约定设置一个或多个对象的格式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1639">Format one or more objects by using the conventions of the current culture.</span></span>|<span data-ttu-id="3cd3e-1640">除了包含参数的重载以外 `provider` ，其余 <xref:System.String.Format%2A> 重载包含一个参数， <xref:System.String> 后跟一个或多个对象参数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1640">Except for the overloads that include a `provider` parameter, the remaining <xref:System.String.Format%2A> overloads include a <xref:System.String> parameter followed by one or more object parameters.</span></span> <span data-ttu-id="3cd3e-1641">因此，不必确定要 <xref:System.String.Format%2A> 调用的重载。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1641">Because of this, you don't have to determine which <xref:System.String.Format%2A> overload you intend to call.</span></span> <span data-ttu-id="3cd3e-1642">根据参数列表，语言编译器会从没有参数的重载中选择相应的重载 `provider` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1642">Your language compiler selects the appropriate overload from among the overloads that don't have a `provider` parameter, based on your argument list.</span></span> <span data-ttu-id="3cd3e-1643">例如，如果参数列表具有五个参数，则编译器将调用 <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1643">For example, if your argument list has five arguments, the compiler calls the <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> method.</span></span>|
|<span data-ttu-id="3cd3e-1644">通过使用特定区域性的约定来设置一个或多个对象的格式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1644">Format one or more objects by using the conventions of a specific culture.</span></span>|<span data-ttu-id="3cd3e-1645">以 <xref:System.String.Format%2A> 参数开头的每个重载 `provider` 后跟一个 <xref:System.String> 参数和一个或多个对象参数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1645">Each <xref:System.String.Format%2A> overload that begins with a `provider` parameter is followed by a <xref:System.String> parameter and one or more object parameters.</span></span> <span data-ttu-id="3cd3e-1646">因此，不必确定要调用的特定 <xref:System.String.Format%2A> 重载。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1646">Because of this, you don't have to determine which specific <xref:System.String.Format%2A> overload you intend to call.</span></span> <span data-ttu-id="3cd3e-1647">语言编译器根据参数列表，从具有参数的重载中选择适当的重载 `provider` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1647">Your language compiler selects the appropriate overload from among the overloads that have a `provider` parameter, based on your argument list.</span></span> <span data-ttu-id="3cd3e-1648">例如，如果参数列表具有五个参数，则编译器将调用 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1648">For example, if your argument list has five arguments, the compiler calls the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> method.</span></span>|
|<span data-ttu-id="3cd3e-1649">使用实现或实现执行自定义格式设置操作 <xref:System.ICustomFormatter> <xref:System.IFormattable> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1649">Perform a custom formatting operation either with an <xref:System.ICustomFormatter> implementation or an <xref:System.IFormattable> implementation.</span></span>|<span data-ttu-id="3cd3e-1650">四个具有参数的重载中的任何一个 `provider` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1650">Any of the four overloads with a `provider` parameter.</span></span> <span data-ttu-id="3cd3e-1651">编译器根据参数列表，从具有参数的重载中选择适当的重载 `provider` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1651">The compiler selects the appropriate overload from among the overloads that have a `provider` parameter, based on your argument list.</span></span>|

<a name="Format_Brief"></a>
## <a name="the-format-method-in-brief"></a><span data-ttu-id="3cd3e-1652">Format 方法 brief</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1652">The Format method in brief</span></span>

 <span data-ttu-id="3cd3e-1653">该方法的每个重载都 <xref:System.String.Format%2A> 使用 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) ，以复合格式字符串形式包含从零开始的索引占位符（称为 *格式项*）。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1653">Each overload of the <xref:System.String.Format%2A> method uses the [composite formatting feature](/dotnet/standard/base-types/composite-formatting) to include zero-based indexed placeholders, called *format items*, in a composite format string.</span></span> <span data-ttu-id="3cd3e-1654">在运行时，每个格式项都替换为参数列表中相应参数的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1654">At run time, each format item is replaced with the string representation of the corresponding argument in a parameter list.</span></span> <span data-ttu-id="3cd3e-1655">如果参数的值为，则 `null` 将格式项替换为 <xref:System.String.Empty?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1655">If the value of the argument is `null`, the format item is replaced with <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3cd3e-1656">例如，以下对方法的调用 <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> 包含一个格式字符串，其中包含三个格式项、、 {0} {1} 和 {2} ，以及包含三个项的参数列表。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1656">For example, the following call to the <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> method includes a format string with three format items, {0}, {1}, and {2}, and an argument list with three items.</span></span>

 [!code-cpp[System.String.Format#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp[System.String.Format#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]

<a name="FormatItem"></a>
## <a name="the-format-item"></a><span data-ttu-id="3cd3e-1657">格式项</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1657">The format item</span></span>
 <span data-ttu-id="3cd3e-1658">格式项具有以下语法：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1658">A format item has this syntax:</span></span>

```
{index[,alignment][:formatString]}
```

 <span data-ttu-id="3cd3e-1659">方括号表示可选元素。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1659">Brackets denote optional elements.</span></span> <span data-ttu-id="3cd3e-1660">需要左大括号和右大括号。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1660">The opening and closing braces are required.</span></span> <span data-ttu-id="3cd3e-1661"> (在格式字符串中包含文本左大括号或右大括号，请参阅[复合格式设置](/dotnet/standard/base-types/composite-formatting)一文中的[转义大括号](/dotnet/standard/base-types/composite-formatting#escaping-braces)部分。 ) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-1661">(To include a literal opening or closing brace in the format string, see the [Escaping Braces](/dotnet/standard/base-types/composite-formatting#escaping-braces) section in the [Composite Formatting](/dotnet/standard/base-types/composite-formatting) article.)</span></span>

 <span data-ttu-id="3cd3e-1662">例如，设置货币值格式的格式项可能如下所示：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1662">For example, a format item to format a currency value might appear like this:</span></span>

 [!code-cpp[System.String.Format#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp[System.String.Format#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]
 [!code-vb[System.String.Format#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatsyntax1.vb#12)]

 <span data-ttu-id="3cd3e-1663">格式项包含以下元素：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1663">A format item has the following elements:</span></span>

 <span data-ttu-id="3cd3e-1664">*索引* 自变量的从零开始的索引，其字符串表示形式将包含在字符串中的此位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1664">*index* The zero-based index of the argument whose string representation is to be included at this position in the string.</span></span> <span data-ttu-id="3cd3e-1665">如果此参数为 `null` ，则字符串中此位置将包含空字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1665">If this argument is `null`, an empty string will be included at this position in the string.</span></span>

 <span data-ttu-id="3cd3e-1666">*对齐* 可有可无.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1666">*alignment* Optional.</span></span> <span data-ttu-id="3cd3e-1667">一个有符号整数，它指示要插入自变量的字段的总长度，并指定该参数是右对齐的， (是正整数) 还是) 负整数 (左对齐。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1667">A signed integer that indicates the total length of the field into which the argument is inserted and whether it is right-aligned (a positive integer) or left-aligned (a negative integer).</span></span> <span data-ttu-id="3cd3e-1668">如果省略 *对齐方式*，则会在不带前导空格或尾随空格的字段中插入相应参数的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1668">If you omit *alignment*, the string representation of the corresponding argument is inserted in a field with no leading or trailing spaces.</span></span>

 <span data-ttu-id="3cd3e-1669">如果 *对齐* 值小于要插入的参数的长度，则将忽略 *对齐* ，并使用参数的字符串表示形式的长度作为字段宽度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1669">If the value of *alignment* is less than the length of the argument to be inserted, *alignment* is ignored and the length of the string representation of the argument is used as the field width.</span></span>

 <span data-ttu-id="3cd3e-1670">*格式字符串* 可有可无.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1670">*formatString* Optional.</span></span> <span data-ttu-id="3cd3e-1671">一个字符串，指定相应参数的结果字符串的格式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1671">A string that specifies the format of the corresponding argument's result string.</span></span> <span data-ttu-id="3cd3e-1672">如果省略 *格式说明符*，则将调用相应的参数的无参数 `ToString` 方法，以生成其字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1672">If you omit *formatString*, the corresponding argument's parameterless `ToString` method is called to produce its string representation.</span></span> <span data-ttu-id="3cd3e-1673">如果指定格式 *字符串*，则该格式项引用的参数必须实现 <xref:System.IFormattable> 接口。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1673">If you specify *formatString*, the argument referenced by the format item must implement the <xref:System.IFormattable> interface.</span></span> <span data-ttu-id="3cd3e-1674">支持格式字符串的类型包括：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1674">Types that support format strings include:</span></span>

-   <span data-ttu-id="3cd3e-1675">所有整型和浮点类型。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1675">All integral and floating-point types.</span></span> <span data-ttu-id="3cd3e-1676"> (参见 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 和 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。 ) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-1676">(See [Standard Numeric Format Strings](/dotnet/standard/base-types/standard-numeric-format-strings) and [Custom Numeric Format Strings](/dotnet/standard/base-types/custom-numeric-format-strings).)</span></span>

-   <span data-ttu-id="3cd3e-1677"><xref:System.DateTime> 和 <xref:System.DateTimeOffset>。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1677"><xref:System.DateTime> and <xref:System.DateTimeOffset>.</span></span> <span data-ttu-id="3cd3e-1678"> (参见 [标准日期和时间格式字符串](/dotnet/standard/base-types/standard-date-and-time-format-strings) 和 [自定义日期和时间格式字符串](/dotnet/standard/base-types/custom-date-and-time-format-strings)。 ) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-1678">(See [Standard Date and Time Format Strings](/dotnet/standard/base-types/standard-date-and-time-format-strings) and [Custom Date and Time Format Strings](/dotnet/standard/base-types/custom-date-and-time-format-strings).)</span></span>

-   <span data-ttu-id="3cd3e-1679">所有枚举类型。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1679">All enumeration types.</span></span> <span data-ttu-id="3cd3e-1680"> (参见 [枚举格式字符串](/dotnet/standard/base-types/enumeration-format-strings)。 ) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-1680">(See [Enumeration Format Strings](/dotnet/standard/base-types/enumeration-format-strings).)</span></span>

-   <span data-ttu-id="3cd3e-1681"><xref:System.TimeSpan> 值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1681"><xref:System.TimeSpan> values.</span></span> <span data-ttu-id="3cd3e-1682"> (参见 [标准 Timespan 格式字符串](/dotnet/standard/base-types/standard-timespan-format-strings) 和 [自定义时间跨度格式字符串](/dotnet/standard/base-types/custom-timespan-format-strings)。 ) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-1682">(See [Standard TimeSpan Format Strings](/dotnet/standard/base-types/standard-timespan-format-strings) and [Custom TimeSpan Format Strings](/dotnet/standard/base-types/custom-timespan-format-strings).)</span></span>

-   <span data-ttu-id="3cd3e-1683">GUID。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1683">GUIDs.</span></span> <span data-ttu-id="3cd3e-1684"> (参见 <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> 方法。 ) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-1684">(See the <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> method.)</span></span>

 <span data-ttu-id="3cd3e-1685">但请注意，任何自定义类型都可以实现 <xref:System.IFormattable> 或扩展现有类型的 <xref:System.IFormattable> 实现。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1685">However, note that any custom type can implement <xref:System.IFormattable> or extend an existing type's <xref:System.IFormattable> implementation.</span></span>

 <span data-ttu-id="3cd3e-1686">下面的示例使用 `alignment` 和 `formatString` 参数来生成格式化的输出。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1686">The following example uses the `alignment` and `formatString` arguments to produce formatted output.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp" id="Snippet9":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs" interactive="try-dotnet-method" id="Snippet9":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb" id="Snippet9":::

<a name="HowFormatted"></a>
## <a name="how-arguments-are-formatted"></a><span data-ttu-id="3cd3e-1687">如何设置参数的格式</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1687">How arguments are formatted</span></span>
 <span data-ttu-id="3cd3e-1688">格式项从字符串的开头按顺序处理。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1688">Format items are processed sequentially from the beginning of the string.</span></span> <span data-ttu-id="3cd3e-1689">每个格式项都具有与方法的参数列表中的对象相对应的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1689">Each format item has an index that corresponds to an object in the method's argument list.</span></span> <span data-ttu-id="3cd3e-1690"><xref:System.String.Format%2A>方法检索参数并按如下方式派生其字符串表示形式：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1690">The <xref:System.String.Format%2A> method retrieves the argument and derives its string representation as follows:</span></span>

-   <span data-ttu-id="3cd3e-1691">如果参数为 `null` ，则该方法将插入 <xref:System.String.Empty?displayProperty=nameWithType> 到结果字符串中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1691">If the argument is `null`, the method inserts <xref:System.String.Empty?displayProperty=nameWithType> into the result string.</span></span> <span data-ttu-id="3cd3e-1692">不必担心如何处理 <xref:System.NullReferenceException> null 参数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1692">You don't have to be concerned with handling a <xref:System.NullReferenceException> for null arguments.</span></span>

-   <span data-ttu-id="3cd3e-1693">如果调用 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> 重载并且 `provider` 对象的 <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> 实现返回非 null <xref:System.ICustomFormatter> 实现，则会将参数传递给其 <xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1693">If you call the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> overload and the `provider` object's <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implementation returns a non-null <xref:System.ICustomFormatter> implementation, the argument is passed to its <xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3cd3e-1694">如果格式项包含格式 *字符串* 参数，则它将作为第一个参数传递给方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1694">If the format item includes a *formatString* argument, it is passed as the first argument to the method.</span></span> <span data-ttu-id="3cd3e-1695">如果 <xref:System.ICustomFormatter> 实现可用并且产生一个非空字符串，则返回该字符串作为参数的字符串表示形式; 否则，将执行下一步。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1695">If the <xref:System.ICustomFormatter> implementation is available and produces a non-null string, that string is returned as the string representation of the argument; otherwise, the next step executes.</span></span>

-   <span data-ttu-id="3cd3e-1696">如果参数实现 <xref:System.IFormattable> 接口， <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> 则调用其实现。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1696">If the argument implements the <xref:System.IFormattable> interface, its <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implementation is called.</span></span>

-   <span data-ttu-id="3cd3e-1697">调用了自变量的无参数 `ToString` 方法，该方法可重写或继承基类实现。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1697">The argument's parameterless `ToString` method, which either overrides or inherits from a base class implementation, is called.</span></span>

 <span data-ttu-id="3cd3e-1698">有关截获对方法的调用， <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> 并允许你查看 <xref:System.String.Format%2A> 方法为复合格式字符串中的每个格式项传递到格式设置方法的信息，请参阅 [示例：截获提供程序和罗马数字格式化程序](#Format7_Example)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1698">For an example that intercepts calls to the <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> method and allows you to see what information the <xref:System.String.Format%2A> method passes to a formatting method for each format item in a composite format string, see [Example: An intercept provider and Roman numeral formatter](#Format7_Example).</span></span>

 <span data-ttu-id="3cd3e-1699">有关详细信息，请参阅[复合格式设置](/dotnet/standard/base-types/composite-formatting)一文中的 "[处理顺序](/dotnet/standard/base-types/composite-formatting##processing-order)" 部分。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1699">For more information, see the [Processing Order](/dotnet/standard/base-types/composite-formatting##processing-order) section in the [Composite Formatting](/dotnet/standard/base-types/composite-formatting) article.</span></span>

<a name="SameIndex"></a>
## <a name="format-items-that-have-the-same-index"></a><span data-ttu-id="3cd3e-1700">设置具有相同索引的项的格式</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1700">Format items that have the same index</span></span>
 <span data-ttu-id="3cd3e-1701"><xref:System.String.Format%2A> <xref:System.FormatException> 如果索引项的索引大于或等于参数列表中的参数数目，则该方法将引发异常。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1701">The <xref:System.String.Format%2A> method throws a <xref:System.FormatException> exception if the index of an index item is greater than or equal to the number of arguments in the argument list.</span></span> <span data-ttu-id="3cd3e-1702">但是， `format` 只要多个格式项具有相同的索引，就可以包含比参数更多的格式项。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1702">However, `format` can include more format items than there are arguments, as long as multiple format items have the same index.</span></span> <span data-ttu-id="3cd3e-1703">在以下示例中，对方法的调用中 <xref:System.String.Format%28System.String%2CSystem.Object%29> ，参数列表具有单个参数，但格式字符串包含两个格式项：一个显示数字的十进制值，另一个显示其十六进制值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1703">In the call to the <xref:System.String.Format%28System.String%2CSystem.Object%29> method in following example, the argument list has a single argument, but the format string includes two format items: one displays the decimal value of a number, and the other displays its hexadecimal value.</span></span>

 [!code-csharp-interactive[System.String.Format2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]

<a name="Format_Culture"></a>
## <a name="format-and-culture"></a><span data-ttu-id="3cd3e-1704">格式和区域性</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1704">Format and culture</span></span>
 <span data-ttu-id="3cd3e-1705">通常，使用当前区域性的约定（由属性返回），将参数列表中的对象转换为其字符串表示形式 <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1705">Generally, objects in the argument list are converted to their string representations by using the conventions of the current culture, which is returned by the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="3cd3e-1706">可以通过调用包含参数的的重载之一来控制此行为 <xref:System.String.Format%2A> `provider` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1706">You can control this behavior by calling one of the overloads of <xref:System.String.Format%2A> that includes a `provider` parameter.</span></span> <span data-ttu-id="3cd3e-1707">`provider`参数是一个 <xref:System.IFormatProvider> 实现，提供用于使格式设置过程适中的自定义和区域性特定的格式设置信息。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1707">The `provider` parameter is an <xref:System.IFormatProvider> implementation that supplies custom and culture-specific formatting information that is used to moderate the formatting process.</span></span>

 <span data-ttu-id="3cd3e-1708">此 <xref:System.IFormatProvider> 接口具有一个成员， <xref:System.IFormatProvider.GetFormat%2A> 该成员负责返回提供格式设置信息的对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1708">The <xref:System.IFormatProvider> interface has a single member, <xref:System.IFormatProvider.GetFormat%2A>, which is responsible for returning the object that provides formatting information.</span></span> <span data-ttu-id="3cd3e-1709">.NET 具有三种 <xref:System.IFormatProvider> 实现，它们提供区域性特定的格式设置：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1709">.NET has three <xref:System.IFormatProvider> implementations that provide culture-specific formatting:</span></span>

-   <span data-ttu-id="3cd3e-1710"><xref:System.Globalization.CultureInfo>。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1710"><xref:System.Globalization.CultureInfo>.</span></span> <span data-ttu-id="3cd3e-1711">其 <xref:System.Globalization.CultureInfo.GetFormat%2A> 方法返回一个特定于区域性的 <xref:System.Globalization.NumberFormatInfo> 对象，用于设置数值的格式，以及 <xref:System.Globalization.DateTimeFormatInfo> 用于设置日期和时间值格式的区域性特定的对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1711">Its <xref:System.Globalization.CultureInfo.GetFormat%2A> method returns a culture-specific <xref:System.Globalization.NumberFormatInfo> object for formatting numeric values and a culture-specific <xref:System.Globalization.DateTimeFormatInfo> object for formatting date and time values.</span></span>

-   <span data-ttu-id="3cd3e-1712"><xref:System.Globalization.DateTimeFormatInfo>，它用于日期和时间值的区域性特定格式设置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1712"><xref:System.Globalization.DateTimeFormatInfo>, which is used for culture-specific formatting of date and time values.</span></span> <span data-ttu-id="3cd3e-1713">其 <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> 方法返回自身。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1713">Its <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> method returns itself.</span></span>

-   <span data-ttu-id="3cd3e-1714"><xref:System.Globalization.NumberFormatInfo>，它用于指定数值的区域性特定格式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1714"><xref:System.Globalization.NumberFormatInfo>, which is used for culture-specific formatting of numeric values.</span></span> <span data-ttu-id="3cd3e-1715">其 <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> 属性返回自身。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1715">Its <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> property returns itself.</span></span>

<a name="Format_Custom"></a>
## <a name="custom-formatting-operations"></a><span data-ttu-id="3cd3e-1716">自定义格式设置操作</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1716">Custom formatting operations</span></span>
 <span data-ttu-id="3cd3e-1717">您还可以调用 <xref:System.String.Format%2A> 具有类型的参数的方法的任何重载 `provider` <xref:System.IFormatProvider> 来执行自定义格式设置操作。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1717">You can also call the any of the overloads of the <xref:System.String.Format%2A> method that have a `provider` parameter of type <xref:System.IFormatProvider> to perform custom formatting operations.</span></span> <span data-ttu-id="3cd3e-1718">例如，可以将整数的格式设置为标识号或电话号码。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1718">For example, you could format an integer as an identification number or as a telephone number.</span></span> <span data-ttu-id="3cd3e-1719">若要执行自定义格式设置，你 `provider` 的参数必须实现 <xref:System.IFormatProvider> 和 <xref:System.ICustomFormatter> 接口。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1719">To perform custom formatting, your `provider` argument must implement both the <xref:System.IFormatProvider> and <xref:System.ICustomFormatter> interfaces.</span></span> <span data-ttu-id="3cd3e-1720">当向 <xref:System.String.Format%2A> 方法传递 <xref:System.ICustomFormatter> 实现作为 `provider` 参数时， <xref:System.String.Format%2A> 方法将调用其   <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> 实现并请求类型的对象 <xref:System.ICustomFormatter> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1720">When the <xref:System.String.Format%2A> method is passed an <xref:System.ICustomFormatter> implementation as the `provider` argument, the <xref:System.String.Format%2A> method calls its   <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implementation and requests an object of type <xref:System.ICustomFormatter>.</span></span> <span data-ttu-id="3cd3e-1721">然后，它调用返回的 <xref:System.ICustomFormatter> 对象的 <xref:System.ICustomFormatter.Format%2A> 方法，以设置传递给它的复合字符串中的每个格式项的格式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1721">It then calls the returned <xref:System.ICustomFormatter> object's <xref:System.ICustomFormatter.Format%2A> method to format each format item in the composite string passed to it.</span></span>

 <span data-ttu-id="3cd3e-1722">有关提供自定义格式设置解决方案的详细信息，请参阅 [如何：定义和使用自定义数值格式提供程序](/dotnet/standard/base-types/how-to-define-and-use-custom-numeric-format-providers) 和 <xref:System.ICustomFormatter> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1722">For more information about providing custom formatting solutions, see [How to: Define and Use Custom Numeric Format Providers](/dotnet/standard/base-types/how-to-define-and-use-custom-numeric-format-providers) and <xref:System.ICustomFormatter>.</span></span> <span data-ttu-id="3cd3e-1723">有关将整数转换为格式化自定义数字的示例，请参阅 [示例：自定义格式设置操作](#Format6_Example)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1723">For an example that converts integers to formatted custom numbers, see [Example: A custom formatting operation](#Format6_Example).</span></span> <span data-ttu-id="3cd3e-1724">有关将无符号字节转换为罗马数字的示例，请参阅 [示例：截获提供程序和罗马数字格式化程序](#Format7_Example)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1724">For an example that converts unsigned bytes to Roman numerals, see [Example: An intercept provider and Roman numeral formatter](#Format7_Example).</span></span>

<a name="Format6_Example"></a>
### <a name="example-a-custom-formatting-operation"></a><span data-ttu-id="3cd3e-1725">示例：自定义格式设置操作</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1725">Example: A custom formatting operation</span></span>
 <span data-ttu-id="3cd3e-1726">此示例定义格式提供程序，该提供程序将整数值的格式设置为 x-xxxxx-xx 形式的客户帐户号。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1726">This example defines a format provider that formats an integer value as a customer account number in the form x-xxxxx-xx.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp" id="Snippet2":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb" id="Snippet2":::

<a name="Format7_Example"></a>
### <a name="example-an-intercept-provider-and-roman-numeral-formatter"></a><span data-ttu-id="3cd3e-1727">示例：截距提供程序和罗马数字格式化程序</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1727">Example: An intercept provider and Roman numeral formatter</span></span>
 <span data-ttu-id="3cd3e-1728">此示例定义了一个自定义格式提供程序，该提供程序实现 <xref:System.ICustomFormatter> 和 <xref:System.IFormatProvider> 接口以执行两项操作：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1728">This example defines a custom format provider that implements the <xref:System.ICustomFormatter> and <xref:System.IFormatProvider> interfaces to do two things:</span></span>

-   <span data-ttu-id="3cd3e-1729">它将显示传递到其实现的参数 <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1729">It displays the parameters passed to its <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> implementation.</span></span> <span data-ttu-id="3cd3e-1730">这使我们能够查看方法将哪些参数 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> 传递到其尝试设置格式的每个对象的自定义格式设置实现。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1730">This enables us to see what parameters the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> method is passing to the custom formatting implementation for each object that it tries to format.</span></span> <span data-ttu-id="3cd3e-1731">调试应用程序时，这会很有用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1731">This can be useful when you're debugging your application.</span></span>

-   <span data-ttu-id="3cd3e-1732">如果要设置格式的对象是要使用 "R" 标准格式字符串设置格式的无符号字节值，则自定义格式化程序将数值的格式设置为罗马数字。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1732">If the object to be formatted is an unsigned byte value that is to be formatted by using the "R" standard format string, the custom formatter formats the numeric value as a Roman numeral.</span></span>

 [!code-cpp[System.String.Format#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp[System.String.Format#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]

<a name="QA"></a>
## <a name="stringformat-q--a"></a><span data-ttu-id="3cd3e-1733">字符串格式 Q &</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1733">String.Format Q & A</span></span>

### <a name="why-do-you-recommend-string-interpolation-over-calls-to-the-stringformat-method"></a><span data-ttu-id="3cd3e-1734">为什么建议通过调用方法来插入字符串 `String.Format` ？</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1734">Why do you recommend string interpolation over calls to the `String.Format` method?</span></span>

<span data-ttu-id="3cd3e-1735">字符串内插为：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1735">String interpolation is:</span></span>

- <span data-ttu-id="3cd3e-1736">更灵活。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1736">More flexible.</span></span> <span data-ttu-id="3cd3e-1737">它可用于任何字符串，无需调用支持复合格式设置的方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1737">It can be used in any string without requiring a call to a method that supports composite formatting.</span></span> <span data-ttu-id="3cd3e-1738">否则，必须调用 <xref:System.String.Format%2A> 方法或支持复合格式设置的其他方法，如 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 或 <xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1738">Otherwise, you have to call the <xref:System.String.Format%2A> method or another method that supports composite formatting, such as <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> or <xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>.</span></span>

- <span data-ttu-id="3cd3e-1739">可读性更强。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1739">More readable.</span></span> <span data-ttu-id="3cd3e-1740">由于插入到字符串中的表达式出现在内插表达式中（而不是自变量列表中），因此，内插字符串的代码和读取更为容易。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1740">Because the expression to insert into a string appears in the interpolated expression rather than in a argument list, interpolated strings are far easier to code and to read.</span></span> <span data-ttu-id="3cd3e-1741">由于其可读性更高，内插字符串不仅可以替换对复合格式方法的调用，还可以在字符串串联操作中使用，以生成更简洁简洁的代码。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1741">Because of their greater readability, interpolated strings can replace not only calls to composite format methods, but they can also be used in string concatenation operations to produce more concise, clearer code.</span></span>

<span data-ttu-id="3cd3e-1742">下面两个代码示例的比较说明了经营字符串连接和对复合格式设置方法的调用的内插字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1742">A comparison of the following two code examples illustrates the superiority of interpolated strings over string concatenation and calls to composite formatting methods.</span></span> <span data-ttu-id="3cd3e-1743">在下面的示例中，使用多个字符串串联操作会生成详细的代码和难于阅读的代码。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1743">The use of multiple string concatenation operations in the following example produces verbose and hard-to-read code.</span></span>

[!code-csharp[non-interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated1.cs#QAInterpolated)]
[!code-vb[non-interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated1.vb)]

<span data-ttu-id="3cd3e-1744">与此相反，在下面的示例中使用内插字符串会生成比字符串串联语句更清晰、更简洁的代码，并对 <xref:System.String.Format%2A> 上一示例中的方法进行调用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1744">In contrast, the use of interpolated strings in the following example produce much clearer, more concise code than the string concatenation statement and the call to the <xref:System.String.Format%2A> method in the previous example.</span></span>

[!code-csharp[interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated2.cs#QAInterpolated2)]
[!code-vb[interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated2.vb)]

### <a name="where-can-i-find-a-list-of-the-predefined-format-strings-that-can-be-used-with-format-items"></a><span data-ttu-id="3cd3e-1745">在哪里可以找到可用于格式项的预定义格式字符串列表？</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1745">Where can I find a list of the predefined format strings that can be used with format items?</span></span>

-   <span data-ttu-id="3cd3e-1746">对于所有整型和浮点类型，请参阅 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 和 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1746">For all integral and floating-point types, see [Standard Numeric Format Strings](/dotnet/standard/base-types/standard-numeric-format-strings) and [Custom Numeric Format Strings](/dotnet/standard/base-types/custom-numeric-format-strings).</span></span>

-   <span data-ttu-id="3cd3e-1747">对于日期和时间值，请参阅 [标准日期和时间格式字符串](/dotnet/standard/base-types/standard-date-and-time-format-strings) 和 [自定义日期和时间格式字符串](/dotnet/standard/base-types/custom-date-and-time-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1747">For date and time values, see [Standard Date and Time Format Strings](/dotnet/standard/base-types/standard-date-and-time-format-strings) and [Custom Date and Time Format Strings](/dotnet/standard/base-types/custom-date-and-time-format-strings).</span></span>

-   <span data-ttu-id="3cd3e-1748">对于枚举值，请参阅 [枚举格式字符串](/dotnet/standard/base-types/enumeration-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1748">For enumeration values, see [Enumeration Format Strings](/dotnet/standard/base-types/enumeration-format-strings).</span></span>

-   <span data-ttu-id="3cd3e-1749">有关 <xref:System.TimeSpan> 值，请参阅  [标准 Timespan 格式字符串](/dotnet/standard/base-types/standard-timespan-format-strings) 和 [自定义 timespan 格式字符串](/dotnet/standard/base-types/custom-timespan-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1749">For <xref:System.TimeSpan> values, see  [Standard TimeSpan Format Strings](/dotnet/standard/base-types/standard-timespan-format-strings) and [Custom TimeSpan Format Strings](/dotnet/standard/base-types/custom-timespan-format-strings).</span></span>

-   <span data-ttu-id="3cd3e-1750">有关 <xref:System.Guid> 值，请参阅引用页的 "备注" 部分 <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1750">For <xref:System.Guid> values, see the Remarks section of the <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> reference page.</span></span>

### <a name="how-do-i-control-the-alignment-of-the-result-strings-that-replace-format-items"></a><span data-ttu-id="3cd3e-1751">如何实现控制替换格式项的结果字符串的对齐方式吗？</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1751">How do I control the alignment of the result strings that replace format items?</span></span>
 <span data-ttu-id="3cd3e-1752">格式项的一般语法为：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1752">The general syntax of a format item is:</span></span>

```
{index[,alignment][: formatString]}
```

 <span data-ttu-id="3cd3e-1753">其中， *对齐方式* 是一个定义字段宽度的带符号整数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1753">where *alignment* is a signed integer that defines the field width.</span></span> <span data-ttu-id="3cd3e-1754">如果此值为负数，则字段中的文本为左对齐。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1754">If this value is negative, text in the field is left-aligned.</span></span> <span data-ttu-id="3cd3e-1755">如果为正数，则文本右对齐。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1755">If it is positive, text is right-aligned.</span></span>

### <a name="how-do-i-control-the-number-of-digits-after-the-decimal-separator"></a><span data-ttu-id="3cd3e-1756">如何实现控制小数点分隔符后的位数？</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1756">How do I control the number of digits after the decimal separator?</span></span>
 <span data-ttu-id="3cd3e-1757">除 "D" (之外的所有 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) （仅适用于整数) "G"、"R" 和 "X"）都允许使用精度说明符定义结果字符串中的小数位数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1757">All [standard numeric format strings](/dotnet/standard/base-types/standard-numeric-format-strings) except "D" (which is used with integers only), "G", "R", and "X" allow a precision specifier that defines the number of decimal digits in the result string.</span></span> <span data-ttu-id="3cd3e-1758">下面的示例使用标准数字格式字符串来控制结果字符串中的小数位数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1758">The following example uses standard numeric format strings to control the number of decimal digits in the result string.</span></span>

 [!code-csharp[System.String.Format#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]

 <span data-ttu-id="3cd3e-1759">如果使用的是 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)，请使用 "0" 格式说明符控制结果字符串中的小数位数，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1759">If you're using a [custom numeric format string](/dotnet/standard/base-types/custom-numeric-format-strings), use the "0" format specifier to control the number of decimal digits in the result string, as the following example shows.</span></span>

 [!code-csharp-interactive[System.String.Format#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]

### <a name="how-do-i-control-the-number-of-integral-digits"></a><span data-ttu-id="3cd3e-1760">如何实现控制整数位数？</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1760">How do I control the number of integral digits?</span></span>
 <span data-ttu-id="3cd3e-1761">默认情况下，格式设置操作仅显示非零整数位数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1761">By default, formatting operations only display non-zero integral digits.</span></span> <span data-ttu-id="3cd3e-1762">如果要设置整数格式，则可以使用带有 "D" 和 "X" 标准格式字符串的精度说明符来控制数字的位数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1762">If you are formatting integers, you can use a precision specifier with the "D" and "X" standard format strings to control the number of digits.</span></span>

 [!code-csharp-interactive[System.String.Format#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]

 <span data-ttu-id="3cd3e-1763">可以通过使用 "0" [自定义数值格式说明符](/dotnet/standard/base-types/custom-numeric-format-strings)，使用前导零填充整数或浮点数，以生成具有指定数量整数位数的结果字符串，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1763">You can pad an integer or floating-point number with leading zeros to produce a result string with a specified number of integral digits by using the "0" [custom numeric format specifier](/dotnet/standard/base-types/custom-numeric-format-strings), as the following example shows.</span></span>

 [!code-csharp-interactive[System.String.Format#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]

### <a name="how-many-items-can-i-include-in-the-format-list"></a><span data-ttu-id="3cd3e-1764">可以在 "格式" 列表中包含多少项？</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1764">How many items can I include in the format list?</span></span>
 <span data-ttu-id="3cd3e-1765">没有实际限制。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1765">There is no practical limit.</span></span> <span data-ttu-id="3cd3e-1766">方法的第二个参数 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> 使用特性进行标记 <xref:System.ParamArrayAttribute> ，这允许您将分隔的列表或对象数组作为格式列表包括在内。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1766">The second parameter of the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> method is tagged with the <xref:System.ParamArrayAttribute> attribute, which allows you to include either a delimited list or an object array as your format list.</span></span>

<a name="braces"></a>
### <a name="how-do-i-include-literal-braces--and--in-the-result-string"></a><span data-ttu-id="3cd3e-1767">如何实现在结果字符串中包含 "{" 和 "}" ( 文本大括号 ) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-1767">How do I include literal braces ("{" and "}") in the result string?</span></span>
 <span data-ttu-id="3cd3e-1768">例如，如何防止下面的方法调用引发 <xref:System.FormatException> 异常？</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1768">For example, how do you prevent the following method call from throwing a <xref:System.FormatException> exception?</span></span>

 [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]

 <span data-ttu-id="3cd3e-1769">单个左大括号或右大括号始终解释为格式项的开头或结尾。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1769">A single opening or closing brace is always interpreted as the beginning or end of a format item.</span></span> <span data-ttu-id="3cd3e-1770">若要按原义解释，则必须对其进行转义。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1770">To be interpreted literally, it must be escaped.</span></span> <span data-ttu-id="3cd3e-1771">通过添加另一个大括号 ( "{{" 和 "}}" 而不是 "{" 和 "}" ) 来转义大括号，如以下方法调用所示：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1771">You escape a brace by adding another brace ("{{" and "}}" instead of "{" and "}"), as in the following method call:</span></span>

 [!code-csharp-interactive[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]

 <span data-ttu-id="3cd3e-1772">不过，甚至可以轻松地误解转义大括号。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1772">However, even escaped braces are easily misinterpreted.</span></span> <span data-ttu-id="3cd3e-1773">建议在格式列表中包含大括号，并使用格式项将它们插入到结果字符串中，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1773">We recommend that you include braces in the format list and use format items to insert them in the result string, as the following example shows.</span></span>

 [!code-csharp-interactive[System.String.Format#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]

### <a name="why-does-my-call-to-the-stringformat-method-throw-a-formatexception"></a><span data-ttu-id="3cd3e-1774">为什么调用字符串。 Format 方法会引发 FormatException？</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1774">Why does my call to the String.Format method throw a FormatException?</span></span>
 <span data-ttu-id="3cd3e-1775">最常见的原因是，格式项的索引不与 "格式" 列表中的对象相对应。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1775">The most common cause of the exception is that the index of a format item doesn't correspond to an object in the format list.</span></span> <span data-ttu-id="3cd3e-1776">通常，这表示您已 misnumbered 格式项的索引，或者您忘记在 "格式" 列表中包含一个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1776">Usually this indicates that you've misnumbered the indexes of format items or you've forgotten to include an object in the format list.</span></span> <span data-ttu-id="3cd3e-1777">尝试包含非转义的左大括号或右大括号会引发 <xref:System.FormatException> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1777">Attempting to include an unescaped left or right brace character also throws a <xref:System.FormatException>.</span></span> <span data-ttu-id="3cd3e-1778">偶尔，异常是由键入错误引起的;例如，典型的错误是错误地键入了 "[" (左括号) 而不是 "{" (左大括号) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1778">Occasionally, the exception is the result of a typo; for example, a typical mistake is to mistype "[" (the left bracket) instead of "{" (the left brace).</span></span>

### <a name="if-the-formatsystemiformatprovidersystemstringsystemobject-method-supports-parameter-arrays-why-does-my-code-throw-an-exception-when-i-use-an-array"></a><span data-ttu-id="3cd3e-1779">如果 (IFormatProvider，System.string，system.object [] ) 方法的格式支持参数数组，则我的代码在使用数组时为什么会引发异常？</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1779">If the Format(System.IFormatProvider,System.String,System.Object[]) method supports parameter arrays, why does my code throw an exception when I use an array?</span></span>
 <span data-ttu-id="3cd3e-1780">例如，以下代码将引发 <xref:System.FormatException> 异常：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1780">For example, the following code throws a <xref:System.FormatException> exception:</span></span>

 [!code-csharp[System.String.Format#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]

 <span data-ttu-id="3cd3e-1781">这是编译器重载决策的问题。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1781">This is a problem of compiler overload resolution.</span></span> <span data-ttu-id="3cd3e-1782">由于编译器无法将整数数组转换为对象数组，因此它将整数数组视为单个参数，因此它将调用 <xref:System.String.Format%28System.String%2CSystem.Object%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1782">Because the compiler cannot convert an array of integers to an object array, it treats the integer array as a single argument, so it calls the <xref:System.String.Format%28System.String%2CSystem.Object%29> method.</span></span> <span data-ttu-id="3cd3e-1783">引发此异常的原因是存在四个格式项，但在 "格式" 列表中只有一个项。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1783">The exception is thrown because there are four format items but only a single item in the format list.</span></span>

 <span data-ttu-id="3cd3e-1784">因为 Visual Basic 和 c # 都不能将整数数组转换为对象数组，所以必须在调用方法之前自行执行转换 <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1784">Because neither Visual Basic nor C# can convert an integer array to an object array, you have to perform the conversion yourself before calling the <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> method.</span></span> <span data-ttu-id="3cd3e-1785">以下示例提供了一个实现。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1785">The following example provides one implementation.</span></span>

 [!code-csharp-interactive[System.String.Format#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]

## Examples

<span data-ttu-id="3cd3e-1786">调用方法的多 <xref:System.String.Format%2A> 个示例贯穿本文的 " [备注](#remarks-top) " 部分。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1786">Numerous examples that call the <xref:System.String.Format%2A> method are interspersed through the [Remarks](#remarks-top) section of this article.</span></span>

<span data-ttu-id="3cd3e-1787">你还可以下载一组完整的 `String.Format` 示例，其中包括 [适用于 c # 的 .net Core 项目](https://docs.microsoft.com/samples/dotnet/samples/string-format/)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1787">You can also download a complete set of `String.Format` examples, which are included a [.NET Core project for C#](https://docs.microsoft.com/samples/dotnet/samples/string-format/).</span></span>

<span data-ttu-id="3cd3e-1788">下面是本文中包含的一些示例：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1788">The following are some of the examples included in the article:</span></span>

### <a name="create-a-format-string"></a><span data-ttu-id="3cd3e-1789">创建格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1789">Create a format string</span></span>

<span data-ttu-id="3cd3e-1790">[插入字符串](#insert-a-string) 
[格式项](#the-format-item) 
[设置具有相同索引的项的格式](#format-items-that-have-the-same-index)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1790">[Inserting a string](#insert-a-string)
[The format item](#the-format-item)
[Format items that have the same index](#format-items-that-have-the-same-index)</span></span>

### <a name="control-formatted-output"></a><span data-ttu-id="3cd3e-1791">控制格式化输出</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1791">Control formatted output</span></span>

<span data-ttu-id="3cd3e-1792">[控制格式设置](#control-formatting) 
[控制间距](#control-spacing) 
[控制对齐方式](#control-alignment) 
[控制整数位数](#how-do-i-control-the-number-of-integral-digits) 
[控制小数点分隔符](#how-do-i-control-the-number-of-digits-after-the-decimal-separator) 
 后的位数[在结果字符串中包含字面大括号](#braces)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1792">[Controlling formatting](#control-formatting)
[Controlling spacing](#control-spacing)
[Controlling alignment](#control-alignment)
[Controlling the number of integral digits](#how-do-i-control-the-number-of-integral-digits)
[Controlling the number of digits after the decimal separator](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)
[Including literal braces in a result string](#braces)</span></span>

### <a name="make-format-strings-culture-sensitive"></a><span data-ttu-id="3cd3e-1793">使格式字符串区分区域性</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1793">Make format strings culture-sensitive</span></span>

[<span data-ttu-id="3cd3e-1794">区分区域性的格式设置</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1794">Culture-sensitive formatting</span></span>](#culture-sensitive-formatting)

### <a name="customize-the-formatting-operation"></a><span data-ttu-id="3cd3e-1795">自定义格式设置操作</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1795">Customize the formatting operation</span></span>

<span data-ttu-id="3cd3e-1796">[自定义格式设置操作](#example-a-custom-formatting-operation) 
[截距提供程序和罗马数字格式化程序](#example-an-intercept-provider-and-roman-numeral-formatter)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1796">[A custom formatting operation](#example-a-custom-formatting-operation)
[An intercept provider and Roman numeral formatter](#example-an-intercept-provider-and-roman-numeral-formatter)</span></span>

 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/base-types/formatting-types"><span data-ttu-id="3cd3e-1797">设置 .NET 中类型的格式</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1797">Formatting Types in .NET</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/composite-formatting"><span data-ttu-id="3cd3e-1798">复合格式设置</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1798">Composite Formatting</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-date-and-time-format-strings"><span data-ttu-id="3cd3e-1799">标准日期和时间格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1799">Standard Date and Time Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-date-and-time-format-strings"><span data-ttu-id="3cd3e-1800">自定义日期和时间格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1800">Custom Date and Time Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings"><span data-ttu-id="3cd3e-1801">标准数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1801">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings"><span data-ttu-id="3cd3e-1802">自定义数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1802">Custom Numeric Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-timespan-format-strings"><span data-ttu-id="3cd3e-1803">标准 TimeSpan 格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1803">Standard TimeSpan Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-timespan-format-strings"><span data-ttu-id="3cd3e-1804">自定义的 TimeSpan 格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1804">Custom TimeSpan Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/enumeration-format-strings"><span data-ttu-id="3cd3e-1805">枚举格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1805">Enumeration Format Strings</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj -&gt; string" Usage="System.string.Format (format, arg0)" />
      <MemberSignature Language="C#" Value="public static string Format (string format, object? arg0);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="3cd3e-1806">[复合格式字符串](/dotnet/standard/base-types/composite-formatting)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1806">A [composite format string](/dotnet/standard/base-types/composite-formatting).</span></span></param>
        <param name="arg0"><span data-ttu-id="3cd3e-1807">要设置格式的对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1807">The object to format.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1808">将字符串中的一个或多个格式项替换为指定对象的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1808">Replaces one or more format items in a string with the string representation of a specified object.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1809"><paramref name="format" /> 的副本，其中的任何格式项均替换为 <paramref name="arg0" /> 的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1809">A copy of <paramref name="format" /> in which any format items are replaced by the string representation of <paramref name="arg0" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)]

<span data-ttu-id="3cd3e-1810">此方法使用 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将表达式的值转换为其字符串表示形式，并将该表示形式嵌入到字符串中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1810">This method uses the [composite formatting feature](/dotnet/standard/base-types/composite-formatting) to convert the value of an expression to its string representation and to embed that representation in a string.</span></span>

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-a-single-argument"></a><span data-ttu-id="3cd3e-1811">示例：设置单个参数的格式</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1811">Example: Formatting a single argument</span></span>

 <span data-ttu-id="3cd3e-1812">下面的示例使用 <xref:System.String.Format%28System.String%2CSystem.Object%29> 方法在字符串中间嵌入单个年龄。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1812">The following example uses the <xref:System.String.Format%28System.String%2CSystem.Object%29> method to embed an individual's age in the middle of a string.</span></span>

 [!code-cpp[System.String.Format#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp-interactive[System.String.Format#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-1813"><paramref name="format" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1813"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="3cd3e-1814"><paramref name="format" /> 中的格式项无效。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1814">The format item in <paramref name="format" /> is invalid.</span></span>

<span data-ttu-id="3cd3e-1815">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1815">-or-</span></span>

<span data-ttu-id="3cd3e-1816">格式项的索引不为零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1816">The index of a format item is not zero.</span></span></exception>
        <related type="Article" href="/dotnet/standard/base-types/formatting-types"><span data-ttu-id="3cd3e-1817">设置 .NET 中类型的格式</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1817">Formatting Types in .NET</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/composite-formatting"><span data-ttu-id="3cd3e-1818">复合格式设置</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1818">Composite Formatting</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-date-and-time-format-strings"><span data-ttu-id="3cd3e-1819">标准日期和时间格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1819">Standard Date and Time Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-date-and-time-format-strings"><span data-ttu-id="3cd3e-1820">自定义日期和时间格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1820">Custom Date and Time Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings"><span data-ttu-id="3cd3e-1821">标准数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1821">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings"><span data-ttu-id="3cd3e-1822">自定义数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1822">Custom Numeric Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-timespan-format-strings"><span data-ttu-id="3cd3e-1823">标准 TimeSpan 格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1823">Standard TimeSpan Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-timespan-format-strings"><span data-ttu-id="3cd3e-1824">自定义的 TimeSpan 格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1824">Custom TimeSpan Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/enumeration-format-strings"><span data-ttu-id="3cd3e-1825">枚举格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1825">Enumeration Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[] args);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj[] -&gt; string" Usage="System.string.Format (format, args)" />
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[]? args);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="3cd3e-1826">[复合格式字符串](/dotnet/standard/base-types/composite-formatting)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1826">A [composite format string](/dotnet/standard/base-types/composite-formatting).</span></span></param>
        <param name="args"><span data-ttu-id="3cd3e-1827">一个对象数组，其中包含零个或多个要设置格式的对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1827">An object array that contains zero or more objects to format.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1828">将指定字符串中的格式项替换为指定数组中相应对象的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1828">Replaces the format item in a specified string with the string representation of a corresponding object in a specified array.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1829"><paramref name="format" /> 的副本，其中格式项已替换为 <paramref name="args" /> 中相应对象的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1829">A copy of <paramref name="format" /> in which the format items have been replaced by the string representation of the corresponding objects in <paramref name="args" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)]

<span data-ttu-id="3cd3e-1830">此方法使用 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将4个或更多表达式的值转换为它们的字符串表示形式，并将这些表示形式嵌入到字符串中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1830">This method uses the [composite formatting feature](/dotnet/standard/base-types/composite-formatting) to convert the value of four or more expressions to their string representations and to embed those representations in a string.</span></span> <span data-ttu-id="3cd3e-1831">由于 `args` 参数是用特性标记的 <xref:System.ParamArrayAttribute?displayProperty=nameWithType> ，因此可以将对象作为单个参数或数组传递给方法 <xref:System.Object> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1831">Since the `args` parameter is marked with the <xref:System.ParamArrayAttribute?displayProperty=nameWithType> attribute, you can pass the objects to the method as individual arguments or as an <xref:System.Object> array.</span></span>

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-format-more-than-three-arguments"></a><span data-ttu-id="3cd3e-1832">示例：格式化三个以上的参数</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1832">Example: Format more than three arguments</span></span>

 <span data-ttu-id="3cd3e-1833">此示例将创建一个字符串，其中包含特定日期的高温和低温度数据。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1833">This example creates a string that contains data on the high and low temperature on a particular date.</span></span> <span data-ttu-id="3cd3e-1834">复合格式字符串在 c # 示例中有五个格式项，在 Visual Basic 示例中有六个格式项。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1834">The composite format string has five format items in the C# example and six in the Visual Basic example.</span></span> <span data-ttu-id="3cd3e-1835">两个格式项定义其对应值的字符串表示形式的宽度，第一个格式项还包括标准日期和时间格式字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1835">Two of the format items define the width of their corresponding value's string representation, and the first format item also includes a standard date and time format string.</span></span>

 [!code-cpp[System.String.Format#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp[System.String.Format#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]

 <span data-ttu-id="3cd3e-1836">还可以传递要格式化为数组而不是参数列表的对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1836">You can also pass the objects to be formatted as an array rather than as an argument list.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp" id="Snippet10":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs" interactive="try-dotnet" id="Snippet10":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb" id="Snippet10":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-1837"><paramref name="format" /> 或 <paramref name="args" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1837"><paramref name="format" /> or <paramref name="args" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="3cd3e-1838"><paramref name="format" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1838"><paramref name="format" /> is invalid.</span></span>

<span data-ttu-id="3cd3e-1839">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1839">-or-</span></span>

<span data-ttu-id="3cd3e-1840">格式项的索引小于零，或者大于或等于 <paramref name="args" /> 数组的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1840">The index of a format item is less than zero, or greater than or equal to the length of the <paramref name="args" /> array.</span></span></exception>
        <related type="Article" href="/dotnet/standard/base-types/formatting-types"><span data-ttu-id="3cd3e-1841">设置 .NET 中类型的格式</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1841">Formatting Types in .NET</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/composite-formatting"><span data-ttu-id="3cd3e-1842">复合格式设置</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1842">Composite Formatting</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-date-and-time-format-strings"><span data-ttu-id="3cd3e-1843">标准日期和时间格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1843">Standard Date and Time Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-date-and-time-format-strings"><span data-ttu-id="3cd3e-1844">自定义日期和时间格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1844">Custom Date and Time Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings"><span data-ttu-id="3cd3e-1845">标准数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1845">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings"><span data-ttu-id="3cd3e-1846">自定义数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1846">Custom Numeric Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-timespan-format-strings"><span data-ttu-id="3cd3e-1847">标准 TimeSpan 格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1847">Standard TimeSpan Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-timespan-format-strings"><span data-ttu-id="3cd3e-1848">自定义的 TimeSpan 格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1848">Custom TimeSpan Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/enumeration-format-strings"><span data-ttu-id="3cd3e-1849">枚举格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1849">Enumeration Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj -&gt; string" Usage="System.string.Format (provider, format, arg0)" />
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider? provider, string format, object? arg0);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="3cd3e-1850">一个提供区域性特定的格式设置信息的对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1850">An object that supplies culture-specific formatting information.</span></span></param>
        <param name="format"><span data-ttu-id="3cd3e-1851">[复合格式字符串](/dotnet/standard/base-types/composite-formatting)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1851">A [composite format string](/dotnet/standard/base-types/composite-formatting).</span></span></param>
        <param name="arg0"><span data-ttu-id="3cd3e-1852">要设置格式的对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1852">The object to format.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1853">将指定字符串中的一个或多个格式项替换为对应对象的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1853">Replaces the format item or items in a specified string with the string representation of the corresponding object.</span></span> <span data-ttu-id="3cd3e-1854">参数提供区域性特定的格式设置信息。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1854">A parameter supplies culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1855"><paramref name="format" /> 的副本，其中的一个或多个格式项已替换为 <paramref name="arg0" /> 的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1855">A copy of <paramref name="format" /> in which the format item or items have been replaced by the string representation of <paramref name="arg0" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)]

<span data-ttu-id="3cd3e-1856">此方法使用 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将表达式的值转换为其字符串表示形式，并将该表示形式嵌入到字符串中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1856">This method uses the [composite formatting feature](/dotnet/standard/base-types/composite-formatting) to convert the value of an expression to its string representation and to embed that representation in a string.</span></span> <span data-ttu-id="3cd3e-1857">在执行转换时，方法使用区分区域性的格式设置或自定义格式化程序。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1857">In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</span></span> <span data-ttu-id="3cd3e-1858">方法 `arg0` 通过调用其 tostring \*\* (IFormatProvider) \*\* 方法转换为其字符串表示形式; 如果对象的相应格式项包含格式字符串，则通过调用其 \*\*Tostring (string，IFormatProvider) \*\* 方法来转换为字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1858">The method converts `arg0` to its string representation by calling its **ToString(IFormatProvider)** method or, if the object's corresponding format item includes a format string, by calling its **ToString(String,IFormatProvider)** method.</span></span> <span data-ttu-id="3cd3e-1859">如果这些方法不存在，它将调用对象的无参数 **ToString** 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1859">If these methods don't exist, it calls the object's parameterless **ToString** method.</span></span>

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-1860"><paramref name="format" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1860"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="3cd3e-1861"><paramref name="format" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1861"><paramref name="format" /> is invalid.</span></span>

<span data-ttu-id="3cd3e-1862">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1862">-or-</span></span>

<span data-ttu-id="3cd3e-1863">格式项的索引不为零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1863">The index of a format item is not zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, params object[] args);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj[] -&gt; string" Usage="System.string.Format (provider, format, args)" />
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider? provider, string format, params object[]? args);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="3cd3e-1864">一个提供区域性特定的格式设置信息的对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1864">An object that supplies culture-specific formatting information.</span></span></param>
        <param name="format"><span data-ttu-id="3cd3e-1865">[复合格式字符串](/dotnet/standard/base-types/composite-formatting)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1865">A [composite format string](/dotnet/standard/base-types/composite-formatting).</span></span></param>
        <param name="args"><span data-ttu-id="3cd3e-1866">一个对象数组，其中包含零个或多个要设置格式的对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1866">An object array that contains zero or more objects to format.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1867">将字符串中的格式项替换为指定数组中相应对象的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1867">Replaces the format items in a string with the string representations of corresponding objects in a specified array.</span></span> <span data-ttu-id="3cd3e-1868">参数提供区域性特定的格式设置信息。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1868">A parameter supplies culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1869"><paramref name="format" /> 的副本，其中格式项已替换为 <paramref name="args" /> 中相应对象的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1869">A copy of <paramref name="format" /> in which the format items have been replaced by the string representation of the corresponding objects in <paramref name="args" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)]

<span data-ttu-id="3cd3e-1870">此方法使用 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将4个或更多表达式转换为其字符串表示形式，并将这些表示形式嵌入到字符串中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1870">This method uses the [composite formatting feature](/dotnet/standard/base-types/composite-formatting) to convert four or more expressions to their string representations and to embed those representations in a string.</span></span> <span data-ttu-id="3cd3e-1871">在执行转换时，方法使用区分区域性的格式设置或自定义格式化程序。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1871">In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</span></span> <span data-ttu-id="3cd3e-1872">方法通过调用其 tostring <xref:System.Object> \*\* (IFormatProvider) \*\* 方法来将每个参数转换为其字符串表示形式; 如果对象的相应格式项包含格式字符串，则通过调用其 \*\*Tostring (string，IFormatProvider) \*\* 方法来将其转换为字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1872">The method converts each <xref:System.Object> argument to its string representation by calling its **ToString(IFormatProvider)** method or, if the object's corresponding format item includes a format string, by calling its **ToString(String,IFormatProvider)** method.</span></span> <span data-ttu-id="3cd3e-1873">如果这些方法不存在，它将调用对象的无参数 **ToString** 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1873">If these methods don't exist, it calls the object's parameterless **ToString** method.</span></span>

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]

<a name="culture-sensitive-formatting" />

### <a name="example-culture-sensitive-formatting"></a><span data-ttu-id="3cd3e-1874">示例：区分区域性的格式设置</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1874">Example: Culture-sensitive formatting</span></span>

 <span data-ttu-id="3cd3e-1875">此示例使用 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> 方法通过使用几个不同的区域性显示某些日期和时间值的字符串表示形式和数值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1875">This example uses the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> method to display the string representation of some date and time values and numeric values by using several different cultures.</span></span>

 [!code-csharp-interactive[System.String.Format2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-1876"><paramref name="format" /> 或 <paramref name="args" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1876"><paramref name="format" /> or <paramref name="args" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="3cd3e-1877"><paramref name="format" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1877"><paramref name="format" /> is invalid.</span></span>

<span data-ttu-id="3cd3e-1878">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1878">-or-</span></span>

<span data-ttu-id="3cd3e-1879">格式项的索引小于零，或者大于或等于 <paramref name="args" /> 数组的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1879">The index of a format item is less than zero, or greater than or equal to the length of the <paramref name="args" /> array.</span></span></exception>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.ICustomFormatter" />
        <altmember cref="T:System.IFormatProvider" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <related type="Article" href="/dotnet/standard/base-types/formatting-types"><span data-ttu-id="3cd3e-1880">设置 .NET 中类型的格式</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1880">Formatting Types in .NET</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/composite-formatting"><span data-ttu-id="3cd3e-1881">复合格式设置</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1881">Composite Formatting</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-date-and-time-format-strings"><span data-ttu-id="3cd3e-1882">标准日期和时间格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1882">Standard Date and Time Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-date-and-time-format-strings"><span data-ttu-id="3cd3e-1883">自定义日期和时间格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1883">Custom Date and Time Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings"><span data-ttu-id="3cd3e-1884">标准数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1884">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings"><span data-ttu-id="3cd3e-1885">自定义数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1885">Custom Numeric Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-timespan-format-strings"><span data-ttu-id="3cd3e-1886">标准 TimeSpan 格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1886">Standard TimeSpan Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-timespan-format-strings"><span data-ttu-id="3cd3e-1887">自定义的 TimeSpan 格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1887">Custom TimeSpan Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/enumeration-format-strings"><span data-ttu-id="3cd3e-1888">枚举格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1888">Enumeration Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1)" />
      <MemberSignature Language="C#" Value="public static string Format (string format, object? arg0, object? arg1);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="3cd3e-1889">[复合格式字符串](/dotnet/standard/base-types/composite-formatting)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1889">A [composite format string](/dotnet/standard/base-types/composite-formatting).</span></span></param>
        <param name="arg0"><span data-ttu-id="3cd3e-1890">要设置格式的第一个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1890">The first object to format.</span></span></param>
        <param name="arg1"><span data-ttu-id="3cd3e-1891">要设置格式的第二个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1891">The second object to format.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1892">将字符串中的格式项替换为两个指定对象的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1892">Replaces the format items in a string with the string representation of two specified objects.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1893"><paramref name="format" /> 的副本，其中的格式项替换为 <paramref name="arg0" /> 和 <paramref name="arg1" /> 的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1893">A copy of <paramref name="format" /> in which format items are replaced by the string representations of <paramref name="arg0" /> and <paramref name="arg1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)]

<span data-ttu-id="3cd3e-1894">此方法使用 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将两个表达式的值转换为它们的字符串表示形式，并将这些表示形式嵌入到字符串中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1894">This method uses the [composite formatting feature](/dotnet/standard/base-types/composite-formatting) to convert the value of two expressions to their string representations and to embed those representations in a string.</span></span>

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-format-two-arguments"></a><span data-ttu-id="3cd3e-1895">示例：设置两个参数的格式</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1895">Example: Format two arguments</span></span>

 <span data-ttu-id="3cd3e-1896">此示例使用 <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> 方法来显示通用对象中存储的时间和温度数据 <xref:System.Collections.Generic.Dictionary%602> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1896">This example uses the <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> method to display time and temperature data stored in a generic <xref:System.Collections.Generic.Dictionary%602> object.</span></span> <span data-ttu-id="3cd3e-1897">请注意，尽管只有两个要设置格式的对象，但格式字符串具有三个格式项。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1897">Note that the format string has three format items, although there are only two objects to format.</span></span> <span data-ttu-id="3cd3e-1898">这是因为列表中的第一个对象 (日期和时间值) 由两个格式项使用：第一个格式项显示时间，第二个对象显示日期。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1898">This is because the first object in the list (a date and time value) is used by two format items: The first format item displays the time, and the second displays the date.</span></span>

 [!code-cpp[System.String.Format#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp[System.String.Format#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-1899"><paramref name="format" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1899"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="3cd3e-1900"><paramref name="format" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1900"><paramref name="format" /> is invalid.</span></span>

<span data-ttu-id="3cd3e-1901">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1901">-or-</span></span>

<span data-ttu-id="3cd3e-1902">格式项的索引不为零或一。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1902">The index of a format item is not zero or one.</span></span></exception>
        <related type="Article" href="/dotnet/standard/base-types/formatting-types"><span data-ttu-id="3cd3e-1903">设置 .NET 中类型的格式</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1903">Formatting Types in .NET</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/composite-formatting"><span data-ttu-id="3cd3e-1904">复合格式设置</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1904">Composite Formatting</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-date-and-time-format-strings"><span data-ttu-id="3cd3e-1905">标准日期和时间格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1905">Standard Date and Time Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-date-and-time-format-strings"><span data-ttu-id="3cd3e-1906">自定义日期和时间格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1906">Custom Date and Time Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings"><span data-ttu-id="3cd3e-1907">标准数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1907">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings"><span data-ttu-id="3cd3e-1908">自定义数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1908">Custom Numeric Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-timespan-format-strings"><span data-ttu-id="3cd3e-1909">标准 TimeSpan 格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1909">Standard TimeSpan Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-timespan-format-strings"><span data-ttu-id="3cd3e-1910">自定义的 TimeSpan 格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1910">Custom TimeSpan Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/enumeration-format-strings"><span data-ttu-id="3cd3e-1911">枚举格式字符串</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1911">Enumeration Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1)" />
      <MemberSignature Language="C#" Value="public static string? Format (IFormatProvider provider, string? format, object arg0, object arg1);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="3cd3e-1912">一个提供区域性特定的格式设置信息的对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1912">An object that supplies culture-specific formatting information.</span></span></param>
        <param name="format"><span data-ttu-id="3cd3e-1913">[复合格式字符串](/dotnet/standard/base-types/composite-formatting)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1913">A [composite format string](/dotnet/standard/base-types/composite-formatting).</span></span></param>
        <param name="arg0"><span data-ttu-id="3cd3e-1914">要设置格式的第一个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1914">The first object to format.</span></span></param>
        <param name="arg1"><span data-ttu-id="3cd3e-1915">要设置格式的第二个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1915">The second object to format.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1916">将字符串中的格式项替换为两个指定对象的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1916">Replaces the format items in a string with the string representation of two specified objects.</span></span> <span data-ttu-id="3cd3e-1917">参数提供区域性特定的格式设置信息。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1917">A parameter supplies culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1918"><paramref name="format" /> 的副本，其中的格式项替换为 <paramref name="arg0" /> 和 <paramref name="arg1" /> 的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1918">A copy of <paramref name="format" /> in which format items are replaced by the string representations of <paramref name="arg0" /> and <paramref name="arg1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)]

<span data-ttu-id="3cd3e-1919">此方法使用 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将两个表达式转换为其字符串表示形式，并将这些表示形式嵌入字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1919">This method uses the [composite formatting feature](/dotnet/standard/base-types/composite-formatting) to convert two expressions to their string representations and to embed those representations in a string.</span></span> <span data-ttu-id="3cd3e-1920">在执行转换时，方法使用区分区域性的格式设置或自定义格式化程序。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1920">In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</span></span> <span data-ttu-id="3cd3e-1921">方法通过调用其 tostring <xref:System.Object> \*\* (IFormatProvider) \*\* 方法来将每个参数转换为其字符串表示形式; 如果对象的相应格式项包含格式字符串，则通过调用其 \*\*Tostring (string，IFormatProvider) \*\* 方法来将其转换为字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1921">The method converts each <xref:System.Object> argument to its string representation by calling its **ToString(IFormatProvider)** method or, if the object's corresponding format item includes a format string, by calling its **ToString(String,IFormatProvider)** method.</span></span> <span data-ttu-id="3cd3e-1922">如果这些方法不存在，它将调用对象的无参数 **ToString** 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1922">If these methods don't exist, it calls the object's parameterless **ToString** method.</span></span>

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-1923"><paramref name="format" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1923"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="3cd3e-1924"><paramref name="format" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1924"><paramref name="format" /> is invalid.</span></span>

<span data-ttu-id="3cd3e-1925">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1925">-or-</span></span>

<span data-ttu-id="3cd3e-1926">格式项的索引不为零或一。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1926">The index of a format item is not zero or one.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1, arg2)" />
      <MemberSignature Language="C#" Value="public static string? Format (string? format, object arg0, object arg1, object arg2);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="3cd3e-1927">[复合格式字符串](/dotnet/standard/base-types/composite-formatting)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1927">A [composite format string](/dotnet/standard/base-types/composite-formatting).</span></span></param>
        <param name="arg0"><span data-ttu-id="3cd3e-1928">要设置格式的第一个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1928">The first object to format.</span></span></param>
        <param name="arg1"><span data-ttu-id="3cd3e-1929">要设置格式的第二个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1929">The second object to format.</span></span></param>
        <param name="arg2"><span data-ttu-id="3cd3e-1930">要设置格式的第三个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1930">The third object to format.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1931">将字符串中的格式项替换为三个指定对象的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1931">Replaces the format items in a string with the string representation of three specified objects.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1932"><paramref name="format" /> 的副本，其中的格式项已替换为 <paramref name="arg0" />、<paramref name="arg1" /> 和 <paramref name="arg2" /> 的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1932">A copy of <paramref name="format" /> in which the format items have been replaced by the string representations of <paramref name="arg0" />, <paramref name="arg1" />, and <paramref name="arg2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)]

<span data-ttu-id="3cd3e-1933">此方法使用 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将三个表达式的值转换为其字符串表示形式，并将这些表示形式嵌入到字符串中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1933">This method uses the [composite formatting feature](/dotnet/standard/base-types/composite-formatting) to convert the value of three expressions to their string representations and to embed those representations in a string.</span></span>

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-format-three-arguments"></a><span data-ttu-id="3cd3e-1934">示例：设置三个参数的格式</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1934">Example: Format three arguments</span></span>

 <span data-ttu-id="3cd3e-1935">此示例使用 <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> 方法创建一个字符串，该字符串演示 `And` 具有两个整数值的布尔运算的结果。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1935">This example uses the <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> method to create a string that illustrates the result of a Boolean `And` operation with two integer values.</span></span> <span data-ttu-id="3cd3e-1936">请注意，格式字符串包含六个格式项，但该方法在其参数列表中只有三个项，因为每个项都以两种不同的方式进行格式设置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1936">Note that the format string includes six format items, but the method has only three items in its parameter list, because each item is formatted in two different ways.</span></span>

 [!code-cpp[System.String.Format#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp-interactive[System.String.Format#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-1937"><paramref name="format" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1937"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="3cd3e-1938"><paramref name="format" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1938"><paramref name="format" /> is invalid.</span></span>

<span data-ttu-id="3cd3e-1939">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1939">-or-</span></span>

<span data-ttu-id="3cd3e-1940">格式项的索引小于零，或者大于二。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1940">The index of a format item is less than zero, or greater than two.</span></span></exception>
        <related type="Article" href="/dotnet/standard/base-types/formatting-types"><span data-ttu-id="3cd3e-1941">设置 .NET 中类型的格式</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1941">Formatting Types in .NET</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/composite-formatting"><span data-ttu-id="3cd3e-1942">复合格式设置</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1942">Composite Formatting</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1, arg2)" />
      <MemberSignature Language="C#" Value="public static string? Format (IFormatProvider provider, string? format, object arg0, object arg1, object arg2);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="4" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="3cd3e-1943">一个提供区域性特定的格式设置信息的对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1943">An object that supplies culture-specific formatting information.</span></span></param>
        <param name="format"><span data-ttu-id="3cd3e-1944">[复合格式字符串](/dotnet/standard/base-types/composite-formatting)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1944">A [composite format string](/dotnet/standard/base-types/composite-formatting).</span></span></param>
        <param name="arg0"><span data-ttu-id="3cd3e-1945">要设置格式的第一个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1945">The first object to format.</span></span></param>
        <param name="arg1"><span data-ttu-id="3cd3e-1946">要设置格式的第二个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1946">The second object to format.</span></span></param>
        <param name="arg2"><span data-ttu-id="3cd3e-1947">要设置格式的第三个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1947">The third object to format.</span></span></param>
        <summary><span data-ttu-id="3cd3e-1948">将字符串中的格式项替换为三个指定对象的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1948">Replaces the format items in a string with the string representation of three specified objects.</span></span> <span data-ttu-id="3cd3e-1949">参数提供区域性特定的格式设置信息。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1949">An parameter supplies culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1950"><paramref name="format" /> 的副本，其中的格式项已替换为 <paramref name="arg0" />、<paramref name="arg1" /> 和 <paramref name="arg2" /> 的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1950">A copy of <paramref name="format" /> in which the format items have been replaced by the string representations of <paramref name="arg0" />, <paramref name="arg1" />, and <paramref name="arg2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)]

<span data-ttu-id="3cd3e-1951">此方法使用 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将三个表达式转换为其字符串表示形式，并将这些表示形式嵌入字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1951">This method uses the [composite formatting feature](/dotnet/standard/base-types/composite-formatting) to convert three expressions to their string representations and to embed those representations in a string.</span></span> <span data-ttu-id="3cd3e-1952">在执行转换时，方法使用区分区域性的格式设置或自定义格式化程序。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1952">In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</span></span> <span data-ttu-id="3cd3e-1953">方法通过调用其 tostring <xref:System.Object> \*\* (IFormatProvider) \*\* 方法来将每个参数转换为其字符串表示形式; 如果对象的相应格式项包含格式字符串，则通过调用其 \*\*Tostring (string，IFormatProvider) \*\* 方法来将其转换为字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1953">The method converts each <xref:System.Object> argument to its string representation by calling its **ToString(IFormatProvider)** method or, if the object's corresponding format item includes a format string, by calling its **ToString(String,IFormatProvider)** method.</span></span> <span data-ttu-id="3cd3e-1954">如果这些方法不存在，它将调用对象的无参数 **ToString** 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1954">If these methods don't exist, it calls the object's parameterless **ToString** method.</span></span>

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-1955"><paramref name="format" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1955"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="3cd3e-1956"><paramref name="format" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1956"><paramref name="format" /> is invalid.</span></span>

<span data-ttu-id="3cd3e-1957">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1957">-or-</span></span>

<span data-ttu-id="3cd3e-1958">格式项的索引小于零，或者大于二。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1958">The index of a format item is less than zero, or greater than two.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As CharEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CharEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; CharEnumerator" Usage="string.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3cd3e-1959">检索一个可以循环访问此字符串中的每个字符的对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1959">Retrieves an object that can iterate through the individual characters in this string.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1960">枚举器对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1960">An enumerator object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!TIP]
> <span data-ttu-id="3cd3e-1961">不是调用 <xref:System.String.GetEnumerator%2A> 方法来检索用于 <xref:System.CharEnumerator> 枚举字符串的对象，而应改为使用语言的迭代构造 (c # 中的 c + +/clr 和 Visual Basic) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1961">Rather than calling the <xref:System.String.GetEnumerator%2A> method to retrieve a <xref:System.CharEnumerator> object that you then use to enumerate a string, you should instead use your language's iteration construct (in C#, in C++/CLR, and in Visual Basic).</span></span> <span data-ttu-id="3cd3e-1962">c # 中的[foreach](/dotnet/csharp/language-reference/keywords/foreach-in) ，[适用](/cpp/dotnet/for-each-in)于 c + +/clr 中的每个，[每个](/dotnet/visual-basic/language-reference/statements/for-each-next-statement)Visual Basic) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1962">[foreach](/dotnet/csharp/language-reference/keywords/foreach-in) in C#, [for each](/cpp/dotnet/for-each-in) in C++/CLR, and [For Each](/dotnet/visual-basic/language-reference/statements/for-each-next-statement) in Visual Basic).</span></span>

 <span data-ttu-id="3cd3e-1963">此方法使您可以循环访问字符串中的单个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1963">This method enables you to iterate the individual characters in a string.</span></span> <span data-ttu-id="3cd3e-1964">例如，Visual Basic `For Each` 和 c # `foreach` 语句调用此方法以返回一个 <xref:System.CharEnumerator> 对象，该对象可提供对此字符串实例中字符的只读访问。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1964">For example, the Visual Basic `For Each` and C# `foreach` statements invoke this method to return a <xref:System.CharEnumerator> object that can provide read-only access to the characters in this string instance.</span></span>



## Examples
 <span data-ttu-id="3cd3e-1965">下面的示例将循环访问多个字符串中的字符，并显示有关其各个字符的信息。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1965">The following example iterates the characters in several strings and displays information about their individual characters.</span></span> <span data-ttu-id="3cd3e-1966">它使用语言迭代构造，而不是调用 <xref:System.String.GetEnumerator%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1966">It uses the language iteration construct rather than a call to the <xref:System.String.GetEnumerator%2A> method.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="P:System.String.Chars(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="string.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3cd3e-1967">返回该字符串的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1967">Returns the hash code for this string.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-1968">32 位有符号整数哈希代码。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1968">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-1969">的行为 <xref:System.String.GetHashCode%2A> 依赖于其实现，该实现可能会从公共语言运行时的一个版本更改为另一个版本。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1969">The behavior of <xref:System.String.GetHashCode%2A> is dependent on its implementation, which might change from one version of the common language runtime to another.</span></span> <span data-ttu-id="3cd3e-1970">导致这种情况的原因是提高的性能 <xref:System.String.GetHashCode%2A> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1970">A reason why this might happen is to improve the performance of <xref:System.String.GetHashCode%2A>.</span></span>

> [!IMPORTANT]
>  <span data-ttu-id="3cd3e-1971">如果两个字符串对象相等，则该 <xref:System.String.GetHashCode%2A> 方法将返回相同的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1971">If two string objects are equal, the <xref:System.String.GetHashCode%2A> method returns identical values.</span></span> <span data-ttu-id="3cd3e-1972">但是，每个唯一字符串值没有唯一的哈希代码值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1972">However, there is not a unique hash code value for each unique string value.</span></span> <span data-ttu-id="3cd3e-1973">不同的字符串可以返回相同的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1973">Different strings can return the same hash code.</span></span>
>
>  <span data-ttu-id="3cd3e-1974">哈希代码本身不一定是稳定的。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1974">The hash code itself is not guaranteed to be stable.</span></span> <span data-ttu-id="3cd3e-1975">相同字符串的哈希代码可跨 .net 实现、跨 .NET 版本和跨 .NET 平台 (例如，.NET 的单个版本32位和64位) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1975">Hash codes for identical strings can differ across .NET implementations, across .NET versions, and across .NET platforms (such as 32-bit and 64-bit) for a single version of .NET.</span></span> <span data-ttu-id="3cd3e-1976">在某些情况下，它们甚至不同于应用程序域。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1976">In some cases, they can even differ by application domain.</span></span> <span data-ttu-id="3cd3e-1977">这意味着，同一程序的两次后续运行可能返回不同的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1977">This implies that two subsequent runs of the same program may return different hash codes.</span></span>
>
>  <span data-ttu-id="3cd3e-1978">因此，哈希代码决不能在创建它们的应用程序域的外部使用，它们永远不应用作集合中的键字段，它们永远不会保留。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1978">As a result, hash codes should never be used outside of the application domain in which they were created, they should never be used as key fields in a collection, and they should never be persisted.</span></span>
>
>  <span data-ttu-id="3cd3e-1979">最后，如果需要加密型强哈希，请不要使用哈希代码（而不是加密哈希函数返回的值）。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1979">Finally, don't use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</span></span> <span data-ttu-id="3cd3e-1980">对于加密哈希，请使用派生自 <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> 或类的类 <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1980">For cryptographic hashes, use a class derived from the <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> or <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> class.</span></span>
>
>  <span data-ttu-id="3cd3e-1981">有关哈希代码的详细信息，请参阅 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1981">For more information about hash codes, see <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="3cd3e-1982">在桌面应用中，你可以使用[ \<UseRandomizedStringHashAlgorithm> 元素](/dotnet/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element)基于每个应用程序域生成唯一的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1982">In desktop apps, you can use the [\<UseRandomizedStringHashAlgorithm> element](/dotnet/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element) to generate unique hash codes on a per application domain basis.</span></span> <span data-ttu-id="3cd3e-1983">这可以减少冲突数，并改善使用哈希表的插入和查找的整体性能。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1983">This can reduce the number of collisions and improve the overall performance of insertions and lookups that use hash tables.</span></span> <span data-ttu-id="3cd3e-1984">下面的示例演示如何使用[ \<UseRandomizedStringHashAlgorithm> 元素](/dotnet/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1984">The following example shows how to use the [\<UseRandomizedStringHashAlgorithm> element](/dotnet/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element).</span></span> <span data-ttu-id="3cd3e-1985">它定义一个 `DisplayString` 类，该类包含一个私有字符串常量， `s` 其值为 "This is a string"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1985">It defines a `DisplayString` class that includes a private string constant, `s`, whose value is "This is a string."</span></span> <span data-ttu-id="3cd3e-1986">它还包括显示字符串值及其哈希代码的 `ShowStringHashCode` 方法以及该方法在其中执行的应用程序域的名称。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1986">It also includes a `ShowStringHashCode` method that displays the string value and its hash code along with the name of the application domain in which the method is executing.</span></span>

 [!code-csharp[System.String.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]

 <span data-ttu-id="3cd3e-1987">当您在未提供配置文件的情况下运行该示例时，它会显示类似下面的输出。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1987">When you run the example without supplying a configuration file, it displays output similar to the following.</span></span> <span data-ttu-id="3cd3e-1988">请注意，字符串的散列码在两个应用程序域中是相同的。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1988">Note that the hash codes for the string are identical in the two application domains.</span></span>

```
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC
String 'This is a string.' in domain 'NewDomain': 941BCEAC
```

 <span data-ttu-id="3cd3e-1989">但是，如果将以下配置文件添加到示例目录，然后运行该示例，则同一个字符串的哈希代码将通过应用程序域进行区分。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1989">However, if you add the following configuration file to the example's directory and then run the example, the hash codes for the same string will differ by application domain.</span></span>

```xml
<?xml version ="1.0"?>
<configuration>
   <runtime>
      <UseRandomizedStringHashAlgorithm enabled="1" />
   </runtime>
</configuration>
```

 <span data-ttu-id="3cd3e-1990">存在配置文件时，示例会显示以下输出：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1990">When the configuration file is present, the example displays the following output:</span></span>

```
String 'This is a string.' in domain 'PerDomain.exe': 5435776D
String 'This is a string.' in domain 'NewDomain': 75CC8236
```

> [!IMPORTANT]
>  <span data-ttu-id="3cd3e-1991">哈希代码用于有效地从哈希表中插入和检索密钥对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1991">Hash codes are used to insert and retrieve keyed objects from hash tables efficiently.</span></span> <span data-ttu-id="3cd3e-1992">但哈希代码不能唯一标识字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1992">However, hash codes don't uniquely identify strings.</span></span> <span data-ttu-id="3cd3e-1993">相同的字符串具有相同的哈希代码，但公共语言运行时还可以将相同的哈希代码分配给不同的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1993">Identical strings have  equal hash codes, but the common language runtime can also assign the same hash code to different strings.</span></span> <span data-ttu-id="3cd3e-1994">此外，哈希代码可根据 .NET 版本、单个版本内的平台和应用程序域的不同而不同。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1994">In addition, hash codes can vary by version of .NET, by platform within a single version, and by application domain.</span></span> <span data-ttu-id="3cd3e-1995">因此，不应序列化或保留哈希代码值，也不应将其用作哈希表或字典中的键。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1995">Because of this, you should not serialize or persist hash code values, nor should you use them as keys in a hash table or dictionary.</span></span>

 <span data-ttu-id="3cd3e-1996">有关哈希代码和方法的使用的其他信息 `GetHashCode` ，请参阅 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1996">For additional information about the use of hash codes and the `GetHashCode` method, see <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>



## Examples
 <span data-ttu-id="3cd3e-1997">下面的示例演示 <xref:System.String.GetHashCode%2A> 使用各种输入字符串的方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1997">The following example demonstrates the <xref:System.String.GetHashCode%2A> method using various input strings.</span></span>

 [!code-cpp[system.string.gethashcode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]

 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-1998">返回的值 <see cref="M:System.String.GetHashCode" /> 与平台相关。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1998">The value returned by <see cref="M:System.String.GetHashCode" /> is platform-dependent.</span></span> <span data-ttu-id="3cd3e-1999">它在 .NET Framework 的32位和64位版本上有所不同。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-1999">It differs on the 32-bit and 64-bit versions of the .NET Framework.</span></span> <span data-ttu-id="3cd3e-2000">它还可能在不同版本的 .NET Framework 和 .NET Core 之间有所不同。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2000">It also can differ between versions of the .NET Framework and .NET Core.</span></span></para></block>
        <altmember cref="M:System.Object.GetHashCode" />
        <related type="Article" href="/dotnet/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element"><span data-ttu-id="3cd3e-2001">&lt;UseRandomizedStringHashAlgorithm &gt; 元素</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2001">&lt;UseRandomizedStringHashAlgorithm&gt; Element</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (value As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="System.string.GetHashCode value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-2002">一个只读字符范围。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2002">A read-only character span.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2003">返回所提供的只读字符范围的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2003">Returns the hash code for the provided read-only character span.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2004">32 位有符号整数哈希代码。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2004">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode(StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : StringComparison -&gt; int" Usage="string.GetHashCode comparisonType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="comparisonType"><span data-ttu-id="3cd3e-2005">一个枚举值，用于指定比较中要使用的规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2005">One of the enumeration values that specifies the rules to use in the comparison.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2006">使用指定的规则返回此字符串的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2006">Returns the hash code for this string using the specified rules.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2007">32 位有符号整数哈希代码。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2007">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : ReadOnlySpan&lt;char&gt; * StringComparison -&gt; int" Usage="System.string.GetHashCode (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-2008">一个只读字符范围。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2008">A read-only character span.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="3cd3e-2009">一个枚举值，用于指定比较中要使用的规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2009">One of the enumeration values that specifies the rules to use in the comparison.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2010">使用指定的规则返回所提供的只读字符范围的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2010">Returns the hash code for the provided read-only character span using the specified rules.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2011">32 位有符号整数哈希代码。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2011">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPinnableReference">
      <MemberSignature Language="C#" Value="public ref readonly char GetPinnableReference ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char GetPinnableReference() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetPinnableReference" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPinnableReference () As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; char ^ GetPinnableReference();" />
      <MemberSignature Language="F#" Value="member this.GetPinnableReference : unit -&gt; char" Usage="string.GetPinnableReference " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Char</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-5.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3cd3e-2012">返回对索引 0 处字符串的元素的引用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2012">Returns a reference to the element of the string at index zero.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2013">一个字符，表示对索引 0 处字符串的元素的引用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2013">A character representing the reference to the element of the string at index zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3cd3e-2014">`GetPinnableReference`方法返回一个可用于 <xref:System.String> 在内存中固定的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2014">The `GetPinnableReference` method returns a character that can be used for pinning a <xref:System.String> in memory.</span></span> <span data-ttu-id="3cd3e-2015">需要在 <xref:System.String> fixed 语句中支持的使用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2015">It is required to support the use of a <xref:System.String> within a fixed statement.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="3cd3e-2016">字符串为 NULL。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2016">The string is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="string.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3cd3e-2017">返回 <see cref="T:System.String" /> 类的 <see cref="T:System.TypeCode" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2017">Returns the <see cref="T:System.TypeCode" /> for the <see cref="T:System.String" /> class.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2018">枚举常数 <see cref="F:System.TypeCode.String" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2018">The enumerated constant, <see cref="F:System.TypeCode.String" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 <span data-ttu-id="3cd3e-2019">下面的示例显示了 <xref:System.TypeCode> 类型的枚举常数 <xref:System.String> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2019">The following example displays the <xref:System.TypeCode> enumerated constant for the <xref:System.String> type.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3cd3e-2020">报告指定 Unicode 字符或字符串在此实例中的第一个匹配项的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2020">Reports the zero-based index of the first occurrence of a specified Unicode character or string within this instance.</span></span> <span data-ttu-id="3cd3e-2021">如果未在此实例中找到该字符或字符串，则此方法返回 -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2021">The method returns -1 if the character or string is not found in this instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-2022">要查找的 Unicode 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2022">A Unicode character to seek.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2023">报告指定 Unicode 字符在此字符串中的第一个匹配项的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2023">Reports the zero-based index of the first occurrence of the specified Unicode character in this string.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2024">如果找到该字符，则为 <paramref name="value" /> 的从零开始的索引位置；如果未找到，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2024">The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2025">索引编号从0开始。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2025">Index numbering starts from zero.</span></span>

 <span data-ttu-id="3cd3e-2026">此方法执行一个序号 (不区分区域性的) 搜索，其中，仅当字符的 Unicode 标量值相同时，才将其视为等效于另一个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2026">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="3cd3e-2027">若要执行区分区域性的搜索，请使用 <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> 方法，其中表示预构成字符的 Unicode 标量值（如连字 "Æ" (U + 00C6) ）可能被视为等效于正确序列中任何字符的组成部分（例如 "AE" (U + 0041，u + 0045) ，具体取决于区域性）。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2027">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2028">下面的示例演示如何 <xref:System.String> 使用方法搜索字符 <xref:System.String.IndexOf%2A> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2028">The following example demonstrates how you can search a <xref:System.String> for a character using the <xref:System.String.IndexOf%2A> method.</span></span>

 [!code-cpp[System.String.IndexOf#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp-interactive[System.String.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-2029">要搜寻的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2029">The string to seek.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2030">报告指定字符串在此实例中的第一个匹配项的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2030">Reports the zero-based index of the first occurrence of the specified string in this instance.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2031">如果找到该字符串，则为 <paramref name="value" /> 的从零开始的索引位置；如果未找到该字符串，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2031">The zero-based index position of <paramref name="value" /> if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="3cd3e-2032">如果 <paramref name="value" /> 为 <see cref="F:System.String.Empty" />，则返回值为 0。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2032">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2033">索引编号从0开始。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2033">Index numbering starts from zero.</span></span>

 <span data-ttu-id="3cd3e-2034">此方法使用当前区域性执行 (区分大小写和区分区域性的) 搜索。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2034">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span> <span data-ttu-id="3cd3e-2035">搜索从该实例的第一个字符位置开始，并继续到最后一个字符的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2035">The search begins at the first character position of this instance and continues until the last character position.</span></span>

 <span data-ttu-id="3cd3e-2036">字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2036">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-2037">在区分区域性的搜索中，如果 `value` 包含一个可忽略字符，则结果与移除了该字符的搜索等效。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2037">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="3cd3e-2038">如果 `value` 仅包含一个或多个可忽略字符，则该 <xref:System.String.IndexOf%28System.String%29> 方法将始终返回 0 (零) ，以指示在当前实例的开头处找到匹配项。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2038">If `value` consists only of one or more ignorable characters, the <xref:System.String.IndexOf%28System.String%29> method always returns 0 (zero) to indicate that the match is found at the beginning of the current instance.</span></span> <span data-ttu-id="3cd3e-2039">在下面的示例中， <xref:System.String.IndexOf%28System.String%29> 方法用于查找 (软连字符的三个子字符串 (U + 00AD) ，软连字符后跟 "n"，软连字符后跟两个字符串中的 "m" ) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2039">In the following example, the <xref:System.String.IndexOf%28System.String%29> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</span></span> <span data-ttu-id="3cd3e-2040">只有一个字符串包含软连字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2040">Only one of the strings contains a soft hyphen.</span></span> <span data-ttu-id="3cd3e-2041">如果该示例在 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 或更高版本上运行，则在每种情况下，因为软连字符是可忽略字符，所以，结果与中未包含软连字符的结果相同 `value` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2041">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in each case, because the soft hyphen is an ignorable character, the result is the same as if the soft hyphen had not been included in `value`.</span></span> <span data-ttu-id="3cd3e-2042">仅搜索软连字符时，方法将返回 0 (零) ，以指示它已在字符串的开头找到匹配项。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2042">When searching for a soft hyphen only, the method returns 0 (zero) to indicate that it has found a match at the beginning of the string.</span></span>

 [!code-csharp[System.String.IndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]



## Examples
 <span data-ttu-id="3cd3e-2043">下面的示例在 "动物" 中搜索 "n"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2043">The following example searches for the "n" in "animal".</span></span> <span data-ttu-id="3cd3e-2044">因为字符串索引从零开始，而不是从零开始，所以 <xref:System.String.IndexOf%28System.String%29> 方法指示 "n" 位于位置1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2044">Because string indexes begin at zero rather than one, the <xref:System.String.IndexOf%28System.String%29> method indicates that the "n" is at position 1.</span></span>

 [!code-cpp[System.String.IndexOf#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp-interactive[System.String.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]

 <span data-ttu-id="3cd3e-2045">下面的示例使用 <xref:System.String.IndexOf%2A> 方法来确定某一句子中动物名称的起始位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2045">The following example uses the <xref:System.String.IndexOf%2A> method to determine the starting position of an animal name in a sentence.</span></span> <span data-ttu-id="3cd3e-2046">然后，它将使用此位置插入描述动物的形容词。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2046">It then uses this position to insert an adjective that describes the animal into the sentence.</span></span>

 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2047"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2047"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-2048">如 [使用字符串的最佳做法](/dotnet/standard/base-types/best-practices-strings)中所述，建议你避免调用替换默认值的字符串比较方法，并改为调用需要显式指定参数的方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2048">As explained in [Best Practices for Using Strings](/dotnet/standard/base-types/best-practices-strings), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="3cd3e-2049">若要使用当前区域性的比较规则查找字符串实例内子字符串的第一个索引，请使用 <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> 其参数的值调用方法重载 <see cref="F:System.StringComparison.CurrentCulture" /> `comparisonType` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2049">To find the first index of a substring within a string instance by using the comparison rules of the current culture, call the <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its `comparisonType` parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-2050">要查找的 Unicode 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2050">A Unicode character to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3cd3e-2051">搜索起始位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2051">The search starting position.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2052">报告指定 Unicode 字符在此字符串中的第一个匹配项的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2052">Reports the zero-based index of the first occurrence of the specified Unicode character in this string.</span></span> <span data-ttu-id="3cd3e-2053">该搜索从指定字符位置开始。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2053">The search starts at a specified character position.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2054">如果找到该字符，则为从字符串的起始位置开始的 <paramref name="value" /> 从零开始的索引位置；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2054">The zero-based index position of <paramref name="value" /> from the start of the string if that character is found, or -1 if it is not.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2055">索引编号从0开始。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2055">Index numbering starts from 0.</span></span> <span data-ttu-id="3cd3e-2056">`startIndex` 参数可以介于 0 到字符串实例的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2056">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span> <span data-ttu-id="3cd3e-2057">如果 `startIndex` 等于字符串实例的长度，则此方法返回-1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2057">If `startIndex` equals the length of the string instance, the method returns -1.</span></span>

 <span data-ttu-id="3cd3e-2058">搜索范围从 `startIndex` 到字符串的末尾。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2058">The search ranges from `startIndex` to the end of the string.</span></span>

 <span data-ttu-id="3cd3e-2059">此方法执行一个序号 (不区分区域性的) 搜索，其中，仅当字符的 Unicode 标量值相同时，才将其视为等效于另一个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2059">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="3cd3e-2060">若要执行区分区域性的搜索，请使用 <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> 方法，其中表示预构成字符的 Unicode 标量值（如连字 "Æ" (U + 00C6) ）可能被视为等效于正确序列中任何字符的组成部分（例如 "AE" (U + 0041，u + 0045) ，具体取决于区域性）。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2060">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2061">下面的示例演示 <xref:System.String.IndexOf%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2061">The following example demonstrates the <xref:System.String.IndexOf%2A> method.</span></span>

 [!code-cpp[string.indexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp-interactive[string.indexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-2062"><paramref name="startIndex" /> 小于 0（零）或大于此字符串的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2062"><paramref name="startIndex" /> is less than 0 (zero) or greater than the length of the string.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-2063">要查找的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2063">The character to seek.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="3cd3e-2064">指定搜索规则的枚举值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2064">An enumeration value that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2065">报告指定 Unicode 字符在此字符串中的第一个匹配项的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2065">Reports the zero-based index of the first occurrence of the specified Unicode character in this string.</span></span> <span data-ttu-id="3cd3e-2066">一个参数指定要用于指定字符的搜索类型。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2066">A parameter specifies the type of search to use for the specified character.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2067">如果找到该字符，则为 <paramref name="value" /> 的从零开始的索引位置；如果未找到，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2067">The zero-based index of <paramref name="value" /> if that character is found, or -1 if it is not.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3cd3e-2068">索引编号从0开始。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2068">Index numbering starts from zero.</span></span>

<span data-ttu-id="3cd3e-2069">`comparisonType`参数是一个 <xref:System.StringComparison> 枚举成员，用于指定对参数的搜索 `value` 是使用当前还是固定的区域性，区分大小写或不区分大小写，或者使用单词或序号比较规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2069">The `comparisonType` parameter is a <xref:System.StringComparison> enumeration member that specifies whether the search for the `value` argument uses the current or invariant culture, is case-sensitive or case-insensitive, or uses word or ordinal comparison rules.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-2070"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2070"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-2071">要搜寻的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2071">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3cd3e-2072">搜索起始位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2072">The search starting position.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2073">报告指定字符串在此实例中的第一个匹配项的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2073">Reports the zero-based index of the first occurrence of the specified string in this instance.</span></span> <span data-ttu-id="3cd3e-2074">该搜索从指定字符位置开始。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2074">The search starts at a specified character position.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2075">如果找到该字符串，则为从当前实例的起始位置开始的从零开始的 <paramref name="value" /> 的索引位置；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2075">The zero-based index position of <paramref name="value" /> from the start of the current instance if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="3cd3e-2076">如果 <paramref name="value" /> 为 <see cref="F:System.String.Empty" />，则返回值为 <paramref name="startIndex" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2076">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2077">索引编号从0开始。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2077">Index numbering starts from 0.</span></span> <span data-ttu-id="3cd3e-2078">`startIndex` 参数可以介于 0 到字符串实例的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2078">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span> <span data-ttu-id="3cd3e-2079">如果 `startIndex` 等于字符串实例的长度，则此方法返回-1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2079">If `startIndex` equals the length of the string instance, the method returns -1.</span></span>

 <span data-ttu-id="3cd3e-2080">此方法使用当前区域性执行 (区分大小写和区分区域性的) 搜索。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2080">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span> <span data-ttu-id="3cd3e-2081">搜索从 `startIndex` 该实例的字符位置开始，并继续到最后一个字符的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2081">The search begins at the `startIndex` character position of this instance and continues until the last character position.</span></span>

 <span data-ttu-id="3cd3e-2082">字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2082">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-2083">在区分区域性的搜索中，如果 `value` 包含一个可忽略字符，则结果与移除了该字符的搜索等效。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2083">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="3cd3e-2084">如果 `value` 仅包含一个或多个可忽略字符，则该 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> 方法将始终返回 `startIndex` ，这是搜索开始处的字符位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2084">If `value` consists only of one or more ignorable characters, the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> method always returns `startIndex`, which is the character position at which the search begins.</span></span> <span data-ttu-id="3cd3e-2085">在下面的示例中， <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> 方法用于查找软连字符 (U + 00AD 的位置) 后跟两个字符串中的 "m"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2085">In the following example, the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" in two strings.</span></span> <span data-ttu-id="3cd3e-2086">只有一个字符串包含必需的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2086">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="3cd3e-2087">如果本示例在 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 或更高版本上运行，则在这两种情况下，因为软连字符是可忽略字符，该方法将返回字符串中的 "m" 的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2087">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string.</span></span> <span data-ttu-id="3cd3e-2088">注意对于第一个字符串，包含软连字符后跟“m”，该方法无法返回该软连字符的索引，而是返回“m”的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2088">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span>

 [!code-csharp[System.String.IndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]



## Examples
 <span data-ttu-id="3cd3e-2089">下面的示例在目标字符串中搜索指定字符串的所有匹配项。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2089">The following example searches for all occurrences of a specified string within a target string.</span></span>

 [!code-cpp[stringindexof4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2090"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2090"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-2091"><paramref name="startIndex" /> 小于 0（零）或大于此字符串的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2091"><paramref name="startIndex" /> is less than 0 (zero) or greater than the length of this string.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-2092">如 [使用字符串的最佳做法](/dotnet/standard/base-types/best-practices-strings)中所述，建议你避免调用替换默认值的字符串比较方法，并改为调用需要显式指定参数的方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2092">As explained in [Best Practices for Using Strings](/dotnet/standard/base-types/best-practices-strings), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="3cd3e-2093">若要通过使用当前区域性的比较规则查找特定字符位置之后发生的子字符串的第一个索引，请使用 <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> 值为的参数调用方法重载 <see cref="F:System.StringComparison.CurrentCulture" /> `comparisonType` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2093">To find the first index of a substring that occurs after a particular character position by using the comparison rules of the current culture, call the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its `comparisonType` parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-2094">要搜寻的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2094">The string to seek.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="3cd3e-2095">指定搜索规则的枚举值之一。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2095">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2096">报告指定的字符串在当前 <see cref="T:System.String" /> 对象中的第一个匹配项的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2096">Reports the zero-based index of the first occurrence of the specified string in the current <see cref="T:System.String" /> object.</span></span> <span data-ttu-id="3cd3e-2097">一个参数指定要用于指定字符串的搜索类型。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2097">A parameter specifies the type of search to use for the specified string.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2098">如果找到该字符串，则为 <paramref name="value" /> 参数的索引位置；如果未找到该字符串，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2098">The index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="3cd3e-2099">如果 <paramref name="value" /> 为 <see cref="F:System.String.Empty" />，则返回值为 0。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2099">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2100">索引编号从0开始。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2100">Index numbering starts from zero.</span></span>

 <span data-ttu-id="3cd3e-2101">`comparisonType`参数指定 `value` 使用当前或固定区域性搜索参数，使用区分大小写或不区分大小写的搜索，以及使用 word 或序号比较规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2101">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2102">下面的示例演示了方法的三个重载 <xref:System.String.IndexOf%2A> ，这些重载使用枚举的不同值在另一个字符串内查找字符串的第一个匹配项 <xref:System.StringComparison> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2102">The following example demonstrates three overloads of the <xref:System.String.IndexOf%2A> method that find the first occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>

 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2103"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2103"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-2104"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2104"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-2105">字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2105">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-2106">在区分区域性的搜索 (即，如果 <paramref name="comparisonType" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2106">In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="3cd3e-2107">如果 <paramref name="value" /> 仅包含一个或多个可忽略字符，则该 <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> 方法将始终返回 0 (零) ，以指示在当前实例的开头处找到匹配项。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2107">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> method always returns 0 (zero) to indicate that the match is found at the beginning of the current instance.</span></span>

<span data-ttu-id="3cd3e-2108">在下面的示例中， <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> 方法用于查找 (软连字符的三个子字符串 (U + 00AD) ，软连字符后跟 "n"，软连字符后跟两个字符串中的 "m" ) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2108">In the following example, the <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</span></span> <span data-ttu-id="3cd3e-2109">只有一个字符串包含软连字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2109">Only one of the strings contains a soft hyphen.</span></span> <span data-ttu-id="3cd3e-2110">如果本示例在 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 或更高版本上运行，因为软连字符是可忽略的字符，所以区分区域性的搜索返回的值与在搜索字符串中未包含软连字符时返回的值相同。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2110">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, because the soft hyphen is an ignorable character, a culture-sensitive search returns the same value that it would return if the soft hyphen were not included in the search string.</span></span> <span data-ttu-id="3cd3e-2111">不过，序号搜索成功地在一个字符串中查找软连字符，并报告从第二个字符串中缺少它。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2111">An ordinal search, however, successfully finds the soft hyphen in one string and reports that it is absent from the second string.</span></span>

<span data-ttu-id="3cd3e-2112">[！ code-csharp[IndexOf # 26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable26.cs#26)][！ code-vb[IndexOf # 26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable26.vb#26)]</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2112">[!code-csharp[System.String.IndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable26.cs#26)] [!code-vb[System.String.IndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable26.vb#26)]</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-2113">要查找的 Unicode 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2113">A Unicode character to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3cd3e-2114">搜索起始位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2114">The search starting position.</span></span></param>
        <param name="count"><span data-ttu-id="3cd3e-2115">要检查的字符位置数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2115">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2116">报告指定字符在此实例中的第一个匹配项的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2116">Reports the zero-based index of the first occurrence of the specified character in this instance.</span></span> <span data-ttu-id="3cd3e-2117">搜索从指定字符位置开始，并检查指定数量的字符位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2117">The search starts at a specified character position and examines a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2118">如果找到该字符，则为从字符串的起始位置开始的 <paramref name="value" /> 从零开始的索引位置；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2118">The zero-based index position of <paramref name="value" /> from the start of the string if that character is found, or -1 if it is not.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2119">搜索从开始 `startIndex` ，并继续到 `startIndex`  +  `count` -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2119">The search begins at `startIndex` and continues to `startIndex` + `count` -1.</span></span> <span data-ttu-id="3cd3e-2120">位于处的字符 `startIndex`  +  `count` 不包含在搜索中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2120">The character at `startIndex` + `count` is not included in the search.</span></span>

 <span data-ttu-id="3cd3e-2121">索引编号从 0 (零开始) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2121">Index numbering starts from 0 (zero).</span></span> <span data-ttu-id="3cd3e-2122">`startIndex` 参数可以介于 0 到字符串实例的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2122">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span>

 <span data-ttu-id="3cd3e-2123">此方法执行一个序号 (不区分区域性的) 搜索，其中，仅当字符的 Unicode 标量值相同时，才将其视为等效于另一个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2123">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="3cd3e-2124">若要执行区分区域性的搜索，请使用 <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> 方法，其中表示预构成字符的 Unicode 标量值（如连字 "Æ" (U + 00C6) ）可能被视为等效于正确序列中任何字符的组成部分（例如 "AE" (U + 0041，u + 0045) ，具体取决于区域性）。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2124">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2125">下面的示例演示 <xref:System.String.IndexOf%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2125">The following example demonstrates the <xref:System.String.IndexOf%2A> method.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-2126"><paramref name="count" /> 或 <paramref name="startIndex" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2126"><paramref name="count" /> or <paramref name="startIndex" /> is negative.</span></span>

<span data-ttu-id="3cd3e-2127">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2127">-or-</span></span>

 <span data-ttu-id="3cd3e-2128"><paramref name="startIndex" /> 大于此字符串的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2128"><paramref name="startIndex" /> is greater than the length of this string.</span></span>

<span data-ttu-id="3cd3e-2129">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2129">-or-</span></span>

 <span data-ttu-id="3cd3e-2130"><paramref name="count" /> 大于此字符串的长度减 <paramref name="startIndex" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2130"><paramref name="count" /> is greater than the length of this string minus <paramref name="startIndex" />.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-2131">要搜寻的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2131">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3cd3e-2132">搜索起始位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2132">The search starting position.</span></span></param>
        <param name="count"><span data-ttu-id="3cd3e-2133">要检查的字符位置数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2133">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2134">报告指定字符串在此实例中的第一个匹配项的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2134">Reports the zero-based index of the first occurrence of the specified string in this instance.</span></span> <span data-ttu-id="3cd3e-2135">搜索从指定字符位置开始，并检查指定数量的字符位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2135">The search starts at a specified character position and examines a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2136">如果找到该字符串，则为从当前实例的起始位置开始的从零开始的 <paramref name="value" /> 的索引位置；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2136">The zero-based index position of <paramref name="value" /> from the start of the current instance if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="3cd3e-2137">如果 <paramref name="value" /> 为 <see cref="F:System.String.Empty" />，则返回值为 <paramref name="startIndex" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2137">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2138">索引编号从 0 (零开始) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2138">Index numbering starts from 0 (zero).</span></span> <span data-ttu-id="3cd3e-2139">`startIndex` 参数可以介于 0 到字符串实例的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2139">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span>

 <span data-ttu-id="3cd3e-2140">此方法使用当前区域性执行 (区分大小写和区分区域性的) 搜索。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2140">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span> <span data-ttu-id="3cd3e-2141">搜索从开始 `startIndex` ，并继续到 `startIndex`  +  `count` -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2141">The search begins at `startIndex` and continues to `startIndex` + `count` -1.</span></span> <span data-ttu-id="3cd3e-2142">位于处的字符 `startIndex`  +  `count` 不包含在搜索中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2142">The character at `startIndex` + `count` is not included in the search.</span></span>

 <span data-ttu-id="3cd3e-2143">字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2143">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-2144">在区分区域性的搜索中，如果 `value` 包含一个可忽略字符，则结果与移除了该字符的搜索等效。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2144">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="3cd3e-2145">如果 `value` 仅包含一个或多个可忽略字符，则该 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> 方法将始终返回 `startIndex` ，这是搜索开始处的字符位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2145">If `value` consists only of one or more ignorable characters, the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> method always returns `startIndex`, which is the character position at which the search begins.</span></span> <span data-ttu-id="3cd3e-2146">在下面的示例中， <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> 方法用于查找软连字符 (U + 00AD) 的位置，并在两个字符串中从第三个到第六个字符位置开始的 "m"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2146">In the following example, the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting in the third through sixth character positions in two strings.</span></span> <span data-ttu-id="3cd3e-2147">只有一个字符串包含必需的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2147">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="3cd3e-2148">如果该示例在 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 或更高版本上运行，则在这两种情况下，因为软连字符是可忽略的字符，所以当执行区分区域性的比较时，该方法将返回字符串中的 "m" 的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2148">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-2149">注意对于第一个字符串，包含软连字符后跟“m”，该方法无法返回该软连字符的索引，而是返回“m”的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2149">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span>

 [!code-csharp[System.String.IndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]



## Examples
 <span data-ttu-id="3cd3e-2150">下面的示例查找字符串 "he" 在另一个字符串的子字符串中的所有匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2150">The following example finds the index of all occurrences of the string "he" within a substring of another string.</span></span> <span data-ttu-id="3cd3e-2151">请注意，必须为每个搜索迭代重新计算要搜索的字符数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2151">Note that the number of characters to be searched must be recalculated for each search iteration.</span></span>

 [!code-cpp[string.indexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp-interactive[string.indexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2152"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2152"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-2153"><paramref name="count" /> 或 <paramref name="startIndex" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2153"><paramref name="count" /> or <paramref name="startIndex" /> is negative.</span></span>

<span data-ttu-id="3cd3e-2154">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2154">-or-</span></span>

 <span data-ttu-id="3cd3e-2155"><paramref name="startIndex" /> 大于此字符串的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2155"><paramref name="startIndex" /> is greater than the length of this string.</span></span>

<span data-ttu-id="3cd3e-2156">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2156">-or-</span></span>

 <span data-ttu-id="3cd3e-2157"><paramref name="count" /> 大于此字符串的长度减 <paramref name="startIndex" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2157"><paramref name="count" /> is greater than the length of this string minus <paramref name="startIndex" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-2158">如 [使用字符串的最佳做法](/dotnet/standard/base-types/best-practices-strings)中所述，建议你避免调用替换默认值的字符串比较方法，并改为调用需要显式指定参数的方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2158">As explained in [Best Practices for Using Strings](/dotnet/standard/base-types/best-practices-strings), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="3cd3e-2159">若要使用当前区域性的比较规则来执行此操作，请使用的 <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> 参数的值调用方法重载 <see cref="F:System.StringComparison.CurrentCulture" /> `comparisonType` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2159">To use the comparison rules of the current culture to perform this operation, call the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its `comparisonType` parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-2160">要搜寻的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2160">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3cd3e-2161">搜索起始位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2161">The search starting position.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="3cd3e-2162">指定搜索规则的枚举值之一。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2162">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2163">报告指定的字符串在当前 <see cref="T:System.String" /> 对象中的第一个匹配项的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2163">Reports the zero-based index of the first occurrence of the specified string in the current <see cref="T:System.String" /> object.</span></span> <span data-ttu-id="3cd3e-2164">参数指定当前字符串中的起始搜索位置以及用于指定字符串的搜索类型。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2164">Parameters specify the starting search position in the current string and the type of search to use for the specified string.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2165">如果找到该字符串，则为从当前实例的起始位置开始的从零开始的 <paramref name="value" /> 参数索引位置；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2165">The zero-based index position of the <paramref name="value" /> parameter from the start of the current instance if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="3cd3e-2166">如果 <paramref name="value" /> 为 <see cref="F:System.String.Empty" />，则返回值为 <paramref name="startIndex" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2166">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2167">索引编号从0开始。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2167">Index numbering starts from 0.</span></span> <span data-ttu-id="3cd3e-2168">`startIndex` 参数可以介于 0 到字符串实例的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2168">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span> <span data-ttu-id="3cd3e-2169">如果 `startIndex` 等于字符串实例的长度，则此方法返回-1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2169">If `startIndex` equals the length of the string instance, the method returns -1.</span></span>

 <span data-ttu-id="3cd3e-2170">`comparisonType`参数指定 `value` 使用当前或固定区域性搜索参数，使用区分大小写或不区分大小写的搜索，以及使用 word 或序号比较规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2170">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2171">下面的示例演示了方法的三个重载 <xref:System.String.IndexOf%2A> ，这些重载使用枚举的不同值在另一个字符串内查找字符串的第一个匹配项 <xref:System.StringComparison> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2171">The following example demonstrates three overloads of the <xref:System.String.IndexOf%2A> method that find the first occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>

 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2172"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2172"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-2173"><paramref name="startIndex" /> 小于 0（零）或大于此字符串的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2173"><paramref name="startIndex" /> is less than 0 (zero) or greater than the length of this string.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-2174"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2174"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-2175">字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2175">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-2176">在区分区域性的搜索 (即，如果 <paramref name="comparisonType" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2176">In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="3cd3e-2177">如果 <paramref name="value" /> 仅包含一个或多个可忽略字符，则该 <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> 方法将始终返回 <paramref name="startIndex" /> ，这是搜索开始处的字符位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2177">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.</span></span>

<span data-ttu-id="3cd3e-2178">在下面的示例中， <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> 方法用于查找软连字符 (U + 00AD 的位置) 后跟一个从两个字符串中的第三个字符位置开始的 "m"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2178">In the following example, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting with the third character position in two strings.</span></span> <span data-ttu-id="3cd3e-2179">只有一个字符串包含必需的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2179">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="3cd3e-2180">如果该示例在 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 或更高版本上运行，则在这两种情况下，因为软连字符是可忽略的字符，所以当执行区分区域性的比较时，该方法将返回字符串中的 "m" 的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2180">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-2181">注意对于第一个字符串，包含软连字符后跟“m”，该方法无法返回该软连字符的索引，而是返回“m”的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2181">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span> <span data-ttu-id="3cd3e-2182">只有当此方法执行序号比较时，它才会在第一个字符串中返回软连字符的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2182">The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</span></span>

<span data-ttu-id="3cd3e-2183">[！ code-csharp[IndexOf # 25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable25.cs#25)][！ code-vb[IndexOf # 25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable25.vb#25)]</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2183">[!code-csharp[System.String.IndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable25.cs#25)] [!code-vb[System.String.IndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable25.vb#25)]</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-2184">要搜寻的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2184">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3cd3e-2185">搜索起始位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2185">The search starting position.</span></span></param>
        <param name="count"><span data-ttu-id="3cd3e-2186">要检查的字符位置数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2186">The number of character positions to examine.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="3cd3e-2187">指定搜索规则的枚举值之一。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2187">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2188">报告指定的字符串在当前 <see cref="T:System.String" /> 对象中的第一个匹配项的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2188">Reports the zero-based index of the first occurrence of the specified string in the current <see cref="T:System.String" /> object.</span></span> <span data-ttu-id="3cd3e-2189">参数指定当前字符串中的起始搜索位置、要搜索的当前字符串中的字符数量，以及要用于指定字符串的搜索类型。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2189">Parameters specify the starting search position in the current string, the number of characters in the current string to search, and the type of search to use for the specified string.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2190">如果找到该字符串，则为从当前实例的起始位置开始的从零开始的 <paramref name="value" /> 参数索引位置；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2190">The zero-based index position of the <paramref name="value" /> parameter from the start of the current instance if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="3cd3e-2191">如果 <paramref name="value" /> 为 <see cref="F:System.String.Empty" />，则返回值为 <paramref name="startIndex" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2191">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2192">索引编号从 0 (零开始) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2192">Index numbering starts from 0 (zero).</span></span> <span data-ttu-id="3cd3e-2193">`startIndex` 参数可以介于 0 到字符串实例的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2193">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span>

 <span data-ttu-id="3cd3e-2194">搜索从开始 `startIndex` ，并继续到 `startIndex`  +  `count` -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2194">The search begins at `startIndex` and continues to `startIndex` + `count` -1.</span></span> <span data-ttu-id="3cd3e-2195">位于处的字符 `startIndex`  +  `count` 不包含在搜索中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2195">The character at `startIndex` + `count` is not included in the search.</span></span>

 <span data-ttu-id="3cd3e-2196">`comparisonType`参数指定 `value` 使用当前或固定区域性搜索参数，使用区分大小写或不区分大小写的搜索，以及使用 word 或序号比较规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2196">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2197">下面的示例演示了方法的三个重载 <xref:System.String.IndexOf%2A> ，这些重载使用枚举的不同值在另一个字符串内查找字符串的第一个匹配项 <xref:System.StringComparison> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2197">The following example demonstrates three overloads of the <xref:System.String.IndexOf%2A> method that find the first occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>

 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2198"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2198"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-2199"><paramref name="count" /> 或 <paramref name="startIndex" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2199"><paramref name="count" /> or <paramref name="startIndex" /> is negative.</span></span>

<span data-ttu-id="3cd3e-2200">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2200">-or-</span></span>

 <span data-ttu-id="3cd3e-2201"><paramref name="startIndex" /> 大于此实例的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2201"><paramref name="startIndex" /> is greater than the length of this instance.</span></span>

<span data-ttu-id="3cd3e-2202">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2202">-or-</span></span>

 <span data-ttu-id="3cd3e-2203"><paramref name="count" /> 大于此字符串的长度减 <paramref name="startIndex" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2203"><paramref name="count" /> is greater than the length of this string minus <paramref name="startIndex" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-2204"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2204"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-2205">字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2205">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-2206">在区分区域性的搜索 (即，如果 <paramref name="comparisonType" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2206">In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="3cd3e-2207">如果 <paramref name="value" /> 仅包含一个或多个可忽略字符，则该 <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> 方法将始终返回 <paramref name="startIndex" /> ，这是搜索开始处的字符位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2207">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.</span></span>

<span data-ttu-id="3cd3e-2208">在下面的示例中， <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> 方法用于查找软连字符 (U + 00AD) 的位置，并在两个字符串中从第三个到第六个字符位置开始的 "m"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2208">In the following example, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting in the third through sixth character positions in two strings.</span></span> <span data-ttu-id="3cd3e-2209">只有一个字符串包含必需的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2209">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="3cd3e-2210">如果该示例在 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 或更高版本上运行，则在这两种情况下，因为软连字符是可忽略的字符，所以当执行区分区域性的比较时，该方法将返回字符串中的 "m" 的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2210">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-2211">但当它执行序号比较时，它只查找第一个字符串中的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2211">When it performs an ordinal comparison, however, it finds the substring only in the first string.</span></span> <span data-ttu-id="3cd3e-2212">请注意，对于包含软连字符后跟 "m" 的软连字符的第一个字符串，该方法将无法返回软连字符的索引，而是在执行区分区域性的比较时返回 "m" 的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2212">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m" when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-2213">只有当此方法执行序号比较时，它才会在第一个字符串中返回软连字符的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2213">The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</span></span>

<span data-ttu-id="3cd3e-2214">[！ code-csharp[IndexOf # 24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable24.cs#24)][！ code-vb[IndexOf # 24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable24.vb#24)]</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2214">[!code-csharp[System.String.IndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable24.cs#24)] [!code-vb[System.String.IndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable24.vb#24)]</span></span></para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3cd3e-2215">报告指定 Unicode 字符数组中的任意字符在此实例中第一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2215">Reports the index of the first occurrence in this instance of any character in a specified array of Unicode characters.</span></span> <span data-ttu-id="3cd3e-2216">如果未在此实例中找到数组中的字符，则此方法返回 -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2216">The method returns -1 if the characters in the array are not found in this instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] -&gt; int" Usage="string.IndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="3cd3e-2217">Unicode 字符数组，包含一个或多个要查找的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2217">A Unicode character array containing one or more characters to seek.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2218">报告指定 Unicode 字符数组中的任意字符在此实例中第一个匹配项的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2218">Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2219">在此实例中第一次找到 <paramref name="anyOf" /> 中的任意字符的索引位置（从零开始）；如果未找到 <paramref name="anyOf" /> 中的字符，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2219">The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2220">索引编号从0开始。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2220">Index numbering starts from zero.</span></span>

 <span data-ttu-id="3cd3e-2221">的搜索 `anyOf` 区分大小写。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2221">The search for `anyOf` is case-sensitive.</span></span> <span data-ttu-id="3cd3e-2222">如果 `anyOf` 为空数组，该方法将在字符串的开头找到匹配项 (即索引零) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2222">If `anyOf` is an empty array, the method finds a match at the beginning of the string (that  is, at index zero).</span></span>

 <span data-ttu-id="3cd3e-2223">此方法执行一个序号 (不区分区域性的) 搜索，其中，仅当字符的 Unicode 标量值相同时，才将其视为等效于另一个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2223">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="3cd3e-2224">若要执行区分区域性的搜索，请使用 <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> 方法，其中表示预构成字符的 Unicode 标量值（如连字 "Æ" (U + 00C6) ）可能被视为等效于正确序列中任何字符的组成部分（例如 "AE" (U + 0041，u + 0045) ，具体取决于区域性）。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2224">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2225">下面的示例查找字符串中的第一个元音。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2225">The following example finds the first vowel in a string.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2226"><paramref name="anyOf" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2226"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="3cd3e-2227">Unicode 字符数组，包含一个或多个要查找的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2227">A Unicode character array containing one or more characters to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3cd3e-2228">搜索起始位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2228">The search starting position.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2229">报告指定 Unicode 字符数组中的任意字符在此实例中第一个匹配项的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2229">Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</span></span> <span data-ttu-id="3cd3e-2230">该搜索从指定字符位置开始。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2230">The search starts at a specified character position.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2231">在此实例中第一次找到 <paramref name="anyOf" /> 中的任意字符的索引位置（从零开始）；如果未找到 <paramref name="anyOf" /> 中的字符，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2231">The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2232">索引编号从0开始。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2232">Index numbering starts from zero.</span></span> <span data-ttu-id="3cd3e-2233">`startIndex`参数的范围可以介于0到字符串实例的长度之间。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2233">The `startIndex` parameter can range from 0 to one less than the length of the string instance.</span></span>

 <span data-ttu-id="3cd3e-2234">搜索范围从 `startIndex` 到字符串的末尾。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2234">The search ranges from `startIndex` to the end of the string.</span></span>

 <span data-ttu-id="3cd3e-2235">的搜索 `anyOf` 区分大小写。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2235">The search for `anyOf` is case-sensitive.</span></span>

 <span data-ttu-id="3cd3e-2236">此方法执行一个序号 (不区分区域性的) 搜索，其中，仅当字符的 Unicode 标量值相同时，才将其视为等效于另一个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2236">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</span></span> <span data-ttu-id="3cd3e-2237">若要执行区分区域性的搜索，请使用 <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> 方法，其中表示预构成字符的 Unicode 标量值（如连字 "Æ" (U + 00C6) ）可能被视为等效于正确序列中任何字符的组成部分（例如 "AE" (U + 0041，u + 0045) ，具体取决于区域性）。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2237">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2238">下面的示例查找字符串 "is" 在另一个字符串的子字符串中的匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2238">The following example finds the index of the occurrence of any character of the string "is" within a substring of another string.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2239"><paramref name="anyOf" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2239"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-2240"><paramref name="startIndex" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2240"><paramref name="startIndex" /> is negative.</span></span>

<span data-ttu-id="3cd3e-2241">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2241">-or-</span></span>

 <span data-ttu-id="3cd3e-2242"><paramref name="startIndex" /> 大于此实例中的字符数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2242"><paramref name="startIndex" /> is greater than the number of characters in this instance.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="3cd3e-2243">Unicode 字符数组，包含一个或多个要查找的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2243">A Unicode character array containing one or more characters to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3cd3e-2244">搜索起始位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2244">The search starting position.</span></span></param>
        <param name="count"><span data-ttu-id="3cd3e-2245">要检查的字符位置数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2245">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2246">报告指定 Unicode 字符数组中的任意字符在此实例中第一个匹配项的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2246">Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</span></span> <span data-ttu-id="3cd3e-2247">搜索从指定字符位置开始，并检查指定数量的字符位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2247">The search starts at a specified character position and examines a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2248">在此实例中第一次找到 <paramref name="anyOf" /> 中的任意字符的索引位置（从零开始）；如果未找到 <paramref name="anyOf" /> 中的字符，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2248">The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2249">搜索从开始 `startIndex` ，并继续到 `startIndex`  +  `count` -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2249">The search begins at `startIndex` and continues to `startIndex` + `count` -1.</span></span> <span data-ttu-id="3cd3e-2250">位于处的字符 `startIndex`  +  `count` 不包含在搜索中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2250">The character at `startIndex` + `count` is not included in the search.</span></span>

 <span data-ttu-id="3cd3e-2251">索引编号从0开始。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2251">Index numbering starts from zero.</span></span> <span data-ttu-id="3cd3e-2252">`startIndex`参数的范围可以介于0到字符串实例的长度之间。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2252">The `startIndex` parameter can range from 0 to one less than the length of the string instance.</span></span>

 <span data-ttu-id="3cd3e-2253">的搜索 `anyOf` 区分大小写。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2253">The search for `anyOf` is case-sensitive.</span></span>

 <span data-ttu-id="3cd3e-2254">此方法执行一个序号 (不区分区域性的) 搜索，其中，仅当字符的 Unicode 标量值相同时，才将其视为等效于另一个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2254">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</span></span> <span data-ttu-id="3cd3e-2255">若要执行区分区域性的搜索，请使用 <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> 方法，其中表示预构成字符的 Unicode 标量值（如连字 "Æ" (U + 00C6) ）可能被视为等效于正确序列中任何字符的组成部分（例如 "AE" (U + 0041，u + 0045) ，具体取决于区域性）。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2255">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2256">下面的示例查找字符串 "辅助" 的任何字符在另一个字符串的子字符串中的匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2256">The following example finds the index of the occurrence of any character of the string "aid" within a substring of another string.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2257"><paramref name="anyOf" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2257"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-2258"><paramref name="count" /> 或 <paramref name="startIndex" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2258"><paramref name="count" /> or <paramref name="startIndex" /> is negative.</span></span>

<span data-ttu-id="3cd3e-2259">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2259">-or-</span></span>

 <span data-ttu-id="3cd3e-2260"><paramref name="count" /> + <paramref name="startIndex" /> 大于此实例中的字符数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2260"><paramref name="count" /> + <paramref name="startIndex" /> is greater than the number of characters in this instance.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (startIndex As Integer, value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Insert(int startIndex, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; string" Usage="string.Insert (startIndex, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="3cd3e-2261">插入的从零开始的索引位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2261">The zero-based index position of the insertion.</span></span></param>
        <param name="value"><span data-ttu-id="3cd3e-2262">要插入的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2262">The string to insert.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2263">返回一个新的字符串，在此实例中的指定的索引位置插入指定的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2263">Returns a new string in which a specified string is inserted at a specified index position in this instance.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2264">与此实例等效的一个新字符串，但在该字符串的 <paramref name="value" /> 位置处插入了 <paramref name="startIndex" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2264">A new string that is equivalent to this instance, but with <paramref name="value" /> inserted at position <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2265">如果 `startIndex` 等于此实例的长度， `value` 则将追加到此实例的末尾。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2265">If `startIndex` is equal to the length of this instance, `value` is appended to the end of this instance.</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-2266">此方法不会修改当前实例的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2266">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="3cd3e-2267">相反，它会返回一个新字符串， `value` 并将其插入到当前实例中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2267">Instead, it returns a new string in which `value` is inserted into the current instance.</span></span>

 <span data-ttu-id="3cd3e-2268">例如，返回值 `"abc".Insert(2, "XYZ")` 为 "abXYZc"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2268">For example, the return value of `"abc".Insert(2, "XYZ")` is "abXYZc".</span></span>



## Examples
 <span data-ttu-id="3cd3e-2269">下面的示例在字符串的索引 3) 的字符 (的第四个字符位置插入一个空格字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2269">The following example inserts a space character in the fourth character position (the character at index 3) of a string.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb" id="Snippet1":::

 <span data-ttu-id="3cd3e-2270">以下控制台应用程序将提示用户输入一个或多个形容词来描述两个动物。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2270">The following console application prompts the users to enter one or more adjectives to describe two animals.</span></span> <span data-ttu-id="3cd3e-2271">然后，它调用 <xref:System.String.Insert%2A> 方法将用户输入的文本插入到字符串中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2271">It then calls the <xref:System.String.Insert%2A> method to insert the text entered by the user into a string.</span></span>

 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2272"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2272"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-2273"><paramref name="startIndex" /> 为负数或大于此实例的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2273"><paramref name="startIndex" /> is negative or greater than the length of this instance.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Intern (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Intern(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Intern : string -&gt; string" Usage="System.string.Intern str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="str"><span data-ttu-id="3cd3e-2274">要在暂存池中搜索的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2274">A string to search for in the intern pool.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2275">检索系统对指定 <see cref="T:System.String" /> 的引用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2275">Retrieves the system's reference to the specified <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2276">如果暂存了 <paramref name="str" />，则返回系统对其的引用；否则返回对值为 <paramref name="str" /> 的字符串的新引用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2276">The system's reference to <paramref name="str" />, if it is interned; otherwise, a new reference to a string with the value of <paramref name="str" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2277">公共语言运行时通过维护名为拘留池的表来节省字符串存储，该表包含对程序中以编程方式声明或创建的每个唯一文本字符串的单个引用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2277">The common language runtime conserves string storage by maintaining a table, called the intern pool, that contains a single reference to each unique literal string declared or created programmatically in your program.</span></span> <span data-ttu-id="3cd3e-2278">因此，系统中仅存在一个具有特定值的文本字符串的实例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2278">Consequently, an instance of a literal string with a particular value only exists once in the system.</span></span>

 <span data-ttu-id="3cd3e-2279">例如，如果将相同的文本字符串分配给几个变量，则运行时将从暂存池中检索到文本字符串的相同引用，并将其分配给每个变量。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2279">For example, if you assign the same literal string to several variables, the runtime retrieves the same reference to the literal string from the intern pool and assigns it to each variable.</span></span>

 <span data-ttu-id="3cd3e-2280"><xref:System.String.Intern%2A>方法使用拘留池搜索等于值的字符串 `str` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2280">The <xref:System.String.Intern%2A> method uses the intern pool to search for a string equal to the value of `str`.</span></span> <span data-ttu-id="3cd3e-2281">如果存在这样的字符串，则返回暂存池中的引用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2281">If such a string exists, its reference in the intern pool is returned.</span></span> <span data-ttu-id="3cd3e-2282">如果该字符串不存在，则会将对的引用 `str` 添加到拘留池中，然后返回该引用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2282">If the string does not exist, a reference to `str` is added to the intern pool, then that reference is returned.</span></span>

 <span data-ttu-id="3cd3e-2283">在下面的示例中，已暂存值为 "MyTest" 的字符串 s1，因为它是程序中的文本。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2283">In the following example, the string s1, which has a value of "MyTest", is already interned because it is a literal in the program.</span></span> <span data-ttu-id="3cd3e-2284"><xref:System.Text.StringBuilder?displayProperty=nameWithType>类将生成一个与 s1 具有相同值的新字符串对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2284">The <xref:System.Text.StringBuilder?displayProperty=nameWithType> class generates a new string object that has the same value as s1.</span></span> <span data-ttu-id="3cd3e-2285">对该字符串的引用将分配给 s2。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2285">A reference to that string is assigned to s2.</span></span> <span data-ttu-id="3cd3e-2286"><xref:System.String.Intern%2A>方法搜索与 s2 具有相同值的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2286">The <xref:System.String.Intern%2A> method searches for a string that has the same value as s2.</span></span> <span data-ttu-id="3cd3e-2287">由于存在这样的字符串，因此该方法将返回分配给 s1 的相同引用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2287">Because such a string exists, the method returns the same reference that is assigned to s1.</span></span> <span data-ttu-id="3cd3e-2288">然后，将该引用分配给 s3。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2288">That reference is then assigned to s3.</span></span> <span data-ttu-id="3cd3e-2289">引用 s1 和 s2 比较不相等，因为它们引用不同的对象;引用 s1 和 s3 比较相等，因为它们引用相同的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2289">References s1 and s2 compare unequal because they refer to different objects; references s1 and s3 compare equal because they refer to the same string.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb" id="Snippet1":::

 <span data-ttu-id="3cd3e-2290">将此方法与方法进行比较 <xref:System.String.IsInterned%2A> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2290">Compare this method to the <xref:System.String.IsInterned%2A> method.</span></span>

## <a name="version-considerations"></a><span data-ttu-id="3cd3e-2291">版本注意事项</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2291">Version considerations</span></span>

 <span data-ttu-id="3cd3e-2292">在中 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] ， <xref:System.String.Intern%2A> 方法将恢复为其在 .NET Framework 1.0 和1.1 中的行为，并将其放入空字符串中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2292">In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)], the <xref:System.String.Intern%2A> method reverts to its behavior in the .NET Framework 1.0 and 1.1 with regard to interning the empty string.</span></span> <span data-ttu-id="3cd3e-2293">在下面的示例中，为变量 `str1` 赋值 <xref:System.String.Empty?displayProperty=nameWithtype> ，并 `str2` <xref:System.String.Empty?displayProperty=nameWithtype> 通过 <xref:System.String.Intern%2A> 在将值为的对象转换为字符串后调用方法，将对的引用分配给该变量 <xref:System.Text.StringBuilder> <xref:System.String.Empty?displayProperty=nameWithtype> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2293">In the following example, the variable `str1` is assigned a reference to <xref:System.String.Empty?displayProperty=nameWithtype>, and the variable `str2` is assigned the reference to <xref:System.String.Empty?displayProperty=nameWithtype> that is returned by calling the <xref:System.String.Intern%2A> method after converting a <xref:System.Text.StringBuilder> object whose value is <xref:System.String.Empty?displayProperty=nameWithtype> to a string.</span></span> <span data-ttu-id="3cd3e-2294">然后，比较和中包含的引用是否 `str1` `str2` 相等。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2294">Then the references contained in `str1` and `str2` are compared for equality.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb" id="Snippet2":::

 <span data-ttu-id="3cd3e-2295">在 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] 和中 [!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)] ， `str1` 和 `str2` 不相等。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2295">In the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] and [!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)], `str1` and `str2` are not equal.</span></span> <span data-ttu-id="3cd3e-2296">在所有其他版本中， `str1` 和 `str2` 相等。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2296">In all other versions, `str1` and `str2` are equal.</span></span>

## <a name="performance-considerations"></a><span data-ttu-id="3cd3e-2297">性能注意事项</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2297">Performance Considerations</span></span>
 <span data-ttu-id="3cd3e-2298">如果尝试减少应用程序分配的内存总量，请记住，暂存字符串具有两个不需要的副作用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2298">If you are trying to reduce the total amount of memory your application allocates, keep in mind that interning a string has two unwanted side effects.</span></span> <span data-ttu-id="3cd3e-2299">首先，在 <xref:System.String> 公共语言运行时 (CLR) 终止之前，为暂存对象分配的内存不大可能被释放。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2299">First, the memory allocated for interned <xref:System.String> objects is not likely to be released until the common language runtime (CLR) terminates.</span></span> <span data-ttu-id="3cd3e-2300">原因在于，在 <xref:System.String> 应用程序甚至应用程序域终止后，CLR 对暂存对象的引用可能会保持不变。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2300">The reason is that the CLR's reference to the interned <xref:System.String> object can persist after your application, or even your application domain, terminates.</span></span> <span data-ttu-id="3cd3e-2301">其次，若要暂存字符串，必须先创建字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2301">Second, to intern a string, you must first create the string.</span></span> <span data-ttu-id="3cd3e-2302"><xref:System.String>即使将最终回收内存，仍必须分配对象使用的内存。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2302">The memory used by the <xref:System.String> object must still be allocated, even though the memory will eventually be garbage collected.</span></span>

 <span data-ttu-id="3cd3e-2303">.NET Framework 版本2.0 引入了 <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType> 枚举成员。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2303">The .NET Framework version 2.0 introduces the <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType> enumeration member.</span></span> <span data-ttu-id="3cd3e-2304"><xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning>成员将程序集标记为不需要字符串的暂留。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2304">The <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> member marks an assembly as not requiring string-literal interning.</span></span> <span data-ttu-id="3cd3e-2305">您可以 <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> 使用属性应用于程序集 <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2305">You can apply <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> to an assembly using the <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> attribute.</span></span> <span data-ttu-id="3cd3e-2306">此外，当你使用 [Ngen.exe (本机映像生成器) ](/dotnet/framework/tools/ngen-exe-native-image-generator) 以便在运行时提前编译程序集时，不会在模块之间暂存字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2306">Also, when you use the [Ngen.exe (Native Image Generator)](/dotnet/framework/tools/ngen-exe-native-image-generator) to compile an assembly in advance of run time, strings are not interned across modules.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2307">下面的示例使用三个相同值的字符串来确定新创建的字符串和暂存的字符串是否相等。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2307">The following example uses three strings that are equal in value to determine whether a newly created string and an interned string are equal.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2308"><paramref name="str" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2308"><paramref name="str" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.IsInterned(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string? IsInterned (string str);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInterned (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ IsInterned(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsInterned : string -&gt; string" Usage="System.string.IsInterned str" />
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="str"><span data-ttu-id="3cd3e-2309">要在暂存池中搜索的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2309">The string to search for in the intern pool.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2310">检索对指定 <see cref="T:System.String" /> 的引用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2310">Retrieves a reference to a specified <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2311">如果 <paramref name="str" /> 在公共语言运行时的暂存池中，则返回对它的引用；否则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2311">A reference to <paramref name="str" /> if it is in the common language runtime intern pool; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2312">公共语言运行时自动维护一个名为拘留池的表，该表包含在程序中声明的每个唯一文本字符串常量的单个实例，以及 <xref:System.String> 通过调用方法以编程方式添加的任何唯一实例 <xref:System.String.Intern%2A> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2312">The common language runtime automatically maintains a table, called the intern pool, which contains a single instance of each unique literal string constant declared in a program, as well as any unique instance of <xref:System.String> you add programmatically by calling the <xref:System.String.Intern%2A> method.</span></span>

 <span data-ttu-id="3cd3e-2313">拘留池节省了字符串存储。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2313">The intern pool conserves string storage.</span></span> <span data-ttu-id="3cd3e-2314">如果将文本字符串常量分配给几个变量，则每个变量将设置为引用拘留池中的相同常量，而不是引用具有相同值的多个不同实例 <xref:System.String> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2314">If you assign a literal string constant to several variables, each variable is set to reference the same constant in the intern pool instead of referencing several different instances of <xref:System.String> that have identical values.</span></span>

 <span data-ttu-id="3cd3e-2315">此方法查找 `str` 暂存池中的。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2315">This method looks up `str` in the intern pool.</span></span> <span data-ttu-id="3cd3e-2316">如果已 `str` 暂存，则返回对该实例的引用; 否则 `null` 返回。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2316">If `str` has already been interned, a reference to that instance is returned; otherwise, `null` is returned.</span></span>

 <span data-ttu-id="3cd3e-2317">将此方法与方法进行比较 <xref:System.String.Intern%2A> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2317">Compare this method to the <xref:System.String.Intern%2A> method.</span></span>

 <span data-ttu-id="3cd3e-2318">此方法不返回布尔值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2318">This method does not return a Boolean value.</span></span> <span data-ttu-id="3cd3e-2319">如果调用方法，因为您需要一个指示是否暂存特定字符串的布尔值，则可以使用如下所示的代码。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2319">If you call the method because you want a Boolean value that indicates whether a particular string is interned, you can use code such as the following.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb" id="Snippet1":::

> [!NOTE]
>  <span data-ttu-id="3cd3e-2320">从 .NET Framework 版本2.0 开始，当你使用 [Ngen.exe (本机映像生成器) ](/dotnet/framework/tools/ngen-exe-native-image-generator) 将程序集安装到本地计算机上的本机映像缓存时，你可以重写拘留池的使用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2320">Starting with the .NET Framework version 2.0, you can override the use of the intern pool when you use the [Ngen.exe (Native Image Generator)](/dotnet/framework/tools/ngen-exe-native-image-generator) to install an assembly to the native image cache on a local computer.</span></span> <span data-ttu-id="3cd3e-2321">有关详细信息，请参阅 "备注" 部分中属性的性能注意事项 <xref:System.String.Intern%2A> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2321">For more information, see Performance Considerations in the Remarks section for the <xref:System.String.Intern%2A> property.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2322">下面的示例演示了编译器自动暂存文本字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2322">The following example demonstrates that literal strings are interned automatically by the compiler.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2323"><paramref name="str" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2323"><paramref name="str" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.Intern(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3cd3e-2324">指示此字符串是否符合特定的 Unicode 范式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2324">Indicates whether this string is in a particular Unicode normalization form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 <span data-ttu-id="3cd3e-2325">下面的示例确定字符串是否已成功规范化为各种范式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2325">The following example determines whether a string is successfully normalized to various normalization forms.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : unit -&gt; bool" Usage="string.IsNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3cd3e-2326">指示此字符串是否符合 Unicode 范式 C。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2326">Indicates whether this string is in Unicode normalization form C.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2327">如果此字符串符合范式 C，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2327"><see langword="true" /> if this string is in normalization form C; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2328">某些 Unicode 字符具有多个等效的二进制表示形式，其中包含组合和/或复合 Unicode 字符的集合。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2328">Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</span></span> <span data-ttu-id="3cd3e-2329">单个字符存在多个表示形式会使搜索、排序、匹配和其他操作复杂化。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2329">The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</span></span>

 <span data-ttu-id="3cd3e-2330">Unicode 标准定义了一个名为规范化的进程，该进程在给定任何等效的二进制表示形式的字符时返回一个二进制表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2330">The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</span></span> <span data-ttu-id="3cd3e-2331">可以通过多个算法（称为标准化形式）来执行规范化，它们遵循不同的规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2331">Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</span></span> <span data-ttu-id="3cd3e-2332">.NET 当前支持范式 C、D、GLM-KC-QNW 和 KD。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2332">.NET currently supports normalization forms C, D, KC, and KD.</span></span>

 <span data-ttu-id="3cd3e-2333">有关支持的 Unicode 范式的说明，请参阅 <xref:System.Text.NormalizationForm?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2333">For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-2334">当前实例包含无效的 Unicode 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2334">The current instance contains invalid Unicode characters.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-2335">此 <see cref="Overload:System.String.IsNormalized" /> 方法 <see langword="false" /> 会在遇到字符串中第一个非规范化字符时立即返回。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2335">The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string.</span></span> <span data-ttu-id="3cd3e-2336">因此，如果字符串包含非规范化字符后跟无效的 Unicode 字符，则该 <see cref="Overload:System.String.Normalize" /> 方法将引发， <see cref="T:System.ArgumentException" /> 但 <see cref="Overload:System.String.IsNormalized" /> 返回 <see langword="false" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2336">Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method will throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</span></span></para></block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized (normalizationForm As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : System.Text.NormalizationForm -&gt; bool" Usage="string.IsNormalized normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="normalizationForm"><span data-ttu-id="3cd3e-2337">一个 Unicode 范式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2337">A Unicode normalization form.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2338">指示此字符串是否符合指定的 Unicode 范式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2338">Indicates whether this string is in the specified Unicode normalization form.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2339">如果此字符串符合由 <see langword="true" /> 参数指定的范式，则为 <paramref name="normalizationForm" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2339"><see langword="true" /> if this string is in the normalization form specified by the <paramref name="normalizationForm" /> parameter; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2340">某些 Unicode 字符具有多个等效的二进制表示形式，其中包含组合和/或复合 Unicode 字符的集合。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2340">Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</span></span> <span data-ttu-id="3cd3e-2341">单个字符存在多个表示形式会使搜索、排序、匹配和其他操作复杂化。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2341">The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</span></span>

 <span data-ttu-id="3cd3e-2342">Unicode 标准定义了一个名为规范化的进程，该进程在给定任何等效的二进制表示形式的字符时返回一个二进制表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2342">The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</span></span> <span data-ttu-id="3cd3e-2343">可以通过多个算法（称为标准化形式）来执行规范化，它们遵循不同的规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2343">Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</span></span> <span data-ttu-id="3cd3e-2344">.NET 当前支持范式 C、D、GLM-KC-QNW 和 KD。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2344">.NET currently supports normalization forms C, D, KC, and KD.</span></span>

 <span data-ttu-id="3cd3e-2345">有关支持的 Unicode 范式的说明，请参阅 <xref:System.Text.NormalizationForm?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2345">For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-2346">当前实例包含无效的 Unicode 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2346">The current instance contains invalid Unicode characters.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-2347">此 <see cref="Overload:System.String.IsNormalized" /> 方法 <see langword="false" /> 会在遇到字符串中第一个非规范化字符时立即返回。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2347">The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string.</span></span> <span data-ttu-id="3cd3e-2348">因此，如果字符串包含非规范化字符后跟无效的 Unicode 字符，则该 <see cref="Overload:System.String.Normalize" /> 方法将引发， <see cref="T:System.ArgumentException" /> 但 <see cref="Overload:System.String.IsNormalized" /> 返回 <see langword="false" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2348">Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method will throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</span></span></para></block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrEmpty (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrEmpty(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrEmpty : string -&gt; bool" Usage="System.string.IsNullOrEmpty value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-2349">要测试的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2349">The string to test.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2350">指示指定的字符串是 <see langword="null" /> 还是空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2350">Indicates whether the specified string is <see langword="null" /> or an empty string ("").</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2351">如果 <see langword="true" /> 参数为 <paramref name="value" /> 或空字符串 ("")，则为 <see langword="null" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2351"><see langword="true" /> if the <paramref name="value" /> parameter is <see langword="null" /> or an empty string (""); otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2352"><xref:System.String.IsNullOrEmpty%2A> 是一种便捷方法，使您能够同时测试 <xref:System.String> 是 `null` 还是其值为 <xref:System.String.Empty?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2352"><xref:System.String.IsNullOrEmpty%2A> is a convenience method that enables you to simultaneously test whether a <xref:System.String> is `null` or its value is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3cd3e-2353">它等效于以下代码：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2353">It is equivalent to the following code:</span></span>

 [!code-cpp[System.String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp-interactive[System.String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]

 <span data-ttu-id="3cd3e-2354">您可以使用 <xref:System.String.IsNullOrWhiteSpace%2A> 方法来测试字符串是否为 `null` ，其值为 <xref:System.String.Empty?displayProperty=nameWithType> ，或仅由空白字符组成。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2354">You can use the <xref:System.String.IsNullOrWhiteSpace%2A> method to test whether a string is `null`, its value is <xref:System.String.Empty?displayProperty=nameWithType>,  or it consists only of white-space characters.</span></span>

## <a name="what-is-a-null-string"></a><span data-ttu-id="3cd3e-2355">什么是空字符串？</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2355">What is a null string?</span></span>

<span data-ttu-id="3cd3e-2356">如果尚未为 `null` 它分配值 (c + + 和 Visual Basic) ，或者显式为其赋值，则为字符串 `null` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2356">A string is `null` if it has not been assigned a value (in C++ and Visual Basic) or if it has explicitly been assigned a value of `null`.</span></span> <span data-ttu-id="3cd3e-2357">尽管 [复合格式设置](/dotnet/standard/base-types/composite-formatting) 功能可以适当地处理空字符串（如下面的示例所示），但如果其成员引发，则尝试调用它 <xref:System.NullReferenceException> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2357">Although the [composite formatting](/dotnet/standard/base-types/composite-formatting) feature can gracefully handle a null string, as the following example shows, attempting to call one if its members throws a <xref:System.NullReferenceException>.</span></span>

[!code-cpp[System.String.IsNullOrEmpty#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
[!code-csharp-interactive[System.String.IsNullOrEmpty#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
[!code-vb[System.String.IsNullOrEmpty#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]

## <a name="what-is-an-empty-string"></a><span data-ttu-id="3cd3e-2358">什么是空字符串？</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2358">What is an empty string?</span></span>

<span data-ttu-id="3cd3e-2359">如果字符串显式分配空字符串 ( "" ) 或，则为空字符串 <xref:System.String.Empty?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2359">A string is empty if it  is explicitly assigned an empty string ("") or <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3cd3e-2360">空字符串的为 <xref:System.String.Length%2A> 0。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2360">An empty string has a <xref:System.String.Length%2A> of 0.</span></span>  <span data-ttu-id="3cd3e-2361">下面的示例创建一个空字符串并显示其值和它的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2361">The following example creates an empty string and displays its value and its length.</span></span>

[!code-cpp[System.String.IsNullOrEmpty#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
[!code-csharp-interactive[System.String.IsNullOrEmpty#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
[!code-vb[System.String.IsNullOrEmpty#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]

## Examples
 <span data-ttu-id="3cd3e-2362">下面的示例检查三个字符串，并确定每个字符串是否有值、是否为空字符串或是否为 `null` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2362">The following example examines three strings and determines whether each string has a value, is an empty string, or is `null`.</span></span>

 [!code-cpp[String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp-interactive[String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrWhiteSpace (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrWhiteSpace(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrWhiteSpace : string -&gt; bool" Usage="System.string.IsNullOrWhiteSpace value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-2363">要测试的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2363">The string to test.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2364">指示指定的字符串是 <see langword="null" />、空还是仅由空白字符组成。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2364">Indicates whether a specified string is <see langword="null" />, empty, or consists only of white-space characters.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2365">如果 <see langword="true" /> 参数为 <paramref name="value" /> 或 <see langword="null" />，或者如果 <see cref="F:System.String.Empty" /> 仅由空白字符组成，则为 <paramref name="value" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2365"><see langword="true" /> if the <paramref name="value" /> parameter is <see langword="null" /> or <see cref="F:System.String.Empty" />, or if <paramref name="value" /> consists exclusively of white-space characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2366"><xref:System.String.IsNullOrWhiteSpace%2A> 是一种简便的方法，类似于以下代码，但它提供了优异的性能：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2366"><xref:System.String.IsNullOrWhiteSpace%2A> is a convenience method that is similar to the following  code, except that it offers superior performance:</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb" id="Snippet2":::

 <span data-ttu-id="3cd3e-2367">空白字符由 Unicode 标准定义。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2367">White-space characters are defined by the Unicode standard.</span></span> <span data-ttu-id="3cd3e-2368"><xref:System.String.IsNullOrWhiteSpace%2A>当将值 `true` 作为空白字符传递给方法时，该方法将解释返回值的任何字符 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2368">The <xref:System.String.IsNullOrWhiteSpace%2A> method interprets any character that returns a value of `true` when it is passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method as a white-space character.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2369">下面的示例创建一个字符串数组，然后将数组的每个元素传递给 <xref:System.String.IsNullOrWhiteSpace%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2369">The following example creates a string array, and then passes each element of the array to the <xref:System.String.IsNullOrWhiteSpace%2A> method.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3cd3e-2370">连接指定数组的元素或集合的成员，在每个元素或成员之间使用指定的分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2370">Concatenates the elements of a specified array or the members of a collection, using the specified separator between each element or member.</span></span></summary>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[]? values);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[] values);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="3cd3e-2371">要用作分隔符的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2371">The character to use as a separator.</span></span> <span data-ttu-id="3cd3e-2372">只有在 <paramref name="separator" /> 具有多个元素时，<paramref name="value" /> 才包括在返回的字符串中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2372"><paramref name="separator" /> is included in the returned string only if <paramref name="value" /> has more than one element.</span></span></param>
        <param name="values"><span data-ttu-id="3cd3e-2373">将连接其字符串表示形式的对象数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2373">An array of objects whose string representations will be concatenated.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2374">连接对象数组的字符串表示形式，其中在每个成员之间使用指定的分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2374">Concatenates the string representations of an array of objects, using the specified separator between each member.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2375">一个由 <paramref name="values" /> 的元素组成的字符串，这些元素以 <paramref name="separator" /> 字符分隔。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2375">A string that consists of the elements of <paramref name="values" /> delimited by the <paramref name="separator" /> character.</span></span>

<span data-ttu-id="3cd3e-2376">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2376">-or-</span></span>

<span data-ttu-id="3cd3e-2377">如果 <paramref name="values" /> 包含零个元素或 <paramref name="values" /> 的所有元素都为 <see langword="null" />，则为 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2377"><see cref="F:System.String.Empty" /> if <paramref name="values" /> has zero elements or all the elements of <paramref name="values" /> are <see langword="null" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2378"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2378"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="3cd3e-2379">生成的字符串长度超出了允许的最大长度 (<see cref="F:System.Int32.MaxValue" />)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2379">The length of the resulting string overflows the maximum allowed length (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[]? value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[] value);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="value" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="3cd3e-2380">要用作分隔符的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2380">The character to use as a separator.</span></span> <span data-ttu-id="3cd3e-2381">只有在 <paramref name="separator" /> 具有多个元素时，<paramref name="value" /> 才包括在返回的字符串中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2381"><paramref name="separator" /> is included in the returned string only if <paramref name="value" /> has more than one element.</span></span></param>
        <param name="value"><span data-ttu-id="3cd3e-2382">要连接的字符串数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2382">An array of strings to concatenate.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2383">连接字符串数组，其中在每个成员之间使用指定的分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2383">Concatenates an array of strings, using the specified separator between each member.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2384">一个由 <paramref name="value" /> 的元素组成的字符串，这些元素以 <paramref name="separator" /> 字符分隔。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2384">A string that consists of the elements of <paramref name="value" /> delimited by the <paramref name="separator" /> character.</span></span>

<span data-ttu-id="3cd3e-2385">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2385">-or-</span></span>

<span data-ttu-id="3cd3e-2386">如果 <paramref name="value" /> 包含零个元素或 <paramref name="value" /> 的所有元素都为 <see langword="null" />，则为 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2386"><see cref="F:System.String.Empty" /> if <paramref name="value" /> has zero elements or all the elements of <paramref name="value" /> are <see langword="null" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2387"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2387"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="3cd3e-2388">生成的字符串长度超出了允许的最大长度 (<see cref="F:System.Int32.MaxValue" />)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2388">The length of the resulting string overflows the maximum allowed length (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;string&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberSignature Language="C#" Value="public static string Join (string? separator, System.Collections.Generic.IEnumerable&lt;string&gt;? values);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="3cd3e-2389">要用作分隔符的字符串。<paramref name="separator" /></span><span class="sxs-lookup"><span data-stu-id="3cd3e-2389">The string to use as a separator.<paramref name="separator" /></span></span> <span data-ttu-id="3cd3e-2390">包括在返回的字符串中（只有在 <paramref name="values" /> 具有多个元素时）。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2390">is included in the returned string only if <paramref name="values" /> has more than one element.</span></span></param>
        <param name="values"><span data-ttu-id="3cd3e-2391">一个包含要串联的字符串的集合。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2391">A collection that contains the strings to concatenate.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2392">串联类型为 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 的 <see cref="T:System.String" /> 构造集合的成员，其中在每个成员之间使用指定的分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2392">Concatenates the members of a constructed <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection of type <see cref="T:System.String" />, using the specified separator between each member.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2393">一个由 <paramref name="values" /> 的成员组成的字符串，这些成员以 <paramref name="separator" /> 字符串分隔。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2393">A string that consists of the members of <paramref name="values" /> delimited by the <paramref name="separator" /> string.</span></span>

<span data-ttu-id="3cd3e-2394">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2394">-or-</span></span>

<span data-ttu-id="3cd3e-2395">如果 <paramref name="values" /> 包含零个元素或 <paramref name="values" /> 的所有元素都为 <see langword="null" />，则为 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2395"><see cref="F:System.String.Empty" /> if <paramref name="values" /> has zero elements or all the elements of <paramref name="values" /> are <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2396">如果 `separator` 为 `null` ，则改为使用 () 的空字符串 <xref:System.String.Empty?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2396">If `separator` is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="3cd3e-2397">如果的任何成员 `values` 为 `null` ，则改为使用空字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2397">If any member of `values` is `null`, an empty string is used instead.</span></span>

 <span data-ttu-id="3cd3e-2398"><xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 是一种简便方法，使您可以连接集合中的每个元素， `IEnumerable(Of String)` 而无需先将元素转换为字符串数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2398"><xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> is a convenience method that lets you concatenate each element in an `IEnumerable(Of String)` collection without first converting the elements to a string array.</span></span> <span data-ttu-id="3cd3e-2399">它对于 Language-Integrated 查询 (LINQ) 查询表达式特别有用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2399">It is particularly useful with Language-Integrated Query (LINQ) query expressions.</span></span> <span data-ttu-id="3cd3e-2400">下面的示例将 `List(Of String)` 包含字母表的大写或小写字母的对象传递给 lambda 表达式，该表达式选择等于或大于特定字母 (的字母，在本例中为 "M" ) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2400">The following example passes a `List(Of String)` object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is "M").</span></span> <span data-ttu-id="3cd3e-2401">`IEnumerable(Of String)`方法返回的集合 <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> 传递给 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 方法，以单个字符串的形式显示结果。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2401">The `IEnumerable(Of String)` collection returned by the <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> method is passed to the <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method to display the result as a single string.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs" interactive="try-dotnet" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb" id="Snippet4":::

## Examples
 <span data-ttu-id="3cd3e-2402">下面的示例使用埃拉托色 of 尼斯筛法算法来计算小于或等于100的质数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2402">The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</span></span> <span data-ttu-id="3cd3e-2403">它将结果分配给 <xref:System.Collections.Generic.List%601> 类型的对象，然后将该对象 <xref:System.String> 传递给 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2403">It assigns the result to a <xref:System.Collections.Generic.List%601> object of type <xref:System.String>, which it then passes to the <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb" id="Snippet3":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2404"><paramref name="values" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2404"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="3cd3e-2405">生成的字符串长度超出了允许的最大长度 (<see cref="F:System.Int32.MaxValue" />)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2405">The length of the resulting string overflows the maximum allowed length (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params object[] values);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberSignature Language="C#" Value="public static string Join (string? separator, params object[]? values);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="3cd3e-2406">要用作分隔符的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2406">The string to use as a separator.</span></span> <span data-ttu-id="3cd3e-2407">只有在 <paramref name="separator" /> 具有多个元素时，<paramref name="values" /> 才包括在返回的字符串中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2407"><paramref name="separator" /> is included in the returned string only if <paramref name="values" /> has more than one element.</span></span></param>
        <param name="values"><span data-ttu-id="3cd3e-2408">一个数组，其中包含要连接的元素。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2408">An array that contains the elements to concatenate.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2409">串联对象数组的各个元素，其中在每个元素之间使用指定的分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2409">Concatenates the elements of an object array, using the specified separator between each element.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2410">一个由 <paramref name="values" /> 的元素组成的字符串，这些元素以 <paramref name="separator" /> 字符串分隔。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2410">A string that consists of the elements of <paramref name="values" /> delimited by the <paramref name="separator" /> string.</span></span> <span data-ttu-id="3cd3e-2411">如果 <paramref name="values" /> 为空数组，该方法将返回 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2411">If <paramref name="values" /> is an empty array, the method returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2412">如果 `separator` 为 `null` ，或者第一个元素之外的任何元素 `values` 为 `null` ，则改为使用空字符串 (<xref:System.String.Empty?displayProperty=nameWithType>) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2412">If `separator` is `null` or if any element of `values` other than the first element is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="3cd3e-2413">如果的第一个元素为，请参阅 "调用方的说明" 部分 `values` `null` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2413">See the Notes for Callers section if the first element of `values` is `null`.</span></span>

 <span data-ttu-id="3cd3e-2414"><xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> 是一种简便方法，使您可以连接对象数组中的每个元素，而无需将其元素显式转换为字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2414"><xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> is a convenience method that lets you concatenate each element in an object array without explicitly converting its elements to strings.</span></span> <span data-ttu-id="3cd3e-2415">数组中每个对象的字符串表示形式是通过调用该对象的方法派生的 `ToString` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2415">The string representation of each object in the array is derived by calling that object's `ToString` method.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2416">下面的示例使用埃拉托色 of 尼斯筛法算法来计算小于或等于100的质数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2416">The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</span></span> <span data-ttu-id="3cd3e-2417">它将结果赋给一个整数数组，然后将其传递给 <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2417">It assigns the result to a integer array, which it then passes to the <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> method.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2418"><paramref name="values" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2418"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="3cd3e-2419">生成的字符串长度超出了允许的最大长度 (<see cref="F:System.Int32.MaxValue" />)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2419">The length of the resulting string overflows the maximum allowed length (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-2420">如果的第一个元素 <paramref name="values" /> 为 <see langword="null" /> ，则该 <see cref="M:System.String.Join(System.String,System.Object[])" /> 方法不会连接中的元素， <paramref name="values" /> 而是返回 <see cref="F:System.String.Empty" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2420">If the first element of <paramref name="values" /> is <see langword="null" />, the <see cref="M:System.String.Join(System.String,System.Object[])" /> method does not concatenate the elements in <paramref name="values" /> but instead returns <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="3cd3e-2421">此问题有多种解决方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2421">A number of workarounds for this issue are available.</span></span> <span data-ttu-id="3cd3e-2422">最简单的方法是将值赋给 <see cref="F:System.String.Empty" /> 数组的第一个元素，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2422">The easiest is to assign a value of <see cref="F:System.String.Empty" /> to the first element of the array, as the following example shows.</span></span>

<span data-ttu-id="3cd3e-2423">[！ code-csharp-interactive[system.string # 6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)][！ code-vb[system.string # 6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2423">[!code-csharp-interactive[System.String.Join#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)] [!code-vb[System.String.Join#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</span></span></para></block>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params string[] value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray value As String()) As String" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ value);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberSignature Language="C#" Value="public static string Join (string? separator, params string[]? value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String()) As String" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="3cd3e-2424">要用作分隔符的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2424">The string to use as a separator.</span></span> <span data-ttu-id="3cd3e-2425">只有在 <paramref name="separator" /> 具有多个元素时，<paramref name="value" /> 才包括在返回的字符串中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2425"><paramref name="separator" /> is included in the returned string only if <paramref name="value" /> has more than one element.</span></span></param>
        <param name="value"><span data-ttu-id="3cd3e-2426">一个数组，其中包含要连接的元素。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2426">An array that contains the elements to concatenate.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2427">串联字符串数组的所有元素，其中在每个元素之间使用指定的分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2427">Concatenates all the elements of a string array, using the specified separator between each element.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2428">一个由 <paramref name="value" /> 中的元素组成的字符串，这些元素以 <paramref name="separator" /> 字符串分隔。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2428">A string that consists of the elements in <paramref name="value" /> delimited by the <paramref name="separator" /> string.</span></span> <span data-ttu-id="3cd3e-2429">如果 <paramref name="value" /> 为空数组，该方法将返回 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2429">If <paramref name="value" /> is an empty array, the method returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2430">例如，如果 `separator` 为 "，"，的元素为 `value` "apple"、"橙色"、"grape" 和 "梨"，则 `Join(separator, value)` 返回 "apple，橙色，grape，梨"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2430">For example, if `separator` is ", " and the elements of `value` are "apple", "orange", "grape", and "pear", `Join(separator, value)` returns "apple, orange, grape, pear".</span></span>

 <span data-ttu-id="3cd3e-2431">如果 `separator` 为 `null` ，则改为使用 () 的空字符串 <xref:System.String.Empty?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2431">If `separator` is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="3cd3e-2432">如果中的任何元素 `value` 为 `null` ，则改为使用空字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2432">If any element in `value` is `null`, an empty string is used instead.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2433">下面的示例演示 <xref:System.String.Join%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2433">The following example demonstrates the <xref:System.String.Join%2A> method.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2434"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2434"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="3cd3e-2435">生成的字符串长度超出了允许的最大长度 (<see cref="F:System.Int32.MaxValue" />)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2435">The length of the resulting string overflows the maximum allowed length (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[]? value, int startIndex, int count);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="value" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="3cd3e-2436">连接字符串数组，其中在每个成员之间使用指定的分隔符，并且从位于指定索引处的元素开始，并包含指定数量的元素。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2436">Concatenates an array of strings, using the specified separator between each member, starting with the element located at the specified index and including a specified number of elements.</span></span></param>
        <param name="value"><span data-ttu-id="3cd3e-2437">要连接的字符串数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2437">An array of strings to concatenate.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3cd3e-2438">要连接的 <paramref name="value" /> 中的第一个项。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2438">The first item in <paramref name="value" /> to concatenate.</span></span></param>
        <param name="count"><span data-ttu-id="3cd3e-2439">要连接的 <paramref name="value" /> 中的元素数，从位于 <paramref name="startIndex" /> 位置的元素开始。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2439">The number of elements from <paramref name="value" /> to concatenate, starting with the element in the <paramref name="startIndex" /> position.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2440">连接字符串数组，其中在每个成员之间使用指定的分隔符，并且从位于 <paramref name="startIndex" /> 位置的 <paramref name="value" /> 中的元素开始，并连接多达 <paramref name="count" /> 个元素。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2440">Concatenates an array of strings, using the specified separator between each member, starting with the element in <paramref name="value" /> located at the <paramref name="startIndex" /> position, and concatenating up to <paramref name="count" /> elements.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2441">一个由 <paramref name="value" /> 的元素组成的字符串，这些元素以 <paramref name="separator" /> 字符分隔。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2441">A string that consists of the elements of <paramref name="value" /> delimited by the <paramref name="separator" /> character.</span></span>

<span data-ttu-id="3cd3e-2442">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2442">-or-</span></span>

<span data-ttu-id="3cd3e-2443">如果 <paramref name="count" /> 为零，<paramref name="value" /> 没有元素，或 <paramref name="value" /> 的全部元素均为 <see langword="null" /> 或 <see cref="F:System.String.Empty" />，则为 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2443"><see cref="F:System.String.Empty" /> if <paramref name="count" /> is zero, <paramref name="value" /> has no elements, or all the elements of <paramref name="value" /> are <see langword="null" /> or <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2444"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2444"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-2445"><paramref name="startIndex" /> 或 <paramref name="count" /> 为负。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2445"><paramref name="startIndex" /> or <paramref name="count" /> are negative.</span></span>

<span data-ttu-id="3cd3e-2446">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2446">-or-</span></span>

<span data-ttu-id="3cd3e-2447"><paramref name="startIndex" /> 大于 <paramref name="value" /> 的长度   - <paramref name="count" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2447"><paramref name="startIndex" /> is greater than the length of <paramref name="value" />  - <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="3cd3e-2448">生成的字符串长度超出了允许的最大长度 (<see cref="F:System.Int32.MaxValue" />)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2448">The length of the resulting string overflows the maximum allowed length (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberSignature Language="C#" Value="public static string Join (string? separator, string[]? value, int startIndex, int count);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="3cd3e-2449">要用作分隔符的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2449">The string to use as a separator.</span></span> <span data-ttu-id="3cd3e-2450">只有在 <paramref name="separator" /> 具有多个元素时，<paramref name="value" /> 才包括在返回的字符串中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2450"><paramref name="separator" /> is included in the returned string only if <paramref name="value" /> has more than one element.</span></span></param>
        <param name="value"><span data-ttu-id="3cd3e-2451">一个数组，其中包含要连接的元素。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2451">An array that contains the elements to concatenate.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3cd3e-2452"><paramref name="value" /> 中要使用的第一个元素。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2452">The first element in <paramref name="value" /> to use.</span></span></param>
        <param name="count"><span data-ttu-id="3cd3e-2453">要使用的 <paramref name="value" /> 的元素数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2453">The number of elements of <paramref name="value" /> to use.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2454">串联字符串数组的指定元素，其中在每个元素之间使用指定的分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2454">Concatenates the specified elements of a string array, using the specified separator between each element.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2455">由 <paramref name="value" /> 中的字符串组成的字符串，这些字符串以 <paramref name="separator" /> 字符串分隔。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2455">A string that consists of the strings in <paramref name="value" /> delimited by the <paramref name="separator" /> string.</span></span>

<span data-ttu-id="3cd3e-2456">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2456">-or-</span></span>

 <span data-ttu-id="3cd3e-2457">如果 <see cref="F:System.String.Empty" /> 为零，<paramref name="count" /> 没有元素，或 <paramref name="value" /> 以及 <paramref name="separator" /> 的全部元素均为 <paramref name="value" />，则为 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2457"><see cref="F:System.String.Empty" /> if <paramref name="count" /> is zero, <paramref name="value" /> has no elements, or <paramref name="separator" /> and all the elements of <paramref name="value" /> are <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2458">例如，如果 `separator` 为 "，"，的元素为 `value` "apple"、"橙色"、"grape" 和 "梨"，则 `Join(separator, value, 1, 2)` 返回 "橙色，grape"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2458">For example, if `separator` is ", " and the elements of `value` are "apple", "orange", "grape", and "pear", `Join(separator, value, 1, 2)` returns "orange, grape".</span></span>

 <span data-ttu-id="3cd3e-2459">如果 `separator` 为 `null` ，则改为使用 () 的空字符串 <xref:System.String.Empty?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2459">If `separator` is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="3cd3e-2460">如果中的任何元素 `value` 为 `null` ，则改为使用空字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2460">If any element in `value` is `null`, an empty string is used instead.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2461">下面的示例连接水果名称数组中的两个元素。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2461">The following example concatenates two elements from an array of names of fruit.</span></span>

 [!code-cpp[string.join2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp-interactive[string.join2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2462"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2462"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-2463"><paramref name="startIndex" /> 或 <paramref name="count" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2463"><paramref name="startIndex" /> or <paramref name="count" /> is less than 0.</span></span>

<span data-ttu-id="3cd3e-2464">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2464">-or-</span></span>

<span data-ttu-id="3cd3e-2465"><paramref name="startIndex" /> 加上 <paramref name="count" /> 大于 <paramref name="value" />中的元素数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2465"><paramref name="startIndex" /> plus <paramref name="count" /> is greater than the number of elements in <paramref name="value" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="3cd3e-2466">内存不足。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2466">Out of memory.</span></span></exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As Char, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3cd3e-2467"><paramref name="values" /> 成员的类型。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2467">The type of the members of <paramref name="values" />.</span></span></typeparam>
        <param name="separator"><span data-ttu-id="3cd3e-2468">要用作分隔符的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2468">The character to use as a separator.</span></span> <span data-ttu-id="3cd3e-2469">只有在 <paramref name="separator" /> 具有多个元素时，<paramref name="values" /> 才包括在返回的字符串中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2469"><paramref name="separator" /> is included in the returned string only if <paramref name="values" /> has more than one element.</span></span></param>
        <param name="values"><span data-ttu-id="3cd3e-2470">一个包含要串联的对象的集合。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2470">A collection that contains the objects to concatenate.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2471">串联集合的成员，其中在每个成员之间使用指定的分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2471">Concatenates the members of a collection, using the specified separator between each member.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2472">一个由 <paramref name="values" /> 的成员组成的字符串，这些成员以 <paramref name="separator" /> 字符分隔。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2472">A string that consists of the members of <paramref name="values" /> delimited by the <paramref name="separator" /> character.</span></span> <span data-ttu-id="3cd3e-2473">如果 <paramref name="values" /> 没有成员，则该方法返回 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2473">If <paramref name="values" /> has no members, the method returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2474"><paramref name="values" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2474"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="3cd3e-2475">生成的字符串长度超出了允许的最大长度 (<see cref="F:System.Int32.MaxValue" />)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2475">The length of the resulting string overflows the maximum allowed length (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As String, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string? separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3cd3e-2476"><paramref name="values" /> 成员的类型。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2476">The type of the members of <paramref name="values" />.</span></span></typeparam>
        <param name="separator"><span data-ttu-id="3cd3e-2477">要用作分隔符的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2477">The string to use as a separator.</span></span> <span data-ttu-id="3cd3e-2478">只有在 <paramref name="separator" /> 具有多个元素时，<paramref name="values" /> 才包括在返回的字符串中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2478"><paramref name="separator" /> is included in the returned string only if <paramref name="values" /> has more than one element.</span></span></param>
        <param name="values"><span data-ttu-id="3cd3e-2479">一个包含要串联的对象的集合。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2479">A collection that contains the objects to concatenate.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2480">串联集合的成员，其中在每个成员之间使用指定的分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2480">Concatenates the members of a collection, using the specified separator between each member.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2481">一个由 <paramref name="values" /> 的成员组成的字符串，这些成员以 <paramref name="separator" /> 字符串分隔。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2481">A string that consists of the members of <paramref name="values" /> delimited by the <paramref name="separator" /> string.</span></span> <span data-ttu-id="3cd3e-2482">如果 <paramref name="values" /> 没有成员，则该方法返回 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2482">If <paramref name="values" /> has no members, the method returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2483">如果 `separator` 为 `null` ，则改为使用 () 的空字符串 <xref:System.String.Empty?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2483">If `separator` is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="3cd3e-2484">如果的任何成员 `values` 为 `null` ，则改为使用空字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2484">If any member of `values` is `null`, an empty string is used instead.</span></span>

 <span data-ttu-id="3cd3e-2485"><xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> 是一种简便方法，使您可以连接集合的每个成员， <xref:System.Collections.Generic.IEnumerable%601> 无需先将其转换为字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2485"><xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> is a convenience method that lets you concatenate each member of an <xref:System.Collections.Generic.IEnumerable%601> collection without first converting them to strings.</span></span> <span data-ttu-id="3cd3e-2486">集合中每个对象的字符串表示形式 <xref:System.Collections.Generic.IEnumerable%601> 都是通过调用该对象的 `ToString` 方法派生的。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2486">The string representation of each object in the <xref:System.Collections.Generic.IEnumerable%601> collection is derived by calling that object's `ToString` method.</span></span>

 <span data-ttu-id="3cd3e-2487">此方法对于 Language-Integrated 查询 (LINQ) 查询表达式特别有用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2487">This method is particular useful with Language-Integrated Query (LINQ) query expressions.</span></span> <span data-ttu-id="3cd3e-2488">例如，下面的代码定义了一个非常简单的 `Animal` 类，其中包含动物的名称及其所属的顺序。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2488">For example, the following code defines a very simple `Animal` class that contains the name of an animal and the order to which it belongs.</span></span> <span data-ttu-id="3cd3e-2489">然后，它定义 <xref:System.Collections.Generic.List%601> 包含多个对象的对象 `Animal` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2489">It then defines a <xref:System.Collections.Generic.List%601> object that contains a number of `Animal` objects.</span></span> <span data-ttu-id="3cd3e-2490"><xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>调用扩展方法以提取 `Animal` 其 `Order` 属性等于 "啮齿类" 的对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2490">The <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> extension method is called to extract the `Animal` objects whose `Order` property equals "Rodent".</span></span> <span data-ttu-id="3cd3e-2491">结果传递给 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2491">The result is passed to the <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> method.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs" interactive="try-dotnet" id="Snippet5":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb" id="Snippet5":::

## Examples
 <span data-ttu-id="3cd3e-2492">下面的示例使用埃拉托色 of 尼斯筛法算法来计算小于或等于100的质数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2492">The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</span></span> <span data-ttu-id="3cd3e-2493">它将结果分配给 <xref:System.Collections.Generic.List%601> 类型为 integer 的对象，然后将该对象传递给 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2493">It assigns the result to a <xref:System.Collections.Generic.List%601> object of type integer, which it then passes to the <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> method.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb" id="Snippet2":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2494"><paramref name="values" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2494"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="3cd3e-2495">生成的字符串长度超出了允许的最大长度 (<see cref="F:System.Int32.MaxValue" />)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2495">The length of the resulting string overflows the maximum allowed length (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3cd3e-2496">报告指定 Unicode 字符或字符串在此实例中的最后一个匹配项的从零开始的索引的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2496">Reports the zero-based index position of the last occurrence of a specified Unicode character or string within this instance.</span></span> <span data-ttu-id="3cd3e-2497">如果未在此实例中找到该字符或字符串，则此方法返回 -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2497">The method returns -1 if the character or string is not found in this instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-2498">要查找的 Unicode 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2498">The Unicode character to seek.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2499">报告指定 Unicode 字符在此实例中的最后一个匹配项的从零开始的索引的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2499">Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2500">如果找到该字符，则为 <paramref name="value" /> 的从零开始的索引位置；如果未找到，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2500">The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2501">索引编号从0开始。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2501">Index numbering starts from zero.</span></span> <span data-ttu-id="3cd3e-2502">也就是说，字符串中的第一个字符位于索引零，最后一个字符为 <xref:System.String.Length%2A> -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2502">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>

 <span data-ttu-id="3cd3e-2503">此方法从该实例的最后一个字符位置开始搜索，然后在 `value` 找到或检查了第一个字符位置之前，向后翻一层。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2503">This method begins searching at the last character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.</span></span> <span data-ttu-id="3cd3e-2504">搜索区分大小写。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2504">The search is case-sensitive.</span></span>

 <span data-ttu-id="3cd3e-2505">此方法执行一个序号 (不区分区域性的) 搜索，其中，仅当字符的 Unicode 标量值相同时，才将其视为等效于另一个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2505">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="3cd3e-2506">若要执行区分区域性的搜索，请使用 <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> 方法，其中表示预构成字符的 Unicode 标量值（如连字 "Æ" (U + 00C6) ）可能被视为等效于正确序列中任何字符的组成部分（例如 "AE" (U + 0041，u + 0045) ，具体取决于区域性）。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2506">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2507">下面的示例定义了一个 `ExtractFilename` 方法，该方法使用 <xref:System.String.LastIndexOf%28System.Char%29> 方法查找字符串中的最后一个目录分隔符字符并提取字符串的文件名。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2507">The following example defines an `ExtractFilename` method that uses the <xref:System.String.LastIndexOf%28System.Char%29> method to find the last directory separator character in a string and to extract the string's file name.</span></span> <span data-ttu-id="3cd3e-2508">如果文件存在，则方法将返回文件名，而不返回其路径。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2508">If the file exists, the method returns the file name without its path.</span></span>

 [!code-csharp[System.String.LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-2509">要搜寻的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2509">The string to seek.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2510">报告指定字符串在此实例中的最后一个匹配项的从零开始的索引的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2510">Reports the zero-based index position of the last occurrence of a specified string within this instance.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2511">如果找到该字符串，则为 <paramref name="value" /> 的从零开始的起始索引位置；如果未找到该字符串，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2511">The zero-based starting index position of <paramref name="value" /> if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="3cd3e-2512">如果 <paramref name="value" /> 为 <see cref="F:System.String.Empty" />，则返回值为此实例中的最后一个索引位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2512">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2513">索引编号从0开始。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2513">Index numbering starts from zero.</span></span> <span data-ttu-id="3cd3e-2514">也就是说，字符串中的第一个字符位于索引零，最后一个字符为 <xref:System.String.Length%2A> -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2514">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>

 <span data-ttu-id="3cd3e-2515">此搜索从该实例的最后一个字符位置开始，并在 `value` 找到或已检查第一个字符位置之前的某个时间开始向后滚动。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2515">The search begins at the last character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.</span></span>

 <span data-ttu-id="3cd3e-2516">此方法使用当前区域性执行 (区分大小写和区分区域性的) 搜索。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2516">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span>

 <span data-ttu-id="3cd3e-2517">字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2517">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-2518">在区分区域性的搜索中，如果 `value` 包含一个可忽略字符，则结果与移除了该字符的搜索等效。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2518">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="3cd3e-2519">如果 `value` 仅包含一个或多个可忽略字符，则此 <xref:System.String.LastIndexOf%28System.String%29> 方法始终返回 <xref:System.String.Length%2A?displayProperty=nameWithType> -1，表示当前实例中的最后一个索引位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2519">If `value` consists only of one or more ignorable characters, the <xref:System.String.LastIndexOf%28System.String%29> method always returns <xref:System.String.Length%2A?displayProperty=nameWithType> - 1, which represents the last index position in the current instance.</span></span> <span data-ttu-id="3cd3e-2520">在下面的示例中， <xref:System.String.LastIndexOf%28System.String%29> 方法用于查找 (软连字符的三个子字符串 (U + 00AD) ，软连字符后跟 "n"，软连字符后跟两个字符串中的 "m" ) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2520">In the following example, the <xref:System.String.LastIndexOf%28System.String%29> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</span></span> <span data-ttu-id="3cd3e-2521">只有一个字符串包含软连字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2521">Only one of the strings contains a soft hyphen.</span></span> <span data-ttu-id="3cd3e-2522">如果该示例在 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 或更高版本上运行，则在每种情况下，因为软连字符是可忽略字符，所以，结果与中未包含软连字符的结果相同 `value` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2522">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in each case, because the soft hyphen is an ignorable character, the result is the same as if the soft hyphen had not been included in `value`.</span></span> <span data-ttu-id="3cd3e-2523">仅搜索软连字符时，该方法返回6和5。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2523">When searching for a soft hyphen only, the method returns 6 and 5.</span></span> <span data-ttu-id="3cd3e-2524">这些值对应于两个字符串中最后一个字符的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2524">These values correspond to the index of the last character in the two strings.</span></span>

 [!code-csharp[System.String.LastIndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]



## Examples
 <span data-ttu-id="3cd3e-2525">下面的示例在标记开始和结束字符串时，删除字符串中的开始和关闭 HTML 标记。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2525">The following example removes opening and closing HTML tags from a string if the tags begin and end the string.</span></span> <span data-ttu-id="3cd3e-2526">如果字符串以右括号字符结尾 ( ">" ) ，则该示例使用 <xref:System.String.LastIndexOf%2A> 方法来查找结束标记的开头。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2526">If a string ends with a closing bracket character (">"), the example uses the <xref:System.String.LastIndexOf%2A> method to locate the start of the end tag.</span></span>

 [!code-csharp[System.String.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2527"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2527"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-2528">如 [使用字符串的最佳做法](/dotnet/standard/base-types/best-practices-strings)中所述，建议你避免调用替换默认值的字符串比较方法，并改为调用需要显式指定参数的方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2528">As explained in [Best Practices for Using Strings](/dotnet/standard/base-types/best-practices-strings), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="3cd3e-2529">若要通过使用当前区域性的比较规则查找字符串实例内子字符串的最后一个索引，请使用的 <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> 参数的值调用方法重载 <see cref="F:System.StringComparison.CurrentCulture" /> <paramref name="comparisonType" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2529">To find the last index of a substring within a string instance by using the comparison rules of the current culture, call the <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-2530">要查找的 Unicode 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2530">The Unicode character to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3cd3e-2531">搜索的起始位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2531">The starting position of the search.</span></span> <span data-ttu-id="3cd3e-2532">从 <paramref name="startIndex" /> 此实例的开头开始搜索。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2532">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2533">报告指定 Unicode 字符在此实例中的最后一个匹配项的从零开始的索引的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2533">Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.</span></span> <span data-ttu-id="3cd3e-2534">在指定的字符位置开始和在向后的右边该字符串的开头处理的搜索。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2534">The search starts at a specified character position and proceeds backward toward the beginning of the string.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2535">如果找到该字符，则为 <paramref name="value" /> 的从零开始的索引位置；如果未找到该字符或当前实例等于 <see cref="F:System.String.Empty" />，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2535">The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2536">索引编号从0开始。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2536">Index numbering starts from zero.</span></span> <span data-ttu-id="3cd3e-2537">也就是说，字符串中的第一个字符位于索引零，最后一个字符为 <xref:System.String.Length%2A> -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2537">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span> <span data-ttu-id="3cd3e-2538">此方法开始搜索 `startIndex` 此实例的字符位置，并沿当前实例的开头向后移动，直到 `value` 找到或已检查第一个字符位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2538">This method begins searching at the `startIndex` character position of this instance and proceeds backward toward the beginning of the current instance until either `value` is found or the first character position has been examined.</span></span> <span data-ttu-id="3cd3e-2539">例如，如果 `startIndex` 为 <xref:System.String.Length%2A> -1，则方法会搜索字符串中最后一个字符的每个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2539">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches every character from the last character in the string to the beginning.</span></span> <span data-ttu-id="3cd3e-2540">搜索区分大小写。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2540">The search is case-sensitive.</span></span>

 <span data-ttu-id="3cd3e-2541">此方法执行一个序号 (不区分区域性的) 搜索，其中，仅当字符的 Unicode 标量值相同时，才将其视为等效于另一个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2541">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="3cd3e-2542">若要执行区分区域性的搜索，请使用 <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> 方法，其中表示预构成字符的 Unicode 标量值（如连字 "Æ" (U + 00C6) ）可能被视为等效于正确序列中任何字符的组成部分（例如 "AE" (U + 0041，u + 0045) ，具体取决于区域性）。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2542">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2543">下面的示例查找字符串中出现的所有字符的索引，该索引从字符串的末尾到字符串的开头。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2543">The following example finds the index of all occurrences of a character in a string, working from the end of the string to the start of the string.</span></span>

 [!code-cpp[string.lastindexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-2544">当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 小于零或大于等于当前实例的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2544">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than zero or greater than or equal to the length of this instance.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-2545">要搜寻的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2545">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3cd3e-2546">搜索起始位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2546">The search starting position.</span></span> <span data-ttu-id="3cd3e-2547">从 <paramref name="startIndex" /> 此实例的开头开始搜索。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2547">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2548">报告指定字符串在此实例中的最后一个匹配项的从零开始的索引的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2548">Reports the zero-based index position of the last occurrence of a specified string within this instance.</span></span> <span data-ttu-id="3cd3e-2549">在指定的字符位置开始和在向后的右边该字符串的开头处理的搜索。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2549">The search starts at a specified character position and proceeds backward toward the beginning of the string.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2550">如果找到该字符串，则为 <paramref name="value" /> 的从零开始的起始索引位置；如果未找到该字符串或当前实例等于 <see cref="F:System.String.Empty" />，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2550">The zero-based starting index position of <paramref name="value" /> if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="3cd3e-2551">如果 <paramref name="value" /> 为 <see cref="F:System.String.Empty" />，则返回值为 <paramref name="startIndex" /> 和此实例中的最后一个索引位置中的较小者。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2551">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2552">索引编号从0开始。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2552">Index numbering starts from zero.</span></span> <span data-ttu-id="3cd3e-2553">也就是说，字符串中的第一个字符位于索引零，最后一个字符为 <xref:System.String.Length%2A> -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2553">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>

 <span data-ttu-id="3cd3e-2554">此搜索从 `startIndex` 该实例的字符位置开始，并在 `value` 找到或已检查第一个字符位置之前向后继续。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2554">The search begins at the `startIndex` character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.</span></span> <span data-ttu-id="3cd3e-2555">例如，如果 `startIndex` 为 <xref:System.String.Length%2A> -1，则方法会搜索字符串中最后一个字符的每个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2555">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches every character from the last character in the string to the beginning.</span></span>

 <span data-ttu-id="3cd3e-2556">此方法使用当前区域性执行 (区分大小写和区分区域性的) 搜索。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2556">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span>

 <span data-ttu-id="3cd3e-2557">字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2557">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-2558">在区分区域性的搜索中，如果 `value` 包含一个可忽略字符，则结果与移除了该字符的搜索等效。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2558">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="3cd3e-2559">如果 `value` 仅包含一个或多个可忽略字符，则该 <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> 方法将始终返回 `startIndex` ，这是搜索开始处的字符位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2559">If `value` consists only of one or more ignorable characters, the <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> method always returns `startIndex`, which is the character position at which the search begins.</span></span> <span data-ttu-id="3cd3e-2560">在下面的示例中， <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> 方法用于查找子字符串，其中包含软连字符 (U + 00AD) ，并在字符串前面或包含最后的 "m"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2560">In the following example, the <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> method is used to find a substring that includes a soft hyphen (U+00AD) and that precedes or includes the final "m" in a string.</span></span> <span data-ttu-id="3cd3e-2561">如果本示例在 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 或更高版本上运行，则将忽略搜索字符串中的软连字符，调用方法以查找由软连字符和 "m" 组成的子字符串，并将 "m" 的位置返回到字符串中，而调用它可查找由软连字符组成的子字符串，而 "n" 将返回 "n" 的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2561">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, because the soft hyphen in the search string is ignored, calling the method to find a substring that consists of the soft hyphen and "m" returns the position of the "m" in the string, whereas calling it to find a substring that consists of the soft hyphen and "n" returns the position of the "n".</span></span> <span data-ttu-id="3cd3e-2562">如果搜索字符串只包含软连字符，则方法返回 "m" 的索引，该索引表示的值 `startIndex` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2562">When the search string contains only the soft hyphen, the method returns the index of the "m", which represents the value of `startIndex`.</span></span>

 [!code-csharp[System.String.LastIndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]



## Examples
 <span data-ttu-id="3cd3e-2563">下面的示例查找目标字符串中字符串的所有匹配项的索引，从目标字符串的末尾到目标字符串的开头。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2563">The following example finds the index of all occurrences of a string in target string, working from the end of the target string to the start of the target string.</span></span>

 [!code-cpp[string.lastindexof7#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2564"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2564"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-2565">当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 小于零或大于当前实例的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2565">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than zero or greater than the length of the current instance.</span></span>

<span data-ttu-id="3cd3e-2566">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2566">-or-</span></span>

<span data-ttu-id="3cd3e-2567">当前实例等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 小于-1 或大于零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2567">The current instance equals <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than -1 or greater than zero.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-2568">如 [使用字符串的最佳做法](/dotnet/standard/base-types/best-practices-strings)中所述，建议你避免调用替换默认值的字符串比较方法，并改为调用需要显式指定参数的方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2568">As explained in [Best Practices for Using Strings](/dotnet/standard/base-types/best-practices-strings), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="3cd3e-2569">若要通过使用当前区域性的比较规则查找特定字符位置之前的子字符串的索引，请使用 <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> 其参数的值调用方法重载 <see cref="F:System.StringComparison.CurrentCulture" /> <paramref name="comparisonType" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2569">To find the index of a substring that precedes a particular character position by using the comparison rules of the current culture, call the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * StringComparison -&gt; int" Usage="string.LastIndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-2570">要搜寻的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2570">The string to seek.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="3cd3e-2571">指定搜索规则的枚举值之一。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2571">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2572">报告指定字符串在当前 <see cref="T:System.String" /> 对象中最后一个匹配项的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2572">Reports the zero-based index of the last occurrence of a specified string within the current <see cref="T:System.String" /> object.</span></span> <span data-ttu-id="3cd3e-2573">一个参数指定要用于指定字符串的搜索类型。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2573">A parameter specifies the type of search to use for the specified string.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2574">如果找到该字符串，则为 <paramref name="value" /> 参数的从零开始的起始索引位置；如果未找到该字符串，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2574">The zero-based starting index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="3cd3e-2575">如果 <paramref name="value" /> 为 <see cref="F:System.String.Empty" />，则返回值为此实例中的最后一个索引位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2575">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2576">索引编号从0开始。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2576">Index numbering starts from zero.</span></span> <span data-ttu-id="3cd3e-2577">也就是说，字符串中的第一个字符位于索引零，最后一个字符为 <xref:System.String.Length%2A> -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2577">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>

 <span data-ttu-id="3cd3e-2578">`comparisonType`参数指定 `value` 使用当前或固定区域性搜索参数，使用区分大小写或不区分大小写的搜索，以及使用 word 或序号比较规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2578">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>

 <span data-ttu-id="3cd3e-2579">此搜索从该实例的最后一个字符位置开始，并在 `value` 找到或已检查第一个字符位置之前的某个时间开始向后滚动。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2579">The search begins at the last character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2580">下面的示例演示了方法的三个重载 <xref:System.String.LastIndexOf%2A> ，这些重载使用枚举的不同值在另一个字符串内查找字符串的最后一个匹配项 <xref:System.StringComparison> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2580">The following example demonstrates three overloads of the <xref:System.String.LastIndexOf%2A> method that find the last occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>

 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2581"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2581"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-2582"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2582"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-2583">字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2583">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-2584">在区分区域性的搜索 (即，如果 <paramref name="options" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2584">In a culture-sensitive search (that is, if <paramref name="options" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="3cd3e-2585">如果 <paramref name="value" /> 仅包含一个或多个可忽略字符，则此 <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> 方法始终返回 <see cref="P:System.String.Length" /> -1，表示当前实例中的最后一个索引位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2585">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> method always returns <see cref="P:System.String.Length" /> - 1, which represents the last index position in the current instance.</span></span>

<span data-ttu-id="3cd3e-2586">在下面的示例中， <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> 方法用于查找 (软连字符的三个子字符串 (U + 00AD) ，软连字符后跟 "n"，软连字符后跟两个字符串中的 "m" ) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2586">In the following example, the <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</span></span> <span data-ttu-id="3cd3e-2587">只有一个字符串包含软连字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2587">Only one of the strings contains a soft hyphen.</span></span> <span data-ttu-id="3cd3e-2588">如果本示例在 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 或更高版本上运行，因为软连字符是可忽略的字符，所以区分区域性的搜索返回的值与在搜索字符串中未包含软连字符时返回的值相同。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2588">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, because the soft hyphen is an ignorable character, a culture-sensitive search returns the same value that it would return if the soft hyphen were not included in the search string.</span></span> <span data-ttu-id="3cd3e-2589">不过，序号搜索成功地在一个字符串中查找软连字符，并报告从第二个字符串中缺少它。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2589">An ordinal search, however, successfully finds the soft hyphen in one string and reports that it is absent from the second string.</span></span>

<span data-ttu-id="3cd3e-2590">[！ code-csharp[LastIndexOf # 26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof26.cs#26)][！ code-vb[LastIndexOf # 26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof26.vb#26)]</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2590">[!code-csharp[System.String.LastIndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof26.cs#26)] [!code-vb[System.String.LastIndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof26.vb#26)]</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-2591">要查找的 Unicode 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2591">The Unicode character to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3cd3e-2592">搜索的起始位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2592">The starting position of the search.</span></span> <span data-ttu-id="3cd3e-2593">从 <paramref name="startIndex" /> 此实例的开头开始搜索。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2593">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <param name="count"><span data-ttu-id="3cd3e-2594">要检查的字符位置数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2594">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2595">报告指定的 Unicode 字符在此实例内的子字符串中的最后一个匹配项的从零开始的索引的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2595">Reports the zero-based index position of the last occurrence of the specified Unicode character in a substring within this instance.</span></span> <span data-ttu-id="3cd3e-2596">搜索在指定字符位置的数目的字符串开始时，开始指定字符和其后面的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2596">The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2597">如果找到该字符，则为 <paramref name="value" /> 的从零开始的索引位置；如果未找到该字符或当前实例等于 <see cref="F:System.String.Empty" />，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2597">The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2598">索引编号从0开始。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2598">Index numbering starts from zero.</span></span> <span data-ttu-id="3cd3e-2599">也就是说，字符串中的第一个字符位于索引零，最后一个字符为 <xref:System.String.Length%2A> -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2599">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>

 <span data-ttu-id="3cd3e-2600">此方法从 `startIndex` 字符位置开始搜索，并沿此实例的开头向后移动，直到 `value` 找到了或已检查了个 `count` 字符位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2600">This method begins searching at the `startIndex` character position and proceeds backward toward the beginning of this instance until either `value` is found or `count` character positions have been examined.</span></span> <span data-ttu-id="3cd3e-2601">例如，如果 `startIndex` 为 <xref:System.String.Length%2A> -1，则该方法将在 `count` 字符串的最后一个字符中搜索向后字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2601">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches backward `count` characters from the last character in the string.</span></span> <span data-ttu-id="3cd3e-2602">搜索区分大小写。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2602">The search is case-sensitive.</span></span>

 <span data-ttu-id="3cd3e-2603">此方法执行一个序号 (不区分区域性的) 搜索，其中，仅当字符的 Unicode 标量值相同时，才将其视为等效于另一个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2603">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</span></span> <span data-ttu-id="3cd3e-2604">若要执行区分区域性的搜索，请使用 <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> 方法，其中表示预构成字符的 Unicode 标量值（如连字 "Æ" (U + 00C6) ）可能被视为等效于正确序列中任何字符的组成部分（例如 "AE" (U + 0041，u + 0045) ，具体取决于区域性）。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2604">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2605">下面的示例查找子字符串中某个字符的所有匹配项的索引，该索引从子字符串的末尾到子字符串的开头。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2605">The following example finds the index of all occurrences of a character in a substring, working from the end of the substring to the start of the substring.</span></span>

 [!code-cpp[string.lastindexof2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-2606">当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 小于零或大于等于当前实例的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2606">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than zero or greater than or equal to the length of this instance.</span></span>

<span data-ttu-id="3cd3e-2607">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2607">-or-</span></span>

<span data-ttu-id="3cd3e-2608">当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> - <paramref name="count" /> + 1 小于零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2608">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> - <paramref name="count" /> + 1 is less than zero.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-2609">要搜寻的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2609">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3cd3e-2610">搜索起始位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2610">The search starting position.</span></span> <span data-ttu-id="3cd3e-2611">从 <paramref name="startIndex" /> 此实例的开头开始搜索。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2611">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <param name="count"><span data-ttu-id="3cd3e-2612">要检查的字符位置数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2612">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2613">报告指定字符串在此实例中的最后一个匹配项的从零开始的索引的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2613">Reports the zero-based index position of the last occurrence of a specified string within this instance.</span></span> <span data-ttu-id="3cd3e-2614">搜索在指定字符位置的数目的字符串开始时，开始指定字符和其后面的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2614">The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2615">如果找到该字符串，则为 <paramref name="value" /> 的从零开始的起始索引位置；如果未找到该字符串或当前实例等于 <see cref="F:System.String.Empty" />，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2615">The zero-based starting index position of <paramref name="value" /> if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="3cd3e-2616">如果 <paramref name="value" /> 为 <see cref="F:System.String.Empty" />，则返回值为 <paramref name="startIndex" /> 和此实例中的最后一个索引位置中的较小者。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2616">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2617">索引编号从0开始。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2617">Index numbering starts from zero.</span></span> <span data-ttu-id="3cd3e-2618">也就是说，字符串中的第一个字符位于索引零，最后一个字符为 <xref:System.String.Length%2A> -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2618">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>

 <span data-ttu-id="3cd3e-2619">此搜索从 `startIndex` 该实例的字符位置开始，并在找到或已检查了个 `value` 字符位置之前向后继续 `count` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2619">The search begins at the `startIndex` character position of this instance and proceeds backward toward the beginning until either `value` is found or `count` character positions have been examined.</span></span> <span data-ttu-id="3cd3e-2620">例如，如果 `startIndex` 为 <xref:System.String.Length%2A> -1，则该方法将在 `count` 字符串的最后一个字符中搜索向后字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2620">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches backward `count` characters from the last character in the string.</span></span>

 <span data-ttu-id="3cd3e-2621">此方法使用当前区域性执行 (区分大小写和区分区域性的) 搜索。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2621">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span>

 <span data-ttu-id="3cd3e-2622">字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2622">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-2623">在区分区域性的搜索中，如果 `value` 包含一个可忽略字符，则结果与移除了该字符的搜索等效。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2623">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="3cd3e-2624">如果 `value` 仅包含一个或多个可忽略字符，则该 <xref:System.String.LastIndexOf%2A> 方法将始终返回 `startIndex` ，这是搜索开始处的字符位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2624">If `value` consists only of one or more ignorable characters, the <xref:System.String.LastIndexOf%2A> method always returns `startIndex`, which is the character position at which the search begins.</span></span> <span data-ttu-id="3cd3e-2625">在下面的示例中， <xref:System.String.LastIndexOf%2A> 方法用于查找软连字符 (U + 00AD 的位置) 在两个字符串的最后一个 "m" 之前的两个字符中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2625">In the following example, the <xref:System.String.LastIndexOf%2A> method is used to find the position of a soft hyphen (U+00AD) in the two characters that precede the final "m" of two strings.</span></span> <span data-ttu-id="3cd3e-2626">只有一个字符串包含必需的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2626">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="3cd3e-2627">如果该示例在 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 或更高版本上运行，则在这两种情况下，因为软连字符是可忽略的字符，所以当执行区分区域性的比较时，该方法将返回字符串中的 "m" 的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2627">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-2628">注意对于第一个字符串，包含软连字符后跟“m”，该方法无法返回该软连字符的索引，而是返回“m”的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2628">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span>

 [!code-csharp[System.String.LastIndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]



## Examples
 <span data-ttu-id="3cd3e-2629">下面的示例查找子字符串中字符串的所有匹配项的索引（从子字符串的末尾到子字符串的开头）。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2629">The following example finds the index of all occurrences of a string in substring, working from the end of the substring to the start of the substring.</span></span>

 [!code-cpp[string.lastindexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2630"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2630"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-2631"><paramref name="count" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2631"><paramref name="count" /> is negative.</span></span>

<span data-ttu-id="3cd3e-2632">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2632">-or-</span></span>

<span data-ttu-id="3cd3e-2633">当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2633">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is negative.</span></span>

<span data-ttu-id="3cd3e-2634">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2634">-or-</span></span>

<span data-ttu-id="3cd3e-2635">当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 大于此实例的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2635">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is greater than the length of this instance.</span></span>

<span data-ttu-id="3cd3e-2636">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2636">-or-</span></span>

<span data-ttu-id="3cd3e-2637">当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> - <paramref name="count" /> + 1 指定不在此实例内的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2637">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> - <paramref name="count" />+ 1 specifies a position that is not within this instance.</span></span>

<span data-ttu-id="3cd3e-2638">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2638">-or-</span></span>

<span data-ttu-id="3cd3e-2639">当前实例等于 <see cref="F:System.String.Empty" /> 并且 <paramref name="start" /> 小于 -1 或大于零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2639">The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="start" /> is less than -1 or greater than zero.</span></span>

<span data-ttu-id="3cd3e-2640">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2640">-or-</span></span>

<span data-ttu-id="3cd3e-2641">当前实例等于 <see cref="F:System.String.Empty" /> 并且 <paramref name="count" /> 大于 1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2641">The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="count" /> is greater than 1.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-2642">如 [使用字符串的最佳做法](/dotnet/standard/base-types/best-practices-strings)中所述，建议你避免调用替换默认值的字符串比较方法，并改为调用需要显式指定参数的方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2642">As explained in [Best Practices for Using Strings](/dotnet/standard/base-types/best-practices-strings), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="3cd3e-2643">若要通过使用当前区域性的比较规则来执行此操作，请使用的 <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> 参数的值调用方法重载 <see cref="F:System.StringComparison.CurrentCulture" /> <paramref name="comparisonType" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2643">To perform this operation by using the comparison rules of the current culture, call the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-2644">要搜寻的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2644">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3cd3e-2645">搜索起始位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2645">The search starting position.</span></span> <span data-ttu-id="3cd3e-2646">从 <paramref name="startIndex" /> 此实例的开头开始搜索。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2646">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="3cd3e-2647">指定搜索规则的枚举值之一。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2647">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2648">报告指定字符串在当前 <see cref="T:System.String" /> 对象中最后一个匹配项的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2648">Reports the zero-based index of the last occurrence of a specified string within the current <see cref="T:System.String" /> object.</span></span> <span data-ttu-id="3cd3e-2649">在指定的字符位置开始和在向后的右边该字符串的开头处理的搜索。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2649">The search starts at a specified character position and proceeds backward toward the beginning of the string.</span></span> <span data-ttu-id="3cd3e-2650">一个参数指定要执行搜索指定字符串的比较类型。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2650">A parameter specifies the type of comparison to perform when searching for the specified string.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2651">如果找到该字符串，则为 <paramref name="value" /> 参数的从零开始的起始索引位置；如果未找到该字符串或当前实例等于 <see cref="F:System.String.Empty" />，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2651">The zero-based starting index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="3cd3e-2652">如果 <paramref name="value" /> 为 <see cref="F:System.String.Empty" />，则返回值为 <paramref name="startIndex" /> 和此实例中的最后一个索引位置中的较小者。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2652">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2653">索引编号从0开始。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2653">Index numbering starts from zero.</span></span> <span data-ttu-id="3cd3e-2654">也就是说，字符串中的第一个字符位于索引零，最后一个字符为 <xref:System.String.Length%2A> -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2654">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>

 <span data-ttu-id="3cd3e-2655">搜索从 `startIndex` 字符位置开始，一直向后移动，直到 `value` 找到或已检查第一个字符位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2655">The search begins at the `startIndex` character position and proceeds backward until either `value` is found or the first character position has been examined.</span></span> <span data-ttu-id="3cd3e-2656">例如，如果 `startIndex` 为 <xref:System.String.Length%2A> -1，则方法会搜索字符串中最后一个字符的每个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2656">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches every character from the last character in the string to the beginning.</span></span>

 <span data-ttu-id="3cd3e-2657">`comparisonType`参数指定 `value` 使用当前或固定区域性搜索参数，使用区分大小写或不区分大小写的搜索，以及使用 word 或序号比较规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2657">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2658">下面的示例演示了方法的三个重载 <xref:System.String.LastIndexOf%2A> ，这些重载使用枚举的不同值在另一个字符串内查找字符串的最后一个匹配项 <xref:System.StringComparison> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2658">The following example demonstrates three overloads of the <xref:System.String.LastIndexOf%2A> method that find the last occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>

 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2659"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2659"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-2660">当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 小于零或大于当前实例的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2660">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than zero or greater than the length of the current instance.</span></span>

<span data-ttu-id="3cd3e-2661">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2661">-or-</span></span>

<span data-ttu-id="3cd3e-2662">当前实例等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 小于-1 或大于零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2662">The current instance equals <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than -1 or greater than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-2663"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2663"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-2664">字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2664">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-2665">在区分区域性的搜索 (即，如果 <paramref name="comparisonType" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2665">In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="3cd3e-2666">如果 <paramref name="value" /> 仅包含一个或多个可忽略字符，则该 <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> 方法将始终返回 <paramref name="startIndex" /> ，这是搜索开始处的字符位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2666">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.</span></span>

<span data-ttu-id="3cd3e-2667">在下面的示例中， <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> 方法用于查找软连字符 (U + 00AD 的位置) 后跟 "m"，从两个字符串中的最后一个 "m" 开始。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2667">In the following example, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m", starting with the final "m" in two strings.</span></span> <span data-ttu-id="3cd3e-2668">只有一个字符串包含必需的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2668">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="3cd3e-2669">如果该示例在 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 或更高版本上运行，则在这两种情况下，因为软连字符是可忽略的字符，所以当执行区分区域性的比较时，该方法将返回字符串中的 "m" 的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2669">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-2670">注意对于第一个字符串，包含软连字符后跟“m”，该方法无法返回该软连字符的索引，而是返回“m”的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2670">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span> <span data-ttu-id="3cd3e-2671">只有当此方法执行序号比较时，它才会在第一个字符串中返回软连字符的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2671">The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</span></span>

<span data-ttu-id="3cd3e-2672">[！ code-csharp[LastIndexOf # 25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof25.cs#25)][！ code-vb[LastIndexOf # 25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof25.vb#25)]</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2672">[!code-csharp[System.String.LastIndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof25.cs#25)] [!code-vb[System.String.LastIndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof25.vb#25)]</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-2673">要搜寻的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2673">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3cd3e-2674">搜索起始位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2674">The search starting position.</span></span> <span data-ttu-id="3cd3e-2675">从 <paramref name="startIndex" /> 此实例的开头开始搜索。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2675">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <param name="count"><span data-ttu-id="3cd3e-2676">要检查的字符位置数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2676">The number of character positions to examine.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="3cd3e-2677">指定搜索规则的枚举值之一。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2677">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2678">报告指定字符串在此实例中的最后一个匹配项的从零开始的索引的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2678">Reports the zero-based index position of the last occurrence of a specified string within this instance.</span></span> <span data-ttu-id="3cd3e-2679">搜索在所指定的字符位置的数目的字符串开始时，开始指定字符和其后面的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2679">The search starts at a specified character position and proceeds backward toward the beginning of the string for the specified number of character positions.</span></span> <span data-ttu-id="3cd3e-2680">一个参数指定要执行搜索指定字符串的比较类型。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2680">A parameter specifies the type of comparison to perform when searching for the specified string.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2681">如果找到该字符串，则为 <paramref name="value" /> 参数的从零开始的起始索引位置；如果未找到该字符串或当前实例等于 <see cref="F:System.String.Empty" />，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2681">The zero-based starting index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="3cd3e-2682">如果 <paramref name="value" /> 为 <see cref="F:System.String.Empty" />，则返回值为 <paramref name="startIndex" /> 和此实例中的最后一个索引位置中的较小者。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2682">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2683">索引编号从0开始。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2683">Index numbering starts from zero.</span></span> <span data-ttu-id="3cd3e-2684">也就是说，字符串中的第一个字符位于索引零，最后一个字符为 <xref:System.String.Length%2A> -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2684">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>

 <span data-ttu-id="3cd3e-2685">搜索从 `startIndex` 字符位置开始，一直向后移动，直到 `value` 找到或检查了个 `count` 字符位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2685">The search begins at the `startIndex` character position and proceeds backward until either `value` is found or `count` character positions have been examined.</span></span> <span data-ttu-id="3cd3e-2686">例如，如果 `startIndex` 为 <xref:System.String.Length%2A> -1，则该方法将在 `count` 字符串的最后一个字符中搜索向后字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2686">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches backward `count` characters from the last character in the string.</span></span>

 <span data-ttu-id="3cd3e-2687">`comparisonType`参数指定 `value` 使用当前或固定区域性搜索参数，使用区分大小写或不区分大小写的搜索，以及使用 word 或序号比较规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2687">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2688">下面的示例演示了方法的三个重载 <xref:System.String.LastIndexOf%2A> ，这些重载使用枚举的不同值在另一个字符串内查找字符串的最后一个匹配项 <xref:System.StringComparison> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2688">The following example demonstrates three overloads of the <xref:System.String.LastIndexOf%2A> method that find the last occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>

 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2689"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2689"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-2690"><paramref name="count" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2690"><paramref name="count" /> is negative.</span></span>

<span data-ttu-id="3cd3e-2691">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2691">-or-</span></span>

<span data-ttu-id="3cd3e-2692">当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2692">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is negative.</span></span>

<span data-ttu-id="3cd3e-2693">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2693">-or-</span></span>

<span data-ttu-id="3cd3e-2694">当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 大于此实例的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2694">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is greater than the length of this instance.</span></span>

<span data-ttu-id="3cd3e-2695">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2695">-or-</span></span>

<span data-ttu-id="3cd3e-2696">当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> + 1 - <paramref name="count" /> 指定不在此实例内的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2696">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> + 1 - <paramref name="count" /> specifies a position that is not within this instance.</span></span>

<span data-ttu-id="3cd3e-2697">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2697">-or-</span></span>

<span data-ttu-id="3cd3e-2698">当前实例等于 <see cref="F:System.String.Empty" /> 并且 <paramref name="start" /> 小于 -1 或大于零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2698">The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="start" /> is less than -1 or greater than zero.</span></span>

<span data-ttu-id="3cd3e-2699">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2699">-or-</span></span>

<span data-ttu-id="3cd3e-2700">当前实例等于 <see cref="F:System.String.Empty" /> 并且 <paramref name="count" /> 大于 1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2700">The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="count" /> is greater than 1.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-2701"><paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2701"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-2702">字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2702">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-2703">在区分区域性的搜索 (即，如果 <paramref name="comparisonType" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2703">In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="3cd3e-2704">如果 <paramref name="value" /> 仅包含一个或多个可忽略字符，则该 <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> 方法将始终返回 <paramref name="startIndex" /> ，这是搜索开始处的字符位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2704">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.</span></span>

<span data-ttu-id="3cd3e-2705">在下面的示例中， <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> 方法用于查找软连字符 (U + 00AD 的位置) 后跟一个 "m"，但在两个字符串中的最后一个字符位置之前的第一个字符位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2705">In the following example, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" in all but the first character position before the final "m" in two strings.</span></span> <span data-ttu-id="3cd3e-2706">只有一个字符串包含必需的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2706">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="3cd3e-2707">如果该示例在 [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] 或更高版本上运行，则在这两种情况下，因为软连字符是可忽略的字符，所以当执行区分区域性的比较时，该方法将返回字符串中的 "m" 的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2707">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-2708">但当它执行序号比较时，它只查找第一个字符串中的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2708">When it performs an ordinal comparison, however, it finds the substring only in the first string.</span></span> <span data-ttu-id="3cd3e-2709">请注意，对于包含软连字符后跟 "m" 的软连字符的第一个字符串，该方法将无法返回软连字符的索引，而是在执行区分区域性的比较时返回 "m" 的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2709">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m" when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="3cd3e-2710">只有当此方法执行序号比较时，它才会在第一个字符串中返回软连字符的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2710">The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</span></span>

<span data-ttu-id="3cd3e-2711">[！ code-csharp[LastIndexOf # 24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof24.cs#24)][！ code-vb[LastIndexOf # 24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof24.vb#24)]</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2711">[!code-csharp[System.String.LastIndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof24.cs#24)] [!code-vb[System.String.LastIndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof24.vb#24)]</span></span></para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3cd3e-2712">报告在 Unicode 数组中指定的一个或多个字符在此实例中的最后一个匹配项的从零开始的索引的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2712">Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</span></span> <span data-ttu-id="3cd3e-2713">如果未在此实例中找到数组中的字符，则此方法返回 -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2713">The method returns -1 if the characters in the array are not found in this instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] -&gt; int" Usage="string.LastIndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="3cd3e-2714">Unicode 字符数组，包含一个或多个要查找的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2714">A Unicode character array containing one or more characters to seek.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2715">报告在 Unicode 数组中指定的一个或多个字符在此实例中的最后一个匹配项的从零开始的索引的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2715">Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2716">最后一次在此实例中找到 <paramref name="anyOf" /> 中的任意字符的索引位置；如果未找到 <paramref name="anyOf" /> 中的字符，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2716">The index position of the last occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2717">索引编号从0开始。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2717">Index numbering starts from zero.</span></span>

 <span data-ttu-id="3cd3e-2718">此方法从该实例的最后一个字符位置开始搜索，并在开始时向后继续，直到找到中的字符 `anyOf` 或检查了第一个字符位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2718">This method begins searching at the last character position of this instance and proceeds backward toward the beginning until either a character in `anyOf` is found or the first character position has been examined.</span></span> <span data-ttu-id="3cd3e-2719">搜索区分大小写。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2719">The search is case-sensitive.</span></span>

 <span data-ttu-id="3cd3e-2720">此方法执行一个序号 (不区分区域性的) 搜索，其中，仅当字符的 Unicode 标量值相同时，才将其视为等效于另一个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2720">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="3cd3e-2721">若要执行区分区域性的搜索，请使用 <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> 方法，其中表示预构成字符的 Unicode 标量值（如连字 "Æ" (U + 00C6) ）可能被视为等效于正确序列中任何字符的组成部分（例如 "AE" (U + 0041，u + 0045) ，具体取决于区域性）。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2721">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2722">下面的示例查找字符串 "is" 中的任何字符在另一个字符串中的最后一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2722">The following example finds the index of the last occurrence of any character in the string "is" within another string.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2723"><paramref name="anyOf" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2723"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="3cd3e-2724">Unicode 字符数组，包含一个或多个要查找的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2724">A Unicode character array containing one or more characters to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3cd3e-2725">搜索起始位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2725">The search starting position.</span></span> <span data-ttu-id="3cd3e-2726">从 <paramref name="startIndex" /> 此实例的开头开始搜索。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2726">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2727">报告在 Unicode 数组中指定的一个或多个字符在此实例中的最后一个匹配项的从零开始的索引的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2727">Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</span></span> <span data-ttu-id="3cd3e-2728">在指定的字符位置开始和在向后的右边该字符串的开头处理的搜索。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2728">The search starts at a specified character position and proceeds backward toward the beginning of the string.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2729">最后一次在此实例中找到 <paramref name="anyOf" /> 中的任意字符的索引位置；如果未找到 <paramref name="anyOf" /> 中的字符或者当前实例等于<see cref="F:System.String.Empty" />，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2729">The index position of the last occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2730">索引编号从0开始。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2730">Index numbering starts from zero.</span></span>

 <span data-ttu-id="3cd3e-2731">此方法从 `startIndex` 该实例的字符位置开始搜索，并在开始时向后移动，直到找到中的字符 `anyOf` 或检查了第一个字符位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2731">This method begins searching at the `startIndex` character position of this instance and proceeds backward toward the beginning until either a character in `anyOf` is found or the first character position has been examined.</span></span> <span data-ttu-id="3cd3e-2732">搜索区分大小写。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2732">The search is case-sensitive.</span></span>

 <span data-ttu-id="3cd3e-2733">此方法执行一个序号 (不区分区域性的) 搜索，其中，仅当字符的 Unicode 标量值相同时，才将其视为等效于另一个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2733">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="3cd3e-2734">若要执行区分区域性的搜索，请使用 <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> 方法，其中表示预构成字符的 Unicode 标量值（如连字 "Æ" (U + 00C6) ）可能被视为等效于正确序列中任何字符的组成部分（例如 "AE" (U + 0041，u + 0045) ，具体取决于区域性）。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2734">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2735">下面的示例查找字符串 "is" 中任何字符的最后一个匹配项的索引，该字符串位于另一个字符串的子字符串中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2735">The following example finds the index of the last occurrence of any character in the string "is" within a substring of another string.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2736"><paramref name="anyOf" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2736"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-2737">当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 指定不在此实例内的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2737">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> specifies a position that is not within this instance.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="3cd3e-2738">Unicode 字符数组，包含一个或多个要查找的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2738">A Unicode character array containing one or more characters to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3cd3e-2739">搜索起始位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2739">The search starting position.</span></span> <span data-ttu-id="3cd3e-2740">从 <paramref name="startIndex" /> 此实例的开头开始搜索。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2740">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <param name="count"><span data-ttu-id="3cd3e-2741">要检查的字符位置数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2741">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2742">报告在 Unicode 数组中指定的一个或多个字符在此实例中的最后一个匹配项的从零开始的索引的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2742">Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</span></span> <span data-ttu-id="3cd3e-2743">搜索在指定字符位置的数目的字符串开始时，开始指定字符和其后面的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2743">The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2744">最后一次在此实例中找到 <paramref name="anyOf" /> 中的任意字符的索引位置；如果未找到 <paramref name="anyOf" /> 中的字符或者当前实例等于<see cref="F:System.String.Empty" />，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2744">The index position of the last occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2745">索引编号从0开始。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2745">Index numbering starts from zero.</span></span>

 <span data-ttu-id="3cd3e-2746">此方法从 `startIndex` 该实例的字符位置开始搜索，并在开始时向后移动，直到找到了中的一个字符 `anyOf` 或 `count` 已检查了个字符位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2746">This method begins searching at the `startIndex` character position of this instance and proceeds backward toward the beginning until either a character in `anyOf` is found or `count` character positions have been examined.</span></span> <span data-ttu-id="3cd3e-2747">搜索区分大小写。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2747">The search is case-sensitive.</span></span>

 <span data-ttu-id="3cd3e-2748">此方法执行一个序号 (不区分区域性的) 搜索，其中，仅当字符的 Unicode 标量值相同时，才将其视为等效于另一个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2748">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="3cd3e-2749">若要执行区分区域性的搜索，请使用 <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> 方法，其中表示预构成字符的 Unicode 标量值（如连字 "Æ" (U + 00C6) ）可能被视为等效于正确序列中任何字符的组成部分（例如 "AE" (U + 0041，u + 0045) ，具体取决于区域性）。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2749">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2750">下面的示例查找字符串 "帮助" 中的任意字符在另一个字符串的子字符串中的最后一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2750">The following example finds the index of the last occurrence of any character in the string "aid" within a substring of another string.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2751"><paramref name="anyOf" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2751"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-2752">当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="count" /> 或 <paramref name="startIndex" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2752">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="count" /> or <paramref name="startIndex" /> is negative.</span></span>

<span data-ttu-id="3cd3e-2753">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2753">-or-</span></span>

<span data-ttu-id="3cd3e-2754">当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 减去 <paramref name="count" /> 再加 1 小于零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2754">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> minus <paramref name="count" /> + 1 is less than zero.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.string.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3cd3e-2755">获取当前 <see cref="T:System.String" /> 对象中的字符数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2755">Gets the number of characters in the current <see cref="T:System.String" /> object.</span></span></summary>
        <value><span data-ttu-id="3cd3e-2756">当前字符串中字符的数量。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2756">The number of characters in the current string.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2757"><xref:System.String.Length%2A>属性返回 <xref:System.Char> 此实例中的对象数，而不是 Unicode 字符数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2757">The <xref:System.String.Length%2A> property returns the number of <xref:System.Char> objects in this instance, not the number of Unicode characters.</span></span> <span data-ttu-id="3cd3e-2758">原因是 Unicode 字符可能由多个表示 <xref:System.Char> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2758">The reason is that a Unicode character might be represented by more than one <xref:System.Char>.</span></span> <span data-ttu-id="3cd3e-2759">使用 <xref:System.Globalization.StringInfo?displayProperty=nameWithType> 类来处理每个 Unicode 字符，而不是每个 Unicode 字符 <xref:System.Char> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2759">Use the <xref:System.Globalization.StringInfo?displayProperty=nameWithType> class to work with each Unicode character instead of each <xref:System.Char>.</span></span>

 <span data-ttu-id="3cd3e-2760">在某些语言（如 C 和 c + +）中，空字符表示字符串的末尾。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2760">In some languages, such as C and C++, a null character indicates the end of a string.</span></span> <span data-ttu-id="3cd3e-2761">在 .NET 中，可以在字符串中嵌入空字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2761">In .NET, a null character can be embedded in a string.</span></span> <span data-ttu-id="3cd3e-2762">如果字符串中包含一个或多个 null 字符，则它们将包含在总字符串的长度中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2762">When a string includes one or more null characters, they are included in the length of the total string.</span></span> <span data-ttu-id="3cd3e-2763">例如，在下面的字符串中，子字符串 "abc" 和 "def" 由 null 字符分隔。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2763">For example, in the following string, the substrings "abc" and "def" are separated by a null character.</span></span> <span data-ttu-id="3cd3e-2764"><xref:System.String.Length%2A>属性返回7，这表示它包含六个字母字符以及 null 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2764">The <xref:System.String.Length%2A> property returns 7, which indicates that it includes the six alphabetic characters as well as the null character.</span></span>

 [!code-cpp[System.String.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp-interactive[System.String.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]



## Examples
 <span data-ttu-id="3cd3e-2765">下面的示例演示了 <xref:System.String.Length%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2765">The following example demonstrates the <xref:System.String.Length%2A> property.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Normalize">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3cd3e-2766">返回一个新字符串，其二进制表示形式符合特定的 Unicode 范式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2766">Returns a new string whose binary representation is in a particular Unicode normalization form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 <span data-ttu-id="3cd3e-2767">下面的示例将一个字符串规范化为四个范式中的每一个，确认该字符串已规范化为指定范式，然后列出规范化字符串中的码位。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2767">The following example normalizes a string to each of four normalization forms, confirms the string was normalized to the specified normalization form, then lists the code points in the normalized string.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize();" />
      <MemberSignature Language="F#" Value="member this.Normalize : unit -&gt; string" Usage="string.Normalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3cd3e-2768">返回一个新字符串，其文本值与此字符串相同，但其二进制表示形式符合 Unicode 范式 C。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2768">Returns a new string whose textual value is the same as this string, but whose binary representation is in Unicode normalization form C.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2769">一个新的规范化字符串，其文本值与此字符串相同，但其二进制表示形式符合范式 C。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2769">A new, normalized string whose textual value is the same as this string, but whose binary representation is in normalization form C.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2770">某些 Unicode 字符具有多个等效的二进制表示形式，其中包含组合和/或复合 Unicode 字符的集合。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2770">Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</span></span> <span data-ttu-id="3cd3e-2771">例如，以下任何代码点都可以表示字母 "ắ"：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2771">For example, any of the following code points can represent the letter "ắ":</span></span>

-   <span data-ttu-id="3cd3e-2772">U + 1EAF</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2772">U+1EAF</span></span>

-   <span data-ttu-id="3cd3e-2773">U + 0103 U + 0301</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2773">U+0103 U+0301</span></span>

-   <span data-ttu-id="3cd3e-2774">U + 0061 U + 0306 U + 0301</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2774">U+0061 U+0306 U+0301</span></span>

 <span data-ttu-id="3cd3e-2775">单个字符存在多个表示形式会使搜索、排序、匹配和其他操作复杂化。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2775">The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</span></span>

 <span data-ttu-id="3cd3e-2776">Unicode 标准定义了一个名为规范化的进程，该进程在给定任何等效的二进制表示形式的字符时返回一个二进制表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2776">The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</span></span> <span data-ttu-id="3cd3e-2777">可以通过多个算法（称为标准化形式）来执行规范化，它们遵循不同的规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2777">Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</span></span> <span data-ttu-id="3cd3e-2778">.NET 支持由 Unicode 标准定义的四种范式 (C、D、GLM-KC-QNW 和 KD) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2778">.NET supports the four normalization forms (C, D, KC, and KD) that are defined by the Unicode standard.</span></span> <span data-ttu-id="3cd3e-2779">如果两个字符串用同一范式表示，则可以使用序号比较对它们进行比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2779">When two strings are represented in the same normalization form, they can be compared by using ordinal comparison.</span></span>

 <span data-ttu-id="3cd3e-2780">若要规范化和比较两个字符串，请执行以下操作：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2780">To normalize and compare two strings, do the following:</span></span>

1.  <span data-ttu-id="3cd3e-2781">获取要从输入源（如文件或用户输入设备）进行比较的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2781">Obtain the strings to be compared from an input source, such as a file or a user input device.</span></span>

2.  <span data-ttu-id="3cd3e-2782">调用 <xref:System.String.Normalize> 方法以将字符串规范化为范式 C。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2782">Call the <xref:System.String.Normalize> method to normalize the strings to normalization form C.</span></span>

3.  <span data-ttu-id="3cd3e-2783">若要比较两个字符串，请调用支持序号字符串比较的方法，如 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> 方法，并将或的值 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 作为参数提供 <xref:System.StringComparison> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2783">To compare two strings, call a method that supports ordinal string comparison, such as the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, and supply a value of <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> as the <xref:System.StringComparison> argument.</span></span> <span data-ttu-id="3cd3e-2784">若要对规范化字符串数组进行排序，请将 `comparer` 或的值传递给的 <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> 适当重载 <xref:System.Array.Sort%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2784">To sort an array of normalized strings, pass a `comparer` value of <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> or <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> to an appropriate overload of <xref:System.Array.Sort%2A?displayProperty=nameWithType>.</span></span>

4.  <span data-ttu-id="3cd3e-2785">根据上一步指示的顺序，在已排序的输出中发出字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2785">Emit the strings in the sorted output based on the order indicated by the previous step.</span></span>

 <span data-ttu-id="3cd3e-2786">有关支持的 Unicode 范式的说明，请参阅 <xref:System.Text.NormalizationForm?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2786">For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-2787">当前实例包含无效的 Unicode 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2787">The current instance contains invalid Unicode characters.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-2788">此 <see cref="Overload:System.String.IsNormalized" /> 方法 <see langword="false" /> 会在遇到字符串中第一个非规范化字符时立即返回。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2788">The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string.</span></span> <span data-ttu-id="3cd3e-2789">因此，如果字符串包含非规范化字符后跟无效的 Unicode 字符，则该 <see cref="Overload:System.String.Normalize" /> 方法将引发， <see cref="T:System.ArgumentException" /> 但 <see cref="Overload:System.String.IsNormalized" /> 返回 <see langword="false" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2789">Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method will throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</span></span></para></block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize (normalizationForm As NormalizationForm) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.Normalize : System.Text.NormalizationForm -&gt; string" Usage="string.Normalize normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="normalizationForm"><span data-ttu-id="3cd3e-2790">一个 Unicode 范式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2790">A Unicode normalization form.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2791">返回一个新字符串，其文本值与此字符串相同，但其二进制表示形式符合指定的 Unicode 范式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2791">Returns a new string whose textual value is the same as this string, but whose binary representation is in the specified Unicode normalization form.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2792">一个新字符串，其文本值与此字符串相同，但其二进制表示形式符合由 <paramref name="normalizationForm" /> 参数指定的范式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2792">A new string whose textual value is the same as this string, but whose binary representation is in the normalization form specified by the <paramref name="normalizationForm" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2793">某些 Unicode 字符具有多个等效的二进制表示形式，其中包含组合和/或复合 Unicode 字符的集合。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2793">Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</span></span> <span data-ttu-id="3cd3e-2794">单个字符存在多个表示形式会使搜索、排序、匹配和其他操作复杂化。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2794">The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</span></span>

 <span data-ttu-id="3cd3e-2795">Unicode 标准定义了一个名为规范化的进程，该进程在给定任何等效的二进制表示形式的字符时返回一个二进制表示形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2795">The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</span></span> <span data-ttu-id="3cd3e-2796">可以通过多个算法（称为标准化形式）来执行规范化，它们遵循不同的规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2796">Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</span></span> <span data-ttu-id="3cd3e-2797">.NET 支持由 Unicode 标准定义的四种范式 (C、D、GLM-KC-QNW 和 KD) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2797">.NET supports the four normalization forms (C, D, KC, and KD) that are defined by the Unicode standard.</span></span> <span data-ttu-id="3cd3e-2798">如果两个字符串用同一范式表示，则可以使用序号比较对它们进行比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2798">When two strings are represented in the same normalization form, they can be compared by using ordinal comparison.</span></span>

 <span data-ttu-id="3cd3e-2799">若要规范化和比较两个字符串，请执行以下操作：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2799">To normalize and compare two strings, do the following:</span></span>

1.  <span data-ttu-id="3cd3e-2800">获取要从输入源（如文件或用户输入设备）进行比较的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2800">Obtain the strings to be compared from an input source, such as a file or a user input device.</span></span>

2.  <span data-ttu-id="3cd3e-2801">调用 <xref:System.String.Normalize%28System.Text.NormalizationForm%29> 方法以将字符串规范化为指定的范式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2801">Call the <xref:System.String.Normalize%28System.Text.NormalizationForm%29> method to normalize the strings to a specified normalization form.</span></span>

3.  <span data-ttu-id="3cd3e-2802">若要比较两个字符串，请调用支持序号字符串比较的方法，如 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> 方法，并将或的值 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 作为参数提供 <xref:System.StringComparison> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2802">To compare two strings, call a method that supports ordinal string comparison, such as the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, and supply a value of <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> as the <xref:System.StringComparison> argument.</span></span> <span data-ttu-id="3cd3e-2803">若要对规范化字符串数组进行排序，请将 `comparer` 或的值传递给的 <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> 适当重载 <xref:System.Array.Sort%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2803">To sort an array of normalized strings, pass a `comparer` value of <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> or <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> to an appropriate overload of <xref:System.Array.Sort%2A?displayProperty=nameWithType>.</span></span>

4.  <span data-ttu-id="3cd3e-2804">根据上一步指示的顺序，在已排序的输出中发出字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2804">Emit the strings in the sorted output based on the order indicated by the previous step.</span></span>

 <span data-ttu-id="3cd3e-2805">有关支持的 Unicode 范式的说明，请参阅 <xref:System.Text.NormalizationForm?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2805">For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-2806">当前实例包含无效的 Unicode 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2806">The current instance contains invalid Unicode characters.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-2807">此 <see cref="Overload:System.String.IsNormalized" /> 方法 <see langword="false" /> 会在遇到字符串中第一个非规范化字符时立即返回。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2807">The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string.</span></span> <span data-ttu-id="3cd3e-2808">因此，如果字符串包含非规范化字符后跟无效的 Unicode 字符，则该 <see cref="Overload:System.String.Normalize" /> 方法可能会引发， <see cref="T:System.ArgumentException" /> 但 <see cref="Overload:System.String.IsNormalized" /> 返回 <see langword="false" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2808">Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method may throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</span></span></para></block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member ( = ) : string * string -&gt; bool" Usage="a = b" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="3cd3e-2809">要比较的第一个字符串，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2809">The first string to compare, or <see langword="null" />.</span></span></param>
        <param name="b"><span data-ttu-id="3cd3e-2810">要比较的第二个字符串，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2810">The second string to compare, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2811">确定两个指定的字符串是否具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2811">Determines whether two specified strings have the same value.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2812">如果 <see langword="true" /> 的值与 <paramref name="a" /> 的值相同，则为 <paramref name="b" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2812"><see langword="true" /> if the value of <paramref name="a" /> is the same as the value of <paramref name="b" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2813"><xref:System.String.op_Equality%2A>方法定义类的相等运算符的运算 <xref:System.String> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2813">The <xref:System.String.op_Equality%2A> method defines the operation of the equality operator for the <xref:System.String> class.</span></span> <span data-ttu-id="3cd3e-2814">它将启用示例部分中所示的代码。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2814">It enables code such as that shown in the Example section.</span></span> <span data-ttu-id="3cd3e-2815">运算符反过来调用静态 <xref:System.String.Equals%28System.String%2CSystem.String%29> 方法，该方法执行 (区分大小写和不区分区域性的) 比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2815">The operator, in turn, calls the static <xref:System.String.Equals%28System.String%2CSystem.String%29> method, which performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-2816">Visual Basic 编译器不会将相等运算符解析为对方法的调用 <xref:System.String.op_Equality%2A> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2816">The Visual Basic compiler does not resolve the equality operator as a call to the <xref:System.String.op_Equality%2A> method.</span></span> <span data-ttu-id="3cd3e-2817">相反，相等运算符包装对方法的调用 <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2817">Instead, the equality operator wraps a call to the <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> method.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2818">下面的示例演示了相等运算符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2818">The following example demonstrates the equality operator.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs" interactive="try-dotnet" id="Snippet1":::
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;char&gt; (string? value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;char&gt; op_Implicit(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Implicit(System.String)~System.ReadOnlySpan{System.Char}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;char&gt;(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.string.op_Implicit value" />
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;char&gt; (string value);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-2819">要隐式转换的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2819">A string to implicitly convert.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2820">定义给定字符串到只读字符范围的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2820">Defines an implicit conversion of a given string to a read-only span of characters.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2821">表示字符串的新只读字符范围。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2821">A new read-only span of characters representing the string.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : string * string -&gt; bool" Usage="System.string.op_Inequality (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="3cd3e-2822">要比较的第一个字符串，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2822">The first string to compare, or <see langword="null" />.</span></span></param>
        <param name="b"><span data-ttu-id="3cd3e-2823">要比较的第二个字符串，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2823">The second string to compare, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2824">确定两个指定的字符串是否具有不同的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2824">Determines whether two specified strings have different values.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2825">如果 <see langword="true" /> 的值与 <paramref name="a" /> 的值不同，则为 <paramref name="b" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2825"><see langword="true" /> if the value of <paramref name="a" /> is different from the value of <paramref name="b" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2826"><xref:System.String.op_Inequality%2A>方法为类定义不相等运算符的运算 <xref:System.String> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2826">The <xref:System.String.op_Inequality%2A> method defines the operation of the inequality operator for the <xref:System.String> class.</span></span>   <span data-ttu-id="3cd3e-2827">它将启用示例部分中所示的代码。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2827">It enables code such as that shown in the Examples section.</span></span>

 <span data-ttu-id="3cd3e-2828"><xref:System.String.op_Inequality%2A>运算符反过来调用静态 <xref:System.String.Equals%28System.String%2CSystem.String%29> 方法，该方法执行 (区分大小写和不区分区域性的) 比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2828">The <xref:System.String.op_Inequality%2A> operator in turn calls the static <xref:System.String.Equals%28System.String%2CSystem.String%29> method, which  performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-2829">Visual Basic 编译器不会将不相等运算符解析为对方法的调用 <xref:System.String.op_Inequality%2A> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2829">The Visual Basic compiler does not resolve the inequality operator as a call to the <xref:System.String.op_Inequality%2A> method.</span></span> <span data-ttu-id="3cd3e-2830">相反，不等运算符包装对方法的调用 <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2830">Instead, the inequality operator wraps a call to the <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> method.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2831">下面的示例演示不等运算符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2831">The following example demonstrates the inequality operator.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs" interactive="try-dotnet" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PadLeft">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3cd3e-2832">返回一个指定长度的新字符串，其中在当前字符串的开头填充空格或指定的 Unicode 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2832">Returns a new string of a specified length in which the beginning of the current string is padded with spaces or with a specified Unicode character.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int -&gt; string" Usage="string.PadLeft totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth"><span data-ttu-id="3cd3e-2833">结果字符串中的字符数，等于原始字符数加上任何其他填充字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2833">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2834">返回一个新字符串，该字符串通过在此实例中的字符左侧填充空格来达到指定的总长度，从而实现右对齐。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2834">Returns a new string that right-aligns the characters in this instance by padding them with spaces on the left, for a specified total length.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2835">与此实例等效的一个新字符串，但该字符串为右对齐，因此，在左侧填充所需任意数量的空格，使长度达到 <paramref name="totalWidth" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2835">A new string that is equivalent to this instance, but right-aligned and padded on the left with as many spaces as needed to create a length of <paramref name="totalWidth" />.</span></span> <span data-ttu-id="3cd3e-2836">但是，如果 <paramref name="totalWidth" /> 小于此实例的长度，则此方法返回对现有实例的引用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2836">However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance.</span></span> <span data-ttu-id="3cd3e-2837">如果 <paramref name="totalWidth" /> 等于此实例的长度，则此方法返回与此实例相同的新字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2837">If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2838">Unicode 空格定义为十六进制0x0020。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2838">A Unicode space is defined as hexadecimal 0x0020.</span></span>

 <span data-ttu-id="3cd3e-2839"><xref:System.String.PadLeft%28System.Int32%29>方法用于填充返回的字符串的开头。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2839">The <xref:System.String.PadLeft%28System.Int32%29> method pads the beginning of the returned string.</span></span> <span data-ttu-id="3cd3e-2840">这意味着，当与从右到左的语言结合使用时，它将填充字符串的右侧部分。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2840">This means that, when used with right-to-left languages, it pads the right portion of the string.</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-2841">如果 <xref:System.String.PadLeft%2A> 方法用空白字符填充当前实例，则此方法不会修改当前实例的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2841">If the <xref:System.String.PadLeft%2A> method pads the current instance with white-space characters, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="3cd3e-2842">相反，它会返回一个新字符串，该字符串使用前导空格填充，使其总长度为 `totalWidth` 个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2842">Instead, it returns a new string that is padded with leading white space so that its total length is `totalWidth` characters.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2843">下面的示例演示 <xref:System.String.PadLeft%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2843">The following example demonstrates the <xref:System.String.PadLeft%2A> method.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-2844"><paramref name="totalWidth" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2844"><paramref name="totalWidth" /> is less than zero.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int * char -&gt; string" Usage="string.PadLeft (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth"><span data-ttu-id="3cd3e-2845">结果字符串中的字符数，等于原始字符数加上任何其他填充字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2845">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</span></span></param>
        <param name="paddingChar"><span data-ttu-id="3cd3e-2846">Unicode 填充字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2846">A Unicode padding character.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2847">返回一个新字符串，该字符串通过在此实例中的字符左侧填充指定的 Unicode 字符来达到指定的总长度，从而使这些字符右对齐。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2847">Returns a new string that right-aligns the characters in this instance by padding them on the left with a specified Unicode character, for a specified total length.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2848">与此实例等效的一个新字符串，但该字符串为右对齐，因此，在左侧填充所需任意数量的 <paramref name="paddingChar" /> 字符，使长度达到 <paramref name="totalWidth" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2848">A new string that is equivalent to this instance, but right-aligned and padded on the left with as many <paramref name="paddingChar" /> characters as needed to create a length of <paramref name="totalWidth" />.</span></span> <span data-ttu-id="3cd3e-2849">但是，如果 <paramref name="totalWidth" /> 小于此实例的长度，则此方法返回对现有实例的引用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2849">However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance.</span></span> <span data-ttu-id="3cd3e-2850">如果 <paramref name="totalWidth" /> 等于此实例的长度，则此方法返回与此实例相同的新字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2850">If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2851"><xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29>方法用于填充返回的字符串的开头。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2851">The <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29> method pads the beginning of the returned string.</span></span> <span data-ttu-id="3cd3e-2852">这意味着，当与从右到左的语言结合使用时，它将填充字符串的右侧部分。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2852">This means that, when used with right-to-left languages, it pads the right portion of the string.</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-2853">如果 <xref:System.String.PadLeft%2A> 方法用空白字符填充当前实例，则此方法不会修改当前实例的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2853">If the <xref:System.String.PadLeft%2A> method pads the current instance with white-space characters, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="3cd3e-2854">相反，它会返回一个新字符串，该字符串使用前导字符填充， `paddingChar` 使其总长度为 `totalWidth` 个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2854">Instead, it returns a new string that is padded with leading `paddingChar` characters so that its total length is `totalWidth` characters.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2855">下面的示例演示 <xref:System.String.PadLeft%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2855">The following example demonstrates the <xref:System.String.PadLeft%2A> method.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-2856"><paramref name="totalWidth" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2856"><paramref name="totalWidth" /> is less than zero.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PadRight">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3cd3e-2857">返回一个指定长度的新字符串，其中在当前字符串的结尾填充空格或指定的 Unicode 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2857">Returns a new string of a specified length in which the end of the current string is padded with spaces or with a specified Unicode character.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int -&gt; string" Usage="string.PadRight totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth"><span data-ttu-id="3cd3e-2858">结果字符串中的字符数，等于原始字符数加上任何其他填充字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2858">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2859">返回一个新字符串，该字符串通过在此字符串中的字符右侧填充空格来达到指定的总长度，从而使这些字符左对齐。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2859">Returns a new string that left-aligns the characters in this string by padding them with spaces on the right, for a specified total length.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2860">与此实例等效的一个新字符串，但该字符串为左对齐，因此，在右侧填充所需任意数量的空格，使长度达到 <paramref name="totalWidth" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2860">A new string that is equivalent to this instance, but left-aligned and padded on the right with as many spaces as needed to create a length of <paramref name="totalWidth" />.</span></span> <span data-ttu-id="3cd3e-2861">但是，如果 <paramref name="totalWidth" /> 小于此实例的长度，则此方法返回对现有实例的引用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2861">However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance.</span></span> <span data-ttu-id="3cd3e-2862">如果 <paramref name="totalWidth" /> 等于此实例的长度，则此方法返回与此实例相同的新字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2862">If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2863">Unicode 空格定义为十六进制0x0020。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2863">A Unicode space is defined as hexadecimal 0x0020.</span></span>

 <span data-ttu-id="3cd3e-2864"><xref:System.String.PadRight%28System.Int32%29>方法用于填充返回的字符串的末尾。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2864">The <xref:System.String.PadRight%28System.Int32%29> method pads the end of the returned string.</span></span> <span data-ttu-id="3cd3e-2865">这意味着，当与从右到左的语言结合使用时，它将填充字符串的左侧部分。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2865">This means that, when used with right-to-left languages, it pads the left portion of the string.</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-2866">如果 <xref:System.String.PadRight%2A> 方法用空白字符填充当前实例，则此方法不会修改当前实例的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2866">If the <xref:System.String.PadRight%2A> method pads the current instance with white-space characters, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="3cd3e-2867">相反，它会返回一个新字符串，该字符串用尾随空格填充，使其总长度为 `totalWidth` 个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2867">Instead, it returns a new string that is padded with trailing white space so that its total length is `totalWidth` characters.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2868">下面的示例演示 <xref:System.String.PadRight%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2868">The following example demonstrates the <xref:System.String.PadRight%2A> method.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-2869"><paramref name="totalWidth" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2869"><paramref name="totalWidth" /> is less than zero.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int * char -&gt; string" Usage="string.PadRight (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth"><span data-ttu-id="3cd3e-2870">结果字符串中的字符数，等于原始字符数加上任何其他填充字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2870">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</span></span></param>
        <param name="paddingChar"><span data-ttu-id="3cd3e-2871">Unicode 填充字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2871">A Unicode padding character.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2872">返回一个新字符串，该字符串通过在此字符串中的字符右侧填充指定的 Unicode 字符来达到指定的总长度，从而使这些字符左对齐。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2872">Returns a new string that left-aligns the characters in this string by padding them on the right with a specified Unicode character, for a specified total length.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2873">与此实例等效的一个新字符串，但该字符串为左对齐，因此，在右侧填充所需任意数量的 <paramref name="paddingChar" /> 字符，使长度达到 <paramref name="totalWidth" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2873">A new string that is equivalent to this instance, but left-aligned and padded on the right with as many <paramref name="paddingChar" /> characters as needed to create a length of <paramref name="totalWidth" />.</span></span> <span data-ttu-id="3cd3e-2874">但是，如果 <paramref name="totalWidth" /> 小于此实例的长度，则此方法返回对现有实例的引用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2874">However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance.</span></span> <span data-ttu-id="3cd3e-2875">如果 <paramref name="totalWidth" /> 等于此实例的长度，则此方法返回与此实例相同的新字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2875">If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2876"><xref:System.String.PadRight%28System.Int32%2CSystem.Char%29>方法用于填充返回的字符串的末尾。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2876">The <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29> method pads the end of the returned string.</span></span> <span data-ttu-id="3cd3e-2877">这意味着，当与从右到左的语言结合使用时，它将填充字符串的左侧部分。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2877">This means that, when used with right-to-left languages, it pads the left portion of the string.</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-2878">如果 <xref:System.String.PadRight%2A> 方法用空白字符填充当前实例，则此方法不会修改当前实例的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2878">If the <xref:System.String.PadRight%2A> method pads the current instance with white-space characters, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="3cd3e-2879">相反，它会返回一个新字符串，该字符串用尾随字符填充， `paddingChar` 使其总长度为 `totalWidth` 个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2879">Instead, it returns a new string that is padded with trailing `paddingChar` characters so that its total length is `totalWidth` characters.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2880">下面的示例演示 <xref:System.String.PadRight%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2880">The following example demonstrates the <xref:System.String.PadRight%2A> method.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-2881"><paramref name="totalWidth" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2881"><paramref name="totalWidth" /> is less than zero.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3cd3e-2882">返回一个新字符串，它相当于从当前字符串删除了指定数量的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2882">Returns a new string in which a specified number of characters from the current string are deleted.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Remove : int -&gt; string" Usage="string.Remove startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="3cd3e-2883">开始删除字符的从零开始的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2883">The zero-based position to begin deleting characters.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2884">返回当前实例中从指定位置到最后位置的所有以删除的字符的新字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2884">Returns a new string in which all the characters in the current instance, beginning at a specified position and continuing through the last position, have been deleted.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2885">一个新字符串，除所删除的字符之外，该字符串与此字符串等效。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2885">A new string that is equivalent to this string except for the removed characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2886">在中 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] ，字符串是从零开始的。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2886">In the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], strings are zero-based.</span></span> <span data-ttu-id="3cd3e-2887">参数的值的 `startIndex` 范围可以介于0到字符串实例的长度之间。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2887">The value of the `startIndex` parameter can range from zero to one less than the length of the string instance.</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-2888">此方法不会修改当前实例的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2888">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="3cd3e-2889">相反，它会返回一个新字符串，其中的所有字符都从 `startIndex` 一个位置移到原始字符串的末尾。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2889">Instead, it returns a new string in which all characters from position `startIndex` to the end of the original string have been removed.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2890">下面的示例演示 <xref:System.String.Remove%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2890">The following example demonstrates the <xref:System.String.Remove%2A> method.</span></span> <span data-ttu-id="3cd3e-2891">"下一步到最后一种情况" 从字符串的末尾开始删除从指定索引处开始的所有文本。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2891">The next-to-last case removes all text starting from the specified index through the end of the string.</span></span> <span data-ttu-id="3cd3e-2892">最后一种情况从指定的索引开始删除三个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2892">The last case removes three characters starting from the specified index.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-2893"><paramref name="startIndex" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2893"><paramref name="startIndex" /> is less than zero.</span></span>

<span data-ttu-id="3cd3e-2894">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2894">-or-</span></span>

 <span data-ttu-id="3cd3e-2895"><paramref name="startIndex" /> 指定不在此字符串中的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2895"><paramref name="startIndex" /> specifies a position that is not within this string.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; string" Usage="string.Remove (startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="3cd3e-2896">开始删除字符的从零开始的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2896">The zero-based position to begin deleting characters.</span></span></param>
        <param name="count"><span data-ttu-id="3cd3e-2897">要删除的字符数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2897">The number of characters to delete.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2898">返回指定数量字符在当前这个实例起始点在已删除的指定的位置的新字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2898">Returns a new string in which a specified number of characters in the current instance beginning at a specified position have been deleted.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2899">一个新字符串，除所删除的字符之外，该字符串与此实例等效。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2899">A new string that is equivalent to this instance except for the removed characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2900">在中 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] ，字符串是从零开始的。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2900">In the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], strings are zero-based.</span></span> <span data-ttu-id="3cd3e-2901">参数的值的 `startIndex` 范围可以介于0到字符串实例的长度之间。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2901">The value of the `startIndex` parameter can range from zero to one less than the length of the string instance.</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-2902">此方法不会修改当前实例的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2902">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="3cd3e-2903">相反，它会返回一个新字符串，其中已删除参数指定的字符数 `count` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2903">Instead, it returns a new string in which the number of characters specified by the `count` parameter have been removed.</span></span> <span data-ttu-id="3cd3e-2904">在指定的位置删除字符 `startIndex` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2904">The characters are removed at the position specified by `startIndex`.</span></span>



## Examples
 <span data-ttu-id="3cd3e-2905">下面的示例演示如何删除完整名称中的中间名。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2905">The following example demonstrates how you can remove the middle name from a complete name.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-2906"><paramref name="startIndex" /> 或 <paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2906">Either <paramref name="startIndex" /> or <paramref name="count" /> is less than zero.</span></span>

<span data-ttu-id="3cd3e-2907">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2907">-or-</span></span>

 <span data-ttu-id="3cd3e-2908"><paramref name="startIndex" /> 加 <paramref name="count" /> 指定此实例之外的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2908"><paramref name="startIndex" /> plus <paramref name="count" /> specify a position outside this instance.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3cd3e-2909">返回一个新字符串，其中已将当前字符串中的指定 Unicode 字符或 <see cref="T:System.String" /> 的所有匹配项替换为其他指定的 Unicode 字符或 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2909">Returns a new string in which all occurrences of a specified Unicode character or <see cref="T:System.String" /> in the current string are replaced with another specified Unicode character or <see cref="T:System.String" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; string" Usage="string.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar"><span data-ttu-id="3cd3e-2910">要替换的 Unicode 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2910">The Unicode character to be replaced.</span></span></param>
        <param name="newChar"><span data-ttu-id="3cd3e-2911">要替换出现的所有 <paramref name="oldChar" /> 的 Unicode 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2911">The Unicode character to replace all occurrences of <paramref name="oldChar" />.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2912">返回一个新字符串，其中此实例中出现的所有指定 Unicode 字符都替换为另一个指定的 Unicode 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2912">Returns a new string in which all occurrences of a specified Unicode character in this instance are replaced with another specified Unicode character.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2913">等效于此实例（除了 <paramref name="oldChar" /> 的所有实例都已替换为 <paramref name="newChar" /> 外）的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2913">A string that is equivalent to this instance except that all instances of <paramref name="oldChar" /> are replaced with <paramref name="newChar" />.</span></span> <span data-ttu-id="3cd3e-2914">如果在当前实例中找不到 <paramref name="oldChar" />，此方法返回未更改的当前实例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2914">If <paramref name="oldChar" /> is not found in the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2915">此方法执行 (区分大小写和不区分区域性的序号) 搜索以查找 `oldChar` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2915">This method performs an ordinal (case-sensitive and culture-insensitive) search to find `oldChar`.</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-2916">此方法不会修改当前实例的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2916">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="3cd3e-2917">相反，它会返回一个新字符串，其中的所有匹配项 `oldChar` 都将替换为 `newChar` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2917">Instead, it returns a new string in which all occurrences of `oldChar` are replaced by `newChar`.</span></span>

 <span data-ttu-id="3cd3e-2918">由于此方法返回修改后的字符串，因此可以将对方法的连续调用链接在一起， <xref:System.String.Replace%2A> 以对原始字符串执行多次替换。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2918">Because this method returns the modified string, you can chain together successive calls to the <xref:System.String.Replace%2A> method to perform multiple replacements on the original string.</span></span> <span data-ttu-id="3cd3e-2919">方法调用从左至右执行。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2919">Method calls are executed from left to right.</span></span> <span data-ttu-id="3cd3e-2920">下面的示例进行了这方面的演示。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2920">The following example provides an illustration.</span></span>

 [!code-csharp-interactive[System.String.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]



## Examples
 <span data-ttu-id="3cd3e-2921">下面的示例通过用逗号替换一系列数字之间的空格来创建逗号分隔值列表。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2921">The following example creates a comma separated value list by substituting commas for the blanks between a series of numbers.</span></span>

 [!code-cpp[string.replace1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp-interactive[string.replace1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="string.Replace (oldValue, newValue)" />
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string? newValue);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue"><span data-ttu-id="3cd3e-2922">要替换的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2922">The string to be replaced.</span></span></param>
        <param name="newValue"><span data-ttu-id="3cd3e-2923">要替换 <paramref name="oldValue" /> 的所有匹配项的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2923">The string to replace all occurrences of <paramref name="oldValue" />.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2924">返回一个新字符串，其中当前实例中出现的所有指定字符串都替换为另一个指定的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2924">Returns a new string in which all occurrences of a specified string in the current instance are replaced with another specified string.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2925">等效于当前字符串（除了 <paramref name="oldValue" /> 的所有实例都已替换为 <paramref name="newValue" /> 外）的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2925">A string that is equivalent to the current string except that all instances of <paramref name="oldValue" /> are replaced with <paramref name="newValue" />.</span></span> <span data-ttu-id="3cd3e-2926">如果在当前实例中找不到 <paramref name="oldValue" />，此方法返回未更改的当前实例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2926">If <paramref name="oldValue" /> is not found in the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2927">如果 `newValue` 为 `null` ，则删除的所有匹配项 `oldValue` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2927">If `newValue` is `null`, all occurrences of `oldValue` are removed.</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-2928">此方法不会修改当前实例的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2928">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="3cd3e-2929">相反，它会返回一个新字符串，其中的所有匹配项 `oldValue` 都将替换为 `newValue` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2929">Instead, it returns a new string in which all occurrences of `oldValue` are replaced by `newValue`.</span></span>

 <span data-ttu-id="3cd3e-2930">此方法执行 (区分大小写和不区分区域性的序号) 搜索以查找 `oldValue` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2930">This method performs an ordinal (case-sensitive and culture-insensitive) search to find `oldValue`.</span></span>

 <span data-ttu-id="3cd3e-2931">由于此方法返回修改后的字符串，因此可以将对方法的连续调用链接在一起， <xref:System.String.Replace%2A> 以对原始字符串执行多次替换。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2931">Because this method returns the modified string, you can chain together successive calls to the <xref:System.String.Replace%2A> method to perform multiple replacements on the original string.</span></span> <span data-ttu-id="3cd3e-2932">方法调用从左至右执行。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2932">Method calls are executed from left to right.</span></span> <span data-ttu-id="3cd3e-2933">下面的示例进行了这方面的演示。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2933">The following example provides an illustration.</span></span>

 [!code-csharp-interactive[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]



## Examples
 <span data-ttu-id="3cd3e-2934">下面的示例演示如何使用 <xref:System.String.Replace%2A> 方法更正拼写错误。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2934">The following example demonstrates how you can use the <xref:System.String.Replace%2A> method to correct a spelling error.</span></span>

 [!code-cpp[stringreplace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp-interactive[stringreplace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2935"><paramref name="oldValue" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2935"><paramref name="oldValue" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-2936"><paramref name="oldValue" /> 为空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2936"><paramref name="oldValue" /> is the empty string ("").</span></span></exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string? newValue, StringComparison comparisonType);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, comparisonType As StringComparison) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * StringComparison -&gt; string" Usage="string.Replace (oldValue, newValue, comparisonType)" />
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="newValue" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="oldValue"><span data-ttu-id="3cd3e-2937">要替换的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2937">The string to be replaced.</span></span></param>
        <param name="newValue"><span data-ttu-id="3cd3e-2938">要替换 <paramref name="oldValue" /> 的所有匹配项的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2938">The string to replace all occurrences of <paramref name="oldValue" />.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="3cd3e-2939">枚举值之一，用于确定在此实例内搜索 <paramref name="oldValue" /> 的方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2939">One of the enumeration values that determines how <paramref name="oldValue" /> is searched within this instance.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2940">返回一个新字符串，其中当前实例中出现的所有指定字符串都使用提供的比较类型替换为另一个指定的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2940">Returns a new string in which all occurrences of a specified string in the current instance are replaced with another specified string, using the provided comparison type.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2941">等效于当前字符串（除了 <paramref name="oldValue" /> 的所有实例都已替换为 <paramref name="newValue" /> 外）的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2941">A string that is equivalent to the current string except that all instances of <paramref name="oldValue" /> are replaced with <paramref name="newValue" />.</span></span> <span data-ttu-id="3cd3e-2942">如果在当前实例中找不到 <paramref name="oldValue" />，此方法返回未更改的当前实例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2942">If <paramref name="oldValue" /> is not found in the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
<span data-ttu-id="3cd3e-2943">如果 `newValue` 为 `null` ，则删除的所有匹配项 `oldValue` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2943">If `newValue` is `null`, all occurrences of `oldValue` are removed.</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-2944">此方法不会修改当前实例的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2944">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="3cd3e-2945">相反，它会返回一个新字符串，其中的所有匹配项 `oldValue` 都将替换为 `newValue` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2945">Instead, it returns a new string in which all occurrences of `oldValue` are replaced by `newValue`.</span></span>

<span data-ttu-id="3cd3e-2946">此方法执行搜索以查找 `oldValue` 使用所述的区域性和区分大小写 `comparisonType` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2946">This method performs a search to find `oldValue` using the culture and case sensitivity described by `comparisonType`.</span></span>

<span data-ttu-id="3cd3e-2947">由于此方法返回修改后的字符串，因此可以将对方法的连续调用链接在一起， <xref:System.String.Replace%2A> 以对原始字符串执行多次替换。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2947">Because this method returns the modified string, you can chain together successive calls to the <xref:System.String.Replace%2A> method to perform multiple replacements on the original string.</span></span> <span data-ttu-id="3cd3e-2948">方法调用从左至右执行。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2948">Method calls are executed from left to right.</span></span> <span data-ttu-id="3cd3e-2949">下面的示例进行了这方面的演示。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2949">The following example provides an illustration.</span></span>

[!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
[!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2950"><paramref name="oldValue" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2950"><paramref name="oldValue" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-2951"><paramref name="oldValue" /> 为空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2951"><paramref name="oldValue" /> is the empty string ("").</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string? newValue, bool ignoreCase, System.Globalization.CultureInfo? culture);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, ignoreCase As Boolean, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * bool * System.Globalization.CultureInfo -&gt; string" Usage="string.Replace (oldValue, newValue, ignoreCase, culture)" />
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="newValue" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="oldValue"><span data-ttu-id="3cd3e-2952">要替换的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2952">The string to be replaced.</span></span></param>
        <param name="newValue"><span data-ttu-id="3cd3e-2953">要替换 <paramref name="oldValue" /> 的所有匹配项的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2953">The string to replace all occurrences of <paramref name="oldValue" />.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="3cd3e-2954">在比较时忽略大小写则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2954"><see langword="true" /> to ignore casing when comparing; <see langword="false" /> otherwise.</span></span></param>
        <param name="culture"><span data-ttu-id="3cd3e-2955">比较时要使用的区域性。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2955">The culture to use when comparing.</span></span></param>
        <summary><span data-ttu-id="3cd3e-2956">返回一个新字符串，其中当前实例中出现的所有指定字符串都使用提供的区域性和区分大小写属性替换为另一个指定的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2956">Returns a new string in which all occurrences of a specified string in the current instance are replaced with another specified string, using the provided culture and case sensitivity.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-2957">等效于当前字符串（除了 <paramref name="oldValue" /> 的所有实例都已替换为 <paramref name="newValue" /> 外）的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2957">A string that is equivalent to the current string except that all instances of <paramref name="oldValue" /> are replaced with <paramref name="newValue" />.</span></span> <span data-ttu-id="3cd3e-2958">如果在当前实例中找不到 <paramref name="oldValue" />，此方法返回未更改的当前实例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2958">If <paramref name="oldValue" /> is not found in the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
<span data-ttu-id="3cd3e-2959">如果 `newValue` 为 `null` ，则删除的所有匹配项 `oldValue` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2959">If `newValue` is `null`, all occurrences of `oldValue` are removed.</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-2960">此方法不会修改当前实例的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2960">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="3cd3e-2961">相反，它会返回一个新字符串，其中的所有匹配项 `oldValue` 都将替换为 `newValue` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2961">Instead, it returns a new string in which all occurrences of `oldValue` are replaced by `newValue`.</span></span>

<span data-ttu-id="3cd3e-2962">此方法 `oldValue` 使用提供的 `culture` 和 `ignoreCase` 区分大小写来执行搜索以查找。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2962">This method performs a search to find `oldValue` using the provided `culture` and `ignoreCase` case sensitivity.</span></span>

<span data-ttu-id="3cd3e-2963">由于此方法返回修改后的字符串，因此可以将对方法的连续调用链接在一起， <xref:System.String.Replace%2A> 以对原始字符串执行多次替换。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2963">Because this method returns the modified string, you can chain together successive calls to the <xref:System.String.Replace%2A> method to perform multiple replacements on the original string.</span></span> <span data-ttu-id="3cd3e-2964">方法调用从左至右执行。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2964">Method calls are executed from left to right.</span></span> <span data-ttu-id="3cd3e-2965">下面的示例进行了这方面的演示。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2965">The following example provides an illustration.</span></span>

[!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
[!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-2966"><paramref name="oldValue" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2966"><paramref name="oldValue" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-2967"><paramref name="oldValue" /> 为空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2967"><paramref name="oldValue" /> is the empty string ("").</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3cd3e-2968">返回的字符串数组包含此实例中的子字符串（由指定字符串或 Unicode 字符数组的元素分隔）。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2968">Returns a string array that contains the substrings in this instance that are delimited by elements of a specified string or Unicode character array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-2969"><xref:System.String.Split%2A> 用于将分隔的字符串拆分为子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2969"><xref:System.String.Split%2A> is used to break a delimited string into substrings.</span></span> <span data-ttu-id="3cd3e-2970">您可以使用字符数组指定 () 方法的零个、一个或多个分隔字符 <xref:System.String.Split%28System.Char%5B%5D%29> ，也可以使用字符数组指定零个、一个或多个分隔字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2970">You can use either a character array to specify zero, one, or multiple delimiting characters (the <xref:System.String.Split%28System.Char%5B%5D%29> method), or you can use a character array to specify zero, one, or multiple delimiting strings.</span></span> <span data-ttu-id="3cd3e-2971">使用方法的重载， <xref:System.String.Split%2A> 可以限制方法)  (方法返回的子字符串的数量 <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29> ，确定是否在返回的子字符串 (和方法中包含空字符串 <xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29> <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> ，或同时 (<xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> 和 <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> 方法) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2971">Overloads of the <xref:System.String.Split%2A> method allow you to limit the number of substrings returned by the method (the <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29> method), to determine whether empty strings are included in the returned substrings (the <xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29> and <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> methods, or to do both (the <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> and <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> methods).</span></span>

### <a name="alternatives-to-stringsplit"></a><span data-ttu-id="3cd3e-2972">String. Split 的替代项</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2972">Alternatives to String.Split</span></span>

 <span data-ttu-id="3cd3e-2973"><xref:System.String.Split%2A>方法并非总是将分隔的字符串拆分为子字符串的最佳方式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2973">The <xref:System.String.Split%2A> method is not always the best way to break a delimited string into substrings.</span></span> <span data-ttu-id="3cd3e-2974">如果你不希望提取分隔字符串的所有子字符串，或者如果你想要基于某个模式而不是一组分隔符字符来分析字符串，请考虑以下替代项。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2974">If you don't want to extract all of the substrings of a delimited string, or if you want to parse a string based on a pattern instead of a set of delimiter characters, consider the following alternatives.</span></span>

### <a name="regular-expressions"></a><span data-ttu-id="3cd3e-2975">正则表达式</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2975">Regular expressions</span></span>
 <span data-ttu-id="3cd3e-2976">如果字符串符合固定模式，则可以使用正则表达式提取并处理其元素。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2976">If your strings conform to a fixed pattern, you can use a regular expression to extract and handle their elements.</span></span> <span data-ttu-id="3cd3e-2977">例如，如果字符串采用 "*number* *操作数* *number*" 格式，则可以使用 [正则表达式](/dotnet/standard/base-types/regular-expressions) 提取并处理字符串的元素。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2977">For example, if strings take the form "*number* *operand* *number*" you can use a [regular expression](/dotnet/standard/base-types/regular-expressions) to extract and handle the string's elements.</span></span> <span data-ttu-id="3cd3e-2978">下面是一个示例：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2978">Here's an example:</span></span>

 [!code-csharp-interactive[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]

 <span data-ttu-id="3cd3e-2979">正则表达式模式的 `(\d+)\s+([-+*/])\s+(\d+)` 定义如下所示：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2979">The regular expression pattern `(\d+)\s+([-+*/])\s+(\d+)` is defined like this:</span></span>

|<span data-ttu-id="3cd3e-2980">模式</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2980">Pattern</span></span>|<span data-ttu-id="3cd3e-2981">描述</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2981">Description</span></span>|
|-------------|-----------------|
|`(\d+)`|<span data-ttu-id="3cd3e-2982">匹配一个或多个十进制数字。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2982">Match one or more decimal digits.</span></span> <span data-ttu-id="3cd3e-2983">这是第一个捕获组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2983">This is the first capturing group.</span></span>|
|`\s+`|<span data-ttu-id="3cd3e-2984">匹配一个或多个空白字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2984">Match one or more white-space characters.</span></span>|
|`([-+*/])`|<span data-ttu-id="3cd3e-2985">匹配算术运算符符号 (+、-、\* 或/) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2985">Match an arithmetic operator sign (+, -, \*, or /).</span></span> <span data-ttu-id="3cd3e-2986">这是第二个捕获组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2986">This is the second capturing group.</span></span>|
|`\s+`|<span data-ttu-id="3cd3e-2987">匹配一个或多个空白字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2987">Match one or more white-space characters.</span></span>|
|`(\d+)`|<span data-ttu-id="3cd3e-2988">匹配一个或多个十进制数字。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2988">Match one or more decimal digits.</span></span> <span data-ttu-id="3cd3e-2989">这是第三个捕获组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2989">This is the third capturing group.</span></span>|

 <span data-ttu-id="3cd3e-2990">还可以使用正则表达式从字符串中提取基于模式的子字符串，而不是固定的字符集。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2990">You can also use a regular expression to extract substrings from a string based on a pattern rather than a fixed set of characters.</span></span> <span data-ttu-id="3cd3e-2991">当发生以下情况之一时，这种情况很常见：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2991">This is a common scenario when either of these conditions occurs:</span></span>

-   <span data-ttu-id="3cd3e-2992">一个或多个分隔符字符并不总是作为实例中的分隔符 <xref:System.String> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2992">One or more of the delimiter characters does not always serve as a delimiter in the <xref:System.String> instance.</span></span>

-   <span data-ttu-id="3cd3e-2993">分隔符字符的顺序和数量是变量或未知的。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2993">The sequence and number of delimiter characters is variable or unknown.</span></span>

 <span data-ttu-id="3cd3e-2994">例如，该 <xref:System.String.Split%2A> 方法不能用于拆分以下字符串，因为 `\n` c # 中的 (数 ) 或 `vbCrLf` (Visual Basic 中) 个字符是可变的，它们并不总是用作分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2994">For example, the <xref:System.String.Split%2A> method cannot be used to split the following string, because the number of `\n` (in C#) or `vbCrLf` (in Visual Basic) characters is variable, and they don't always serve as delimiters.</span></span>

```text
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]
```

 <span data-ttu-id="3cd3e-2995">正则表达式可以轻松拆分此字符串，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2995">A regular expression can split this string easily, as the following example shows.</span></span>

 [!code-csharp-interactive[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]

 <span data-ttu-id="3cd3e-2996">正则表达式模式的 `\[([^\[\]]+)\]` 定义如下所示：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2996">The regular expression pattern `\[([^\[\]]+)\]` is defined like this:</span></span>

|<span data-ttu-id="3cd3e-2997">模式</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2997">Pattern</span></span>|<span data-ttu-id="3cd3e-2998">描述</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2998">Description</span></span>|
|-------------|-----------------|
|`\[`|<span data-ttu-id="3cd3e-2999">匹配左大括号。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-2999">Match an opening bracket.</span></span>|
|`([^\[\]]+)`|<span data-ttu-id="3cd3e-3000">一次或多次匹配不是左括号或右括号的任何字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3000">Match any character that is not an opening or a closing bracket one or more times.</span></span> <span data-ttu-id="3cd3e-3001">这是第一个捕获组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3001">This is the first capturing group.</span></span>|
|`\]`|<span data-ttu-id="3cd3e-3002">匹配右方括号。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3002">Match a closing bracket.</span></span>|

 <span data-ttu-id="3cd3e-3003"><xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法几乎与相同 <xref:System.String.Split%2A?displayProperty=nameWithType> ，只不过它将基于正则表达式模式而不是固定字符集拆分字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3003">The <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> method is almost identical to <xref:System.String.Split%2A?displayProperty=nameWithType>, except that it splits a string based on a regular expression pattern instead of a fixed character set.</span></span> <span data-ttu-id="3cd3e-3004">例如，下面的示例使用 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 方法拆分一个字符串，该字符串包含由连字符和其他字符的各种组合分隔的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3004">For example, the following example uses the <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> method to split a string that contains substrings delimited by various combinations of hyphens and other characters.</span></span>

 [!code-csharp-interactive[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]

 <span data-ttu-id="3cd3e-3005">正则表达式模式的 `\s-\s?[+*]?\s?-\s` 定义如下所示：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3005">The regular expression pattern `\s-\s?[+*]?\s?-\s` is defined like this:</span></span>

|<span data-ttu-id="3cd3e-3006">模式</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3006">Pattern</span></span>|<span data-ttu-id="3cd3e-3007">描述</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3007">Description</span></span>|
|-------------|-----------------|
|`\s-`|<span data-ttu-id="3cd3e-3008">匹配后跟连字符的空白字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3008">Match a white-space character followed by a hyphen.</span></span>|
|`\s?`|<span data-ttu-id="3cd3e-3009">匹配零个或一个空白字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3009">Match zero or one white-space character.</span></span>|
|`[+*]?`|<span data-ttu-id="3cd3e-3010">匹配 + 或 \* 字符的零个或一个匹配项。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3010">Match zero or one occurrence of either the + or \* character.</span></span>|
|`\s?`|<span data-ttu-id="3cd3e-3011">匹配零个或一个空白字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3011">Match zero or one white-space character.</span></span>|
|`-\s`|<span data-ttu-id="3cd3e-3012">匹配后跟一个空白字符的连字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3012">Match a hyphen followed by a white-space character.</span></span>|

### <a name="search-methods-and-the-substring-method"></a><span data-ttu-id="3cd3e-3013">搜索方法和 Substring 方法</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3013">Search methods and the Substring method</span></span>
 <span data-ttu-id="3cd3e-3014">如果对字符串中的所有子字符串都不感兴趣，则可能更倾向于使用一个字符串比较方法，该方法返回匹配项的开始位置的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3014">If you aren't interested in all of the substrings in a string, you might prefer to work with one of the string comparison methods that returns the index at which the match begins.</span></span> <span data-ttu-id="3cd3e-3015">然后，可以调用 <xref:System.String.Substring%2A> 方法来提取所需的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3015">You can then call the <xref:System.String.Substring%2A> method to extract the substring that you want.</span></span> <span data-ttu-id="3cd3e-3016">字符串比较方法包括：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3016">The string comparison methods include:</span></span>

-   <span data-ttu-id="3cd3e-3017"><xref:System.String.IndexOf%2A>，它返回字符串实例中字符或字符串的第一个匹配项的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3017"><xref:System.String.IndexOf%2A>, which returns the zero-based index of the first occurrence of a character or string in a string instance.</span></span>

-   <span data-ttu-id="3cd3e-3018"><xref:System.String.IndexOfAny%2A>，它返回字符数组中任何字符的第一个匹配项的当前字符串实例中的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3018"><xref:System.String.IndexOfAny%2A>, which returns the zero-based index in the current string instance of the first occurrence of any character in a character array.</span></span>

-   <span data-ttu-id="3cd3e-3019"><xref:System.String.LastIndexOf%2A>，它返回字符串实例中最后一个匹配项的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3019"><xref:System.String.LastIndexOf%2A>, which returns the zero-based index of the last occurrence of a character or string in a string instance.</span></span>

-   <span data-ttu-id="3cd3e-3020"><xref:System.String.LastIndexOfAny%2A>，它返回字符数组中任何字符的最后一个匹配项的当前字符串实例中的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3020"><xref:System.String.LastIndexOfAny%2A>, which returns a zero-based index in the current string instance of the last occurrence of any character in a character array.</span></span>

 <span data-ttu-id="3cd3e-3021">下面的示例使用 <xref:System.String.IndexOf%2A> 方法来查找字符串中的句点。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3021">The following example uses the <xref:System.String.IndexOf%2A> method to find the periods in a string.</span></span> <span data-ttu-id="3cd3e-3022">然后，它使用 <xref:System.String.Substring%2A> 方法返回完整句子。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3022">It then uses the <xref:System.String.Substring%2A> method to return full sentences.</span></span>

 [!code-csharp-interactive[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (params char[] separator);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (ParamArray separator As Char()) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(... cli::array &lt;char&gt; ^ separator);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] -&gt; string[]" Usage="string.Split separator" />
      <MemberSignature Language="C#" Value="public string[] Split (params char[]? separator);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="3cd3e-3023">分隔此字符串中子字符串的字符数组、不包含分隔符的空数组或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3023">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3024">基于分隔符数组中的字符将字符串拆分为多个子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3024">Splits a string into substrings that are based on the characters in the separator array.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3025">一个数组，其元素包含此实例中的子字符串，这些子字符串由 <paramref name="separator" /> 中的一个或多个字符分隔。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3025">An array whose elements contain the substrings from this instance that are delimited by one or more characters in <paramref name="separator" />.</span></span> <span data-ttu-id="3cd3e-3026">有关详细信息，请参阅“备注”部分。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3026">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3027">当使用一组已知的字符分隔字符串时，可以使用 <xref:System.String.Split%28System.Char%5B%5D%29> 方法将其分隔为子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3027">When a string is delimited by a known set of characters, you can use the <xref:System.String.Split%28System.Char%5B%5D%29> method to separate it into substrings.</span></span>

### <a name="return-value-details"></a><span data-ttu-id="3cd3e-3028">返回值详细信息</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3028">Return value details</span></span>
 <span data-ttu-id="3cd3e-3029">分隔符字符不包含在返回数组的元素中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3029">Delimiter characters are not included in the elements of the returned array.</span></span> <span data-ttu-id="3cd3e-3030">例如，如果分隔符数组包含字符 "-"，而当前字符串实例的值为 "aa-bb-cc"，则该方法将返回包含三个元素的数组： "aa"、"bb" 和 "cc"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3030">For example, if the separator array includes the character "-" and the value of the current string instance is "aa-bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</span></span>

 <span data-ttu-id="3cd3e-3031">如果此实例不包含中的任何字符 `separator` ，则返回的数组由包含此实例的单个元素组成。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3031">If this instance does not contain any of the characters in `separator`, the returned array consists of a single element that contains this instance.</span></span>

 <span data-ttu-id="3cd3e-3032">的每个元素 `separator` 定义单独的分隔符字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3032">Each element of `separator` defines a separate delimiter character.</span></span> <span data-ttu-id="3cd3e-3033">如果两个分隔符相邻，或在此实例的开头或结尾找到了分隔符，则返回数组中的相应元素包含 <xref:System.String.Empty?displayProperty=nameWithtype> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3033">If two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance, the corresponding element in the returned array contains <xref:System.String.Empty?displayProperty=nameWithtype>.</span></span> <span data-ttu-id="3cd3e-3034">下面是一些示例：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3034">Here are some examples:</span></span>

|<span data-ttu-id="3cd3e-3035">字符串值</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3035">String value</span></span>|<span data-ttu-id="3cd3e-3036">Separator</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3036">Separator</span></span>|<span data-ttu-id="3cd3e-3037">返回数组</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3037">Returned array</span></span>|
|------------------|---------------|--------------------|
|<span data-ttu-id="3cd3e-3038">"42, 12, 19"</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3038">"42, 12, 19"</span></span>|<span data-ttu-id="3cd3e-3039">new Char [] {"，'，' '} (c # ) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-3039">new Char[] {',', ' '} (C#)</span></span><br /><br /> <span data-ttu-id="3cd3e-3040">Char ( # A1 = {"，" c，"" c} )  (Visual Basic) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-3040">Char() = {","c, " "c}) (Visual Basic)</span></span>|<span data-ttu-id="3cd3e-3041">{"42", "", "12", "", "19"}</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3041">{"42", "", "12", "", "19"}</span></span>|
|<span data-ttu-id="3cd3e-3042">"42..12..19"</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3042">"42..12..19"</span></span>|<span data-ttu-id="3cd3e-3043">new Char [] {"."}</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3043">new Char[] {'.'}</span></span> <span data-ttu-id="3cd3e-3044">(C#)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3044">(C#)</span></span><br /><br /> <span data-ttu-id="3cd3e-3045">Char ( # A1 = {"."c} (Visual Basic) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-3045">Char() = {"."c} (Visual Basic)</span></span>|<span data-ttu-id="3cd3e-3046">{"42", "", "12", "", "19"}</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3046">{"42", "", "12", "", "19"}</span></span>|
|<span data-ttu-id="3cd3e-3047">香蕉</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3047">"Banana"</span></span>|<span data-ttu-id="3cd3e-3048">new Char [] {"."}</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3048">new Char[] {'.'}</span></span> <span data-ttu-id="3cd3e-3049">(C#)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3049">(C#)</span></span><br /><br /> <span data-ttu-id="3cd3e-3050">Char ( # A1 = {"."c} (Visual Basic) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-3050">Char() = {"."c} (Visual Basic)</span></span>|<span data-ttu-id="3cd3e-3051">{"香蕉"}</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3051">{"Banana"}</span></span>|
|<span data-ttu-id="3cd3e-3052">"Darb\nSmarba" (c # ) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-3052">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="3cd3e-3053">"Darb" & vbLf & "Smarba" (Visual Basic) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-3053">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="3cd3e-3054">new Char [] {} (c # ) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-3054">new Char[] {} (C#)</span></span><br /><br /> <span data-ttu-id="3cd3e-3055">Char ( # A1 = {} (Visual Basic) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-3055">Char() = {} (Visual Basic)</span></span>|<span data-ttu-id="3cd3e-3056">{"Darb", "Smarba"}</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3056">{"Darb", "Smarba"}</span></span>|
|<span data-ttu-id="3cd3e-3057">"Darb\nSmarba" (c # ) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-3057">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="3cd3e-3058">"Darb" & vbLf & "Smarba" (Visual Basic) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-3058">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="3cd3e-3059">null (C#)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3059">null (C#)</span></span><br /><br /> <span data-ttu-id="3cd3e-3060">Nothing (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3060">Nothing (Visual Basic)</span></span>|<span data-ttu-id="3cd3e-3061">{"Darb", "Smarba"}</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3061">{"Darb", "Smarba"}</span></span>|

### <a name="the-separator-array"></a><span data-ttu-id="3cd3e-3062">分隔符数组</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3062">The separator array</span></span>
 <span data-ttu-id="3cd3e-3063">分隔符的每个元素都定义一个由单个字符组成的单独分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3063">Each element of separator defines a separate delimiter that consists of a single character.</span></span> <span data-ttu-id="3cd3e-3064">如果 `separator` 参数为 `null` 或不包含任何字符，则该方法将空白字符视为分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3064">If the `separator` argument is `null` or contains no characters, the method treats white-space characters as the delimiters.</span></span> <span data-ttu-id="3cd3e-3065">空白字符由 Unicode 标准定义; `true` 如果将其传递给方法，则会返回 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3065">White-space characters are defined by the Unicode standard; they return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>

### <a name="stringsplitchar-and-compiler-overload-resolution"></a><span data-ttu-id="3cd3e-3066">字符串拆分 (Char [] ) 和编译器重载决策</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3066">String.Split(Char[]) and compiler overload resolution</span></span>
 <span data-ttu-id="3cd3e-3067">尽管此重载的单个参数 <xref:System.String.Split%2A?displayProperty=nameWithType> 是字符数组，但你可以使用单个字符调用它，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3067">Although the single parameter for this overload of <xref:System.String.Split%2A?displayProperty=nameWithType> is a character array, you can call it with a single character, as the following example shows.</span></span>

 [!code-csharp-interactive[System.String.Split#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)]
 [!code-vb[System.String.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)]

 <span data-ttu-id="3cd3e-3068">由于 `separator` 参数使用特性进行修饰 <xref:System.ParamArrayAttribute> ，因此编译器会将单个字符解释为单元素字符数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3068">Because the `separator` parameter is decorated  with the <xref:System.ParamArrayAttribute> attribute, compilers will interpret a single character as a single-element character array.</span></span> <span data-ttu-id="3cd3e-3069">这种情况并非 <xref:System.String.Split%2A?displayProperty=nameWithType> 包含参数的其他重载的情况 `separator` ; 必须以参数形式将字符数组显式传递给这些重载 `separator` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3069">This is not the case for other <xref:System.String.Split%2A?displayProperty=nameWithType> overloads that include a `separator` parameter; you must explicitly pass these overloads a character array as the `separator` argument.</span></span>

### <a name="comparison-details"></a><span data-ttu-id="3cd3e-3070">比较详细信息</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3070">Comparison details</span></span>
 <span data-ttu-id="3cd3e-3071"><xref:System.String.Split%28System.Char%5B%5D%29>方法提取此字符串中的子字符串，这些子字符串由数组中的一个或多个字符分隔 `separator` ，并将这些子字符串作为数组的元素返回。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3071">The <xref:System.String.Split%28System.Char%5B%5D%29> method extracts the substrings in this string that are delimited by one or more of the characters in the `separator` array, and returns those substrings as elements of an array.</span></span>

 <span data-ttu-id="3cd3e-3072"><xref:System.String.Split%28System.Char%5B%5D%29>方法通过使用区分大小写的序号排序规则执行比较来查找分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3072">The <xref:System.String.Split%28System.Char%5B%5D%29> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</span></span> <span data-ttu-id="3cd3e-3073">有关 word、字符串和序号排序的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 枚举。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3073">For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span>

### <a name="performance-considerations"></a><span data-ttu-id="3cd3e-3074">性能注意事项</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3074">Performance Considerations</span></span>
 <span data-ttu-id="3cd3e-3075"><xref:System.String.Split%2A>方法为返回的数组对象分配内存，并为 <xref:System.String> 每个数组元素分配一个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3075">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="3cd3e-3076">如果你的应用程序需要最佳性能，或者在你的应用程序中管理内存分配非常重要，请考虑使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3076">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method.</span></span> <span data-ttu-id="3cd3e-3077">你还可以选择使用 <xref:System.String.Compare%2A> 方法来查找字符串中的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3077">You also have the option of using the <xref:System.String.Compare%2A> method to locate a substring within a string.</span></span>

 <span data-ttu-id="3cd3e-3078">若要在分隔符处拆分字符串，请使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法在字符串中查找分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3078">To split a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="3cd3e-3079">若要将字符串拆分为分隔符字符串，请使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法查找分隔符字符串的第一个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3079">To split a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="3cd3e-3080">然后，使用 <xref:System.String.Compare%2A> 方法来确定第一个字符后面的字符是否等于分隔符字符串的剩余字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3080">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>

 <span data-ttu-id="3cd3e-3081">此外，如果使用相同的字符集拆分多个方法调用中的字符串 <xref:System.String.Split%2A> ，请考虑创建一个数组，并在每个方法调用中引用它。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3081">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="3cd3e-3082">这可以显著降低每个方法调用的额外开销。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3082">This significantly reduces the additional overhead of each method call.</span></span>

## Examples
 <span data-ttu-id="3cd3e-3083">下面的示例演示如何通过将空白和标点符号视为分隔符来从文本块提取各个单词。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3083">The following example demonstrates how to extract individual words from a block of text by treating white space and punctuation marks as delimiters.</span></span> <span data-ttu-id="3cd3e-3084">传递给方法的参数的字符数组 `separator` <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> 包含一个空格字符和一个制表符以及一些常用的标点符号。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3084">The character array passed to the `separator` parameter of the <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> method consists of a space character and a tab character, together with some common punctuation symbols.</span></span>

 [!code-csharp-interactive[System.String.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split2.cs#2)]
 [!code-vb[System.String.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split2.vb#2)]

 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-3085">在 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 和早期版本中，如果向 <see cref="M:System.String.Split(System.Char[])" /> 方法传递的 <paramref name="separator" /> 是 <see langword="null" /> 或不包含任何字符，则该方法将使用一组略有不同的字符来拆分字符串，而不是使用 <see cref="M:System.String.Trim(System.Char[])" /> 方法来剪裁字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3085">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="3cd3e-3086">从 .NET Framework 4 开始，这两个方法都使用一组相同的 Unicode 空白字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3086">Starting with the .NET Framework 4, both methods use an identical set of Unicode white-space characters.</span></span></para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="3cd3e-3087">一个字符，用于分隔此字符串中的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3087">A character that delimits the substrings in this string.</span></span></param>
        <param name="options"><span data-ttu-id="3cd3e-3088">枚举值之一，用于确定拆分操作是否应省略返回值中的空子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3088">One of the enumeration values that determines whether the split operation should omit empty substrings from the return value.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3089">根据提供的字符分隔符将字符串拆分为多个子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3089">Splits a string into substrings based on the provided character separator.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3090">一个数组，其元素包含此实例中的子字符串，这些子字符串由 <paramref name="separator" /> 分隔。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3090">An array whose elements contain the substrings from this instance that are delimited by <paramref name="separator" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int -&gt; string[]" Usage="string.Split (separator, count)" />
      <MemberSignature Language="C#" Value="public string[] Split (char[]? separator, int count);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="3cd3e-3091">分隔此字符串中子字符串的字符数组、不包含分隔符的空数组或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3091">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <param name="count"><span data-ttu-id="3cd3e-3092">要返回的子字符串的最大数量。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3092">The maximum number of substrings to return.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3093">基于数组中的字符将一个字符串拆分成最大数量的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3093">Splits a string into a maximum number of substrings based on the characters in an array.</span></span> <span data-ttu-id="3cd3e-3094">也可指定要返回的子字符串的最大数量。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3094">You also specify the maximum number of substrings to return.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3095">一个数组，其元素包含此实例中的子字符串，这些子字符串由 <paramref name="separator" /> 中的一个或多个字符分隔。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3095">An array whose elements contain the substrings in this instance that are delimited by one or more characters in <paramref name="separator" />.</span></span> <span data-ttu-id="3cd3e-3096">有关详细信息，请参阅“备注”部分。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3096">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3097">分隔符字符不包含在返回数组的元素中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3097">Delimiter characters are not included in the elements of the returned array.</span></span>

 <span data-ttu-id="3cd3e-3098">如果此实例不包含中的任何字符 `separator` ，则返回的数组由包含此实例的单个元素组成。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3098">If this instance does not contain any of the characters in `separator`, the returned array consists of a single element that contains this instance.</span></span> <span data-ttu-id="3cd3e-3099">如果 `count` 为零，则返回空数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3099">If `count` is zero, an empty array is returned.</span></span>

 <span data-ttu-id="3cd3e-3100">如果 `separator` 参数为 `null` 或不包含任何字符，则假定空格字符为分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3100">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="3cd3e-3101">空白字符由 Unicode 标准定义，并在 `true` 传递给方法时返回 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3101">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>

 <span data-ttu-id="3cd3e-3102">的每个元素 `separator` 定义单独的分隔符字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3102">Each element of `separator` defines a separate delimiter character.</span></span> <span data-ttu-id="3cd3e-3103">如果两个分隔符相邻，或在此实例的开头或结尾找到了分隔符，则对应的数组元素包含 <xref:System.String.Empty?displayProperty=nameWithtype> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3103">If two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty?displayProperty=nameWithtype>.</span></span>

 <span data-ttu-id="3cd3e-3104">如果 `count` 此实例中的子字符串多于个子字符串，则返回 `count` 值的第一个减1元素返回第一个减号子字符串 `count` ，并且在返回值的最后一个元素中返回此实例中剩余的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3104">If there are more than `count` substrings in this instance, the first `count` minus 1 substrings are returned in the first `count` minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</span></span>

 <span data-ttu-id="3cd3e-3105">如果 `count` 大于子字符串的数目，则将返回可用的子字符串，并且不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3105">If `count` is greater than the number of substrings, the available substrings are returned and no exception is thrown.</span></span>

 <span data-ttu-id="3cd3e-3106">下表提供了一些示例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3106">The following table provides examples.</span></span>

|<span data-ttu-id="3cd3e-3107">字符串值</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3107">String value</span></span>|<span data-ttu-id="3cd3e-3108">Separator</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3108">Separator</span></span>|<span data-ttu-id="3cd3e-3109">计数</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3109">Count</span></span>|<span data-ttu-id="3cd3e-3110">返回数组</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3110">Returned array</span></span>|
|------------------|---------------|-----------|--------------------|
|<span data-ttu-id="3cd3e-3111">"42, 12, 19"</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3111">"42, 12, 19"</span></span>|<span data-ttu-id="3cd3e-3112">new Char [] {"，'，' '} (c # ) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-3112">new Char[] {',', ' '} (C#)</span></span><br /><br /> <span data-ttu-id="3cd3e-3113">Char ( # A1 = {"，" c，"" c} (Visual Basic) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-3113">Char() = {","c, " "c} (Visual Basic)</span></span>|<span data-ttu-id="3cd3e-3114">2</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3114">2</span></span>|<span data-ttu-id="3cd3e-3115">{"42", " 12, 19"}</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3115">{"42", " 12, 19"}</span></span>|
|<span data-ttu-id="3cd3e-3116">"42..12..19"</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3116">"42..12..19"</span></span>|<span data-ttu-id="3cd3e-3117">new Char [] {"."}</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3117">new Char[] {'.'}</span></span> <span data-ttu-id="3cd3e-3118">(C#)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3118">(C#)</span></span><br /><br /> <span data-ttu-id="3cd3e-3119">Char ( # A1 = {"."c} (Visual Basic) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-3119">Char() = {"."c} (Visual Basic)</span></span>|<span data-ttu-id="3cd3e-3120">4</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3120">4</span></span>|<span data-ttu-id="3cd3e-3121">{"42", "", "12", ".19"}</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3121">{"42", "", "12", ".19"}</span></span>|
|<span data-ttu-id="3cd3e-3122">香蕉</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3122">"Banana"</span></span>|<span data-ttu-id="3cd3e-3123">new Char [] {"."}</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3123">new Char[] {'.'}</span></span> <span data-ttu-id="3cd3e-3124">(C#)</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3124">(C#)</span></span><br /><br /> <span data-ttu-id="3cd3e-3125">Char ( # A1 = {"."c} (Visual Basic) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-3125">Char() = {"."c} (Visual Basic)</span></span>|<span data-ttu-id="3cd3e-3126">2</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3126">2</span></span>|<span data-ttu-id="3cd3e-3127">{"香蕉"}</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3127">{"Banana"}</span></span>|
|<span data-ttu-id="3cd3e-3128">"Darb\nSmarba" (c # ) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-3128">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="3cd3e-3129">"Darb" & vbLf & "Smarba" (Visual Basic) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-3129">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="3cd3e-3130">new Char [] {} (c # ) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-3130">new Char[] {} (C#)</span></span><br /><br /> <span data-ttu-id="3cd3e-3131">Char ( # A1 = {} (Visual Basic) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-3131">Char() = {} (Visual Basic)</span></span>|<span data-ttu-id="3cd3e-3132">1</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3132">1</span></span>|<span data-ttu-id="3cd3e-3133">{"Darb\nSmarba"} (c # ) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-3133">{"Darb\nSmarba"} (C#)</span></span><br /><br /> <span data-ttu-id="3cd3e-3134">"Darb" & vbLf & "Smarba" (Visual Basic) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-3134">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|
|<span data-ttu-id="3cd3e-3135">"Darb\nSmarba" (c # ) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-3135">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="3cd3e-3136">"Darb" & vbLf & "Smarba" (Visual Basic) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-3136">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="3cd3e-3137">new Char [] null (c # ) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-3137">new Char[] null (C#)</span></span><br /><br /> <span data-ttu-id="3cd3e-3138">Char ( # A1 = Nothing</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3138">Char() = Nothing</span></span>|<span data-ttu-id="3cd3e-3139">2</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3139">2</span></span>|<span data-ttu-id="3cd3e-3140">{"Darb", "Smarba"}</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3140">{"Darb", "Smarba"}</span></span>|
|<span data-ttu-id="3cd3e-3141">"Darb\nSmarba" (c # ) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-3141">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="3cd3e-3142">"Darb" & vbLf & "Smarba" (Visual Basic) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-3142">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="3cd3e-3143">new Char [] null (c # ) </span><span class="sxs-lookup"><span data-stu-id="3cd3e-3143">new Char[] null (C#)</span></span><br /><br /> <span data-ttu-id="3cd3e-3144">Char ( # A1 = Nothing</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3144">Char() = Nothing</span></span>|<span data-ttu-id="3cd3e-3145">100</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3145">100</span></span>|<span data-ttu-id="3cd3e-3146">{"Darb", "Smarba"}</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3146">{"Darb", "Smarba"}</span></span>|

### <a name="performance-considerations"></a><span data-ttu-id="3cd3e-3147">性能注意事项</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3147">Performance Considerations</span></span>
 <span data-ttu-id="3cd3e-3148"><xref:System.String.Split%2A>方法为返回的数组对象分配内存，并为 <xref:System.String> 每个数组元素分配一个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3148">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="3cd3e-3149">如果你的应用程序需要最佳性能，或者在你的应用程序中管理内存分配非常重要，请考虑使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法，并根据需要使用 <xref:System.String.Compare%2A> 方法来查找字符串中的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3149">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>

 <span data-ttu-id="3cd3e-3150">如果要在分隔符处拆分字符串，请使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法来查找字符串中的分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3150">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="3cd3e-3151">如果要将字符串拆分为分隔符字符串，请使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法查找分隔符字符串的第一个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3151">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="3cd3e-3152">然后，使用 <xref:System.String.Compare%2A> 方法来确定第一个字符后面的字符是否等于分隔符字符串的剩余字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3152">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>

 <span data-ttu-id="3cd3e-3153">此外，如果使用相同的字符集拆分多个方法调用中的字符串 <xref:System.String.Split%2A> ，请考虑创建一个数组，并在每个方法调用中引用它。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3153">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="3cd3e-3154">这可以显著降低每个方法调用的额外开销。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3154">This significantly reduces the additional overhead of each method call.</span></span>



## Examples
 <span data-ttu-id="3cd3e-3155">下面的示例演示如何 `count` 影响返回的字符串的数目 <xref:System.String.Split%2A> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3155">The following example demonstrates how `count` affects the number of strings returned by <xref:System.String.Split%2A>.</span></span>

 [!code-csharp-interactive[StringSplit2#10](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/StringSplit10.cs#10)]
 [!code-vb[StringSplit2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit10.vb#10)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-3156"><paramref name="count" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3156"><paramref name="count" /> is negative.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-3157">在 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 和早期版本中，如果向 <see cref="M:System.String.Split(System.Char[])" /> 方法传递的 <paramref name="separator" /> 是 <see langword="null" /> 或不包含任何字符，则该方法将使用一组略有不同的字符来拆分字符串，而不是使用 <see cref="M:System.String.Trim(System.Char[])" /> 方法来剪裁字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3157">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="3cd3e-3158">从 .NET Framework 4 开始，这两个方法都使用一组相同的 Unicode 空白字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3158">Starting with the .NET Framework 4, both methods use an identical set of Unicode white-space characters.</span></span></para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberSignature Language="C#" Value="public string[] Split (char[]? separator, StringSplitOptions options);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="3cd3e-3159">分隔此字符串中子字符串的字符数组、不包含分隔符的空数组或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3159">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <param name="options"><span data-ttu-id="3cd3e-3160">要省略返回的数组中的空数组元素，则为 <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />；要包含返回的数组中的空数组元素，则为 <see cref="F:System.StringSplitOptions.None" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3160"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3161">基于数组中的字符将字符串拆分为多个子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3161">Splits a string into substrings based on the characters in an array.</span></span> <span data-ttu-id="3cd3e-3162">可以指定子字符串是否包含空数组元素。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3162">You can specify whether the substrings include empty array elements.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3163">一个数组，其元素包含此字符串中的子字符串，这些子字符串由 <paramref name="separator" /> 中的一个或多个字符分隔。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3163">An array whose elements contain the substrings in this string that are delimited by one or more characters in <paramref name="separator" />.</span></span> <span data-ttu-id="3cd3e-3164">有关详细信息，请参阅“备注”部分。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3164">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

### <a name="return-value-details"></a><span data-ttu-id="3cd3e-3165">返回值详细信息</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3165">Return value details</span></span>
 <span data-ttu-id="3cd3e-3166">分隔符字符 (数组中的字符 `separator`) 不包含在返回数组的元素中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3166">Delimiter characters (the characters in the `separator` array) are not included in the elements of the returned array.</span></span> <span data-ttu-id="3cd3e-3167">例如，如果 `separator` 数组包含字符 "-"，而当前字符串实例的值为 "aa-bb-cc"，则该方法将返回包含三个元素的数组： "aa"、"bb" 和 "cc"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3167">For example, if the `separator` array includes the character "-" and the value of the current string instance is "aa-bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</span></span>

 <span data-ttu-id="3cd3e-3168">如果此实例不包含中的任何字符 `separator` ，则返回的数组由包含此实例的单个元素组成。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3168">If this instance does not contain any of the characters in `separator`, the returned array consists of a single element that contains this instance.</span></span>

 <span data-ttu-id="3cd3e-3169">如果 `options` 参数为 <xref:System.StringSplitOptions.RemoveEmptyEntries> ，并且此实例的长度为零，则该方法将返回一个空数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3169">If the `options` parameter is <xref:System.StringSplitOptions.RemoveEmptyEntries> and the length of this instance is zero, the method returns an empty array.</span></span>

 <span data-ttu-id="3cd3e-3170">的每个元素都 `separator` 定义一个由单个字符组成的单独分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3170">Each element of `separator` defines a separate delimiter that consists of a single character.</span></span> <span data-ttu-id="3cd3e-3171">如果 `options` 参数为 <xref:System.StringSplitOptions.None> ，并且两个分隔符相邻，或在此实例的开头或结尾找到了分隔符，则对应的数组元素包含 <xref:System.String.Empty?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3171">If the `options` argument is <xref:System.StringSplitOptions.None>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3cd3e-3172">例如，如果 `separator` 包含两个元素 "-" 和 " \_ "，则字符串实例的值为 "- \_ aa- \_ "，而参数的值 `options` 为 <xref:System.StringSplitOptions.None> ，则该方法返回一个字符串数组，其中包含以下五个元素：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3172">For example, if `separator` includes  two elements, "-" and "\_", the value of the string instance is "-\_aa-\_", and the value of   the `options` argument is <xref:System.StringSplitOptions.None>, the method returns a string array with the following five elements:</span></span>

1.  <span data-ttu-id="3cd3e-3173"><xref:System.String.Empty?displayProperty=nameWithType>，它表示位于索引0处的 "-" 字符之前的空字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3173"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that precedes the "-" character at index 0.</span></span>

2.  <span data-ttu-id="3cd3e-3174"><xref:System.String.Empty?displayProperty=nameWithType>，它表示位于索引0处的 "-" 字符和索引1处 "_" 字符之间的空字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3174"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string between the "-" character at index 0 and the "_" character at index 1.</span></span>

3.  <span data-ttu-id="3cd3e-3175">"aa",</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3175">"aa",</span></span>

4.  <span data-ttu-id="3cd3e-3176"><xref:System.String.Empty?displayProperty=nameWithType>，它表示位于索引4的 "_" 字符之后的空字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3176"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that follows the "_" character at index 4.</span></span>

5.  <span data-ttu-id="3cd3e-3177"><xref:System.String.Empty?displayProperty=nameWithType>，它表示位于索引5的 "-" 字符之后的空字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3177"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that follows the "-" character at index 5.</span></span>

### <a name="the-separator-array"></a><span data-ttu-id="3cd3e-3178">分隔符数组</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3178">The separator array</span></span>
 <span data-ttu-id="3cd3e-3179">如果 `separator` 参数为 `null` 或不包含任何字符，则假定空格字符为分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3179">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="3cd3e-3180">空白字符由 Unicode 标准定义，并在 `true` 传递给方法时返回 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3180">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>

 <span data-ttu-id="3cd3e-3181">如果 `separator` 调用此方法重载的中的参数为 `null` ，则编译器重载决策失败。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3181">If the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails.</span></span> <span data-ttu-id="3cd3e-3182">为了明确标识所调用的方法，你的代码必须指示的类型 `null` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3182">To unambiguously identify the called method, your code must indicate the type of the `null`.</span></span> <span data-ttu-id="3cd3e-3183">下面的示例演示了几种明确识别此重载的方式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3183">The following example shows several ways to unambiguously identify this overload.</span></span>

 [!code-csharp[System.String.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)]
 [!code-vb[System.String.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)]

### <a name="comparison-details"></a><span data-ttu-id="3cd3e-3184">比较详细信息</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3184">Comparison details</span></span>
 <span data-ttu-id="3cd3e-3185"><xref:System.String.Split%2A>方法提取此字符串中的子字符串，这些子字符串由参数中的一个或多个字符分隔 `separator` ，并将这些子字符串作为数组的元素返回。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3185">The <xref:System.String.Split%2A> method extracts the substrings in this string that are delimited by one or more of the characters in the `separator` parameter, and returns those substrings as elements of an array.</span></span>

 <span data-ttu-id="3cd3e-3186"><xref:System.String.Split%2A>方法通过使用区分大小写的序号排序规则执行比较来查找分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3186">The <xref:System.String.Split%2A> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</span></span> <span data-ttu-id="3cd3e-3187">有关 word、字符串和序号排序的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 枚举。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3187">For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span>

### <a name="performance-considerations"></a><span data-ttu-id="3cd3e-3188">性能注意事项</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3188">Performance Considerations</span></span>
 <span data-ttu-id="3cd3e-3189"><xref:System.String.Split%2A>方法为返回的数组对象分配内存，并为 <xref:System.String> 每个数组元素分配一个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3189">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="3cd3e-3190">如果你的应用程序需要最佳性能，或者在你的应用程序中管理内存分配非常重要，请考虑使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法，并根据需要使用 <xref:System.String.Compare%2A> 方法来查找字符串中的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3190">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>

 <span data-ttu-id="3cd3e-3191">如果要在分隔符处拆分字符串，请使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法来查找字符串中的分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3191">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="3cd3e-3192">如果要将字符串拆分为分隔符字符串，请使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法查找分隔符字符串的第一个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3192">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="3cd3e-3193">然后，使用 <xref:System.String.Compare%2A> 方法来确定第一个字符后面的字符是否等于分隔符字符串的剩余字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3193">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>

 <span data-ttu-id="3cd3e-3194">此外，如果使用相同的字符集拆分多个方法调用中的字符串 <xref:System.String.Split%2A> ，请考虑创建一个数组，并在每个方法调用中引用它。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3194">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="3cd3e-3195">这可以显著降低每个方法调用的额外开销。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3195">This significantly reduces the additional overhead of each method call.</span></span>



## Examples
 <span data-ttu-id="3cd3e-3196">下面的示例使用 <xref:System.StringSplitOptions> 枚举来包括或排除方法生成的子字符串 <xref:System.String.Split%2A> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3196">The following example uses the <xref:System.StringSplitOptions> enumeration to include or exclude substrings generated by the <xref:System.String.Split%2A> method.</span></span>

 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-3197"><paramref name="options" /> 不是 <see cref="T:System.StringSplitOptions" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3197"><paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-3198">在 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 和早期版本中，如果向 <see cref="M:System.String.Split(System.Char[])" /> 方法传递的 <paramref name="separator" /> 是 <see langword="null" /> 或不包含任何字符，则该方法将使用一组略有不同的字符来拆分字符串，而不是使用 <see cref="M:System.String.Trim(System.Char[])" /> 方法来剪裁字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3198">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="3cd3e-3199">从 .NET Framework 4 开始，这两个方法都使用一组相同的 Unicode 空白字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3199">Starting with the .NET Framework 4, both methods use an identical set of Unicode white-space characters.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string? separator, StringSplitOptions options = System.StringSplitOptions.None);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="3cd3e-3200">一个字符串，用于分隔此字符串中的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3200">A string that delimits the substrings in this string.</span></span></param>
        <param name="options"><span data-ttu-id="3cd3e-3201">枚举值之一，用于确定拆分操作是否应省略返回值中的空子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3201">One of the enumeration values that determines whether the split operation should omit empty substrings from the return value.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3202">根据提供的字符串分隔符将字符串拆分为多个子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3202">Splits a string into substrings that are based on the provided string separator.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3203">一个数组，其元素包含此实例中的子字符串，这些子字符串由 <paramref name="separator" /> 分隔。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3203">An array whose elements contain the substrings from this instance that are delimited by <paramref name="separator" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberSignature Language="C#" Value="public string[] Split (string[]? separator, StringSplitOptions options);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="3cd3e-3204">分隔此字符串中子字符串的字符串数组、不包含分隔符的空数组或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3204">A string array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <param name="options"><span data-ttu-id="3cd3e-3205">要省略返回的数组中的空数组元素，则为 <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />；要包含返回的数组中的空数组元素，则为 <see cref="F:System.StringSplitOptions.None" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3205"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3206">基于数组中的字符串将字符串拆分为多个子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3206">Splits a string into substrings based on the strings in an array.</span></span> <span data-ttu-id="3cd3e-3207">可以指定子字符串是否包含空数组元素。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3207">You can specify whether the substrings include empty array elements.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3208">一个数组，其元素包含此字符串中的子字符串，这些子字符串由 <paramref name="separator" /> 中的一个或多个字符串分隔。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3208">An array whose elements contain the substrings in this string that are delimited by one or more strings in <paramref name="separator" />.</span></span> <span data-ttu-id="3cd3e-3209">有关详细信息，请参阅“备注”部分。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3209">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3210">当使用一组已知的字符串分隔字符串时，可以使用 <xref:System.String.Split%2A> 方法将其分隔为子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3210">When a string is delimited by a known set of strings, you can use the <xref:System.String.Split%2A> method to separate it into substrings.</span></span>

### <a name="return-value-details"></a><span data-ttu-id="3cd3e-3211">返回值详细信息</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3211">Return value details</span></span>
 <span data-ttu-id="3cd3e-3212">分隔符字符串不包含在返回数组的元素中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3212">Delimiter strings are not included in the elements of the returned array.</span></span> <span data-ttu-id="3cd3e-3213">例如，如果 `separator` 数组包含字符串 "--"，而当前字符串实例的值为 "aa--bb-cc"，则该方法将返回包含三个元素的数组： "aa"、"bb" 和 "cc"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3213">For example, if the `separator` array includes the string "--" and the value of the current string instance is "aa--bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</span></span>

 <span data-ttu-id="3cd3e-3214">如果此实例不包含中的任何字符串 `separator` ，则返回的数组包含一个包含此实例的元素。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3214">If this instance does not contain any of the strings in `separator`, the returned array consists of a single element that contains this instance.</span></span>

 <span data-ttu-id="3cd3e-3215">如果 `options` 参数为 <xref:System.StringSplitOptions.RemoveEmptyEntries> ，并且此实例的长度为零，则该方法将返回一个空数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3215">If the `options` parameter is <xref:System.StringSplitOptions.RemoveEmptyEntries> and the length of this instance is zero, the method returns an empty array.</span></span>

 <span data-ttu-id="3cd3e-3216">的每个元素都 `separator` 定义一个由一个或多个字符组成的单独分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3216">Each element of `separator` defines a separate delimiter that consists of one or more characters.</span></span> <span data-ttu-id="3cd3e-3217">如果 `options` 参数为 <xref:System.StringSplitOptions.None> ，并且两个分隔符相邻，或在此实例的开头或结尾找到了分隔符，则对应的数组元素包含 <xref:System.String.Empty?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3217">If the `options` argument is <xref:System.StringSplitOptions.None>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3cd3e-3218">例如，如果 `separator` 包含两个元素 "-" 和 " \_ "，则字符串实例的值为 "- \_ aa- \_ "，而参数的值 `options` 为 <xref:System.StringSplitOptions.None> ，则该方法返回一个字符串数组，其中包含以下五个元素：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3218">For example, if `separator` includes  two elements, "-" and "\_", the value of the string instance is "-\_aa-\_", and the value of   the `options` argument is <xref:System.StringSplitOptions.None>, the method returns a sting array with the following five elements:</span></span>

1.  <span data-ttu-id="3cd3e-3219"><xref:System.String.Empty?displayProperty=nameWithType>，它表示位于索引0处的 "-" 子字符串之前的空字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3219"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that precedes the "-" substring at index 0.</span></span>

2.  <span data-ttu-id="3cd3e-3220"><xref:System.String.Empty?displayProperty=nameWithType>，它表示位于索引0处的 "-" 子字符串与索引1处的 "_" 子字符串之间的空字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3220"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string between the "-" substring at index 0 and the "_" substring at index 1.</span></span>

3.  <span data-ttu-id="3cd3e-3221">"aa",</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3221">"aa",</span></span>

4.  <span data-ttu-id="3cd3e-3222"><xref:System.String.Empty?displayProperty=nameWithType>，它表示位于索引4的 "_" 子字符串后面的空字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3222"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that follows the "_" substring at index 4.</span></span>

5.  <span data-ttu-id="3cd3e-3223"><xref:System.String.Empty?displayProperty=nameWithType>，它表示位于索引5的 "-" 子字符串之后的空字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3223"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that follows the "-" substring at index 5.</span></span>

### <a name="the-separator-array"></a><span data-ttu-id="3cd3e-3224">分隔符数组</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3224">The separator array</span></span>
 <span data-ttu-id="3cd3e-3225">如果中的任何元素 `separator` 包含多个字符，则整个子字符串被视为分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3225">If any of the elements in `separator` consists of multiple characters, the entire substring is considered a delimiter.</span></span> <span data-ttu-id="3cd3e-3226">例如，如果中的一个元素 `separator` 为 "10"，则尝试拆分字符串 "This10is10a10string"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3226">For example, if one of the elements in `separator` is "10", attempting to split the string "This10is10a10string."</span></span> <span data-ttu-id="3cd3e-3227">返回以下四元素数组： {"This"、"is"、"a"、"string"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3227">returns the following four-element array: { "This", "is", "a", "string."</span></span> <span data-ttu-id="3cd3e-3228">}.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3228">}.</span></span>

 <span data-ttu-id="3cd3e-3229">如果 `separator` 参数为 `null` 或不包含任何字符，则假定空格字符为分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3229">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="3cd3e-3230">空白字符由 Unicode 标准定义，并在 `true` 传递给方法时返回 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3230">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>

 <span data-ttu-id="3cd3e-3231">如果 `separator` 调用此方法重载的中的参数为 `null` ，则编译器重载决策失败。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3231">If the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails.</span></span> <span data-ttu-id="3cd3e-3232">为了明确标识所调用的方法，你的代码必须指示的类型 `null` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3232">To unambiguously identify the called method, your code must indicate the type of the `null`.</span></span> <span data-ttu-id="3cd3e-3233">下面的示例演示了几种明确识别此重载的方式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3233">The following example shows several ways to unambiguously identify this overload.</span></span>

 [!code-csharp[System.String.Split#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)]
 [!code-vb[System.String.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)]

### <a name="comparison-details"></a><span data-ttu-id="3cd3e-3234">比较详细信息</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3234">Comparison details</span></span>
 <span data-ttu-id="3cd3e-3235"><xref:System.String.Split%2A>方法提取此字符串中的子字符串，这些子字符串由参数中的一个或多个字符串分隔 `separator` ，并将这些子字符串作为数组的元素返回。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3235">The <xref:System.String.Split%2A> method extracts the substrings in this string that are delimited by one or more of the strings in the `separator` parameter, and returns those substrings as elements of an array.</span></span>

 <span data-ttu-id="3cd3e-3236"><xref:System.String.Split%2A>方法通过使用区分大小写的序号排序规则执行比较来查找分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3236">The <xref:System.String.Split%2A> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</span></span> <span data-ttu-id="3cd3e-3237">有关 word、字符串和序号排序的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 枚举。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3237">For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span>

 <span data-ttu-id="3cd3e-3238"><xref:System.String.Split%2A>方法将忽略 `separator` 其值为 `null` 或空字符串 ( "" ) 的任何元素。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3238">The <xref:System.String.Split%2A> method ignores any element of `separator` whose value is `null` or the empty string ("").</span></span>

 <span data-ttu-id="3cd3e-3239">若要在中的字符串具有相同的字符时避免出现不明确的结果， `separator` 则 <xref:System.String.Split%2A> 操作将从实例值的开头开始，并与中的第一个元素（ `separator` 等于实例中的分隔符）匹配。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3239">To avoid ambiguous results when strings in `separator` have characters in common, the <xref:System.String.Split%2A> operation proceeds from the beginning to the end of the value of the instance, and matches the first element in `separator` that is equal to a delimiter in the instance.</span></span> <span data-ttu-id="3cd3e-3240">实例中的子字符串的出现顺序优先于中元素的顺序 `separator` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3240">The order in which substrings are encountered in the instance takes precedence over the order of elements in `separator`.</span></span>

 <span data-ttu-id="3cd3e-3241">例如，假设值为 "abcdef" 的实例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3241">For example, consider an instance whose value is "abcdef".</span></span> <span data-ttu-id="3cd3e-3242">如果中的第一个元素 `separator` 为 "ef"，第二个元素为 "bcde"，则拆分操作的结果将是一个字符串数组，其中包含两个元素： "a" 和 "f"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3242">If the first element in `separator` was "ef" and the second element was "bcde", the result of the split operation would be a string array that contains two elements, "a" and "f".</span></span> <span data-ttu-id="3cd3e-3243">这是因为，在遇到子字符串 "f" 之前，遇到了实例 "bcde" 中的子字符串，并与中的元素匹配 `separator` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3243">This is because the substring in the instance, "bcde", is encountered and matches an element in `separator` before the substring "f" is encountered.</span></span>

 <span data-ttu-id="3cd3e-3244">但是，如果的第一个元素 `separator` 为 "bcd"，第二个元素为 "bc"，则拆分操作的结果将是一个字符串数组，其中包含两个元素： "a" 和 "ef"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3244">However, if the first element of `separator` was "bcd" and the second element was "bc", the result of the split operation would be a string array that contains two elements, "a" and "ef".</span></span> <span data-ttu-id="3cd3e-3245">这是因为 "bcd" 是中的第一个分隔符 `separator` ，它与实例中的分隔符相匹配。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3245">This is because "bcd" is the first delimiter in `separator` that matches a delimiter in the instance.</span></span> <span data-ttu-id="3cd3e-3246">如果分隔符的顺序已颠倒，因此第一个元素为 "bc"，第二个元素为 "bcd"，则结果将是一个字符串数组，其中包含两个元素： "a" 和 "def"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3246">If the order of the separators was reversed so the first element was "bc" and the second element was "bcd", the result would be a string array that contains two elements,  "a" and "def".</span></span>

### <a name="performance-considerations"></a><span data-ttu-id="3cd3e-3247">性能注意事项</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3247">Performance considerations</span></span>
 <span data-ttu-id="3cd3e-3248"><xref:System.String.Split%2A>方法为返回的数组对象分配内存，并为 <xref:System.String> 每个数组元素分配一个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3248">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="3cd3e-3249">如果你的应用程序需要最佳性能，或者在你的应用程序中管理内存分配非常重要，请考虑使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法，并根据需要使用 <xref:System.String.Compare%2A> 方法来查找字符串中的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3249">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>

 <span data-ttu-id="3cd3e-3250">如果要在分隔符处拆分字符串，请使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法来查找字符串中的分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3250">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="3cd3e-3251">如果要将字符串拆分为分隔符字符串，请使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法查找分隔符字符串的第一个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3251">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="3cd3e-3252">然后，使用 <xref:System.String.Compare%2A> 方法来确定第一个字符后面的字符是否等于分隔符字符串的剩余字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3252">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>

 <span data-ttu-id="3cd3e-3253">此外，如果使用相同的字符集拆分多个方法调用中的字符串 <xref:System.String.Split%2A> ，请考虑创建一个数组，并在每个方法调用中引用它。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3253">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="3cd3e-3254">这可以显著降低每个方法调用的额外开销。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3254">This significantly reduces the additional overhead of each method call.</span></span>



## Examples
 <span data-ttu-id="3cd3e-3255">下面的示例说明了通过调用字符串的 <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType> 方法（其 `options` 参数等于和）返回的数组中的 <xref:System.StringSplitOptions.None?displayProperty=nameWithType> 差异 <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3255">The following example illustrates the difference in the arrays returned by calling a string's <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType> method with its `options` parameter equal to <xref:System.StringSplitOptions.None?displayProperty=nameWithType> and <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>.</span></span>

 [!code-csharp-interactive[System.String.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split.cs#1)]
 [!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split.vb#1)]

 <span data-ttu-id="3cd3e-3256">下面的示例定义一个包含标点和空白字符的分隔符数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3256">The following example defines an array of separators that include punctuation and white-space characters.</span></span> <span data-ttu-id="3cd3e-3257">如果将此数组与的值一起传递 <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> 给方法，则将 <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> 返回一个由字符串中的单个单词组成的数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3257">Passing this array along with a value of <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> to the <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> method returns an array that consists of the individual words from the string.</span></span>

 [!code-csharp-interactive[System.String.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split7.cs#7)]
 [!code-vb[System.String.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split7.vb#7)]

 <span data-ttu-id="3cd3e-3258">请注意，在参数设置为的情况下调用方法 `options` <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3258">Note that the method is called with the `options` argument set to <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3cd3e-3259">这可以防止返回的数组包含 <xref:System.String.Empty?displayProperty=nameWithType> 表示标点符号和空白字符之间的空子字符串匹配项的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3259">This prevents the returned array from including <xref:System.String.Empty?displayProperty=nameWithType> values that represent empty substring matches between punctuation marks and white-space characters.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-3260"><paramref name="options" /> 不是 <see cref="T:System.StringSplitOptions" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3260"><paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-3261">在 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 和早期版本中，如果向 <see cref="M:System.String.Split(System.Char[])" /> 方法传递的 <paramref name="separator" /> 是 <see langword="null" /> 或不包含任何字符，则该方法将使用一组略有不同的字符来拆分字符串，而不是使用 <see cref="M:System.String.Trim(System.Char[])" /> 方法来剪裁字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3261">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="3cd3e-3262">从 .NET Framework 4 开始，这两个方法都使用一组相同的 Unicode 空白字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3262">Starting with the .NET Framework 4, both methods use an identical set of Unicode white-space characters.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="3cd3e-3263">一个字符，用于分隔此实例中的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3263">A character that delimits the substrings in this instance.</span></span></param>
        <param name="count"><span data-ttu-id="3cd3e-3264">数组中预期的最大元素数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3264">The maximum number of elements expected in the array.</span></span></param>
        <param name="options"><span data-ttu-id="3cd3e-3265">枚举值之一，用于确定拆分操作是否应省略返回值中的空子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3265">One of the enumeration values that determines whether the split operation should omit empty substrings from the return value.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3266">根据提供的字符分隔符将字符串拆分为最大数目的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3266">Splits a string into a maximum number substrings based on the provided character separator.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3267">一个数组，其元素包含此实例中的至多 <paramref name="count" /> 个子字符串，这些子字符串由 <paramref name="separator" /> 分隔。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3267">An array whose elements contain at most <paramref name="count" /> substrings from this instance that are delimited by <paramref name="separator" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3cd3e-3268">如果该字符串已拆分 `count` 为1次，但尚未到达字符串的末尾，则返回的数组中的最后一个字符串将包含此实例的其余尾随子字符串（不变）。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3268">If the string has already been split `count` - 1 times, but the end of the string has not been reached, then the last string in the returned array will contain this instance's remaining trailing substring, untouched.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberSignature Language="C#" Value="public string[] Split (char[]? separator, int count, StringSplitOptions options);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="3cd3e-3269">分隔此字符串中子字符串的字符数组、不包含分隔符的空数组或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3269">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <param name="count"><span data-ttu-id="3cd3e-3270">要返回的子字符串的最大数量。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3270">The maximum number of substrings to return.</span></span></param>
        <param name="options"><span data-ttu-id="3cd3e-3271">要省略返回的数组中的空数组元素，则为 <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />；要包含返回的数组中的空数组元素，则为 <see cref="F:System.StringSplitOptions.None" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3271"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3272">基于数组中的字符将一个字符串拆分成最大数量的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3272">Splits a string into a maximum number of substrings based on the characters in an array.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3273">一个数组，其元素包含此字符串中的子字符串，这些子字符串由 <paramref name="separator" /> 中的一个或多个字符分隔。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3273">An array whose elements contain the substrings in this string that are delimited by one or more characters in <paramref name="separator" />.</span></span> <span data-ttu-id="3cd3e-3274">有关详细信息，请参阅“备注”部分。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3274">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3275">分隔符字符不包含在返回数组的元素中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3275">Delimiter characters are not included in the elements of the returned array.</span></span>

 <span data-ttu-id="3cd3e-3276">如果此实例不包含中的任何字符 `separator` ，或者 `count` 参数为1，则返回的数组由包含此实例的单个元素组成。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3276">If this instance does not contain any of the characters in `separator`, or the `count` parameter is 1, the returned array consists of a single element that contains this instance.</span></span> <span data-ttu-id="3cd3e-3277">如果 `separator` 参数为 `null` 或不包含任何字符，则假定空格字符为分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3277">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="3cd3e-3278">空白字符由 Unicode 标准定义，并在 `true` 传递给方法时返回 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3278">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3cd3e-3279">但是，如果对 `separator` 此方法重载的调用中的参数为 `null` ，则编译器重载决策失败。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3279">However, if the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails.</span></span> <span data-ttu-id="3cd3e-3280">为了明确标识所调用的方法，你的代码必须指示 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3280">To unambiguously identify the called method, your code must indicate the type of the null.</span></span> <span data-ttu-id="3cd3e-3281">下面的示例演示了几种明确识别此重载的方式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3281">The following example shows several ways to unambiguously identify this overload.</span></span>

 [!code-csharp[System.String.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)]
 [!code-vb[System.String.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)]

 <span data-ttu-id="3cd3e-3282">如果 `count` 参数为零，或者 `options` 参数为 <xref:System.StringSplitOptions.RemoveEmptyEntries> ，并且此实例的长度为零，则返回空数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3282">If the `count` parameter is zero, or the `options` parameter is <xref:System.StringSplitOptions.RemoveEmptyEntries> and the length of this instance is zero, an empty array is returned.</span></span>

 <span data-ttu-id="3cd3e-3283">的每个元素 `separator` 定义单独的分隔符字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3283">Each element of `separator` defines a separate delimiter character.</span></span> <span data-ttu-id="3cd3e-3284">如果 `options` 参数为 <xref:System.StringSplitOptions.None> ，并且两个分隔符相邻，或在此实例的开头或结尾找到了分隔符，则对应的数组元素包含 <xref:System.String.Empty?displayProperty=nameWithtype> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3284">If the `options` parameter is <xref:System.StringSplitOptions.None>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty?displayProperty=nameWithtype>.</span></span>

 <span data-ttu-id="3cd3e-3285">如果 `count` 此实例中的子字符串多于个子字符串，则返回 `count` 值的第一个减1元素返回第一个减号子字符串 `count` ，并且在返回值的最后一个元素中返回此实例中剩余的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3285">If there are more than `count` substrings in this instance, the first `count` minus 1 substrings are returned in the first `count` minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</span></span>

 <span data-ttu-id="3cd3e-3286">如果 `count` 大于子字符串的数目，则将返回可用的子字符串，并且不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3286">If `count` is greater than the number of substrings, the available substrings are returned and no exception is thrown.</span></span>

### <a name="performance-considerations"></a><span data-ttu-id="3cd3e-3287">性能注意事项</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3287">Performance Considerations</span></span>
 <span data-ttu-id="3cd3e-3288"><xref:System.String.Split%2A>方法为返回的数组对象分配内存，并为 <xref:System.String> 每个数组元素分配一个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3288">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="3cd3e-3289">如果你的应用程序需要最佳性能，或者在你的应用程序中管理内存分配非常重要，请考虑使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法，并根据需要使用 <xref:System.String.Compare%2A> 方法来查找字符串中的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3289">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>

 <span data-ttu-id="3cd3e-3290">如果要在分隔符处拆分字符串，请使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法来查找字符串中的分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3290">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="3cd3e-3291">如果要将字符串拆分为分隔符字符串，请使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法查找分隔符字符串的第一个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3291">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="3cd3e-3292">然后，使用 <xref:System.String.Compare%2A> 方法来确定第一个字符后面的字符是否等于分隔符字符串的剩余字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3292">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>

 <span data-ttu-id="3cd3e-3293">此外，如果使用相同的字符集拆分多个方法调用中的字符串 <xref:System.String.Split%2A> ，请考虑创建一个数组，并在每个方法调用中引用它。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3293">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="3cd3e-3294">这可以显著降低每个方法调用的额外开销。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3294">This significantly reduces the additional overhead of each method call.</span></span>



## Examples
 <span data-ttu-id="3cd3e-3295">下面的示例使用 <xref:System.StringSplitOptions> 枚举来包括或排除方法生成的子字符串 <xref:System.String.Split%2A> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3295">The following example uses the <xref:System.StringSplitOptions> enumeration to include or exclude substrings generated by the <xref:System.String.Split%2A> method.</span></span>

 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-3296"><paramref name="count" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3296"><paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-3297"><paramref name="options" /> 不是 <see cref="T:System.StringSplitOptions" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3297"><paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-3298">在 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 和早期版本中，如果向 <see cref="M:System.String.Split(System.Char[])" /> 方法传递的 <paramref name="separator" /> 是 <see langword="null" /> 或不包含任何字符，则该方法将使用一组略有不同的字符来拆分字符串，而不是使用 <see cref="M:System.String.Trim(System.Char[])" /> 方法来剪裁字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3298">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="3cd3e-3299">从 .NET Framework 4 开始，这两个方法都使用一组相同的 Unicode 空白字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3299">Starting with the .NET Framework 4, both methods use an identical set of Unicode white-space characters.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string? separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="3cd3e-3300">一个字符串，用于分隔此实例中的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3300">A string that delimits the substrings in this instance.</span></span></param>
        <param name="count"><span data-ttu-id="3cd3e-3301">数组中预期的最大元素数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3301">The maximum number of elements expected in the array.</span></span></param>
        <param name="options"><span data-ttu-id="3cd3e-3302">枚举值之一，用于确定拆分操作是否应省略返回值中的空子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3302">One of the enumeration values that determines whether the split operation should omit empty substrings from the return value.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3303">根据提供的字符串分隔符将字符串拆分为最大数目的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3303">Splits a string into a maximum number of substrings based on the provided string separator.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3304">一个数组，其元素包含此实例中的至多 <paramref name="count" /> 个子字符串，这些子字符串由 <paramref name="separator" /> 分隔。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3304">An array whose elements contain at most <paramref name="count" /> substrings from this instance that are delimited by <paramref name="separator" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3cd3e-3305">如果该字符串已拆分 `count` 为1次，但尚未到达字符串的末尾，则返回的数组中的最后一个字符串将包含此实例的其余尾随子字符串（不变）。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3305">If the string has already been split `count` - 1 times, but the end of the string has not been reached, then the last string in the returned array will contain this instance's remaining trailing substring, untouched.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberSignature Language="C#" Value="public string[] Split (string[]? separator, int count, StringSplitOptions options);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="3cd3e-3306">分隔此字符串中子字符串的字符串数组、不包含分隔符的空数组或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3306">A string array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <param name="count"><span data-ttu-id="3cd3e-3307">要返回的子字符串的最大数量。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3307">The maximum number of substrings to return.</span></span></param>
        <param name="options"><span data-ttu-id="3cd3e-3308">要省略返回的数组中的空数组元素，则为 <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />；要包含返回的数组中的空数组元素，则为 <see cref="F:System.StringSplitOptions.None" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3308"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3309">基于数组中的字符串将一个字符串拆分成最大数量的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3309">Splits a string into a maximum number of substrings based on the strings in an array.</span></span> <span data-ttu-id="3cd3e-3310">可以指定子字符串是否包含空数组元素。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3310">You can specify whether the substrings include empty array elements.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3311">一个数组，其元素包含此字符串中的子字符串，这些子字符串由 <paramref name="separator" /> 中的一个或多个字符串分隔。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3311">An array whose elements contain the substrings in this string that are delimited by one or more strings in <paramref name="separator" />.</span></span> <span data-ttu-id="3cd3e-3312">有关详细信息，请参阅“备注”部分。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3312">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

### <a name="return-value-details"></a><span data-ttu-id="3cd3e-3313">返回值详细信息</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3313">Return value details</span></span>
 <span data-ttu-id="3cd3e-3314">分隔符字符串不包含在返回数组的元素中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3314">Delimiter strings are not included in the elements of the returned array.</span></span>

 <span data-ttu-id="3cd3e-3315">如果此实例不包含中的任何字符串 `separator` ，或者 `count` 参数为1，则返回的数组由包含此实例的单个元素组成。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3315">If this instance does not contain any of the strings in `separator`, or the `count` parameter is 1, the returned array consists of a single element that contains this instance.</span></span> <span data-ttu-id="3cd3e-3316">如果 `separator` 参数为 `null` 或不包含任何字符，则假定空格字符为分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3316">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="3cd3e-3317">空白字符由 Unicode 标准定义，并在 `true` 传递给方法时返回 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3317">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3cd3e-3318">但是，如果对 `separator` 此方法重载的调用中的参数为 `null` ，则编译器重载决策失败。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3318">However, if the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails.</span></span> <span data-ttu-id="3cd3e-3319">为了明确标识所调用的方法，你的代码必须指示的类型 `null` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3319">To unambiguously identify the called method, your code must indicate the type of the `null`.</span></span> <span data-ttu-id="3cd3e-3320">下面的示例演示了几种明确识别此重载的方式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3320">The following example shows several ways to unambiguously identify this overload.</span></span>

 [!code-csharp[System.String.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)]
 [!code-vb[System.String.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)]

 <span data-ttu-id="3cd3e-3321">如果 `count` 参数为零，或者 `options` 参数为 <xref:System.StringSplitOptions.RemoveEmptyEntries> ，并且此实例的长度为零，则返回空数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3321">If the `count` parameter is zero, or the `options` parameter is <xref:System.StringSplitOptions.RemoveEmptyEntries> and the length of this instance is zero, an empty array is returned.</span></span>

 <span data-ttu-id="3cd3e-3322">的每个元素都 `separator` 定义一个由一个或多个字符组成的单独分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3322">Each element of `separator` defines a separate delimiter that consists of one or more characters.</span></span> <span data-ttu-id="3cd3e-3323">如果 `options` 参数为 <xref:System.StringSplitOptions.None> ，并且两个分隔符相邻，或在此实例的开头或结尾找到了分隔符，则对应的数组元素包含 <xref:System.String.Empty?displayProperty=nameWithtype> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3323">If the `options` parameter is <xref:System.StringSplitOptions.None>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty?displayProperty=nameWithtype>.</span></span>

 <span data-ttu-id="3cd3e-3324">如果 `count` 此实例中的子字符串多于个子字符串，则返回 `count` 值的第一个减1元素返回第一个减号子字符串 `count` ，并且在返回值的最后一个元素中返回此实例中剩余的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3324">If there are more than `count` substrings in this instance, the first `count` minus 1 substrings are returned in the first `count` minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</span></span>

 <span data-ttu-id="3cd3e-3325">如果 `count` 大于子字符串的数目，则将返回可用的子字符串，并且不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3325">If `count` is greater than the number of substrings, the available substrings are returned and no exception is thrown.</span></span>

### <a name="the-separator-array"></a><span data-ttu-id="3cd3e-3326">分隔符数组</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3326">The separator array</span></span>
 <span data-ttu-id="3cd3e-3327">如果中的任何元素 `separator` 包含多个字符，则整个子字符串被视为分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3327">If any of the elements in `separator` consists of multiple characters, the entire substring is considered a delimiter.</span></span> <span data-ttu-id="3cd3e-3328">例如，如果中的一个元素 `separator` 为 "10"，则尝试拆分字符串 "This10is10a10string"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3328">For example, if one of the elements in `separator` is "10", attempting to split the string "This10is10a10string."</span></span> <span data-ttu-id="3cd3e-3329">返回这四元素数组： {"This"、"is"、"a"、"string"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3329">returns this four-element array: { "This", "is", "a", "string."</span></span> <span data-ttu-id="3cd3e-3330">}.</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3330">}.</span></span>

### <a name="comparison-details"></a><span data-ttu-id="3cd3e-3331">比较详细信息</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3331">Comparison details</span></span>
 <span data-ttu-id="3cd3e-3332"><xref:System.String.Split%2A>方法提取此字符串中的子字符串，这些子字符串由参数中的一个或多个字符串分隔 `separator` ，并将这些子字符串作为数组的元素返回。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3332">The <xref:System.String.Split%2A> method extracts the substrings in this string that are delimited by one or more of the strings in the `separator` parameter, and returns those substrings as elements of an array.</span></span>

 <span data-ttu-id="3cd3e-3333"><xref:System.String.Split%2A>方法通过使用区分大小写的序号排序规则执行比较来查找分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3333">The <xref:System.String.Split%2A> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</span></span> <span data-ttu-id="3cd3e-3334">有关 word、字符串和序号排序的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 枚举。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3334">For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span>

 <span data-ttu-id="3cd3e-3335"><xref:System.String.Split%2A>方法将忽略 `separator` 其值为 `null` 或空字符串 ( "" ) 的任何元素。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3335">The <xref:System.String.Split%2A> method ignores any element of `separator` whose value is `null` or the empty string ("").</span></span>

 <span data-ttu-id="3cd3e-3336">若要避免在中的字符串具有相同的字符时出现不明确 `separator` 的结果，该 <xref:System.String.Split%2A> 方法将从实例值的开头开始，并与中的第一个元素（ `separator` 该元素等于实例中的分隔符）匹配。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3336">To avoid ambiguous results when strings in `separator` have characters in common, the <xref:System.String.Split%2A> method proceeds from the beginning to the end of the value of the instance, and matches the first element in `separator` that is equal to a delimiter in the instance.</span></span> <span data-ttu-id="3cd3e-3337">实例中的子字符串的出现顺序优先于中元素的顺序 `separator` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3337">The order in which substrings are encountered in the instance takes precedence over the order of elements in `separator`.</span></span>

 <span data-ttu-id="3cd3e-3338">例如，假设值为 "abcdef" 的实例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3338">For example, consider an instance whose value is "abcdef".</span></span> <span data-ttu-id="3cd3e-3339">如果中的第一个元素 `separator` 为 "ef"，第二个元素为 "bcde"，则拆分操作的结果为 "a" 和 "f"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3339">If the first element in `separator` was "ef" and the second element was "bcde", the result of the split operation would be "a" and "f".</span></span> <span data-ttu-id="3cd3e-3340">这是因为，在遇到子字符串 "f" 之前，遇到了实例 "bcde" 中的子字符串，并与中的元素匹配 `separator` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3340">This is because the substring in the instance, "bcde", is encountered and matches an element in `separator` before the substring "f" is encountered.</span></span>

 <span data-ttu-id="3cd3e-3341">但是，如果的第一个元素 `separator` 为 "bcd"，第二个元素为 "bc"，则拆分操作的结果为 "a" 和 "ef"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3341">However, if the first element of `separator` was "bcd" and the second element was "bc", the result of the split operation would be "a" and "ef".</span></span> <span data-ttu-id="3cd3e-3342">这是因为 "bcd" 是中的第一个分隔符 `separator` ，它与实例中的分隔符相匹配。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3342">This is because "bcd" is the first delimiter in `separator` that matches a delimiter in the instance.</span></span> <span data-ttu-id="3cd3e-3343">如果分隔符的顺序已颠倒，因此第一个元素为 "bc"，第二个元素为 "bcd"，则结果为 "a" 和 "def"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3343">If the order of the separators was reversed so the first element was "bc" and the second element was "bcd", the result would be "a" and "def".</span></span>

### <a name="performance-considerations"></a><span data-ttu-id="3cd3e-3344">性能注意事项</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3344">Performance considerations</span></span>
 <span data-ttu-id="3cd3e-3345"><xref:System.String.Split%2A>方法为返回的数组对象分配内存，并为 <xref:System.String> 每个数组元素分配一个对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3345">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="3cd3e-3346">如果你的应用程序需要最佳性能，或者在你的应用程序中管理内存分配非常重要，请考虑使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法，并根据需要使用 <xref:System.String.Compare%2A> 方法来查找字符串中的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3346">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>

 <span data-ttu-id="3cd3e-3347">如果要在分隔符处拆分字符串，请使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法来查找字符串中的分隔符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3347">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="3cd3e-3348">如果要将字符串拆分为分隔符字符串，请使用 <xref:System.String.IndexOf%2A> 或 <xref:System.String.IndexOfAny%2A> 方法查找分隔符字符串的第一个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3348">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="3cd3e-3349">然后，使用 <xref:System.String.Compare%2A> 方法来确定第一个字符后面的字符是否等于分隔符字符串的剩余字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3349">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>

 <span data-ttu-id="3cd3e-3350">此外，如果使用相同的字符集拆分多个方法调用中的字符串 <xref:System.String.Split%2A> ，请考虑创建一个数组，并在每个方法调用中引用它。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3350">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="3cd3e-3351">这可以显著降低每个方法调用的额外开销。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3351">This significantly reduces the additional overhead of each method call.</span></span>



## Examples
 <span data-ttu-id="3cd3e-3352">下面的示例使用 <xref:System.StringSplitOptions> 枚举来包括或排除方法生成的子字符串 <xref:System.String.Split%2A> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3352">The following example uses the <xref:System.StringSplitOptions> enumeration to include or exclude substrings generated by the <xref:System.String.Split%2A> method.</span></span>

 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-3353"><paramref name="count" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3353"><paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-3354"><paramref name="options" /> 不是 <see cref="T:System.StringSplitOptions" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3354"><paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-3355">在 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] 和早期版本中，如果向 <see cref="M:System.String.Split(System.Char[])" /> 方法传递的 <paramref name="separator" /> 是 <see langword="null" /> 或不包含任何字符，则该方法将使用一组略有不同的字符来拆分字符串，而不是使用 <see cref="M:System.String.Trim(System.Char[])" /> 方法来剪裁字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3355">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="3cd3e-3356">从 .NET Framework 4 开始，这两个方法都使用一组相同的 Unicode 空白字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3356">Starting with the .NET Framework 4, both methods use an identical set of Unicode white-space characters.</span></span></para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3cd3e-3357">确定此字符串实例的开头是否与指定的字符串匹配。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3357">Determines whether the beginning of this string instance matches a specified string.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : char -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-3358">要比较的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3358">The character to compare.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3359">确定此字符串实例是否以指定字符开始。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3359">Determines whether this string instance starts with the specified character.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3360">如果 <see langword="true" /> 与此字符串的开头匹配，则为 <paramref name="value" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3360"><see langword="true" /> if <paramref name="value" /> matches the beginning of this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3cd3e-3361">此方法使用当前区域性执行区分大小写的 (区分大小写的) 比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3361">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-3362">要比较的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3362">The string to compare.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3363">确定此字符串实例的开头是否与指定的字符串匹配。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3363">Determines whether the beginning of this string instance matches the specified string.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3364">如果 <see langword="true" /> 与此字符串的开头匹配，则为 <paramref name="value" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3364"><see langword="true" /> if <paramref name="value" /> matches the beginning of this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3cd3e-3365">此方法 `value` 与此实例开头与相同的子字符串进行比较 `value` ，并返回一个指示是否相等的指示。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3365">This method compares `value` to the substring at the beginning of this instance that is the same length as `value`, and returns an indication whether they are equal.</span></span> <span data-ttu-id="3cd3e-3366">若要相等， `value` 必须是 () 的空字符串 <xref:System.String.Empty?displayProperty=nameWithType> ，必须是对此同一个实例的引用，或者必须与此实例的开头匹配。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3366">To be equal, `value` must be an empty string (<xref:System.String.Empty?displayProperty=nameWithType>), must be a reference to this same instance, or must match the beginning of this instance.</span></span>

<span data-ttu-id="3cd3e-3367">此方法使用当前区域性执行区分大小写的 (区分大小写的) 比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3367">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span>

## Examples

<span data-ttu-id="3cd3e-3368">下面的示例定义了一个 `StripStartTags` 方法，该方法使用 <xref:System.String.StartsWith%28System.String%29> 方法从字符串的开头移除 HTML 开始标记。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3368">The following example defines a `StripStartTags` method that uses the <xref:System.String.StartsWith%28System.String%29> method to remove HTML start tags from the beginning of a string.</span></span> <span data-ttu-id="3cd3e-3369">请注意，将 `StripStartTags` 以递归方式调用方法，以确保删除行开头的多个 HTML 开始标记。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3369">Note that the `StripStartTags` method is called recursively to ensure that multiple HTML start tags at the beginning of the line are removed.</span></span> <span data-ttu-id="3cd3e-3370">该示例不删除嵌入在字符串中的 HTML 标记。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3370">The example does not remove HTML tags embedded in a string.</span></span>

:::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp" id="Snippet1":::
:::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs" interactive="try-dotnet" id="Snippet1":::
:::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb" id="Snippet1":::

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-3371"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3371"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-3372">如 [使用字符串的最佳做法](/dotnet/standard/base-types/best-practices-strings)中所述，建议你避免调用替换默认值的字符串比较方法，并改为调用需要显式指定参数的方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3372">As explained in [Best Practices for Using Strings](/dotnet/standard/base-types/best-practices-strings), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="3cd3e-3373">若要通过使用当前区域性的字符串比较规则来确定某个字符串是否以特定子字符串开头，请使用 <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> 其参数的值调用方法重载 <see cref="F:System.StringComparison.CurrentCulture" /> <paramref name="comparisonType" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3373">To determine whether a string begins with a particular substring by using the string comparison rules of the current culture, call the <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="M:System.String.EndsWith(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * StringComparison -&gt; bool" Usage="string.StartsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-3374">要比较的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3374">The string to compare.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="3cd3e-3375">枚举值之一，用于确定如何比较此字符串与 <paramref name="value" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3375">One of the enumeration values that determines how this string and <paramref name="value" /> are compared.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3376">确定在使用指定的比较选项进行比较时此字符串实例的开头是否与指定的字符串匹配。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3376">Determines whether the beginning of this string instance matches the specified string when compared using the specified comparison option.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3377">如果此实例以 <see langword="true" /> 开头，则为 <paramref name="value" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3377"><see langword="true" /> if this instance begins with <paramref name="value" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3378"><xref:System.String.StartsWith%2A>方法将 `value` 参数与此字符串开头的子字符串进行比较，并返回一个值，该值指示它们是否相等。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3378">The <xref:System.String.StartsWith%2A> method compares the `value` parameter to the substring at the beginning of this string and returns a value that indicates whether they are equal.</span></span> <span data-ttu-id="3cd3e-3379">若要相等， `value` 必须是对此同一个字符串的引用，必须为空字符串 ( "" ) ，或者必须与此字符串的开头匹配。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3379">To be equal, `value` must be a reference to this same string, must be the empty string (""), or must match the beginning of this string.</span></span> <span data-ttu-id="3cd3e-3380">方法所执行的比较的类型 <xref:System.String.StartsWith%2A> 取决于参数的值 `comparisonType` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3380">The type of comparison performed by the <xref:System.String.StartsWith%2A> method depends on the value of the `comparisonType` parameter.</span></span> <span data-ttu-id="3cd3e-3381">比较可以使用当前区域性的约定 (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> 和 <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) 或固定区域性 (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> 和 <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>) ），也可以由代码点 (或) 的逐字符比较 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3381">The comparison can use the conventions of the current culture (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> and <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) or the invariant culture (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> and <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>), or it can consist of a character-by-character comparison of code points (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).</span></span> <span data-ttu-id="3cd3e-3382">比较也可以区分大小写 (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> 、 <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> 或 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>) ），也可以忽略大小写 (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> ， <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType> <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3382">The comparison can also be case-sensitive (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>, or <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>), or it can ignore case (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).</span></span>



## Examples
 <span data-ttu-id="3cd3e-3383">下面的示例在字符串 "the" 中搜索以 "the" 开头的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3383">The following example searches for the string "the" at the beginning of a longer string that begins with the word "The".</span></span> <span data-ttu-id="3cd3e-3384">如示例的输出所示，对 <xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29> 执行不区分区域性但区分大小写比较的方法的调用无法匹配字符串，而执行区域性和不区分大小写比较的调用与字符串匹配。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3384">As the output from the example shows, a call to the <xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29> method that performs a culture-insensitive but case-sensitive comparison fails to match the string, while a call that performs a culture- and case-insensitive comparison matches the string.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp" id="Snippet2":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb" id="Snippet2":::

 <span data-ttu-id="3cd3e-3385">下面的示例确定字符串是否以特定子字符串开头。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3385">The following example determines whether a string starts with a particular substring.</span></span> <span data-ttu-id="3cd3e-3386">它初始化二维字符串数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3386">It initializes a two-dimensional string array.</span></span> <span data-ttu-id="3cd3e-3387">第二个维度中的第一个元素包含一个字符串，第二个元素包含在第一个字符串的开头搜索的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3387">The first element in the second dimension contains a string, and the second element contains the string to search for at the start of the first string.</span></span> <span data-ttu-id="3cd3e-3388">结果受区域性选择的影响，是否忽略大小写，以及是否执行序号比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3388">The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</span></span> <span data-ttu-id="3cd3e-3389">请注意，当字符串实例包含连字时，具有其连续字符的区分区域性的比较成功匹配。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3389">Note that when the string instance contains a ligature, culture-sensitive comparisons with its consecutive characters successfully match.</span></span>

 [!code-cpp[System.String.StartsWith#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-3390"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3390"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-3391"><paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3391"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo? culture);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.StartsWith (value, ignoreCase, culture)" />
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-3392">要比较的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3392">The string to compare.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="3cd3e-3393">若要在比较过程中忽略大小写，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3393"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <param name="culture"><span data-ttu-id="3cd3e-3394">确定如何对此字符串与 <paramref name="value" /> 进行比较的区域性信息。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3394">Cultural information that determines how this string and <paramref name="value" /> are compared.</span></span> <span data-ttu-id="3cd3e-3395">如果 <paramref name="culture" /> 为 <see langword="null" />，则使用当前区域性。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3395">If <paramref name="culture" /> is <see langword="null" />, the current culture is used.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3396">确定在使用指定的区域性进行比较时此字符串实例的开头是否与指定的字符串匹配。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3396">Determines whether the beginning of this string instance matches the specified string when compared using the specified culture.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3397">如果 <see langword="true" /> 参数与此字符串的开头匹配，则为 <paramref name="value" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3397"><see langword="true" /> if the <paramref name="value" /> parameter matches the beginning of this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3398">此方法将 `value` 参数与此字符串开头与相同的子字符串进行比较 `value` ，并返回一个值，该值指示它们是否相等。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3398">This method compares the `value` parameter to the substring at the beginning of this string that is the same length as `value`, and returns a value that indicates whether they are equal.</span></span> <span data-ttu-id="3cd3e-3399">若要相等， `value` 必须是 () 的空字符串 <xref:System.String.Empty?displayProperty=nameWithType> ，必须是对此同一个实例的引用，或者必须与此实例的开头匹配。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3399">To be equal, `value` must be an empty string (<xref:System.String.Empty?displayProperty=nameWithType>), must be a reference to this same instance, or must match the beginning of this instance.</span></span>

 <span data-ttu-id="3cd3e-3400">此方法使用指定的大小写和区域性执行比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3400">This method performs a comparison using the specified casing and culture.</span></span>



## Examples
 <span data-ttu-id="3cd3e-3401">下面的示例确定字符串是否出现在另一个字符串的开头。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3401">The following example determines whether a string occurs at the beginning of another string.</span></span> <span data-ttu-id="3cd3e-3402"><xref:System.String.StartsWith%2A>方法使用区分大小写、不区分大小写和影响搜索结果的不同区域性多次调用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3402">The <xref:System.String.StartsWith%2A> method is called several times using case sensitivity, case insensitivity, and different cultures that influence the results of the search.</span></span>

 [!code-csharp[system.string.StartsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-3403"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3403"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Substring">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3cd3e-3404">从此实例检索子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3404">Retrieves a substring from this instance.</span></span>

 <span data-ttu-id="3cd3e-3405">重载此成员。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3405">This member is overloaded.</span></span> <span data-ttu-id="3cd3e-3406">有关此成员的完整信息（包括语法、用法和示例），请单击重载列表中的相应名称。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3406">For complete information about this member, including syntax, usage, and examples, click a name in the overload list.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : int -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="3cd3e-3407">此实例中子字符串的起始字符位置（从零开始）。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3407">The zero-based starting character position of a substring in this instance.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3408">从此实例检索子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3408">Retrieves a substring from this instance.</span></span> <span data-ttu-id="3cd3e-3409">子字符串在指定的字符位置开始并一直到该字符串的末尾。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3409">The substring starts at a specified character position and continues to the end of the string.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3410">与此实例中在 <paramref name="startIndex" /> 处开头的子字符串等效的一个字符串；如果 <see cref="F:System.String.Empty" /> 等于此实例的长度，则为 <paramref name="startIndex" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3410">A string that is equivalent to the substring that begins at <paramref name="startIndex" /> in this instance, or <see cref="F:System.String.Empty" /> if <paramref name="startIndex" /> is equal to the length of this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3411">调用 <xref:System.String.Substring%28System.Int32%29> 方法可从字符串中提取从指定字符位置开始并在字符串末尾结束的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3411">You call the <xref:System.String.Substring%28System.Int32%29> method to extract a substring from a string that begins at a specified character position and ends at the end of the string.</span></span> <span data-ttu-id="3cd3e-3412">起始字符位置是从零开始的;换句话说，字符串中的第一个字符位于索引0，而不是索引1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3412">The starting character position is a zero-based; in other words, the first character in the string is at index 0, not index 1.</span></span> <span data-ttu-id="3cd3e-3413">若要提取从指定字符位置开始并在字符串末尾之前结束的子字符串，请调用 <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3413">To extract a substring that begins at a specified character position and ends before the end of the string, call the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method.</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-3414">此方法不会修改当前实例的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3414">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="3cd3e-3415">相反，它会返回从当前字符串中的位置开始的新字符串 `startIndex` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3415">Instead, it returns a new string that begins at the `startIndex` position in the current string.</span></span>

 <span data-ttu-id="3cd3e-3416">若要提取以特定字符或字符序列开头的子字符串，请调用方法（如  <xref:System.String.IndexOf%2A> 或） <xref:System.String.IndexOf%2A> 来获取的值 `startIndex` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3416">To extract a substring that begins with a particular character or character sequence, call a method such as  <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> to get the value of `startIndex`.</span></span> <span data-ttu-id="3cd3e-3417">第二个示例对此进行了说明：它提取在 "=" 字符后开始一个字符位置的键值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3417">The second example illustrates this; it extracts a key value that begins one character position after the "=" character.</span></span>

 <span data-ttu-id="3cd3e-3418">如果 `startIndex` 等于零，则此方法返回未更改的原始字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3418">If `startIndex` is equal to zero, the method returns the original string unchanged.</span></span>


## Examples
 <span data-ttu-id="3cd3e-3419">下面的示例演示如何从字符串中获取子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3419">The following example demonstrates obtaining a substring from a string.</span></span>

 [!code-cpp[System.String.Substring#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp-interactive[System.String.Substring#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]

 <span data-ttu-id="3cd3e-3420">下面的示例使用 <xref:System.String.Substring%2A> 方法将由 equals ( "=" 分隔的键/值对 ) 字符分隔开。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3420">The following example uses the <xref:System.String.Substring%2A> method to separate key/value pairs that are delimited by an equals ("=") character.</span></span>

 [!code-csharp-interactive[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]

 <span data-ttu-id="3cd3e-3421"><xref:System.String.IndexOf%2A>方法用于获取字符串中 equals 字符的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3421">The <xref:System.String.IndexOf%2A> method is used to get the position of the equals character in the string.</span></span> <span data-ttu-id="3cd3e-3422">对方法的调用 <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> 提取键名称，该键名称从字符串中的第一个字符开始，并针对对方法的调用返回的字符数进行扩展 <xref:System.String.IndexOf%2A> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3422">The call to the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method extracts the key name, which starts from the first character in the string and extends for the number of characters returned by the call to the <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="3cd3e-3423">然后，对方法的调用将 <xref:System.String.Substring%28System.Int32%29> 提取分配给该密钥的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3423">The call to the <xref:System.String.Substring%28System.Int32%29> method then extracts the value assigned to the key.</span></span> <span data-ttu-id="3cd3e-3424">它从 equals 字符之外的一个字符位置开始，并扩展到字符串的末尾。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3424">It starts at one character position beyond the equals character and extends to the end of the string.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-3425"><paramref name="startIndex" /> 小于零或大于此实例的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3425"><paramref name="startIndex" /> is less than zero or greater than the length of this instance.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Substring : int * int -&gt; string" Usage="string.Substring (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="3cd3e-3426">此实例中子字符串的起始字符位置（从零开始）。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3426">The zero-based starting character position of a substring in this instance.</span></span></param>
        <param name="length"><span data-ttu-id="3cd3e-3427">子字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3427">The number of characters in the substring.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3428">从此实例检索子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3428">Retrieves a substring from this instance.</span></span> <span data-ttu-id="3cd3e-3429">子字符串从指定的字符位置开始且具有指定的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3429">The substring starts at a specified character position and has a specified length.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3430">与此实例中在 <paramref name="length" /> 处开头、长度为 <paramref name="startIndex" /> 的子字符串等效的一个字符串；如果 <see cref="F:System.String.Empty" /> 等于此实例的长度且 <paramref name="startIndex" /> 为零，则为 <paramref name="length" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3430">A string that is equivalent to the substring of length <paramref name="length" /> that begins at <paramref name="startIndex" /> in this instance, or <see cref="F:System.String.Empty" /> if <paramref name="startIndex" /> is equal to the length of this instance and <paramref name="length" /> is zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3431">调用 <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> 方法可从字符串中提取从指定字符位置开始并在字符串末尾之前结束的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3431">You call the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method to extract a substring from a string that begins at a specified character position and ends before the end of the string.</span></span> <span data-ttu-id="3cd3e-3432">起始字符位置是从零开始的;换句话说，字符串中的第一个字符位于索引0，而不是索引1。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3432">The starting character position is a zero-based; in other words, the first character in the string is at index 0, not index 1.</span></span> <span data-ttu-id="3cd3e-3433">若要提取从指定字符位置开始并持续到字符串末尾的子字符串，请调用 <xref:System.String.Substring%28System.Int32%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3433">To extract a substring that begins at a specified character position and continues to the end of the string, call the <xref:System.String.Substring%28System.Int32%29> method.</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-3434">此方法不会修改当前实例的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3434">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="3cd3e-3435">相反，它会返回一个新字符串，其中包含 `length` 从 `startIndex` 当前字符串中的位置开始的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3435">Instead, it returns a new string with `length` characters starting from the `startIndex` position in the current string.</span></span>

 <span data-ttu-id="3cd3e-3436">`length`参数表示要从当前字符串实例中提取的字符的总数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3436">The `length` parameter represents the total number of characters to extract from the current string instance.</span></span> <span data-ttu-id="3cd3e-3437">这包括索引处的起始字符  `startIndex` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3437">This includes the starting character found at index  `startIndex`.</span></span>  <span data-ttu-id="3cd3e-3438">换言之，此 <xref:System.String.Substring%2A> 方法尝试从索引 `startIndex` 到索引 `startIndex`  +  `length` -1 提取字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3438">In other words, the <xref:System.String.Substring%2A> method attempts to extract characters from index `startIndex` to index `startIndex` + `length` - 1.</span></span>

 <span data-ttu-id="3cd3e-3439">若要提取以特定字符或字符序列开头的子字符串，请调用方法（如  <xref:System.String.IndexOf%2A> 或） <xref:System.String.LastIndexOf%2A> 来获取的值 `startIndex` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3439">To extract a substring that begins with a particular character or character sequence, call a method such as  <xref:System.String.IndexOf%2A> or <xref:System.String.LastIndexOf%2A> to get the value of `startIndex`.</span></span>

 <span data-ttu-id="3cd3e-3440">如果子字符串从扩展 `startIndex` 到指定的字符序列，则可以调用方法（如  <xref:System.String.IndexOf%2A> 或） <xref:System.String.LastIndexOf%2A> 来获取结束字符或字符序列的索引。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3440">If the substring extends from `startIndex` to a specified character sequence, you can call a method such as  <xref:System.String.IndexOf%2A> or <xref:System.String.LastIndexOf%2A> to get the index of the ending character or character sequence.</span></span>  <span data-ttu-id="3cd3e-3441">然后，可以将该值转换为字符串中的索引位置，如下所示：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3441">You can then convert that value to an index position in the string as follows:</span></span>

-   <span data-ttu-id="3cd3e-3442">如果已搜索要标记子字符串末尾的单个字符，则 `length` 参数等于 `endIndex`  -  `startIndex` + 1，其中 `endIndex` 是或方法的返回值 <xref:System.String.IndexOf%2A> <xref:System.String.IndexOf%2A> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3442">If you've searched for a single character that is to mark the end of the substring, the `length` parameter equals  `endIndex` - `startIndex` + 1, where `endIndex` is the return value of the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="3cd3e-3443">下面的示例从字符串中提取 "b" 字符的连续块。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3443">The following example extracts a continuous block of "b" characters from a string.</span></span>

     [!code-csharp-interactive[System.String.Substring#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]

-   <span data-ttu-id="3cd3e-3444">如果已搜索多个字符来标记子字符串的末尾，则 `length` 参数等于 `endIndex`  +  `endMatchLength`  -  `startIndex` ，其中 `endIndex` 是或方法的返回值 <xref:System.String.IndexOf%2A> <xref:System.String.IndexOf%2A> ， `endMatchLength` 是标记子字符串末尾的字符序列的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3444">If you've searched for multiple characters that are to mark the end of the substring, the `length` parameter equals  `endIndex` + `endMatchLength` - `startIndex`, where `endIndex` is the return value of the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> method, and `endMatchLength` is the length of the character sequence that marks the end of the substring.</span></span> <span data-ttu-id="3cd3e-3445">下面的示例提取包含 XML 元素的文本块 `<definition>` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3445">The following example extracts a block of text that contains an XML `<definition>` element.</span></span>

     [!code-csharp-interactive[System.String.Substring#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]

-   <span data-ttu-id="3cd3e-3446">如果字符或字符序列未包含在子字符串的末尾，则 `length` 参数等于 `endIndex`  -  `startIndex` ，其中 `endIndex` 是或方法的返回值 <xref:System.String.IndexOf%2A> <xref:System.String.IndexOf%2A> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3446">If the character or character sequence is not included in the end of the substring, the `length` parameter equals `endIndex` - `startIndex`, where `endIndex` is the return value of the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> method.</span></span>

 <span data-ttu-id="3cd3e-3447">如果 `startIndex` 等于零并且等于当前字符串的长度，则此方法返回未更改的原始字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3447">If `startIndex` is equal to zero and  equals the length of the current string, the method returns the original string unchanged.</span></span>



## Examples
 <span data-ttu-id="3cd3e-3448">下面的示例演示了一个简单的 <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> 方法调用方法，该方法从第六个字符位置开始的字符串中提取两个字符， (即索引为 5) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3448">The following example illustrates a simple call to the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method that extracts two characters from a string starting at the sixth character position (that is, at index five).</span></span>

 [!code-csharp-interactive[System.String.Substring#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]

 <span data-ttu-id="3cd3e-3449">下面的示例使用 <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> 以下三种情况中的方法来隔离字符串中的子字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3449">The following example uses the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method in the following three cases to isolate substrings within a string.</span></span> <span data-ttu-id="3cd3e-3450">在两种情况下，将在比较中使用子字符串，在第三种情况下将引发异常，因为指定了无效的参数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3450">In two cases the substrings are used in comparisons, and in the third case an exception is thrown because invalid parameters are specified.</span></span>

-   <span data-ttu-id="3cd3e-3451">它提取索引) 2 处的字符串 (中的单个字符和第三个位置，并将其与 "c" 进行比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3451">It extracts the single character and the third position in the string (at index 2) and compares it with a "c".</span></span> <span data-ttu-id="3cd3e-3452">此比较返回 `true` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3452">This comparison returns `true`.</span></span>

-   <span data-ttu-id="3cd3e-3453">它从索引 3) 的字符串 (中的第四个位置提取零个字符，并将其传递给 <xref:System.String.IsNullOrEmpty%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3453">It extracts zero characters starting at the fourth position in the string (at index 3) and passes it to the <xref:System.String.IsNullOrEmpty%2A> method.</span></span> <span data-ttu-id="3cd3e-3454">此方法返回 true，因为对方法的调用将 <xref:System.String.Substring%2A> 返回 <xref:System.String.Empty?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3454">This returns true because the call to the <xref:System.String.Substring%2A> method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

-   <span data-ttu-id="3cd3e-3455">它将尝试从字符串中的第四个位置提取一个字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3455">It attempts to extract one character starting at the fourth position in the string.</span></span> <span data-ttu-id="3cd3e-3456">由于该位置没有任何字符，因此方法调用会引发 <xref:System.ArgumentOutOfRangeException> 异常。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3456">Because there is no character at that position, the method call throws an <xref:System.ArgumentOutOfRangeException> exception.</span></span>

 [!code-csharp-interactive[Classic String.Substring1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]

 <span data-ttu-id="3cd3e-3457">下面的示例使用 <xref:System.String.Substring%2A> 方法将由 equals ( "=" 分隔的键/值对 ) 字符分隔开。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3457">The following example uses the <xref:System.String.Substring%2A> method to separate key/value pairs that are delimited by an equals ("=") character.</span></span>

 [!code-csharp-interactive[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]

 <span data-ttu-id="3cd3e-3458"><xref:System.String.IndexOf%2A>方法用于获取字符串中 equals 字符的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3458">The <xref:System.String.IndexOf%2A> method is used to get the position of the equals character in the string.</span></span> <span data-ttu-id="3cd3e-3459">对方法的调用 <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> 提取键名称，该键名称从字符串中的第一个字符开始，并针对对方法的调用返回的字符数进行扩展 <xref:System.String.IndexOf%2A> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3459">The call to the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method extracts the key name, which starts from the first character in the string and extends for the number of characters returned by the call to the <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="3cd3e-3460">然后，对方法的调用将 <xref:System.String.Substring%28System.Int32%29> 提取分配给该密钥的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3460">The call to the <xref:System.String.Substring%28System.Int32%29> method then extracts the value assigned to the key.</span></span> <span data-ttu-id="3cd3e-3461">它从 equals 字符之外的一个字符位置开始，并扩展到字符串的末尾。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3461">It starts at one character position beyond the equals character and extends to the end of the string.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-3462"><paramref name="startIndex" /> 加 <paramref name="length" /> 指示不在此实例内的位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3462"><paramref name="startIndex" /> plus <paramref name="length" /> indicates a position not within this instance.</span></span>

<span data-ttu-id="3cd3e-3463">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3463">-or-</span></span>

 <span data-ttu-id="3cd3e-3464"><paramref name="startIndex" /> 或 <paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3464"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span></exception>
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator" ExplicitInterfaceMemberName="System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Char) Implements IEnumerable(Of Char).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;char&gt; ^ System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;char&gt;::GetEnumerator;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;char&gt;&#xA;override this.System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;char&gt;" Usage="string.System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3cd3e-3465">返回循环访问当前 <see cref="T:System.String" /> 对象的枚举数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3465">Returns an enumerator that iterates through the current <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3466">可用于循环访问当前 <see cref="T:System.String" /> 对象的强类型化枚举器。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3466">A strongly-typed enumerator that can be used to iterate through the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3467">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3467">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3cd3e-3468">它只能在 <xref:System.String> 实例被强制转换为接口对象时使用 <xref:System.Collections.Generic.IEnumerable%601> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3468">It can be used only when the <xref:System.String> instance is cast to an <xref:System.Collections.Generic.IEnumerable%601> interface object.</span></span> <span data-ttu-id="3cd3e-3469">有关更多信息，请参见 <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3469">For more information, see the <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> method.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IEnumerable.GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.System.Collections.IEnumerable.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="string.System.Collections.IEnumerable.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3cd3e-3470">返回循环访问当前 <see cref="T:System.String" /> 对象的枚举数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3470">Returns an enumerator that iterates through the current <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3471">一个枚举器，可用于循环访问当前的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3471">An enumerator that can be used to iterate through the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3472">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3472">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3cd3e-3473">它只能在 <xref:System.String> 实例被强制转换为 <xref:System.Collections.IEnumerable> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3473">It can be used only when the <xref:System.String> instance is cast to an <xref:System.Collections.IEnumerable> interface.</span></span> <span data-ttu-id="3cd3e-3474">有关更多信息，请参见 <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3474">For more information, see the <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberSignature Language="F#" Value="abstract member System.IComparable.CompareTo : obj -&gt; int&#xA;override this.System.IComparable.CompareTo : obj -&gt; int" Usage="string.System.IComparable.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3cd3e-3475">一个对象，其计算结果为 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3475">An object that evaluates to a <see cref="T:System.String" />.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3476">将此实例与指定的 <see cref="T:System.Object" /> 进行比较，并指示此实例在排序顺序中是位于指定的 <see cref="T:System.Object" /> 之前、之后还是与其出现在同一位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3476">Compares this instance with a specified <see cref="T:System.Object" /> and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <see cref="T:System.Object" />.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3477">一个 32 位带符号整数，该整数指示此实例在排序顺序中是位于 <paramref name="value" /> 参数之前、之后还是与其出现在同一位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3477">A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <paramref name="value" /> parameter.</span></span>

<list type="table"><listheader><term><span data-ttu-id="3cd3e-3478">“值”</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3478">Value</span></span></term><description><span data-ttu-id="3cd3e-3479">条件</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3479">Condition</span></span></description></listheader><item><term><span data-ttu-id="3cd3e-3480">小于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3480">Less than zero</span></span></term><description><span data-ttu-id="3cd3e-3481">此实例位于 <paramref name="value" /> 之前。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3481">This instance precedes <paramref name="value" />.</span></span></description></item><item><term><span data-ttu-id="3cd3e-3482">零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3482">Zero</span></span></term><description><span data-ttu-id="3cd3e-3483">此实例在排序顺序中的位置与 <paramref name="value" /> 相同。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3483">This instance has the same position in the sort order as <paramref name="value" />.</span></span></description></item><item><term><span data-ttu-id="3cd3e-3484">大于零</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3484">Greater than zero</span></span></term><description><span data-ttu-id="3cd3e-3485">此实例位于 <paramref name="value" /> 之后，或 <paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3485">This instance follows <paramref name="value" />, or <paramref name="value" /> is <see langword="null" />.</span></span></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3cd3e-3486">`value` 必须是一个 <xref:System.String> 对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3486">`value` must be a <xref:System.String> object.</span></span>

> [!CAUTION]
>  <span data-ttu-id="3cd3e-3487">此 <xref:System.String.CompareTo%2A> 方法主要用于排序或 alphabetizing 操作。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3487">The <xref:System.String.CompareTo%2A> method was designed primarily for use in sorting or alphabetizing operations.</span></span> <span data-ttu-id="3cd3e-3488">当方法调用的主要目的是确定两个字符串是否相等时，不应使用此方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3488">It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent.</span></span> <span data-ttu-id="3cd3e-3489">若要确定两个字符串是否相等，请调用 <xref:System.String.Equals%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3489">To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.</span></span>

<span data-ttu-id="3cd3e-3490">此方法使用当前区域性执行区分大小写的 (区分大小写的) 比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3490">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span> <span data-ttu-id="3cd3e-3491">有关 word、字符串和顺序排序的详细信息，请参阅 <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3491">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="3cd3e-3492">有关此方法的行为的详细信息，请参阅方法的 "备注" 部分 <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3492">For more information about the behavior of this method, see the Remarks section of the <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> method.</span></span>

## Examples

<span data-ttu-id="3cd3e-3493">下面的示例将 <xref:System.String.CompareTo%2A> 方法与一起使用 <xref:System.Object> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3493">The following example uses the <xref:System.String.CompareTo%2A> method with an <xref:System.Object>.</span></span> <span data-ttu-id="3cd3e-3494">因为它尝试将实例与 <xref:System.String> 对象进行比较 `TestClass` ，所以方法会引发 <xref:System.ArgumentException> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3494">Because it attempts to compare a <xref:System.String> instance to a `TestClass` object, the method throws an <xref:System.ArgumentException>.</span></span>

[!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
[!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
[!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3cd3e-3495"><paramref name="value" /> 不是 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3495"><paramref name="value" /> is not a <see cref="T:System.String" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.GetTypeCode : unit -&gt; TypeCode&#xA;override this.System.IConvertible.GetTypeCode : unit -&gt; TypeCode" Usage="string.System.IConvertible.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3cd3e-3496">返回 <see cref="T:System.String" /> 类的 <see cref="T:System.TypeCode" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3496">Returns the <see cref="T:System.TypeCode" /> for the <see cref="T:System.String" /> class.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3497">枚举常数 <see cref="F:System.TypeCode.String" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3497">The enumerated constant, <see cref="F:System.TypeCode.String" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples

<span data-ttu-id="3cd3e-3498">下面的示例显示了 <xref:System.TypeCode> 类型的枚举常数 <xref:System.String> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3498">The following example displays the <xref:System.TypeCode> enumerated constant for the <xref:System.String> type.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb" id="Snippet1":::

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToBoolean : IFormatProvider -&gt; bool&#xA;override this.System.IConvertible.ToBoolean : IFormatProvider -&gt; bool" Usage="string.System.IConvertible.ToBoolean provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="3cd3e-3499">忽略此参数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3499">This parameter is ignored.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3500">有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3500">For a description of this member, see <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3501">如果当前字符串的值为 <see langword="true" />，则为 <see cref="F:System.Boolean.TrueString" />；如果当前字符串的值为 <see langword="false" />，则为 <see cref="F:System.Boolean.FalseString" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3501"><see langword="true" /> if the value of the current string is <see cref="F:System.Boolean.TrueString" />; <see langword="false" /> if the value of the current string is <see cref="F:System.Boolean.FalseString" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3502">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3502">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3cd3e-3503">它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3503">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="3cd3e-3504">建议的替代方法是调用 <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3504">The recommended alternative is to call the <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="3cd3e-3505">当前字符串的值不为 <see cref="F:System.Boolean.TrueString" /> 或 <see cref="F:System.Boolean.FalseString" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3505">The value of the current string is not <see cref="F:System.Boolean.TrueString" /> or <see cref="F:System.Boolean.FalseString" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToByte : IFormatProvider -&gt; byte&#xA;override this.System.IConvertible.ToByte : IFormatProvider -&gt; byte" Usage="string.System.IConvertible.ToByte provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="3cd3e-3506">一个对象，提供区域性特定的格式设置信息。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3506">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3507">有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3507">For a description of this member, see <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3508">当前 <see cref="T:System.String" /> 对象的转换值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3508">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3509">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3509">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3cd3e-3510">它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3510">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="3cd3e-3511">建议的替代方法是调用 <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3511">The recommended alternative is to call the <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="3cd3e-3512">无法分析当前 <see cref="T:System.String" /> 对象的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3512">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="3cd3e-3513">当前 <see cref="T:System.String" /> 对象的值是一个大于 <see cref="F:System.Byte.MaxValue" /> 或小于 <see cref="F:System.Byte.MinValue" /> 的数字。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3513">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.Byte.MaxValue" /> or less than <see cref="F:System.Byte.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToChar : IFormatProvider -&gt; char&#xA;override this.System.IConvertible.ToChar : IFormatProvider -&gt; char" Usage="string.System.IConvertible.ToChar provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="3cd3e-3514">一个对象，提供区域性特定的格式设置信息。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3514">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3515">有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3515">For a description of this member, see <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3516">当前 <see cref="T:System.String" /> 对象中索引 0 处的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3516">The character at index 0 in the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3517">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3517">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3cd3e-3518">它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3518">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="3cd3e-3519">建议的替代方法是调用 <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3519">The recommended alternative is to call the <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDateTime : IFormatProvider -&gt; DateTime&#xA;override this.System.IConvertible.ToDateTime : IFormatProvider -&gt; DateTime" Usage="string.System.IConvertible.ToDateTime provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="3cd3e-3520">一个对象，提供区域性特定的格式设置信息。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3520">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3521">有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3521">For a description of this member, see <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3522">当前 <see cref="T:System.String" /> 对象的转换值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3522">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3523">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3523">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3cd3e-3524">它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3524">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="3cd3e-3525">建议的替代方法是调用 <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3525">The recommended alternative is to call the <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDecimal : IFormatProvider -&gt; decimal&#xA;override this.System.IConvertible.ToDecimal : IFormatProvider -&gt; decimal" Usage="string.System.IConvertible.ToDecimal provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="3cd3e-3526">一个对象，提供区域性特定的格式设置信息。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3526">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3527">有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3527">For a description of this member, see <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3528">当前 <see cref="T:System.String" /> 对象的转换值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3528">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3529">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3529">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3cd3e-3530">它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3530">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="3cd3e-3531">建议的替代方法是调用 <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3531">The recommended alternative is to call the <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="3cd3e-3532">无法分析当前 <see cref="T:System.String" /> 对象的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3532">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="3cd3e-3533">当前 <see cref="T:System.String" /> 对象的值是一个小于 <see cref="F:System.Decimal.MinValue" /> 或大于 <see cref="F:System.Decimal.MaxValue" /> 的数字。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3533">The value of the current <see cref="T:System.String" /> object is a number less than <see cref="F:System.Decimal.MinValue" /> or than <see cref="F:System.Decimal.MaxValue" /> greater.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDouble : IFormatProvider -&gt; double&#xA;override this.System.IConvertible.ToDouble : IFormatProvider -&gt; double" Usage="string.System.IConvertible.ToDouble provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="3cd3e-3534">一个对象，提供区域性特定的格式设置信息。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3534">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3535">有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3535">For a description of this member, see <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3536">当前 <see cref="T:System.String" /> 对象的转换值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3536">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3537">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3537">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3cd3e-3538">它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3538">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="3cd3e-3539">建议的替代方法是调用 <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3539">The recommended alternative is to call the <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="3cd3e-3540">无法分析当前 <see cref="T:System.String" /> 对象的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3540">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="3cd3e-3541">当前 <see cref="T:System.String" /> 对象的值是一个小于 <see cref="F:System.Double.MinValue" /> 或大于 <see cref="F:System.Double.MaxValue" /> 的数字。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3541">The value of the current <see cref="T:System.String" /> object is a number less than <see cref="F:System.Double.MinValue" /> or greater than <see cref="F:System.Double.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt16 : IFormatProvider -&gt; int16&#xA;override this.System.IConvertible.ToInt16 : IFormatProvider -&gt; int16" Usage="string.System.IConvertible.ToInt16 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="3cd3e-3542">一个对象，提供区域性特定的格式设置信息。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3542">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3543">有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3543">For a description of this member, see <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3544">当前 <see cref="T:System.String" /> 对象的转换值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3544">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3545">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3545">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3cd3e-3546">它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3546">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="3cd3e-3547">建议的替代方法是调用 <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3547">The recommended alternative is to call the <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="3cd3e-3548">无法分析当前 <see cref="T:System.String" /> 对象的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3548">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="3cd3e-3549">当前 <see cref="T:System.String" /> 对象的值是一个大于 <see cref="F:System.Int16.MaxValue" /> 或小于 <see cref="F:System.Int16.MinValue" /> 的数字。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3549">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.Int16.MaxValue" /> or less than <see cref="F:System.Int16.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt32 : IFormatProvider -&gt; int&#xA;override this.System.IConvertible.ToInt32 : IFormatProvider -&gt; int" Usage="string.System.IConvertible.ToInt32 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="3cd3e-3550">一个对象，提供区域性特定的格式设置信息。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3550">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3551">有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3551">For a description of this member, see <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3552">当前 <see cref="T:System.String" /> 对象的转换值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3552">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3553">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3553">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3cd3e-3554">它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3554">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="3cd3e-3555">建议的替代方法是调用 <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3555">The recommended alternative is to call the <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt64 : IFormatProvider -&gt; int64&#xA;override this.System.IConvertible.ToInt64 : IFormatProvider -&gt; int64" Usage="string.System.IConvertible.ToInt64 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="3cd3e-3556">一个对象，提供区域性特定的格式设置信息。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3556">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3557">有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3557">For a description of this member, see <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3558">当前 <see cref="T:System.String" /> 对象的转换值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3558">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3559">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3559">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3cd3e-3560">它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3560">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="3cd3e-3561">建议的替代方法是调用 <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3561">The recommended alternative is to call the <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToSByte : IFormatProvider -&gt; sbyte&#xA;override this.System.IConvertible.ToSByte : IFormatProvider -&gt; sbyte" Usage="string.System.IConvertible.ToSByte provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="3cd3e-3562">一个对象，提供区域性特定的格式设置信息。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3562">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3563">有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3563">For a description of this member, see <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3564">当前 <see cref="T:System.String" /> 对象的转换值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3564">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3565">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3565">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3cd3e-3566">它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3566">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="3cd3e-3567">建议的替代方法是调用 <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3567">The recommended alternative is to call the <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="3cd3e-3568">无法分析当前 <see cref="T:System.String" /> 对象的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3568">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="3cd3e-3569">当前 <see cref="T:System.String" /> 对象的值是一个大于 <see cref="F:System.SByte.MaxValue" /> 或小于 <see cref="F:System.SByte.MinValue" /> 的数字。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3569">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.SByte.MaxValue" /> or less than <see cref="F:System.SByte.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToSingle : IFormatProvider -&gt; single&#xA;override this.System.IConvertible.ToSingle : IFormatProvider -&gt; single" Usage="string.System.IConvertible.ToSingle provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="3cd3e-3570">一个对象，提供区域性特定的格式设置信息。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3570">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3571">有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3571">For a description of this member, see <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3572">当前 <see cref="T:System.String" /> 对象的转换值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3572">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3573">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3573">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3cd3e-3574">它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3574">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="3cd3e-3575">建议的替代方法是调用 <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3575">The recommended alternative is to call the <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToString : IFormatProvider -&gt; string&#xA;override this.System.IConvertible.ToString : IFormatProvider -&gt; string" Usage="string.System.IConvertible.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="3cd3e-3576">一个提供区域性特定的格式设置信息的对象。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3576">An object that supplies culture-specific formatting information.</span></span>

<span data-ttu-id="3cd3e-3577">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3577">-or-</span></span>

<span data-ttu-id="3cd3e-3578">若为 <see langword="null" />，则使用当前区域性的格式设置约定。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3578"><see langword="null" /> to use the formatting conventions of the current culture.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3579">有关此成员的说明，请参见 <see cref="T:System.IConvertible.ToString(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3579">For a description of this member, see <see cref="T:System.IConvertible.ToString(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3580">与此实例的值等效的 <see cref="T:System.String" /> 实例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3580">A <see cref="T:System.String" /> instance equivalent to the value of this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3cd3e-3581">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3581">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3cd3e-3582">它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3582">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToType (type As Type, provider As IFormatProvider) As Object Implements IConvertible.ToType" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToType : Type * IFormatProvider -&gt; obj&#xA;override this.System.IConvertible.ToType : Type * IFormatProvider -&gt; obj" Usage="string.System.IConvertible.ToType (type, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="3cd3e-3583">返回对象的类型。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3583">The type of the returned object.</span></span></param>
        <param name="provider"><span data-ttu-id="3cd3e-3584">一个对象，提供区域性特定的格式设置信息。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3584">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3585">有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3585">For a description of this member, see <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3586">当前 <see cref="T:System.String" /> 对象的转换值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3586">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3587">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3587">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3cd3e-3588">它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3588">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="3cd3e-3589">建议的替代方法是调用 <xref:System.Convert.ChangeType%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3589">The recommended alternative is to call the <xref:System.Convert.ChangeType%2A> method.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-3590"><paramref name="type" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3590"><paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="3cd3e-3591">当前 <see cref="T:System.String" /> 对象的值不能转换为 <paramref name="type" /> 参数指定的类型。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3591">The value of the current <see cref="T:System.String" /> object cannot be converted to the type specified by the <paramref name="type" /> parameter.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt16 : IFormatProvider -&gt; uint16&#xA;override this.System.IConvertible.ToUInt16 : IFormatProvider -&gt; uint16" Usage="string.System.IConvertible.ToUInt16 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="3cd3e-3592">一个对象，提供区域性特定的格式设置信息。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3592">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3593">有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3593">For a description of this member, see <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3594">当前 <see cref="T:System.String" /> 对象的转换值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3594">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3595">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3595">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3cd3e-3596">它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3596">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="3cd3e-3597">建议的替代方法是调用 <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3597">The recommended alternative is to call the <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="3cd3e-3598">无法分析当前 <see cref="T:System.String" /> 对象的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3598">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="3cd3e-3599">当前 <see cref="T:System.String" /> 对象的值是一个大于 <see cref="F:System.UInt16.MaxValue" /> 或小于 <see cref="F:System.UInt16.MinValue" /> 的数字。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3599">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.UInt16.MaxValue" /> or less than <see cref="F:System.UInt16.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt32 : IFormatProvider -&gt; uint32&#xA;override this.System.IConvertible.ToUInt32 : IFormatProvider -&gt; uint32" Usage="string.System.IConvertible.ToUInt32 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="3cd3e-3600">一个对象，提供区域性特定的格式设置信息。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3600">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3601">有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3601">For a description of this member, see <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3602">当前 <see cref="T:System.String" /> 对象的转换值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3602">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3603">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3603">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3cd3e-3604">它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3604">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="3cd3e-3605">建议的替代方法是调用 <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3605">The recommended alternative is to call the <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="3cd3e-3606">无法分析当前 <see cref="T:System.String" /> 对象的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3606">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="3cd3e-3607">当前 <see cref="T:System.String" /> 对象的值是一个大于 <see cref="F:System.UInt32.MaxValue" /> 或小于 <see cref="F:System.UInt32.MinValue" /> 的数字。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3607">The value of the current <see cref="T:System.String" /> object is a number greater <see cref="F:System.UInt32.MaxValue" /> or less than <see cref="F:System.UInt32.MinValue" /></span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt64 : IFormatProvider -&gt; uint64&#xA;override this.System.IConvertible.ToUInt64 : IFormatProvider -&gt; uint64" Usage="string.System.IConvertible.ToUInt64 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="3cd3e-3608">一个对象，提供区域性特定的格式设置信息。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3608">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3609">有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3609">For a description of this member, see <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3610">当前 <see cref="T:System.String" /> 对象的转换值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3610">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3611">此成员是显式接口成员的实现。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3611">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3cd3e-3612">它只能在 <xref:System.String> 实例被强制转换为 <xref:System.IConvertible> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3612">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="3cd3e-3613">建议的替代方法是调用 <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3613">The recommended alternative is to call the <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToCharArray">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3cd3e-3614">将此实例中的字符复制到 Unicode 字符数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3614">Copies the characters in this instance to a Unicode character array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray();" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : unit -&gt; char[]" Usage="string.ToCharArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3cd3e-3615">将此实例中的字符复制到 Unicode 字符数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3615">Copies the characters in this instance to a Unicode character array.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3616">元素为此实例的各字符的 Unicode 字符数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3616">A Unicode character array whose elements are the individual characters of this instance.</span></span> <span data-ttu-id="3cd3e-3617">如果此实例是空字符串，则返回的数组为空且长度为零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3617">If this instance is an empty string, the returned array is empty and has a zero length.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3618">此方法将每个字符 (（即，每个对象都) 字符串中的每个对象）复制 <xref:System.Char> 到一个字符数组中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3618">This method copies each character (that is, each <xref:System.Char> object) in a string to a character array.</span></span> <span data-ttu-id="3cd3e-3619">复制的第一个字符位于返回的字符数组的索引零处;最后复制的字符位于索引 <xref:System.Array.Length%2A?displayProperty=nameWithType> -1 处。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3619">The first character copied is at index zero of the returned character array; the last character copied is at index <xref:System.Array.Length%2A?displayProperty=nameWithType> - 1.</span></span>

 <span data-ttu-id="3cd3e-3620">若要从字符数组中的字符创建字符串，请调用 <xref:System.String.%23ctor%28System.Char%5B%5D%29> 构造函数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3620">To create a string from the characters in a character array, call the <xref:System.String.%23ctor%28System.Char%5B%5D%29> constructor.</span></span>

 <span data-ttu-id="3cd3e-3621">若要创建包含字符串中已编码字符的字节数组，请实例化相应的 <xref:System.Text.Encoding> 对象并调用其 <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3621">To create a byte array that contains the encoded characters in a string, instantiate the appropriate <xref:System.Text.Encoding> object and call its <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3cd3e-3622">.NET 中可用的一些标准编码包括：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3622">Some of the standard encodings available in .NET include the following:</span></span>

|<span data-ttu-id="3cd3e-3623">编码</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3623">Encoding</span></span>|<span data-ttu-id="3cd3e-3624">对象</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3624">Object</span></span>|
|--------------|------------|
|<span data-ttu-id="3cd3e-3625">ASCII</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3625">ASCII</span></span>|<xref:System.Text.ASCIIEncoding>|
|<span data-ttu-id="3cd3e-3626">UTF-7</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3626">UTF-7</span></span>|<xref:System.Text.UTF7Encoding>|
|<span data-ttu-id="3cd3e-3627">UTF-8</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3627">UTF-8</span></span>|<xref:System.Text.UTF8Encoding>|
|<span data-ttu-id="3cd3e-3628">UTF-16</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3628">UTF-16</span></span>|<xref:System.Text.UnicodeEncoding>|
|<span data-ttu-id="3cd3e-3629">UTF-32</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3629">UTF-32</span></span>|<xref:System.Text.UTF32Encoding>|

 <span data-ttu-id="3cd3e-3630">有关详细信息，请参阅 [.net 中的字符编码](/dotnet/standard/base-types/character-encoding)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3630">For more information, see [Character Encoding in .NET](/dotnet/standard/base-types/character-encoding).</span></span>



## Examples
 <span data-ttu-id="3cd3e-3631">下面的示例调用 <xref:System.String.ToCharArray%2A> 方法将字符串中的字符提取到字符数组中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3631">The following example calls the <xref:System.String.ToCharArray%2A> method to extract the characters in a string to a character array.</span></span> <span data-ttu-id="3cd3e-3632">然后，它显示数组中的原始字符串和元素。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3632">It then displays the original string and the elements in the array.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb" id="Snippet1":::

 <span data-ttu-id="3cd3e-3633">下面的示例定义了一个字符串，其中包含在分隔字符串中用作分隔符的字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3633">The following example defines a string containing the characters that serve as delimiters in a delimited string.</span></span> <span data-ttu-id="3cd3e-3634">然后，它会调用 <xref:System.String.ToCharArray%2A> 方法来创建字符数组，该数组可传递给 <xref:System.String.Split%28System.Char%5B%5D%29> 方法，以将分隔的字符串分隔到其单独的子字符串中。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3634">It then calls the <xref:System.String.ToCharArray%2A> method to create a character array that can be passed to the <xref:System.String.Split%28System.Char%5B%5D%29> method to separate the delimited string into its individual substrings.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/StringSplit2/CPP/stringsplit2.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/stringsplit2.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit2.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray (startIndex As Integer, length As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : int * int -&gt; char[]" Usage="string.ToCharArray (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="3cd3e-3635">此实例内子字符串的起始位置。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3635">The starting position of a substring in this instance.</span></span></param>
        <param name="length"><span data-ttu-id="3cd3e-3636">此实例内子字符串的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3636">The length of the substring in this instance.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3637">将此实例中的指定子字符串内的字符复制到 Unicode 字符数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3637">Copies the characters in a specified substring in this instance to a Unicode character array.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3638">元素为此实例中从字符位置 <paramref name="length" /> 开始的 <paramref name="startIndex" /> 字符数的 Unicode 字符数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3638">A Unicode character array whose elements are the <paramref name="length" /> number of characters in this instance starting from character position <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3639">此方法将一部分字符串中的字符复制到字符数组。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3639">This method copies the characters in a portion of a string to a character array.</span></span> <span data-ttu-id="3cd3e-3640">若要从字符数组的字符范围中创建字符串，请调用  <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 构造函数。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3640">To create a string from a range of characters in a character array, call the  <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor.</span></span>

 <span data-ttu-id="3cd3e-3641">`startIndex`参数是从零开始的。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3641">The `startIndex` parameter is zero-based.</span></span> <span data-ttu-id="3cd3e-3642">也就是说，字符串实例中第一个字符的索引为零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3642">That is, the index of the first character in the string instance is zero.</span></span>

 <span data-ttu-id="3cd3e-3643">如果 `length` 为零，则返回的数组为空且长度为零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3643">If `length` is zero, the returned array is empty and has a zero length.</span></span> <span data-ttu-id="3cd3e-3644">如果此实例为 `null` 或空字符串 ( "" ) ，则返回的数组为空且长度为零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3644">If this instance is `null` or an empty string (""), the returned array is empty and has a zero length.</span></span>

 <span data-ttu-id="3cd3e-3645">若要创建包含字符串的一部分中编码字符的字节数组，请实例化相应的 <xref:System.Text.Encoding> 对象并调用其 <xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3645">To create a byte array that contains the encoded characters in a portion of a string, instantiate the appropriate <xref:System.Text.Encoding> object and call its <xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="3cd3e-3646">.NET 中可用的一些标准编码包括：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3646">Some of the standard encodings available in .NET include:</span></span>

|<span data-ttu-id="3cd3e-3647">编码</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3647">Encoding</span></span>|<span data-ttu-id="3cd3e-3648">对象</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3648">Object</span></span>|
|--------------|------------|
|<span data-ttu-id="3cd3e-3649">ASCII</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3649">ASCII</span></span>|<xref:System.Text.ASCIIEncoding>|
|<span data-ttu-id="3cd3e-3650">UTF-7</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3650">UTF-7</span></span>|<xref:System.Text.UTF7Encoding>|
|<span data-ttu-id="3cd3e-3651">UTF-8</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3651">UTF-8</span></span>|<xref:System.Text.UTF8Encoding>|
|<span data-ttu-id="3cd3e-3652">UTF-16</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3652">UTF-16</span></span>|<xref:System.Text.UnicodeEncoding>|
|<span data-ttu-id="3cd3e-3653">UTF-32</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3653">UTF-32</span></span>|<xref:System.Text.UTF32Encoding>|

 <span data-ttu-id="3cd3e-3654">有关详细信息，请参阅 [.net 中的字符编码](/dotnet/standard/base-types/character-encoding)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3654">For more information, see [Character Encoding in .NET](/dotnet/standard/base-types/character-encoding).</span></span>



## Examples
 <span data-ttu-id="3cd3e-3655">下面的示例将字符串中的子字符串转换为字符数组，然后枚举并显示该数组的元素。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3655">The following example converts a substring within a string to an array of characters, then enumerates and displays the elements of the array.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3cd3e-3656"><paramref name="startIndex" /> 或 <paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3656"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span>

<span data-ttu-id="3cd3e-3657">- 或 -</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3657">-or-</span></span>

 <span data-ttu-id="3cd3e-3658"><paramref name="startIndex" /> 加 <paramref name="length" /> 大于此实例的长度。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3658"><paramref name="startIndex" /> plus <paramref name="length" /> is greater than the length of this instance.</span></span></exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3cd3e-3659">返回此字符串转换为小写形式的副本。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3659">Returns a copy of this string converted to lowercase.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower();" />
      <MemberSignature Language="F#" Value="member this.ToLower : unit -&gt; string" Usage="string.ToLower " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3cd3e-3660">返回此字符串转换为小写形式的副本。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3660">Returns a copy of this string converted to lowercase.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3661">一个小写字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3661">A string in lowercase.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3662">此方法将考虑当前区域性的大小写规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3662">This method takes into account the casing rules of the current culture.</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-3663">此方法不会修改当前实例的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3663">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="3cd3e-3664">相反，它会返回一个新字符串，其中当前实例中的所有字符都转换为小写。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3664">Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</span></span>

## <a name="security-considerations"></a><span data-ttu-id="3cd3e-3665">安全注意事项</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3665">Security Considerations</span></span>
 <span data-ttu-id="3cd3e-3666">通过调用方法生成的大小写操作将 <xref:System.String.ToLower> 使用当前区域性的大小写约定。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3666">The casing operation that results from calling the <xref:System.String.ToLower> method takes the casing conventions of the current culture into account.</span></span> <span data-ttu-id="3cd3e-3667">如果需要操作系统标识符的小写或大写版本，如文件名、命名管道或注册表项，请使用 <xref:System.String.ToLowerInvariant%2A> 或 <xref:System.String.ToUpperInvariant%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3667">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> methods.</span></span> <span data-ttu-id="3cd3e-3668">与方法不同，每个区域性 (生成相同的结果 <xref:System.String.ToLower> ，) 并更有效地执行。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3668">This produces the same result in every culture (unlike the <xref:System.String.ToLower> method) and performs more efficiently.</span></span>



## Examples
 <span data-ttu-id="3cd3e-3669">下面的示例将几个大小写混合的字符串转换为小写。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3669">The following example converts several mixed case strings to lowercase.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-3670">如 [使用字符串的最佳做法](/dotnet/standard/base-types/best-practices-strings)中所述，建议你避免调用替换默认值的字符串大小写方法，而是调用需要显式指定参数的方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3670">As explained in [Best Practices for Using Strings](/dotnet/standard/base-types/best-practices-strings), we recommend that you avoid calling string casing methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="3cd3e-3671">若要使用当前区域性的大小写约定将字符转换为小写，请使用 <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> 其参数的值调用方法重载 <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> <paramref name="culture" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3671">To convert a character to lowercase by using the casing conventions of the current culture, call the <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> method overload with a value of <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> for its <paramref name="culture" /> parameter.</span></span></para></block>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo? culture);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToLower : System.Globalization.CultureInfo -&gt; string" Usage="string.ToLower culture" />
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="culture"><span data-ttu-id="3cd3e-3672">一个对象，用于提供区域性特定的大小写规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3672">An object that supplies culture-specific casing rules.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3673">根据指定区域性的大小写规则返回此字符串转换为小写形式的副本。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3673">Returns a copy of this string converted to lowercase, using the casing rules of the specified culture.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3674">当前字符串的等效小写形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3674">The lowercase equivalent of the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3675">参数指定的区域性的大小写规则 `culture` 确定了字符串大小写的更改方式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3675">The casing rules of the culture specified by the `culture` parameter determine the way the case of the string is changed.</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-3676">此方法不会修改当前实例的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3676">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="3cd3e-3677">相反，它会返回一个新字符串，其中当前实例中的所有字符都转换为小写。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3677">Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</span></span>

## <a name="security-considerations"></a><span data-ttu-id="3cd3e-3678">安全注意事项</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3678">Security Considerations</span></span>
 <span data-ttu-id="3cd3e-3679">如果将方法传递 <xref:System.String.ToLower%28System.Globalization.CultureInfo%29> <xref:System.Globalization.CultureInfo> 到之外的对象 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> ，则大小写操作将考虑特定于区域性的规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3679">If you pass the <xref:System.String.ToLower%28System.Globalization.CultureInfo%29> method a <xref:System.Globalization.CultureInfo> object other than <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, the casing operation will take culture-specific rules into account.</span></span> <span data-ttu-id="3cd3e-3680">如果需要操作系统标识符的小写或大写版本，如文件名、命名管道或注册表项，请使用 <xref:System.String.ToLowerInvariant%2A> 或 <xref:System.String.ToUpperInvariant%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3680">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="3cd3e-3681">这会在每个区域性中产生相同的结果并更有效地执行。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3681">This produces the same result in every culture and performs more efficiently.</span></span>



## Examples
 <span data-ttu-id="3cd3e-3682">下面的示例使用 English-United 状态和 Turkish-Turkey 区域性将大写字符的两个字符串转换为小写字符，然后比较小写字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3682">The following example converts two strings of uppercase characters to lowercase characters using the English-United States and Turkish-Turkey cultures, then compares the lowercase strings.</span></span> <span data-ttu-id="3cd3e-3683">大写字符串完全相同，只是对于一个字符串中的每个 Unicode 大写字母 I 的每个匹配项，另一个字符串包含上面带点的拉丁文大写字母 I。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3683">The uppercase strings are identical except that for each occurrence of the Unicode LATIN CAPITAL LETTER I in one string, the other string contains LATIN CAPITAL LETTER I WITH DOT ABOVE.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-3684"><paramref name="culture" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3684"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.ToUpper" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLowerInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLowerInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToLowerInvariant : unit -&gt; string" Usage="string.ToLowerInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3cd3e-3685">返回此 <see cref="T:System.String" /> 对象的转换为小写形式的副本，返回时使用固定区域性的大小写规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3685">Returns a copy of this <see cref="T:System.String" /> object converted to lowercase using the casing rules of the invariant culture.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3686">当前字符串的等效小写形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3686">The lowercase equivalent of the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3687">固定区域性表示不区分区域性的区域性。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3687">The invariant culture represents a culture that is culture-insensitive.</span></span> <span data-ttu-id="3cd3e-3688">它与英语相关联，而不是与特定国家或地区相关联。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3688">It is associated with the English language but not with a specific country or region.</span></span> <span data-ttu-id="3cd3e-3689">有关更多信息，请参见 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3689">For more information, see the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span>

 <span data-ttu-id="3cd3e-3690">如果你的应用程序依赖于以可预测方式（不受当前区域性影响）更改的字符串，请使用 <xref:System.String.ToLowerInvariant%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3690">If your application depends on the case of a string changing in a predictable way that is unaffected by the current culture, use the <xref:System.String.ToLowerInvariant%2A> method.</span></span> <span data-ttu-id="3cd3e-3691"><xref:System.String.ToLowerInvariant%2A>方法等效于 `ToLower(CultureInfo.InvariantCulture)` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3691">The <xref:System.String.ToLowerInvariant%2A> method is equivalent to `ToLower(CultureInfo.InvariantCulture)`.</span></span> <span data-ttu-id="3cd3e-3692">如果在用户界面控件中必须按可预测顺序显示字符串集合，则建议使用方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3692">The method is recommended when a collection of strings must appear in a predictable order in a user interface control.</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-3693">此方法不会修改当前实例的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3693">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="3cd3e-3694">相反，它会返回一个新字符串，其中当前实例中的所有字符都转换为小写。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3694">Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</span></span>

## <a name="security-considerations"></a><span data-ttu-id="3cd3e-3695">安全注意事项</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3695">Security Considerations</span></span>
 <span data-ttu-id="3cd3e-3696">如果需要操作系统标识符的小写或大写版本，如文件名、命名管道或注册表项，请使用 <xref:System.String.ToLowerInvariant%2A> 或 <xref:System.String.ToUpperInvariant%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3696">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> methods.</span></span>



## Examples
 <span data-ttu-id="3cd3e-3697">下面的示例定义了一个字符串数组，其中包含多种语言的单个单词。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3697">The following example defines a string array that contains a single word in a number of languages.</span></span> <span data-ttu-id="3cd3e-3698"><xref:System.String.ToLowerInvariant%2A>方法用于使用每个单词的不区分大小写的版本填充并行数组的元素。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3698">The <xref:System.String.ToLowerInvariant%2A> method is used to populate the elements of a parallel array with the case-insensitive version of each word.</span></span> <span data-ttu-id="3cd3e-3699"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>方法用于根据小写数组中元素的顺序对区分大小写的数组进行排序，以确保元素按与语言无关的顺序显示。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3699">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> method is used to sort the case-sensitive array based on the order of elements in the lowercase array to ensure that elements appear in the same order regardless of language.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpperInvariant" />
        <altmember cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3cd3e-3700">将此实例的值转换为 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3700">Converts the value of this instance to a <see cref="T:System.String" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="string.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3cd3e-3701">返回 <see cref="T:System.String" /> 的此实例；不执行实际转换。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3701">Returns this instance of <see cref="T:System.String" />; no actual conversion is performed.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3702">当前的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3702">The current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3703">由于此方法只是返回未更改的当前字符串，因此不需要直接调用它。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3703">Because this method simply returns the current string unchanged, there is no need to call it directly.</span></span> <span data-ttu-id="3cd3e-3704">它通常在复合格式设置操作中进行隐式调用，如示例所示。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3704">It is usually called implicitly in a composite formatting operation, as the example shows.</span></span>



## Examples
 <span data-ttu-id="3cd3e-3705">下面的示例演示 <xref:System.String.ToString%2A> 方法。请注意，该示例不显式调用 <xref:System.String.ToString%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3705">The following example demonstrates the <xref:System.String.ToString%2A> method.Note that the example does not explicitly call the <xref:System.String.ToString%2A> method.</span></span> <span data-ttu-id="3cd3e-3706">相反，该方法由 [复合格式设置](/dotnet/standard/base-types/composite-formatting) 功能隐式调用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3706">Instead, the method is called implicitly by the [composite formatting](/dotnet/standard/base-types/composite-formatting) feature.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Clone" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider? provider);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="string.ToString provider" />
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="3cd3e-3707">（保留）一个对象，用于提供区域性特定的格式设置信息。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3707">(Reserved) An object that supplies culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3708">返回 <see cref="T:System.String" /> 的此实例；不执行实际转换。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3708">Returns this instance of <see cref="T:System.String" />; no actual conversion is performed.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3709">当前的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3709">The current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3710">`provider` 保留，并且当前不参与此操作。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3710">`provider` is reserved, and does not currently participate in this operation.</span></span>

 <span data-ttu-id="3cd3e-3711">由于此方法只是返回未更改的当前字符串，因此不需要直接调用它。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3711">Because this method simply returns the current string unchanged, there is no need to call it directly.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3cd3e-3712">返回此字符串转换为大写形式的副本。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3712">Returns a copy of this string converted to uppercase.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper();" />
      <MemberSignature Language="F#" Value="member this.ToUpper : unit -&gt; string" Usage="string.ToUpper " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3cd3e-3713">返回此字符串转换为大写形式的副本。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3713">Returns a copy of this string converted to uppercase.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3714">当前字符串的大写形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3714">The uppercase equivalent of the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3715">此方法使用当前区域性的大小写规则将当前实例中的每个字符转换为其大写等效项。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3715">This method uses the casing rules of the current culture to convert each character in the current instance to its uppercase equivalent.</span></span> <span data-ttu-id="3cd3e-3716">如果某个字符没有大写等效项，则在返回的字符串中包含不变的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3716">If a character does not have an uppercase equivalent, it is included unchanged in the returned string.</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-3717">此方法不会修改当前实例的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3717">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="3cd3e-3718">相反，它会返回一个新字符串，其中当前实例中的所有字符都转换为大写形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3718">Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</span></span>

 <span data-ttu-id="3cd3e-3719"><xref:System.String.ToUpper%2A>方法通常用于将字符串转换为大写，以便可以在不区分大小写的比较中使用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3719">The <xref:System.String.ToUpper%2A> method is often used to convert a string to uppercase so that it can be used in a case-insensitive comparison.</span></span> <span data-ttu-id="3cd3e-3720">要执行不区分大小写的比较，更好的方法是调用具有参数的参数的字符串比较方法，此 <xref:System.StringComparison> 参数的值为 <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> 区分区域性、不区分大小写的比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3720">A better method to perform case-insensitive comparison is to call a string comparison method that has a <xref:System.StringComparison> parameter whose value you set to <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> for a culture-sensitive, case-insensitive comparison.</span></span>

## <a name="security-considerations"></a><span data-ttu-id="3cd3e-3721">安全注意事项</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3721">Security Considerations</span></span>
 <span data-ttu-id="3cd3e-3722">通过调用方法生成的大小写操作将 <xref:System.String.ToUpper> 使用当前区域性的大小写约定。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3722">The casing operation that results from calling the <xref:System.String.ToUpper> method takes the casing conventions of the current culture into account.</span></span> <span data-ttu-id="3cd3e-3723">如果需要操作系统标识符的小写或大写版本，如文件名、命名管道或注册表项，请使用 <xref:System.String.ToLowerInvariant%2A> 或 <xref:System.String.ToUpperInvariant%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3723">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="3cd3e-3724">与方法不同，每个区域性 (生成相同的结果 <xref:System.String.ToUpper> ，) 并更有效地执行。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3724">This produces the same result in every culture (unlike the <xref:System.String.ToUpper> method) and performs more efficiently.</span></span>



## Examples
 <span data-ttu-id="3cd3e-3725">下面的示例调用 <xref:System.String.ToUpper%2A> 方法来转换包含基本拉丁语、拉丁语-1 补充和拉丁语扩展字符集中的每个字符的一系列单字符字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3725">The following example calls the <xref:System.String.ToUpper%2A> method to convert a series of one-character strings that contain each character in the Basic Latin, Latin-1 Supplement, and Latin Extended-A character sets.</span></span> <span data-ttu-id="3cd3e-3726">然后，它会显示其大写字符与小写字符不同的每个字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3726">It then displays each string whose uppercase character is different from its lowercase character.</span></span>

 [!code-cpp[System.String.ToUpper#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]

 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-3727">如 [使用字符串的最佳做法](/dotnet/standard/base-types/best-practices-strings)中所述，建议你避免调用替换默认值的字符串大小写方法，而是调用需要显式指定参数的方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3727">As explained in [Best Practices for Using Strings](/dotnet/standard/base-types/best-practices-strings), we recommend that you avoid calling string casing methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="3cd3e-3728">若要使用当前区域性的大小写约定将字符串转换为大写，请使用的 <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> 参数的值调用方法重载 <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> <paramref name="culture" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3728">To convert a string to uppercase by using the casing conventions of the current culture, call the <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> method overload with a value of <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> for its <paramref name="culture" /> parameter.</span></span></para></block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo? culture);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToUpper : System.Globalization.CultureInfo -&gt; string" Usage="string.ToUpper culture" />
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="culture"><span data-ttu-id="3cd3e-3729">一个对象，用于提供区域性特定的大小写规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3729">An object that supplies culture-specific casing rules.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3730">根据指定区域性的大小写规则返回此字符串转换为大写形式的副本。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3730">Returns a copy of this string converted to uppercase, using the casing rules of the specified culture.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3731">当前字符串的大写形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3731">The uppercase equivalent of the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3732">由参数指定的区域性的大小写规则 `culture` 确定字符串大小写的更改方式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3732">The casing rules of the culture specified by the `culture` parameter determine the way the case of a string is changed.</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-3733">此方法不会修改当前实例的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3733">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="3cd3e-3734">相反，它会返回一个新字符串，其中当前实例中的所有字符都转换为大写形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3734">Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</span></span>

## <a name="security-considerations"></a><span data-ttu-id="3cd3e-3735">安全注意事项</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3735">Security Considerations</span></span>
 <span data-ttu-id="3cd3e-3736">如果将方法传递 <xref:System.String.ToUpper%28System.Globalization.CultureInfo%29> <xref:System.Globalization.CultureInfo> 到之外的对象 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> ，则大小写操作将考虑特定于区域性的规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3736">If you pass the <xref:System.String.ToUpper%28System.Globalization.CultureInfo%29> method a <xref:System.Globalization.CultureInfo> object other than <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, the casing operation will take culture-specific rules into account.</span></span> <span data-ttu-id="3cd3e-3737">如果需要操作系统标识符的小写或大写版本，如文件名、命名管道或注册表项，请使用 <xref:System.String.ToLowerInvariant%2A> 或 <xref:System.String.ToUpperInvariant%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3737">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="3cd3e-3738">这会在每个区域性中产生相同的结果并更有效地执行。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3738">This produces the same result in every culture and performs more efficiently.</span></span>



## Examples
 <span data-ttu-id="3cd3e-3739">下面的示例使用 English-United 状态和 Turkish-Turkey 区域性将小写字符字符串转换为大写字符的两个字符串，然后对大写字符串进行比较。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3739">The following example converts a string of lowercase characters to two strings of uppercase characters using the English-United States and Turkish-Turkey cultures, then compares the uppercase strings.</span></span> <span data-ttu-id="3cd3e-3740">大写字符串完全相同，只是对于一个字符串中的每个 Unicode 大写字母 I 的每个匹配项，另一个字符串包含上面带点的拉丁文大写字母 I。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3740">The uppercase strings are identical except that for each occurrence of the Unicode LATIN CAPITAL LETTER I in one string, the other string contains LATIN CAPITAL LETTER I WITH DOT ABOVE.</span></span>

 [!code-csharp[string.toupper1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3cd3e-3741"><paramref name="culture" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3741"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpperInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpperInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToUpperInvariant : unit -&gt; string" Usage="string.ToUpperInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3cd3e-3742">返回此 <see cref="T:System.String" /> 对象的转换为大写形式的副本，返回时使用固定区域性的大小写规则。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3742">Returns a copy of this <see cref="T:System.String" /> object converted to uppercase using the casing rules of the invariant culture.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3743">当前字符串的大写形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3743">The uppercase equivalent of the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="3cd3e-3744">固定区域性表示不区分区域性的区域性。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3744">The invariant culture represents a culture that is culture-insensitive.</span></span> <span data-ttu-id="3cd3e-3745">它与英语相关联，而不是与特定国家或地区相关联。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3745">It is associated with the English language but not with a specific country or region.</span></span> <span data-ttu-id="3cd3e-3746">有关更多信息，请参见 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3746">For more information, see the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span>

 <span data-ttu-id="3cd3e-3747">如果你的应用程序依赖于以可预测方式（不受当前区域性影响）更改的字符串，请使用 <xref:System.String.ToUpperInvariant%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3747">If your application depends on the case of a string changing in a predictable way that is unaffected by the current culture, use the <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="3cd3e-3748"><xref:System.String.ToUpperInvariant%2A>方法等效于 `ToUpper(CultureInfo.InvariantCulture)` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3748">The <xref:System.String.ToUpperInvariant%2A> method is equivalent to `ToUpper(CultureInfo.InvariantCulture)`.</span></span> <span data-ttu-id="3cd3e-3749">如果在用户界面控件中必须按可预测顺序显示字符串集合，则建议使用方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3749">The method is recommended when a collection of strings must appear in a predictable order in a user interface control.</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-3750">此方法不会修改当前实例的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3750">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="3cd3e-3751">相反，它会返回一个新字符串，其中当前实例中的所有字符都转换为大写形式。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3751">Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</span></span>

## <a name="security-considerations"></a><span data-ttu-id="3cd3e-3752">安全注意事项</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3752">Security Considerations</span></span>
 <span data-ttu-id="3cd3e-3753">如果需要操作系统标识符的小写或大写版本，如文件名、命名管道或注册表项，请使用 <xref:System.String.ToLowerInvariant%2A> 或 <xref:System.String.ToUpperInvariant%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3753">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> methods.</span></span>



## Examples
 <span data-ttu-id="3cd3e-3754">下面的示例定义了一个字符串数组，其中包含多种语言的单个单词。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3754">The following example defines a string array that contains a single word in a number of languages.</span></span> <span data-ttu-id="3cd3e-3755"><xref:System.String.ToUpperInvariant%2A>方法用于使用每个单词的不区分大小写的版本填充并行数组的元素。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3755">The <xref:System.String.ToUpperInvariant%2A> method is used to populate the elements of a parallel array with the case-insensitive version of each word.</span></span> <span data-ttu-id="3cd3e-3756"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>方法用于根据大写数组中元素的顺序对区分大小写的数组进行排序，以确保元素按与语言无关的顺序显示。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3756">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> method is used to sort the case-sensitive array based on the order of elements in the uppercase array to ensure that elements appear in the same order regardless of language.</span></span>

 [!code-csharp[System.String.ToUpperInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Trim">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3cd3e-3757">返回一个新字符串，它相当于从当前字符串中删除了一组指定字符的所有前导匹配项和尾随匹配项。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3757">Returns a new string in which all leading and trailing occurrences of a set of specified characters from the current string are removed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim();" />
      <MemberSignature Language="F#" Value="member this.Trim : unit -&gt; string" Usage="string.Trim " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3cd3e-3758">从当前字符串删除所有前导空白字符和尾随空白字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3758">Removes all leading and trailing white-space characters from the current string.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3759">从当前字符串的开头和结尾删除所有空白字符后剩余的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3759">The string that remains after all white-space characters are removed from the start and end of the current string.</span></span> <span data-ttu-id="3cd3e-3760">如果从当前实例无法删除字符，此方法返回未更改的当前实例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3760">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3cd3e-3761">`Trim`方法从当前字符串中删除所有前导和尾随空白字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3761">The `Trim` method removes from the current string all leading and trailing white-space characters.</span></span> <span data-ttu-id="3cd3e-3762">遇到非空白字符时，每个前导和尾随修整操作都会停止。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3762">Each leading and trailing trim operation stops when a non-white-space character is encountered.</span></span> <span data-ttu-id="3cd3e-3763">例如，如果当前字符串为 "abc xyz"，则该 `Trim` 方法返回 "abc xyz"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3763">For example, if the current string is "   abc   xyz    ", the `Trim` method returns "abc   xyz".</span></span> <span data-ttu-id="3cd3e-3764">若要删除字符串中的单词之间的空白字符，请使用 [.Net 正则表达式](/dotnet/standard/base-types/regular-expressions)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3764">To remove white-space characters between words in a string, use [.NET Regular Expressions](/dotnet/standard/base-types/regular-expressions).</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-3765">如果该 `Trim` 方法从当前实例中移除所有字符，则此方法不会修改当前实例的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3765">If the `Trim` method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="3cd3e-3766">相反，它会返回一个新字符串，其中将删除当前实例中找到的所有前导和尾随空格字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3766">Instead, it returns a new string in which all leading and trailing white space characters found in the current instance are removed.</span></span>

<span data-ttu-id="3cd3e-3767">如果当前字符串等于 <xref:System.String.Empty?displayProperty=nameWithtype> 或当前实例中的所有字符都包含空白字符，则该方法将返回 <xref:System.String.Empty?displayProperty=nameWithtype> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3767">If the current string equals <xref:System.String.Empty?displayProperty=nameWithtype> or all the characters in the current instance consist of white-space characters, the method returns <xref:System.String.Empty?displayProperty=nameWithtype>.</span></span>

<span data-ttu-id="3cd3e-3768">空白字符由 Unicode 标准定义。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3768">White-space characters are defined by the Unicode standard.</span></span> <span data-ttu-id="3cd3e-3769">`Trim`方法在将生成返回值的所有前导和尾随字符 `true` 传递给方法时，删除这些字符 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3769">The `Trim` method removes any leading and trailing characters that produce a return value of `true` when they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>

## Examples

<span data-ttu-id="3cd3e-3770">下面的示例使用方法在连接 <xref:System.String.Trim?displayProperty=nameWithType> 之前从用户输入的字符串中删除任何多余的空格。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3770">The following example uses the <xref:System.String.Trim?displayProperty=nameWithType> method to remove any extra white space from strings entered by the user before concatenating them.</span></span>

[!code-cpp[System.String.Trim#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
[!code-csharp[System.String.Trim#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
[!code-vb[System.String.Trim#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]

          ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-3771">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和早期版本维护此方法修整的空白字符的内部列表。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3771">The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintain an internal list of white-space characters that this method trims.</span></span> <span data-ttu-id="3cd3e-3772">从开始 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] ，方法会剪裁所有 Unicode 空白字符， (也就是说，在将 <see langword="true" /> 其传递到方法) 时生成返回值的字符 <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3772">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method).</span></span> <span data-ttu-id="3cd3e-3773">由于此更改，和更 <see cref="M:System.String.Trim" /> 早版本中的方法将 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 删除两个字符，零宽度空间 (u + 200B) 和零宽度无间断空格 (U + FEFF) ，则 <see cref="M:System.String.Trim" /> [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 和更高版本中的方法不会删除。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3773">Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]and later versions does not remove.</span></span> <span data-ttu-id="3cd3e-3774">此外， <see cref="M:System.String.Trim" /> [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 和更早版本中的方法不会剪裁三个 Unicode 空白字符：蒙古语元音分隔符 (u + 180E) 、窄的无中断空格 (u + 202F) 和中等数学空间 (u + 205F) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3774">In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</span></span></para></block>
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.Trim : char -&gt; string" Usage="string.Trim trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="trimChar"><span data-ttu-id="3cd3e-3775">要删除的 Unicode 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3775">A Unicode character to remove.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3776">从当前字符串删除字符的所有前导实例和尾随实例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3776">Removes all leading and trailing instances of a character from the current string.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3777">从当前字符串的开头和结尾删除 <paramref name="trimChar" /> 字符的所有实例后剩余的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3777">The string that remains after all instances of the <paramref name="trimChar" /> character are removed from the start and end of the current string.</span></span> <span data-ttu-id="3cd3e-3778">如果从当前实例无法删除字符，此方法返回未更改的当前实例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3778">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3cd3e-3779">`Trim(System.Char)`方法从当前字符串中删除该字符的所有前导和尾随实例 `trimChar` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3779">The `Trim(System.Char)` method removes from the current string all leading and trailing instances of the `trimChar` character.</span></span> <span data-ttu-id="3cd3e-3780">当遇到与不同的字符时，每个前导和尾随修整操作都会停止 `trimChar` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3780">Each leading and trailing trim operation stops when a character different from `trimChar` is encountered.</span></span> <span data-ttu-id="3cd3e-3781">例如，如果 `trimChar` 为， `-` 并且当前字符串为 "---abc---xyz----"，则该 `Trim(System.Char)` 方法返回 "abc---xyz"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3781">For example, if `trimChar` is `-` and the current string is "---abc---xyz----", the `Trim(System.Char)` method returns "abc---xyz".</span></span> <span data-ttu-id="3cd3e-3782">若要删除字符串中的单词之间的字符，请使用 [.Net 正则表达式](/dotnet/standard/base-types/regular-expressions)。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3782">To remove characters between words in a string, use [.NET Regular Expressions](/dotnet/standard/base-types/regular-expressions).</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-3783">如果该 `Trim(System.Char)` 方法从当前实例中移除所有字符，则此方法不会修改当前实例的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3783">If the `Trim(System.Char)` method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="3cd3e-3784">相反，它会返回一个新字符串，其中将删除在 `trimChar` 当前实例中找到的所有前导和尾随字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3784">Instead, it returns a new string in which all leading and trailing `trimChar` characters found in the current instance are removed.</span></span>

<span data-ttu-id="3cd3e-3785">如果当前字符串等于 <xref:System.String.Empty?displayProperty=nameWithtype> 或当前实例中的所有字符都包含 `trimChar` 字符，则该方法将返回 <xref:System.String.Empty?displayProperty=nameWithtype> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3785">If the current string equals <xref:System.String.Empty?displayProperty=nameWithtype> or all the characters in the current instance consist of `trimChar` characters, the method returns <xref:System.String.Empty?displayProperty=nameWithtype>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (params char[] trimChars);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.Trim : char[] -&gt; string" Usage="string.Trim trimChars" />
      <MemberSignature Language="C#" Value="public string Trim (params char[]? trimChars);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars"><span data-ttu-id="3cd3e-3786">要删除的 Unicode 字符的数组，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3786">An array of Unicode characters to remove, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3787">从当前字符串删除数组中指定的一组字符的所有前导匹配项和尾随匹配项。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3787">Removes all leading and trailing occurrences of a set of characters specified in an array from the current string.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3788">从当前字符串的开头移除所出现的所有 <paramref name="trimChars" /> 参数中的字符后剩余的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3788">The string that remains after all occurrences of the characters in the <paramref name="trimChars" /> parameter are removed from the start and end of the current string.</span></span> <span data-ttu-id="3cd3e-3789">如果 <paramref name="trimChars" /> 为 <see langword="null" /> 或空数组，则改为移除空白字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3789">If <paramref name="trimChars" /> is <see langword="null" /> or an empty array, white-space characters are removed instead.</span></span> <span data-ttu-id="3cd3e-3790">如果从当前实例无法删除字符，此方法返回未更改的当前实例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3790">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3cd3e-3791">`Trim(System.Char[])`方法从当前字符串中删除参数中的所有前导和尾随字符 `trimChars` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3791">The `Trim(System.Char[])` method removes from the current string all leading and trailing characters that are in the `trimChars` parameter.</span></span> <span data-ttu-id="3cd3e-3792">当遇到不在中的字符时，每个前导和尾随修整操作都会停止 `trimChars` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3792">Each leading and trailing trim operation stops when a character that is not in `trimChars` is encountered.</span></span> <span data-ttu-id="3cd3e-3793">例如，如果当前字符串为 "123abc456xyz789" 并且 `trimChars` 包含从 "1" 到 "9" 的数字，则该 `Trim(System.Char[])` 方法将返回 "abc456xyz"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3793">For example, if the current string is "123abc456xyz789" and `trimChars` contains the digits from "1" through "9", the `Trim(System.Char[])` method returns "abc456xyz".</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-3794">如果该 `Trim(System.Char[])` 方法从当前实例中移除所有字符，则此方法不会修改当前实例的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3794">If the `Trim(System.Char[])` method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="3cd3e-3795">相反，它会返回一个新字符串，其中将删除在 `trimChars` 当前实例中找到的所有前导和尾随字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3795">Instead, it returns a new string in which all leading and trailing `trimChars` characters found in the current instance are removed.</span></span>

<span data-ttu-id="3cd3e-3796">如果当前字符串等于 <xref:System.String.Empty?displayProperty=nameWithtype> 或当前实例中的所有字符都包含数组中的字符 `trimChars` ，则该方法将返回 <xref:System.String.Empty?displayProperty=nameWithtype> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3796">If the current string equals <xref:System.String.Empty?displayProperty=nameWithtype> or all the characters in the current instance consist of characters in the `trimChars` array, the method returns <xref:System.String.Empty?displayProperty=nameWithtype>.</span></span>

<span data-ttu-id="3cd3e-3797">如果 `trimChars` 为 `null` 或空数组，则此方法将删除在 `true` 将方法传递给方法时导致该方法返回的所有前导或尾随字符 <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3797">If `trimChars` is `null` or an empty array, this method removes any leading or trailing characters that result in the method returning `true` when they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>

## Examples

<span data-ttu-id="3cd3e-3798">下面的示例使用 `Trim(System.Char[])` 方法从字符串中删除空格、星号 ( \* ) 和撇号 ( ") 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3798">The following example uses the `Trim(System.Char[])` method to remove space, asterisk (\*), and apostrophe (') characters from a string.</span></span>

[!code-cpp[System.String.Trim#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
[!code-csharp-interactive[System.String.Trim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
[!code-vb[System.String.Trim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]

          ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-3799">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本维护一个内部空白字符列表，如果 <paramref name="trimChars" /> 为或空数组，此方法将修整此列表 <see langword="null" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3799">The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintains an internal list of white-space characters that this method trims if <paramref name="trimChars" /> is <see langword="null" /> or an empty array.</span></span> <span data-ttu-id="3cd3e-3800">从开始 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] ，如果 <paramref name="trimChars" /> 为 <see langword="null" /> 或空数组，该方法将剪裁所有 Unicode 空白字符， (也就是说，在将 <see langword="true" /> 其传递到方法) 时生成返回值的字符 <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3800">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], if <paramref name="trimChars" /> is <see langword="null" /> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method).</span></span> <span data-ttu-id="3cd3e-3801">由于此更改，和更 <see cref="M:System.String.Trim" /> 早版本中的方法将 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 删除两个字符，零宽度空间 (u + 200B) 和零宽度无间断空格 (U + FEFF) ，则 <see cref="M:System.String.Trim" /> [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 和更高版本中的方法不会删除。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3801">Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]and later versions does not remove.</span></span> <span data-ttu-id="3cd3e-3802">此外， <see cref="M:System.String.Trim" /> [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 和更早版本中的方法不会剪裁三个 Unicode 空白字符：蒙古语元音分隔符 (u + 180E) 、窄的无中断空格 (u + 202F) 和中等数学空间 (u + 205F) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3802">In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</span></span></para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd();" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : unit -&gt; string" Usage="string.TrimEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3cd3e-3803">从当前字符串删除所有尾随空白字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3803">Removes all the trailing white-space characters from the current string.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3804">从当前字符串的结尾删除所有空白字符后剩余的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3804">The string that remains after all white-space characters are removed from the end of the current string.</span></span> <span data-ttu-id="3cd3e-3805">如果从当前实例无法删除字符，此方法返回未更改的当前实例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3805">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3cd3e-3806">`TrimEnd`方法从当前字符串中删除所有尾随空格字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3806">The `TrimEnd` method removes from the current string all trailing white-space characters.</span></span> <span data-ttu-id="3cd3e-3807">当在字符串末尾遇到第一个非空白字符时，剪裁操作将停止。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3807">The trim operation stops when the first non white-space character is encountered at the end of the string.</span></span> <span data-ttu-id="3cd3e-3808">例如，如果当前字符串为 "abc xyz"，则该 `TrimEnd` 方法返回 "abc xyz"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3808">For example, if the current string is "   abc   xyz    ", the `TrimEnd` method returns "   abc   xyz".</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-3809">如果该 `TrimEnd` 方法从当前实例中移除所有字符，则此方法不会修改当前实例的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3809">If the `TrimEnd` method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="3cd3e-3810">相反，它会返回一个新字符串，其中所有尾随空格字符都从当前字符串中删除。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3810">Instead, it returns a new string in which all trailing white-space characters are removed from the current string.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char -&gt; string" Usage="string.TrimEnd trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="trimChar"><span data-ttu-id="3cd3e-3811">要删除的 Unicode 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3811">A Unicode character to remove.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3812">从当前字符串删除字符的所有尾随匹配项。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3812">Removes all the trailing occurrences of a character from the current string.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3813">从当前字符串的末尾删除所出现的所有 <paramref name="trimChar" /> 字符后剩余的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3813">The string that remains after all occurrences of the <paramref name="trimChar" /> character are removed from the end of the current string.</span></span> <span data-ttu-id="3cd3e-3814">如果从当前实例无法删除字符，此方法返回未更改的当前实例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3814">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3cd3e-3815">`TrimEnd(System.Char)`方法从当前字符串中删除所有尾随 `trimChar` 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3815">The `TrimEnd(System.Char)` method removes from the current string all trailing `trimChar` characters.</span></span> <span data-ttu-id="3cd3e-3816">当在字符串末尾遇到第一个不是的字符时，修整操作将停止 `trimChar` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3816">The trim operation stops when the first character that is not `trimChar` is encountered at the end of the string.</span></span> <span data-ttu-id="3cd3e-3817">例如，如果 `trimChar` 为， `-` 并且当前字符串为 "---abc---xyz----"，则该 `TrimEnd(System.Char)` 方法返回 "---abc---xyz"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3817">For example, if `trimChar` is `-` and the current string is "---abc---xyz----", the `TrimEnd(System.Char)` method returns "---abc---xyz".</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-3818">如果该 `TrimEnd(System.Char)` 方法从当前实例中移除所有字符，则此方法不会修改当前实例的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3818">If the `TrimEnd(System.Char)` method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="3cd3e-3819">相反，它会返回一个新字符串，其中所有尾随 `trimChar` 字符都从当前字符串中删除。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3819">Instead, it returns a new string in which all trailing `trimChar` characters are removed from the current string.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[] trimChars);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char[] -&gt; string" Usage="string.TrimEnd trimChars" />
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[]? trimChars);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars"><span data-ttu-id="3cd3e-3820">要删除的 Unicode 字符的数组，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3820">An array of Unicode characters to remove, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3821">从当前字符串删除数组中指定的一组字符的所有尾随匹配项。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3821">Removes all the trailing occurrences of a set of characters specified in an array from the current string.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3822">从当前字符串的开头移除所出现的所有 <paramref name="trimChars" /> 参数中的字符后剩余的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3822">The string that remains after all occurrences of the characters in the <paramref name="trimChars" /> parameter are removed from the end of the current string.</span></span> <span data-ttu-id="3cd3e-3823">如果 <paramref name="trimChars" /> 为 <see langword="null" /> 或空数组，则改为删除 Unicode 空白字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3823">If <paramref name="trimChars" /> is <see langword="null" /> or an empty array, Unicode white-space characters are removed instead.</span></span> <span data-ttu-id="3cd3e-3824">如果从当前实例无法删除字符，此方法返回未更改的当前实例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3824">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3cd3e-3825">`TrimEnd(System.Char[])`方法从当前字符串中删除参数中的所有尾随字符 `trimChars` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3825">The `TrimEnd(System.Char[])` method removes from the current string all trailing characters that are in the `trimChars` parameter.</span></span> <span data-ttu-id="3cd3e-3826">当在字符串末尾遇到不在中的第一个字符时，剪裁操作将停止 `trimChars` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3826">The trim operation stops when the first character that is not in `trimChars` is encountered at the end of the string.</span></span> <span data-ttu-id="3cd3e-3827">例如，如果当前字符串为 "123abc456xyz789" 并且 `trimChars` 包含从 "1" 到 "9" 的数字，则该 `TrimEnd(System.Char[])` 方法将返回 "123abc456xyz"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3827">For example, if the current string is "123abc456xyz789" and `trimChars` contains the digits from "1" through "9", the `TrimEnd(System.Char[])` method returns "123abc456xyz".</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-3828">如果该 `TrimEnd(System.Char[])` 方法从当前实例中移除所有字符，则此方法不会修改当前实例的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3828">If the `TrimEnd(System.Char[])` method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="3cd3e-3829">相反，它会返回一个新字符串，其中在中找到的所有尾随字符 `trimChars` 将从当前字符串中删除。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3829">Instead, it returns a new string in which all trailing characters found in `trimChars` are removed from the current string.</span></span>

## Examples

<span data-ttu-id="3cd3e-3830">下面的示例演示如何使用 `TrimEnd(System.Char[])` 方法从字符串末尾修整空格或标点符号。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3830">The following example demonstrates how you can use the `TrimEnd(System.Char[])` method to trim white space or punctuation marks from the end of a string.</span></span>

[!code-csharp-interactive[System.String.TrimEnd#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
[!code-vb[System.String.TrimEnd#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]

          ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-3831">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本维护一个内部空白字符列表，如果 <paramref name="trimChars" /> 为或空数组，此方法将修整此列表 <see langword="null" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3831">The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintains an internal list of white-space characters that this method trims if <paramref name="trimChars" /> is <see langword="null" /> or an empty array.</span></span> <span data-ttu-id="3cd3e-3832">从开始 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] ，如果 <paramref name="trimChars" /> 为 <see langword="null" /> 或空数组，该方法将剪裁所有 Unicode 空白字符， (也就是说，在将 <see langword="true" /> 其传递到方法) 时生成返回值的字符 <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3832">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], if <paramref name="trimChars" /> is <see langword="null" /> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method).</span></span> <span data-ttu-id="3cd3e-3833">由于此更改，和更 <see cref="M:System.String.Trim" /> 早版本中的方法将 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 删除两个字符，零宽度空间 (u + 200B) 和零宽度无间断空格 (U + FEFF) ，则 <see cref="M:System.String.Trim" /> [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 和更高版本中的方法不会删除。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3833">Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and later versions does not remove.</span></span> <span data-ttu-id="3cd3e-3834">此外， <see cref="M:System.String.Trim" /> [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 和更早版本中的方法不会剪裁三个 Unicode 空白字符：蒙古语元音分隔符 (u + 180E) 、窄的无中断空格 (u + 202F) 和中等数学空间 (u + 205F) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3834">In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</span></span></para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart();" />
      <MemberSignature Language="F#" Value="member this.TrimStart : unit -&gt; string" Usage="string.TrimStart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3cd3e-3835">从当前字符串删除所有前导空白字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3835">Removes all the leading white-space characters from the current string.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3836">从当前字符串的开头删除所有空白字符后剩余的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3836">The string that remains after all white-space characters are removed from the start of the current string.</span></span> <span data-ttu-id="3cd3e-3837">如果从当前实例无法删除字符，此方法返回未更改的当前实例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3837">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3cd3e-3838">`TrimStart`方法从当前字符串中删除所有前导空白字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3838">The `TrimStart` method removes from the current string all leading white-space characters.</span></span> <span data-ttu-id="3cd3e-3839">如果遇到非空白字符，剪裁操作将停止。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3839">The trim operation stops when a non white-space character is encountered.</span></span> <span data-ttu-id="3cd3e-3840">例如，如果当前字符串为 "abc xyz"，则该 `TrimStart` 方法返回 "abc xyz"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3840">For example, if the current string is "   abc   xyz    ", the `TrimStart` method returns "abc   xyz    ".</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-3841">如果该 `TrimStart` 方法从当前实例中移除所有字符，则此方法不会修改当前实例的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3841">If the `TrimStart` method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="3cd3e-3842">相反，它会返回一个新字符串，其中将删除当前实例中找到的所有前导空格字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3842">Instead, it returns a new string in which all leading white space characters found in the current instance are removed.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char -&gt; string" Usage="string.TrimStart trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="trimChar"><span data-ttu-id="3cd3e-3843">要删除的 Unicode 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3843">The Unicode character to remove.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3844">删除当前字符串中的指定字符的所有前导匹配项。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3844">Removes all the leading occurrences of a specified character from the current string.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3845">从当前字符串的开头删除所出现的所有 <paramref name="trimChar" /> 字符后剩余的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3845">The string that remains after all occurrences of the <paramref name="trimChar" /> character are removed from the start of the current string.</span></span> <span data-ttu-id="3cd3e-3846">如果从当前实例无法删除字符，此方法返回未更改的当前实例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3846">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3cd3e-3847">`TrimStart(System.Char)`方法从当前字符串中删除所有前导 `trimChar` 字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3847">The `TrimStart(System.Char)` method removes from the current string all leading `trimChar` characters.</span></span> <span data-ttu-id="3cd3e-3848">当遇到不是的字符时，剪裁操作将停止 `trimChar` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3848">The trim operation stops when a character that is not `trimChar` is encountered.</span></span> <span data-ttu-id="3cd3e-3849">例如，如果 `trimChar` 为， `-` 并且当前字符串为 "---abc---xyz----"，则该 `TrimStart(System.Char)` 方法返回 "abc---xyz----"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3849">For example, if `trimChar` is `-` and the current string is "---abc---xyz----", the `TrimStart(System.Char)` method returns "abc---xyz----".</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-3850">如果该 `TrimStart(System.Char)` 方法从当前实例中移除所有字符，则此方法不会修改当前实例的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3850">If the `TrimStart(System.Char)` method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="3cd3e-3851">相反，它会返回一个新字符串，其中将 `trimChar` 删除当前实例中找到的所有前导字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3851">Instead, it returns a new string in which all leading `trimChar` characters found in the current instance are removed.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (params char[] trimChars);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char[] -&gt; string" Usage="string.TrimStart trimChars" />
      <MemberSignature Language="C#" Value="public string TrimStart (params char[]? trimChars);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars"><span data-ttu-id="3cd3e-3852">要删除的 Unicode 字符的数组，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3852">An array of Unicode characters to remove, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="3cd3e-3853">从当前字符串删除数组中指定的一组字符的所有前导匹配项。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3853">Removes all the leading occurrences of a set of characters specified in an array from the current string.</span></span></summary>
        <returns><span data-ttu-id="3cd3e-3854">从当前字符串的开头移除所出现的所有 <paramref name="trimChars" /> 参数中的字符后剩余的字符串。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3854">The string that remains after all occurrences of characters in the <paramref name="trimChars" /> parameter are removed from the start of the current string.</span></span> <span data-ttu-id="3cd3e-3855">如果 <paramref name="trimChars" /> 为 <see langword="null" /> 或空数组，则改为移除空白字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3855">If <paramref name="trimChars" /> is <see langword="null" /> or an empty array, white-space characters are removed instead.</span></span> <span data-ttu-id="3cd3e-3856">如果从当前实例无法删除字符，此方法返回未更改的当前实例。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3856">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3cd3e-3857">`TrimStart(System.Char[])`方法从当前字符串中删除参数中的所有前导字符 `trimChars` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3857">The `TrimStart(System.Char[])` method removes from the current string all leading characters that are in the `trimChars` parameter.</span></span> <span data-ttu-id="3cd3e-3858">当遇到不在中的字符时，剪裁操作将停止 `trimChars` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3858">The trim operation stops when a character that is not in `trimChars` is encountered.</span></span> <span data-ttu-id="3cd3e-3859">例如，如果当前字符串为 "123abc456xyz789" 并且 `trimChars` 包含从 "1" 到 "9" 的数字，则该 `TrimStart(System.Char[])` 方法将返回 "abc456xyz789"。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3859">For example, if the current string is "123abc456xyz789" and `trimChars` contains the digits from "1" through "9", the `TrimStart(System.Char[])` method returns "abc456xyz789".</span></span>

> [!NOTE]
>  <span data-ttu-id="3cd3e-3860">如果该 `TrimStart(System.Char[])` 方法从当前实例中移除所有字符，则此方法不会修改当前实例的值。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3860">If the `TrimStart(System.Char[])` method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="3cd3e-3861">相反，它会返回一个新字符串，其中将删除当前实例中找到的参数中的所有前导字符 `trimChars` 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3861">Instead, it returns a new string in which all leading characters that are in the `trimChars` parameter found in the current instance are removed.</span></span>

## Examples

<span data-ttu-id="3cd3e-3862">下面的示例演示方法的基本功能 <xref:System.String.TrimStart%2A> ：</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3862">The following example demonstrates the basic functionality of the <xref:System.String.TrimStart%2A> method:</span></span>

:::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs" id="Snippet1":::
:::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb" id="Snippet1":::

<span data-ttu-id="3cd3e-3863">下面的示例使用 <xref:System.String.TrimStart%2A> 方法从源代码行中剪裁空格和注释字符。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3863">The following example uses the <xref:System.String.TrimStart%2A> method to trim white space and comment characters from lines of source code.</span></span> <span data-ttu-id="3cd3e-3864">`StripComments`方法包装对的调用 <xref:System.String.TrimStart%2A> ，并向其传递一个字符数组，该数组包含一个空格和注释字符，注释字符是 Visual Basic 中的撇号 ( ") ，后者是 c # 中的斜杠 (/) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3864">The `StripComments` method wraps a call to <xref:System.String.TrimStart%2A> and passes it a character array that contains a space and the comment character, which is an apostrophe ( ' ) in Visual Basic and a slash ( / ) in C#.</span></span> <span data-ttu-id="3cd3e-3865">在 <xref:System.String.TrimStart%2A> 计算字符串是否为注释时，还会调用方法来删除前导空格。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3865">The <xref:System.String.TrimStart%2A> method is also called to remove leading white space when evaluating whether a string is a comment.</span></span>

[!code-csharp[System.String.TrimStart#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
[!code-vb[System.String.TrimStart#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]

<span data-ttu-id="3cd3e-3866">下面的示例演示对 `StripComments` 方法的调用。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3866">The following example then illustrates a call to the `StripComments` method.</span></span>

[!code-csharp[System.String.TrimStart#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#3)]
[!code-vb[System.String.TrimStart#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#3)]

          ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="3cd3e-3867">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本维护一个内部空白字符列表，如果 <paramref name="trimChars" /> 为或空数组，此方法将修整此列表 <see langword="null" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3867">The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintains an internal list of white-space characters that this method trims if <paramref name="trimChars" /> is <see langword="null" /> or an empty array.</span></span> <span data-ttu-id="3cd3e-3868">从开始 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] ，如果 <paramref name="trimChars" /> 为 <see langword="null" /> 或空数组，该方法将剪裁所有 Unicode 空白字符， (也就是说，在将 <see langword="true" /> 其传递到方法) 时生成返回值的字符 <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3868">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], if <paramref name="trimChars" /> is <see langword="null" /> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method).</span></span> <span data-ttu-id="3cd3e-3869">由于此更改，和更 <see cref="M:System.String.Trim" /> 早版本中的方法将 [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 删除两个字符，零宽度空间 (u + 200B) 和零宽度无间断空格 (U + FEFF) ，则 <see cref="M:System.String.Trim" /> [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 和更高版本中的方法不会删除。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3869">Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and later versions does not remove.</span></span> <span data-ttu-id="3cd3e-3870">此外， <see cref="M:System.String.Trim" /> [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] 和更早版本中的方法不会剪裁三个 Unicode 空白字符：蒙古语元音分隔符 (u + 180E) 、窄的无中断空格 (u + 202F) 和中等数学空间 (u + 205F) 。</span><span class="sxs-lookup"><span data-stu-id="3cd3e-3870">In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</span></span></para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
  </Members>
</Type>
