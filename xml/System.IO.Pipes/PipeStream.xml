<Type Name="PipeStream" FullName="System.IO.Pipes.PipeStream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bd3c1e58fef4034f7dce9c98d75c6c1c8716ba63" /><Meta Name="ms.sourcegitcommit" Value="9f423345753728e8cad38d4a22663a109e69ea91" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="03/04/2021" /><Meta Name="ms.locfileid" Value="102087336" /></Metadata><TypeSignature Language="C#" Value="public abstract class PipeStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit PipeStream extends System.IO.Stream" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="DocId" Value="T:System.IO.Pipes.PipeStream" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PipeStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class PipeStream abstract : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type PipeStream = class&#xA;    inherit Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract PipeStream extends System.IO.Stream" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Pipes</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.IO.Pipes" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="ba54e-101">公开管道周围的 <see cref="T:System.IO.Stream" /> 对象，该对象同时支持匿名管道和命名管道。</span><span class="sxs-lookup"><span data-stu-id="ba54e-101">Exposes a <see cref="T:System.IO.Stream" /> object around a pipe, which supports both anonymous and named pipes.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-102"><xref:System.IO.Pipes.PipeStream>类为 .NET Framework 中的命名和匿名管道操作提供基类。</span><span class="sxs-lookup"><span data-stu-id="ba54e-102">The <xref:System.IO.Pipes.PipeStream> class provides the base class for named and anonymous pipes operations in the .NET Framework.</span></span> <span data-ttu-id="ba54e-103">将 <xref:System.IO.Pipes.NamedPipeServerStream> 和 <xref:System.IO.Pipes.NamedPipeClientStream> 类用于命名管道操作。</span><span class="sxs-lookup"><span data-stu-id="ba54e-103">Use the <xref:System.IO.Pipes.NamedPipeServerStream> and <xref:System.IO.Pipes.NamedPipeClientStream> classes for named pipe operations.</span></span> <span data-ttu-id="ba54e-104">使用 <xref:System.IO.Pipes.AnonymousPipeServerStream> 和 <xref:System.IO.Pipes.AnonymousPipeClientStream> 类实现匿名管道操作。</span><span class="sxs-lookup"><span data-stu-id="ba54e-104">Use the <xref:System.IO.Pipes.AnonymousPipeServerStream> and <xref:System.IO.Pipes.AnonymousPipeClientStream> classes for anonymous pipe operations.</span></span>  
  
 <span data-ttu-id="ba54e-105">有关管道的详细信息，请参阅 [管道](/dotnet/standard/io/pipe-operations)。</span><span class="sxs-lookup"><span data-stu-id="ba54e-105">For more information about pipes, see [Pipes](/dotnet/standard/io/pipe-operations).</span></span> <span data-ttu-id="ba54e-106">有关匿名管道的示例，请参阅 [如何：使用匿名管道进行本地进程间通信](/dotnet/standard/io/how-to-use-anonymous-pipes-for-local-interprocess-communication)。</span><span class="sxs-lookup"><span data-stu-id="ba54e-106">For an example of anonymous pipes, see [How to: Use Anonymous Pipes for Local Interprocess Communication](/dotnet/standard/io/how-to-use-anonymous-pipes-for-local-interprocess-communication).</span></span> <span data-ttu-id="ba54e-107">有关命名管道的示例，请参阅 [如何：使用命名管道进行网络进程间通信](/dotnet/standard/io/how-to-use-named-pipes-for-network-interprocess-communication)。</span><span class="sxs-lookup"><span data-stu-id="ba54e-107">For an example of named pipes, see [How to: Use Named Pipes for Network Interprocess Communication](/dotnet/standard/io/how-to-use-named-pipes-for-network-interprocess-communication).</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba54e-108">初始化 <see cref="T:System.IO.Pipes.PipeStream" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="ba54e-108">Initializes a new instance of the <see cref="T:System.IO.Pipes.PipeStream" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PipeStream (System.IO.Pipes.PipeDirection direction, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.Pipes.PipeDirection direction, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.#ctor(System.IO.Pipes.PipeDirection,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (direction As PipeDirection, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PipeStream(System::IO::Pipes::PipeDirection direction, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.PipeStream : System.IO.Pipes.PipeDirection * int -&gt; System.IO.Pipes.PipeStream" Usage="new System.IO.Pipes.PipeStream (direction, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction"><span data-ttu-id="ba54e-109"><see cref="T:System.IO.Pipes.PipeDirection" /> 值之一，指示管道对象的方向。</span><span class="sxs-lookup"><span data-stu-id="ba54e-109">One of the <see cref="T:System.IO.Pipes.PipeDirection" /> values that indicates the direction of the pipe object.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="ba54e-110">一个大于或等于 0 的正 <see cref="T:System.Int32" /> 值，指示缓冲区大小。</span><span class="sxs-lookup"><span data-stu-id="ba54e-110">A positive <see cref="T:System.Int32" /> value greater than or equal to 0 that indicates the buffer size.</span></span></param>
        <summary><span data-ttu-id="ba54e-111">使用指定的 <see cref="T:System.IO.Pipes.PipeDirection" /> 值和缓冲区大小初始化 <see cref="T:System.IO.Pipes.PipeStream" /> 类的一个新实例。</span><span class="sxs-lookup"><span data-stu-id="ba54e-111">Initializes a new instance of the <see cref="T:System.IO.Pipes.PipeStream" /> class using the specified <see cref="T:System.IO.Pipes.PipeDirection" /> value and buffer size.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-112">此构造函数使用的管道传输模式 <xref:System.IO.Pipes.PipeTransmissionMode.Byte> 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-112">This constructor uses a pipe transmission mode of <xref:System.IO.Pipes.PipeTransmissionMode.Byte>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba54e-113"><paramref name="direction" /> 不是有效的 <see cref="T:System.IO.Pipes.PipeDirection" /> 值。</span><span class="sxs-lookup"><span data-stu-id="ba54e-113"><paramref name="direction" /> is not a valid <see cref="T:System.IO.Pipes.PipeDirection" /> value.</span></span>  
  
<span data-ttu-id="ba54e-114">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ba54e-114">-or-</span></span> 
 <span data-ttu-id="ba54e-115"><paramref name="bufferSize" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="ba54e-115"><paramref name="bufferSize" /> is less than 0.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PipeStream (System.IO.Pipes.PipeDirection direction, System.IO.Pipes.PipeTransmissionMode transmissionMode, int outBufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.Pipes.PipeDirection direction, valuetype System.IO.Pipes.PipeTransmissionMode transmissionMode, int32 outBufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.#ctor(System.IO.Pipes.PipeDirection,System.IO.Pipes.PipeTransmissionMode,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (direction As PipeDirection, transmissionMode As PipeTransmissionMode, outBufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PipeStream(System::IO::Pipes::PipeDirection direction, System::IO::Pipes::PipeTransmissionMode transmissionMode, int outBufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.PipeStream : System.IO.Pipes.PipeDirection * System.IO.Pipes.PipeTransmissionMode * int -&gt; System.IO.Pipes.PipeStream" Usage="new System.IO.Pipes.PipeStream (direction, transmissionMode, outBufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="transmissionMode" Type="System.IO.Pipes.PipeTransmissionMode" />
        <Parameter Name="outBufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction"><span data-ttu-id="ba54e-116"><see cref="T:System.IO.Pipes.PipeDirection" /> 值之一，指示管道对象的方向。</span><span class="sxs-lookup"><span data-stu-id="ba54e-116">One of the <see cref="T:System.IO.Pipes.PipeDirection" /> values that indicates the direction of the pipe object.</span></span></param>
        <param name="transmissionMode"><span data-ttu-id="ba54e-117"><see cref="T:System.IO.Pipes.PipeTransmissionMode" /> 值之一，指示管道对象的传输模式。</span><span class="sxs-lookup"><span data-stu-id="ba54e-117">One of the <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> values that indicates the transmission mode of the pipe object.</span></span></param>
        <param name="outBufferSize"><span data-ttu-id="ba54e-118">一个大于或等于 0 的正 <see cref="T:System.Int32" /> 值，指示缓冲区大小。</span><span class="sxs-lookup"><span data-stu-id="ba54e-118">A positive <see cref="T:System.Int32" /> value greater than or equal to 0 that indicates the buffer size.</span></span></param>
        <summary><span data-ttu-id="ba54e-119">使用指定的 <see cref="T:System.IO.Pipes.PipeStream" />、<see cref="T:System.IO.Pipes.PipeDirection" /> 和缓冲区大小初始化 <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> 类的一个新实例。</span><span class="sxs-lookup"><span data-stu-id="ba54e-119">Initializes a new instance of the <see cref="T:System.IO.Pipes.PipeStream" /> class using the specified <see cref="T:System.IO.Pipes.PipeDirection" />, <see cref="T:System.IO.Pipes.PipeTransmissionMode" />, and buffer size.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba54e-120"><paramref name="direction" /> 不是有效的 <see cref="T:System.IO.Pipes.PipeDirection" /> 值。</span><span class="sxs-lookup"><span data-stu-id="ba54e-120"><paramref name="direction" /> is not a valid <see cref="T:System.IO.Pipes.PipeDirection" /> value.</span></span>  
  
<span data-ttu-id="ba54e-121">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ba54e-121">-or-</span></span> 
 <span data-ttu-id="ba54e-122"><paramref name="transmissionMode" /> 不是有效的 <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> 值。</span><span class="sxs-lookup"><span data-stu-id="ba54e-122"><paramref name="transmissionMode" /> is not a valid <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> value.</span></span>  
  
<span data-ttu-id="ba54e-123">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ba54e-123">-or-</span></span> 
 <span data-ttu-id="ba54e-124"><paramref name="bufferSize" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="ba54e-124"><paramref name="bufferSize" /> is less than 0.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback? callback, object? state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="pipeStream.BeginRead (buffer, offset, count, callback, state)" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="ba54e-125">将数据读入的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="ba54e-125">The buffer to read data into.</span></span></param>
        <param name="offset"><span data-ttu-id="ba54e-126"><paramref name="buffer" /> 中的字节偏移量，从此处开始读取。</span><span class="sxs-lookup"><span data-stu-id="ba54e-126">The byte offset in <paramref name="buffer" /> at which to begin reading.</span></span></param>
        <param name="count"><span data-ttu-id="ba54e-127">最多读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="ba54e-127">The maximum number of bytes to read.</span></span></param>
        <param name="callback"><span data-ttu-id="ba54e-128">异步读操作完成后调用的方法。</span><span class="sxs-lookup"><span data-stu-id="ba54e-128">The method to call when the asynchronous read operation is completed.</span></span></param>
        <param name="state"><span data-ttu-id="ba54e-129">一个用户提供的对象，它将该特定的异步读取请求与其他请求区别开来。</span><span class="sxs-lookup"><span data-stu-id="ba54e-129">A user-provided object that distinguishes this particular asynchronous read request from other requests.</span></span></param>
        <summary><span data-ttu-id="ba54e-130">开始异步读操作。</span><span class="sxs-lookup"><span data-stu-id="ba54e-130">Begins an asynchronous read operation.</span></span></summary>
        <returns><span data-ttu-id="ba54e-131">引用异步读取的 <see cref="T:System.IAsyncResult" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="ba54e-131">An <see cref="T:System.IAsyncResult" /> object that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-132">将返回的 <xref:System.IAsyncResult> 对象传递给 <xref:System.IO.Pipes.PipeStream.EndRead%2A> 方法以确定读取的字节数，以及释放用于读取的操作系统资源。</span><span class="sxs-lookup"><span data-stu-id="ba54e-132">Pass the returned <xref:System.IAsyncResult> object to the <xref:System.IO.Pipes.PipeStream.EndRead%2A> method to determine how many bytes were read and to release operating system resources used for reading.</span></span> <span data-ttu-id="ba54e-133"><xref:System.IO.Pipes.PipeStream.EndRead%2A> 对于每次调用，都必须调用一次 <xref:System.IO.Pipes.PipeStream.BeginRead%2A> 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-133"><xref:System.IO.Pipes.PipeStream.EndRead%2A> must be called once for every call to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.</span></span> <span data-ttu-id="ba54e-134">这可以在被调用的同一代码中 <xref:System.IO.Pipes.PipeStream.BeginRead%2A> 或在传递给的回调中完成 <xref:System.IO.Pipes.PipeStream.BeginRead%2A> 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-134">This can be done either in the same code that called <xref:System.IO.Pipes.PipeStream.BeginRead%2A> or in a callback that is passed to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.</span></span>  
  
 <span data-ttu-id="ba54e-135">使用 <xref:System.IO.Pipes.PipeStream.CanRead%2A> 属性可确定当前 <xref:System.IO.Pipes.PipeStream> 对象是否支持读操作。</span><span class="sxs-lookup"><span data-stu-id="ba54e-135">Use the <xref:System.IO.Pipes.PipeStream.CanRead%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports read operations.</span></span>  
  
 <span data-ttu-id="ba54e-136">如果管道已关闭或传递到的参数无效 <xref:System.IO.Pipes.PipeStream.BeginRead%2A> ，则会立即引发相应的异常。</span><span class="sxs-lookup"><span data-stu-id="ba54e-136">If the pipe is closed or an invalid argument is passed to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>, the appropriate exceptions are raised immediately.</span></span> <span data-ttu-id="ba54e-137">在执行请求的线程池线程上发生异步读取请求期间发生的错误。</span><span class="sxs-lookup"><span data-stu-id="ba54e-137">Errors that occur during an asynchronous read request occur on the thread pool thread that is performing the request.</span></span> <span data-ttu-id="ba54e-138">当代码调用方法时，将引发异常 <xref:System.IO.Pipes.PipeStream.EndRead%2A> 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-138">The exceptions are raised when the code calls the <xref:System.IO.Pipes.PipeStream.EndRead%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba54e-139"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ba54e-139"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba54e-140"><paramref name="offset" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="ba54e-140"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="ba54e-141">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ba54e-141">-or-</span></span> 
 <span data-ttu-id="ba54e-142"><paramref name="count" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="ba54e-142"><paramref name="count" /> is less than 0.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba54e-143"><paramref name="count" /> 大于 <paramref name="buffer" /> 中可用的字节数。</span><span class="sxs-lookup"><span data-stu-id="ba54e-143"><paramref name="count" /> is greater than the number of bytes available in <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ba54e-144">管道已关闭。</span><span class="sxs-lookup"><span data-stu-id="ba54e-144">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ba54e-145">管道不支持读操作。</span><span class="sxs-lookup"><span data-stu-id="ba54e-145">The pipe does not support read operations.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ba54e-146">管道已断开连接、正在等待连接或尚未设置句柄。</span><span class="sxs-lookup"><span data-stu-id="ba54e-146">The pipe is disconnected, waiting to connect, or the handle has not been set.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ba54e-147">管道已中断或出现其他 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="ba54e-147">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback? callback, object? state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="pipeStream.BeginWrite (buffer, offset, count, callback, state)" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="ba54e-148">包含要写入当前流的数据的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="ba54e-148">The buffer that contains the data to write to the current stream.</span></span></param>
        <param name="offset"><span data-ttu-id="ba54e-149"><paramref name="buffer" /> 中的从零开始的字节偏移量，从此处开始将字节复制到当前流。</span><span class="sxs-lookup"><span data-stu-id="ba54e-149">The zero-based byte offset in <paramref name="buffer" /> at which to begin copying bytes to the current stream.</span></span></param>
        <param name="count"><span data-ttu-id="ba54e-150">最多写入的字节数。</span><span class="sxs-lookup"><span data-stu-id="ba54e-150">The maximum number of bytes to write.</span></span></param>
        <param name="callback"><span data-ttu-id="ba54e-151">异步写操作完成后调用的方法。</span><span class="sxs-lookup"><span data-stu-id="ba54e-151">The method to call when the asynchronous write operation is completed.</span></span></param>
        <param name="state"><span data-ttu-id="ba54e-152">一个用户提供的对象，它将该特定的异步写入请求与其他请求区别开来。</span><span class="sxs-lookup"><span data-stu-id="ba54e-152">A user-provided object that distinguishes this particular asynchronous write request from other requests.</span></span></param>
        <summary><span data-ttu-id="ba54e-153">开始异步写操作。</span><span class="sxs-lookup"><span data-stu-id="ba54e-153">Begins an asynchronous write operation.</span></span></summary>
        <returns><span data-ttu-id="ba54e-154">一个引用异步写操作的 <see cref="T:System.IAsyncResult" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="ba54e-154">An <see cref="T:System.IAsyncResult" /> object that references the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-155"><xref:System.IO.Pipes.PipeStream.EndWrite%2A> 对于每次调用，都必须调用一次 <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-155"><xref:System.IO.Pipes.PipeStream.EndWrite%2A> must be called once for every call to <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>.</span></span> <span data-ttu-id="ba54e-156">这可以在被调用的同一代码中 <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> 或在传递给的回调中完成 <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-156">This can be done either in the same code that called <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> or in a callback that is passed to <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>.</span></span>  
  
 <span data-ttu-id="ba54e-157">使用 <xref:System.IO.Pipes.PipeStream.CanWrite%2A> 属性可确定当前 <xref:System.IO.Pipes.PipeStream> 对象是否支持写入操作。</span><span class="sxs-lookup"><span data-stu-id="ba54e-157">Use the <xref:System.IO.Pipes.PipeStream.CanWrite%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports write operations.</span></span>  
  
 <span data-ttu-id="ba54e-158">如果管道已关闭或传递到的参数无效 <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> ，则会立即引发相应的异常。</span><span class="sxs-lookup"><span data-stu-id="ba54e-158">If the pipe is closed or an invalid argument is passed to <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>, the appropriate exceptions are raised immediately.</span></span> <span data-ttu-id="ba54e-159">在执行请求的线程池线程上发生异步写入请求期间发生的错误。</span><span class="sxs-lookup"><span data-stu-id="ba54e-159">Errors that occur during an asynchronous write request occur on the thread pool thread that is performing the request.</span></span> <span data-ttu-id="ba54e-160">当代码调用方法时，将引发异常  <xref:System.IO.Pipes.PipeStream.EndWrite%2A> 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-160">The exceptions are raised when the code calls the  <xref:System.IO.Pipes.PipeStream.EndWrite%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba54e-161"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ba54e-161"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba54e-162"><paramref name="offset" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="ba54e-162"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="ba54e-163">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ba54e-163">-or-</span></span> 
 <span data-ttu-id="ba54e-164"><paramref name="count" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="ba54e-164"><paramref name="count" /> is less than 0.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba54e-165"><paramref name="count" /> 大于 <paramref name="buffer" /> 中可用的字节数。</span><span class="sxs-lookup"><span data-stu-id="ba54e-165"><paramref name="count" /> is greater than the number of bytes available in <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ba54e-166">管道已关闭。</span><span class="sxs-lookup"><span data-stu-id="ba54e-166">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ba54e-167">管道不支持写操作。</span><span class="sxs-lookup"><span data-stu-id="ba54e-167">The pipe does not support write operations.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ba54e-168">管道已断开连接、正在等待连接或尚未设置句柄。</span><span class="sxs-lookup"><span data-stu-id="ba54e-168">The pipe is disconnected, waiting to connect, or the handle has not been set.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ba54e-169">管道已中断或出现其他 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="ba54e-169">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.Pipes.PipeStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba54e-170">获取一个值，该值指示当前流是否支持读操作。</span><span class="sxs-lookup"><span data-stu-id="ba54e-170">Gets a value indicating whether the current stream supports read operations.</span></span></summary>
        <value><span data-ttu-id="ba54e-171">如果流支持读操作，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ba54e-171"><see langword="true" /> if the stream supports read operations; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-172">如果 <xref:System.IO.Pipes.PipeStream> 对象已关闭，则此属性返回 `false` 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-172">If the <xref:System.IO.Pipes.PipeStream> object is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.Pipes.PipeStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba54e-173">获取一个值，该值指示当前流是否支持查找操作。</span><span class="sxs-lookup"><span data-stu-id="ba54e-173">Gets a value indicating whether the current stream supports seek operations.</span></span></summary>
        <value><span data-ttu-id="ba54e-174">在所有情况下均为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ba54e-174"><see langword="false" /> in all cases.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-175">如果 <xref:System.IO.Pipes.PipeStream> 对象已关闭，则此属性返回 `false` 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-175">If the <xref:System.IO.Pipes.PipeStream> object is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.Pipes.PipeStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba54e-176">获取一个值，该值指示当前流是否支持写操作。</span><span class="sxs-lookup"><span data-stu-id="ba54e-176">Gets a value indicating whether the current stream supports write operations.</span></span></summary>
        <value><span data-ttu-id="ba54e-177">如果流支持写操作，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ba54e-177"><see langword="true" /> if the stream supports write operations; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-178">如果 <xref:System.IO.Pipes.PipeStream> 对象已关闭，则此属性返回 `false` 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-178">If the <xref:System.IO.Pipes.PipeStream> object is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckPipePropertyOperations">
      <MemberSignature Language="C#" Value="protected internal virtual void CheckPipePropertyOperations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CheckPipePropertyOperations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.CheckPipePropertyOperations" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CheckPipePropertyOperations ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CheckPipePropertyOperations();" />
      <MemberSignature Language="F#" Value="abstract member CheckPipePropertyOperations : unit -&gt; unit&#xA;override this.CheckPipePropertyOperations : unit -&gt; unit" Usage="pipeStream.CheckPipePropertyOperations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba54e-179">验证管道是否处于可供获取或设置属性的正确状态。</span><span class="sxs-lookup"><span data-stu-id="ba54e-179">Verifies that the pipe is in a proper state for getting or setting properties.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckReadOperations">
      <MemberSignature Language="C#" Value="protected internal void CheckReadOperations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void CheckReadOperations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.CheckReadOperations" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub CheckReadOperations ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void CheckReadOperations();" />
      <MemberSignature Language="F#" Value="member this.CheckReadOperations : unit -&gt; unit" Usage="pipeStream.CheckReadOperations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba54e-180">验证管道是否处于可供进行读操作的连接状态。</span><span class="sxs-lookup"><span data-stu-id="ba54e-180">Verifies that the pipe is in a connected state for read operations.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckWriteOperations">
      <MemberSignature Language="C#" Value="protected internal void CheckWriteOperations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void CheckWriteOperations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.CheckWriteOperations" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub CheckWriteOperations ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void CheckWriteOperations();" />
      <MemberSignature Language="F#" Value="member this.CheckWriteOperations : unit -&gt; unit" Usage="pipeStream.CheckWriteOperations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba54e-181">验证管道是否处于可供进行写操作的连接状态。</span><span class="sxs-lookup"><span data-stu-id="ba54e-181">Verifies that the pipe is in a connected state for write operations.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="pipeStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="ba54e-182">若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ba54e-182"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="ba54e-183">释放 <see cref="T:System.IO.Pipes.PipeStream" /> 类使用的非托管资源，并可以选择释放托管资源。</span><span class="sxs-lookup"><span data-stu-id="ba54e-183">Releases the unmanaged resources used by the <see cref="T:System.IO.Pipes.PipeStream" /> class and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-184">此方法由公共 <xref:System.ComponentModel.Component.Dispose%2A> 方法和 <xref:System.Object.Finalize%2A> 方法调用。</span><span class="sxs-lookup"><span data-stu-id="ba54e-184">This method is called by the public <xref:System.ComponentModel.Component.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="ba54e-185"><xref:System.ComponentModel.Component.Dispose%2A> 调用受保护的 <xref:System.IO.Pipes.PipeStream.Dispose%2A> 方法，并将 `disposing` 参数设置为 `true` 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-185"><xref:System.ComponentModel.Component.Dispose%2A> invokes the protected <xref:System.IO.Pipes.PipeStream.Dispose%2A> method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="ba54e-186"><xref:System.Object.Finalize%2A><xref:System.IO.Pipes.PipeStream.Dispose%2A>在设置为的情况调用 `disposing` `false` 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-186"><xref:System.Object.Finalize%2A> invokes <xref:System.IO.Pipes.PipeStream.Dispose%2A> with `disposing` set to `false`.</span></span> <span data-ttu-id="ba54e-187">当释放参数为时 `true` ，此方法将释放该对象引用的任何托管对象所持有的所有资源 <xref:System.IO.Pipes.PipeStream> 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-187">When the disposing parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.IO.Pipes.PipeStream> object references.</span></span> <span data-ttu-id="ba54e-188">此方法将调用每个被引用对象的 <xref:System.IO.Pipes.PipeStream.Dispose%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="ba54e-188">This method invokes the <xref:System.IO.Pipes.PipeStream.Dispose%2A> method of each referenced object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="ba54e-189">在派生类中，将所有 <see cref="T:System.IO.Stream" /> 清理逻辑放入 <see cref="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" /> 方法中。</span><span class="sxs-lookup"><span data-stu-id="ba54e-189">In derived classes, put all <see cref="T:System.IO.Stream" /> cleanup logic in the <see cref="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" /> method.</span></span>  
  
 <span data-ttu-id="ba54e-190"><see cref="M:System.ComponentModel.Component.Dispose" /> 可以由其他对象多次调用。</span><span class="sxs-lookup"><span data-stu-id="ba54e-190"><see cref="M:System.ComponentModel.Component.Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="ba54e-191">重写 <see cref="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" /> 时，请注意不要引用在以前调用 <see cref="M:System.ComponentModel.Component.Dispose" /> 时已释放的对象。</span><span class="sxs-lookup"><span data-stu-id="ba54e-191">When overriding <see cref="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see cref="M:System.ComponentModel.Component.Dispose" />.</span></span> <span data-ttu-id="ba54e-192">有关如何实现的详细信息 <see cref="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" /> ，请参阅 [实现 Dispose 方法](/dotnet/standard/garbage-collection/implementing-dispose)。</span><span class="sxs-lookup"><span data-stu-id="ba54e-192">For more information about how to implement <see cref="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](/dotnet/standard/garbage-collection/implementing-dispose).</span></span>  
  
<span data-ttu-id="ba54e-193">有关和的详细 <see cref="M:System.ComponentModel.Component.Dispose" /> 信息 <see cref="M:System.Object.Finalize" /> ，请参阅 [清理非托管资源](/dotnet/standard/garbage-collection/unmanaged)。</span><span class="sxs-lookup"><span data-stu-id="ba54e-193">For more information about <see cref="M:System.ComponentModel.Component.Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](/dotnet/standard/garbage-collection/unmanaged).</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="pipeStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="ba54e-194">对挂起的异步请求的引用。</span><span class="sxs-lookup"><span data-stu-id="ba54e-194">The reference to the pending asynchronous request.</span></span></param>
        <summary><span data-ttu-id="ba54e-195">结束挂起的异步读取请求。</span><span class="sxs-lookup"><span data-stu-id="ba54e-195">Ends a pending asynchronous read request.</span></span></summary>
        <returns><span data-ttu-id="ba54e-196">已读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="ba54e-196">The number of bytes that were read.</span></span> <span data-ttu-id="ba54e-197">返回值 0 指示已到达流的末尾（管道已关闭）。</span><span class="sxs-lookup"><span data-stu-id="ba54e-197">A return value of 0 indicates the end of the stream (the pipe has been closed).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-198">此方法返回由先前对的调用所指定的字节数组中读取的字节数 <xref:System.IO.Pipes.PipeStream.BeginRead%2A> 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-198">This method returns the number of bytes read into the byte array specified by the earlier call to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.</span></span>  
  
 <span data-ttu-id="ba54e-199">将返回的 <xref:System.IAsyncResult> 对象传递给 <xref:System.IO.Pipes.PipeStream.EndRead%2A> 方法以确定读取的字节数，以及释放用于读取的操作系统资源。</span><span class="sxs-lookup"><span data-stu-id="ba54e-199">Pass the returned <xref:System.IAsyncResult> object to the <xref:System.IO.Pipes.PipeStream.EndRead%2A> method to determine how many bytes were read and to release operating system resources used for reading.</span></span> <span data-ttu-id="ba54e-200"><xref:System.IO.Pipes.PipeStream.EndRead%2A> 对于每次调用，都必须调用一次 <xref:System.IO.Pipes.PipeStream.BeginRead%2A> 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-200"><xref:System.IO.Pipes.PipeStream.EndRead%2A> must be called once for every call to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.</span></span> <span data-ttu-id="ba54e-201">这可以在被调用的同一代码中 <xref:System.IO.Pipes.PipeStream.BeginRead%2A> 或在传递给的回调中完成 <xref:System.IO.Pipes.PipeStream.BeginRead%2A> 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-201">This can be done either in the same code that called <xref:System.IO.Pipes.PipeStream.BeginRead%2A> or in a callback that is passed to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.</span></span>  
  
 <span data-ttu-id="ba54e-202">使用 <xref:System.IO.Pipes.PipeStream.CanRead%2A> 属性可确定当前 <xref:System.IO.Pipes.PipeStream> 对象是否支持读操作。</span><span class="sxs-lookup"><span data-stu-id="ba54e-202">Use the <xref:System.IO.Pipes.PipeStream.CanRead%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports read operations.</span></span>  
  
 <span data-ttu-id="ba54e-203">如果管道已关闭或传递到的参数无效 <xref:System.IO.Pipes.PipeStream.BeginRead%2A> ，则会立即引发相应的异常。</span><span class="sxs-lookup"><span data-stu-id="ba54e-203">If the pipe is closed or an invalid argument is passed to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>, the appropriate exceptions are raised immediately.</span></span> <span data-ttu-id="ba54e-204">在执行请求的线程池线程上发生异步读取请求期间发生的错误。</span><span class="sxs-lookup"><span data-stu-id="ba54e-204">Errors that occur during an asynchronous read request occur on the thread pool thread that is performing the request.</span></span> <span data-ttu-id="ba54e-205">当代码调用方法时，将引发异常 <xref:System.IO.Pipes.PipeStream.EndRead%2A> 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-205">The exceptions are raised when the code calls the <xref:System.IO.Pipes.PipeStream.EndRead%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba54e-206"><paramref name="asyncResult" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ba54e-206"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba54e-207"><paramref name="asyncResult" /> 不源于当前流的 <see cref="M:System.IO.Pipes.PipeStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="ba54e-207"><paramref name="asyncResult" /> did not originate from a <see cref="M:System.IO.Pipes.PipeStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method on the current stream.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ba54e-208">流已关闭或出现了内部错误。</span><span class="sxs-lookup"><span data-stu-id="ba54e-208">The stream is closed or an internal error has occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="pipeStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="ba54e-209">对挂起的异步请求的引用。</span><span class="sxs-lookup"><span data-stu-id="ba54e-209">The reference to the pending asynchronous request.</span></span></param>
        <summary><span data-ttu-id="ba54e-210">结束挂起的异步写入请求。</span><span class="sxs-lookup"><span data-stu-id="ba54e-210">Ends a pending asynchronous write request.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-211"><xref:System.IO.Pipes.PipeStream.EndWrite%2A> 对于每次调用，都必须调用一次 <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-211"><xref:System.IO.Pipes.PipeStream.EndWrite%2A> must be called once for every call to <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>.</span></span> <span data-ttu-id="ba54e-212">这可以在被调用的同一代码中 <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> 或在传递给的回调中完成 <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-212">This can be done either in the same code that called <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> or in a callback that is passed to <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>.</span></span>  
  
 <span data-ttu-id="ba54e-213">使用 <xref:System.IO.Pipes.PipeStream.CanWrite%2A> 属性可确定当前 <xref:System.IO.Pipes.PipeStream> 对象是否支持写入操作。</span><span class="sxs-lookup"><span data-stu-id="ba54e-213">Use the <xref:System.IO.Pipes.PipeStream.CanWrite%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports write operations.</span></span>  
  
 <span data-ttu-id="ba54e-214">如果管道已关闭或传递到的参数无效 <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> ，则会立即引发相应的异常。</span><span class="sxs-lookup"><span data-stu-id="ba54e-214">If the pipe is closed or an invalid argument is passed to <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>, the appropriate exceptions are raised immediately.</span></span> <span data-ttu-id="ba54e-215">在执行请求的线程池线程上发生异步写入请求期间发生的错误。</span><span class="sxs-lookup"><span data-stu-id="ba54e-215">Errors that occur during an asynchronous write request occur on the thread pool thread that is performing the request.</span></span> <span data-ttu-id="ba54e-216">当代码调用方法时，将引发异常 <xref:System.IO.Pipes.PipeStream.EndWrite%2A> 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-216">The exceptions are raised when the code the calls <xref:System.IO.Pipes.PipeStream.EndWrite%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba54e-217"><paramref name="asyncResult" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ba54e-217"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba54e-218"><paramref name="asyncResult" /> 不源于当前流的 <see cref="M:System.IO.Pipes.PipeStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="ba54e-218"><paramref name="asyncResult" /> did not originate from a <see cref="M:System.IO.Pipes.PipeStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method on the current stream.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ba54e-219">流已关闭或出现了内部错误。</span><span class="sxs-lookup"><span data-stu-id="ba54e-219">The stream is closed or an internal error has occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="pipeStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba54e-220">清除当前流的缓冲区，并使所有缓冲的数据都写入到基础设备。</span><span class="sxs-lookup"><span data-stu-id="ba54e-220">Clears the buffer for the current stream and causes any buffered data to be written to the underlying device.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-221">此 <xref:System.IO.Pipes.PipeStream.Flush%2A> 方法在类中不受支持 <xref:System.IO.Pipes.PipeStream> ，并且在调用它时不执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="ba54e-221">The <xref:System.IO.Pipes.PipeStream.Flush%2A> method is not supported in the <xref:System.IO.Pipes.PipeStream> class and does nothing when it is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ba54e-222">管道已关闭。</span><span class="sxs-lookup"><span data-stu-id="ba54e-222">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ba54e-223">管道不支持写操作。</span><span class="sxs-lookup"><span data-stu-id="ba54e-223">The pipe does not support write operations.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ba54e-224">管道已中断或出现其他 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="ba54e-224">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function FlushAsync (cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="pipeStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><span data-ttu-id="ba54e-225">要监视取消请求的标记。</span><span class="sxs-lookup"><span data-stu-id="ba54e-225">The token to monitor for cancellation requests.</span></span></param>
        <summary><span data-ttu-id="ba54e-226">异步清除当前流的缓冲区，并使所有缓冲的数据都写入到基础设备。</span><span class="sxs-lookup"><span data-stu-id="ba54e-226">Asynchronously clears the buffer for the current stream and causes any buffered data to be written to the underlying device.</span></span></summary>
        <returns><span data-ttu-id="ba54e-227">表示异步刷新操作的任务。</span><span class="sxs-lookup"><span data-stu-id="ba54e-227">A task that represent the asynchronous flush operation.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.IO.Pipes.PipeSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Pipes.PipeSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As PipeSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Pipes::PipeSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.IO.Pipes.PipeSecurity" Usage="pipeStream.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Pipes.PipeSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba54e-228">获取一个 <see cref="T:System.IO.Pipes.PipeSecurity" /> 对象，该对象封装当前 <see cref="T:System.IO.Pipes.PipeStream" /> 对象所描述管道的访问控制列表 (ACL) 项。</span><span class="sxs-lookup"><span data-stu-id="ba54e-228">Gets a <see cref="T:System.IO.Pipes.PipeSecurity" /> object that encapsulates the access control list (ACL) entries for the pipe described by the current <see cref="T:System.IO.Pipes.PipeStream" /> object.</span></span></summary>
        <returns><span data-ttu-id="ba54e-229">一个 <see cref="T:System.IO.Pipes.PipeSecurity" /> 对象，该对象封装当前 <see cref="T:System.IO.Pipes.PipeStream" /> 对象所描述管道的访问控制列表 (ACL) 项。</span><span class="sxs-lookup"><span data-stu-id="ba54e-229">A <see cref="T:System.IO.Pipes.PipeSecurity" /> object that encapsulates the access control list (ACL) entries for the pipe described by the current <see cref="T:System.IO.Pipes.PipeStream" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-230"> (ACL) 的访问控制列表描述了在指定文件上执行特定操作的权限（或不具有这些权限）。</span><span class="sxs-lookup"><span data-stu-id="ba54e-230">An access control list (ACL) describes individuals and/or groups that have, or do not have, rights to perform specific actions on a specified file.</span></span> <span data-ttu-id="ba54e-231">有关详细信息，请参阅[如何：添加或删除访问控制列表条目](/dotnet/standard/io/how-to-add-or-remove-access-control-list-entries)。</span><span class="sxs-lookup"><span data-stu-id="ba54e-231">For more information, see [How to: Add or Remove Access Control List Entries](/dotnet/standard/io/how-to-add-or-remove-access-control-list-entries).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ba54e-232">管道已关闭。</span><span class="sxs-lookup"><span data-stu-id="ba54e-232">The pipe is closed.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="ba54e-233">用于设置安全信息的基础调用失败。</span><span class="sxs-lookup"><span data-stu-id="ba54e-233">The underlying call to set security information failed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ba54e-234">用于设置安全信息的基础调用失败。</span><span class="sxs-lookup"><span data-stu-id="ba54e-234">The underlying call to set security information failed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ba54e-235">用于设置安全信息的基础调用失败。</span><span class="sxs-lookup"><span data-stu-id="ba54e-235">The underlying call to set security information failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="InBufferSize">
      <MemberSignature Language="C#" Value="public virtual int InBufferSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.InBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property InBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int InBufferSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.InBufferSize : int" Usage="System.IO.Pipes.PipeStream.InBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba54e-236">获取管道的入站缓冲区的大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="ba54e-236">Gets the size, in bytes, of the inbound buffer for a pipe.</span></span></summary>
        <value><span data-ttu-id="ba54e-237">一个整数值，表示入站缓冲区的大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="ba54e-237">An integer value that represents the inbound buffer size, in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-238">如果 <xref:System.IO.Pipes.PipeStream.InBufferSize%2A> 为0，则根据需要分配缓冲区大小。</span><span class="sxs-lookup"><span data-stu-id="ba54e-238">If <xref:System.IO.Pipes.PipeStream.InBufferSize%2A> is 0, the buffer size is allocated as needed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ba54e-239">流不可读。</span><span class="sxs-lookup"><span data-stu-id="ba54e-239">The stream is unreadable.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ba54e-240">管道正在等待连接。</span><span class="sxs-lookup"><span data-stu-id="ba54e-240">The pipe is waiting to connect.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ba54e-241">管道已中断或出现其他 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="ba54e-241">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="InitializeHandle">
      <MemberSignature Language="C#" Value="protected void InitializeHandle (Microsoft.Win32.SafeHandles.SafePipeHandle? handle, bool isExposed, bool isAsync);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeHandle(class Microsoft.Win32.SafeHandles.SafePipeHandle handle, bool isExposed, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeHandle (handle As SafePipeHandle, isExposed As Boolean, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeHandle(Microsoft::Win32::SafeHandles::SafePipeHandle ^ handle, bool isExposed, bool isAsync);" />
      <MemberSignature Language="F#" Value="member this.InitializeHandle : Microsoft.Win32.SafeHandles.SafePipeHandle * bool * bool -&gt; unit" Usage="pipeStream.InitializeHandle (handle, isExposed, isAsync)" />
      <MemberSignature Language="C#" Value="protected void InitializeHandle (Microsoft.Win32.SafeHandles.SafePipeHandle handle, bool isExposed, bool isAsync);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafePipeHandle" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="isExposed" Type="System.Boolean" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="isAsync" Type="System.Boolean" Index="2" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="ba54e-242">要初始化的管道的 <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="ba54e-242">The <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> object of the pipe to initialize.</span></span></param>
        <param name="isExposed"><span data-ttu-id="ba54e-243">要公开句柄，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ba54e-243"><see langword="true" /> to expose the handle; otherwise, <see langword="false" />.</span></span></param>
        <param name="isAsync"><span data-ttu-id="ba54e-244"><see langword="true" /> 指示句柄已异步打开；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ba54e-244"><see langword="true" /> to indicate that the handle was opened asynchronously; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="ba54e-245">从指定的 <see cref="T:System.IO.Pipes.PipeStream" /> 对象中初始化 <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="ba54e-245">Initializes a <see cref="T:System.IO.Pipes.PipeStream" /> object from the specified <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-246">如果管道处于连接状态，则此方法还将 <xref:System.IO.Pipes.PipeStream.IsConnected%2A> 属性设置为 `true` 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-246">If the pipe is in a connected state, this method also sets the <xref:System.IO.Pipes.PipeStream.IsConnected%2A> property to `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ba54e-247">句柄无法绑定到管道中。</span><span class="sxs-lookup"><span data-stu-id="ba54e-247">A handle cannot be bound to the pipe.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAsync { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAsync : bool" Usage="System.IO.Pipes.PipeStream.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba54e-248">获取一个值，该值指示 <see cref="T:System.IO.Pipes.PipeStream" /> 对象是异步打开还是同步打开。</span><span class="sxs-lookup"><span data-stu-id="ba54e-248">Gets a value indicating whether a <see cref="T:System.IO.Pipes.PipeStream" /> object was opened asynchronously or synchronously.</span></span></summary>
        <value><span data-ttu-id="ba54e-249">如果 <see cref="T:System.IO.Pipes.PipeStream" /> 对象是异步打开的，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ba54e-249"><see langword="true" /> if the <see cref="T:System.IO.Pipes.PipeStream" /> object was opened asynchronously; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-250">此属性使您的代码能够 <xref:System.IO.Pipes.PipeStream.SafePipeHandle%2A> 正确使用属性。</span><span class="sxs-lookup"><span data-stu-id="ba54e-250">This property enables your code to use the <xref:System.IO.Pipes.PipeStream.SafePipeHandle%2A> property correctly.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConnected">
      <MemberSignature Language="C#" Value="public bool IsConnected { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConnected" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.IsConnected" />
      <MemberSignature Language="VB.NET" Value="Public Property IsConnected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:  property bool IsConnected {  public:&#xA;bool get(); protected:&#xA; void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsConnected : bool with get, set" Usage="System.IO.Pipes.PipeStream.IsConnected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba54e-251">获取或设置一个值，该值指示是否已连接 <see cref="T:System.IO.Pipes.PipeStream" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="ba54e-251">Gets or sets a value indicating whether a <see cref="T:System.IO.Pipes.PipeStream" /> object is connected.</span></span></summary>
        <value><span data-ttu-id="ba54e-252">如果已连接 <see cref="T:System.IO.Pipes.PipeStream" /> 对象，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ba54e-252"><see langword="true" /> if the <see cref="T:System.IO.Pipes.PipeStream" /> object is connected; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-253"><xref:System.IO.Pipes.PipeStream.IsConnected%2A> `true` 仅当对象已连接时，属性才 <xref:System.IO.Pipes.PipeStream> 会返回。</span><span class="sxs-lookup"><span data-stu-id="ba54e-253">The <xref:System.IO.Pipes.PipeStream.IsConnected%2A> property returns `true` only if the <xref:System.IO.Pipes.PipeStream> object is connected.</span></span> <span data-ttu-id="ba54e-254">如果此属性返回 `false` ，则管道可能正在等待连接，或可能已断开连接、已关闭或已损坏。</span><span class="sxs-lookup"><span data-stu-id="ba54e-254">If this property returns `false`, the pipe may be waiting to connect, or may be disconnected, closed, or broken.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHandleExposed">
      <MemberSignature Language="C#" Value="protected bool IsHandleExposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHandleExposed" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.IsHandleExposed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsHandleExposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsHandleExposed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHandleExposed : bool" Usage="System.IO.Pipes.PipeStream.IsHandleExposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba54e-255">获取一个值，该值指示是否公开了 <see cref="T:System.IO.Pipes.PipeStream" /> 对象的句柄。</span><span class="sxs-lookup"><span data-stu-id="ba54e-255">Gets a value indicating whether a handle to a <see cref="T:System.IO.Pipes.PipeStream" /> object is exposed.</span></span></summary>
        <value><span data-ttu-id="ba54e-256">如果公开了 <see cref="T:System.IO.Pipes.PipeStream" /> 对象的句柄，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ba54e-256"><see langword="true" /> if a handle to the <see cref="T:System.IO.Pipes.PipeStream" /> object is exposed; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-257">当获取当前对象所封装的管道的句柄时，将设置此属性的值 <xref:System.IO.Pipes.PipeStream> 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-257">The value of this property is set when obtaining a handle to the pipe that is encapsulated by the current <xref:System.IO.Pipes.PipeStream> object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMessageComplete">
      <MemberSignature Language="C#" Value="public bool IsMessageComplete { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMessageComplete" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.IsMessageComplete" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMessageComplete As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMessageComplete { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMessageComplete : bool" Usage="System.IO.Pipes.PipeStream.IsMessageComplete" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba54e-258">获取一个值，该值指示最近的读操作返回的消息中是否有更多数据。</span><span class="sxs-lookup"><span data-stu-id="ba54e-258">Gets a value indicating whether there is more data in the message returned from the most recent read operation.</span></span></summary>
        <value><span data-ttu-id="ba54e-259">如果消息中没有更多要读取的字符，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ba54e-259"><see langword="true" /> if there are no more characters to read in the message; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-260">如果管道的 <xref:System.IO.Pipes.PipeStream.ReadMode%2A> 属性被最近对或的调用设置为，则此属性是相关的 <xref:System.IO.Pipes.PipeTransmissionMode.Message> <xref:System.IO.Pipes.PipeStream.Read%2A> <xref:System.IO.Pipes.PipeStream.EndRead%2A> 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-260">This property is relevant if the pipe's <xref:System.IO.Pipes.PipeStream.ReadMode%2A> property was set to <xref:System.IO.Pipes.PipeTransmissionMode.Message> by the most recent call to <xref:System.IO.Pipes.PipeStream.Read%2A> or <xref:System.IO.Pipes.PipeStream.EndRead%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ba54e-261">管道不可连接。</span><span class="sxs-lookup"><span data-stu-id="ba54e-261">The pipe is not connected.</span></span>  
  
<span data-ttu-id="ba54e-262">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ba54e-262">-or-</span></span> 
<span data-ttu-id="ba54e-263">尚未设置管道句柄。</span><span class="sxs-lookup"><span data-stu-id="ba54e-263">The pipe handle has not been set.</span></span>  
  
<span data-ttu-id="ba54e-264">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ba54e-264">-or-</span></span> 
<span data-ttu-id="ba54e-265">管道的 <see cref="P:System.IO.Pipes.PipeStream.ReadMode" /> 属性值不是 <see cref="F:System.IO.Pipes.PipeTransmissionMode.Message" />。</span><span class="sxs-lookup"><span data-stu-id="ba54e-265">The pipe's <see cref="P:System.IO.Pipes.PipeStream.ReadMode" /> property value is not <see cref="F:System.IO.Pipes.PipeTransmissionMode.Message" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ba54e-266">管道已关闭。</span><span class="sxs-lookup"><span data-stu-id="ba54e-266">The pipe is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.Pipes.PipeStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba54e-267">获取流长度（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="ba54e-267">Gets the length of a stream, in bytes.</span></span></summary>
        <value><span data-ttu-id="ba54e-268">在所有情况下均为 0。</span><span class="sxs-lookup"><span data-stu-id="ba54e-268">0 in all cases.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-269"><xref:System.IO.Pipes.PipeStream> 类不支持 <xref:System.IO.Pipes.PipeStream.Length%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="ba54e-269">The <xref:System.IO.Pipes.PipeStream> class does not support the <xref:System.IO.Pipes.PipeStream.Length%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ba54e-270">始终引发。</span><span class="sxs-lookup"><span data-stu-id="ba54e-270">Always thrown.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="OutBufferSize">
      <MemberSignature Language="C#" Value="public virtual int OutBufferSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 OutBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.OutBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property OutBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int OutBufferSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.OutBufferSize : int" Usage="System.IO.Pipes.PipeStream.OutBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba54e-271">获取管道的出站缓冲区的大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="ba54e-271">Gets the size, in bytes, of the outbound buffer for a pipe.</span></span></summary>
        <value><span data-ttu-id="ba54e-272">出站缓冲区的大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="ba54e-272">The outbound buffer size, in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-273">如果 <xref:System.IO.Pipes.PipeStream.OutBufferSize%2A> 为0，则根据需要分配缓冲区大小。</span><span class="sxs-lookup"><span data-stu-id="ba54e-273">If <xref:System.IO.Pipes.PipeStream.OutBufferSize%2A> is 0, the buffer size is allocated as needed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ba54e-274">该流不可写入。</span><span class="sxs-lookup"><span data-stu-id="ba54e-274">The stream is unwriteable.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ba54e-275">管道正在等待连接。</span><span class="sxs-lookup"><span data-stu-id="ba54e-275">The pipe is waiting to connect.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ba54e-276">管道已中断或出现其他 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="ba54e-276">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.Pipes.PipeStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba54e-277">获取或设置当前流的当前位置。</span><span class="sxs-lookup"><span data-stu-id="ba54e-277">Gets or sets the current position of the current stream.</span></span></summary>
        <value><span data-ttu-id="ba54e-278">在所有情况下均为 0。</span><span class="sxs-lookup"><span data-stu-id="ba54e-278">0 in all cases.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-279"><xref:System.IO.Pipes.PipeStream> 类不支持 <xref:System.IO.Pipes.PipeStream.Position%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="ba54e-279">The <xref:System.IO.Pipes.PipeStream> class does not support the <xref:System.IO.Pipes.PipeStream.Position%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ba54e-280">始终引发。</span><span class="sxs-lookup"><span data-stu-id="ba54e-280">Always thrown.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;byte&gt; -&gt; int" Usage="pipeStream.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="ba54e-281">内存的区域。</span><span class="sxs-lookup"><span data-stu-id="ba54e-281">A region of memory.</span></span> <span data-ttu-id="ba54e-282">当此方法返回时，此区域的内容将替换为从当前源读取的字节。</span><span class="sxs-lookup"><span data-stu-id="ba54e-282">When this method returns, the contents of this region are replaced by the bytes read from the current source.</span></span></param>
        <summary><span data-ttu-id="ba54e-283">从当前流中读取一个字节序列，将其写入字节数组，并按读取的字节数向前移动流中的位置。</span><span class="sxs-lookup"><span data-stu-id="ba54e-283">Reads a sequence of bytes from the current stream, writes them to a byte array, and advances the position within the stream by the number of bytes read.</span></span></summary>
        <returns><span data-ttu-id="ba54e-284">读入 <paramref name="buffer" /> 中的总字节数。</span><span class="sxs-lookup"><span data-stu-id="ba54e-284">The total number of bytes read into the <paramref name="buffer" />.</span></span> <span data-ttu-id="ba54e-285">如果很多字节当前不可用，则这可小于在 <paramref name="buffer" /> 中分配的字节数；如果已到达流结尾，则为零 (0)。</span><span class="sxs-lookup"><span data-stu-id="ba54e-285">This can be less than the number of bytes allocated in <paramref name="buffer" /> if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="ba54e-286">使用 <xref:System.IO.Pipes.PipeStream.CanRead%2A> 属性可确定当前 <xref:System.IO.Pipes.PipeStream> 对象是否支持读操作。</span><span class="sxs-lookup"><span data-stu-id="ba54e-286">Use the <xref:System.IO.Pipes.PipeStream.CanRead%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports read operations.</span></span>

<span data-ttu-id="ba54e-287">使用 <xref:System.IO.Pipes.PipeStream.ReadAsync%2A> 方法从当前流中异步读取。</span><span class="sxs-lookup"><span data-stu-id="ba54e-287">Use the <xref:System.IO.Pipes.PipeStream.ReadAsync%2A> method to read asynchronously from the current stream.</span></span>

<span data-ttu-id="ba54e-288">此方法从当前流中读取最多 `buffer.Length` 字节，并将它们存储在中 `buffer` 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-288">This method reads a maximum of `buffer.Length` bytes from the current stream and stores them in `buffer`.</span></span> <span data-ttu-id="ba54e-289">流中的当前位置按读取的字节数提前;但是，如果发生异常，则流中的当前位置将保持不变。</span><span class="sxs-lookup"><span data-stu-id="ba54e-289">The current position within the stream is advanced by the number of bytes read; however, if an exception occurs, the current position within the stream remains unchanged.</span></span>

<span data-ttu-id="ba54e-290">如果没有数据可用，则此方法将被阻止，直到至少有一个字节的数据可供读取。</span><span class="sxs-lookup"><span data-stu-id="ba54e-290">This method will block until at least one byte of data can be read, in the event that no data is available.</span></span>

<span data-ttu-id="ba54e-291">仅当流中没有更多的数据，但不 (需要更多的数据时，此方法才会返回0，如闭合套接字或文件尾) 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-291">This method returns 0 only when there is no more data in the stream and no more is expected (such as a closed socket or end of file).</span></span>

<span data-ttu-id="ba54e-292">即使尚未到达流的末尾，此方法也可以自由返回比所请求的更少的字节。</span><span class="sxs-lookup"><span data-stu-id="ba54e-292">This method is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>

<span data-ttu-id="ba54e-293">用于 `BinaryReader` 读取基元数据类型。</span><span class="sxs-lookup"><span data-stu-id="ba54e-293">Use `BinaryReader` for reading primitive data types.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba54e-294">读取的字节数长于缓冲区长度。</span><span class="sxs-lookup"><span data-stu-id="ba54e-294">The number of bytes read was longer than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ba54e-295">流不支持读取。</span><span class="sxs-lookup"><span data-stu-id="ba54e-295">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ba54e-296">无法访问关闭的管道。</span><span class="sxs-lookup"><span data-stu-id="ba54e-296">Cannot access a closed pipe.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ba54e-297">管道尚未连接。</span><span class="sxs-lookup"><span data-stu-id="ba54e-297">The pipe hasn't been connected yet.</span></span>

<span data-ttu-id="ba54e-298">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ba54e-298">-or-</span></span>

<span data-ttu-id="ba54e-299">管道处于断开连接状态。</span><span class="sxs-lookup"><span data-stu-id="ba54e-299">The pipe is in a disconnected state.</span></span>

<span data-ttu-id="ba54e-300">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ba54e-300">-or-</span></span>

<span data-ttu-id="ba54e-301">尚未设置管道句柄。</span><span class="sxs-lookup"><span data-stu-id="ba54e-301">The pipe handle has not been set.</span></span> <span data-ttu-id="ba54e-302">（你的 <see cref="T:System.IO.Pipes.PipeStream" /> 实现是否调用 <see cref="M:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />？</span><span class="sxs-lookup"><span data-stu-id="ba54e-302">(Did your <see cref="T:System.IO.Pipes.PipeStream" /> implementation call <see cref="M:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />?</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="pipeStream.Read (buffer, offset, count)" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 count) cil managed" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([in]unsigned int8[] buffer, int32 offset, int32 count) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="ba54e-303">当此方法返回时，包含指定的字节数组，此数组中 <paramref name="offset" /> 和 (<paramref name="offset" /> + <paramref name="count" /> - 1) 之间的值被从当前源中读取的字节所替换。</span><span class="sxs-lookup"><span data-stu-id="ba54e-303">When this method returns, contains the specified byte array with the values between <paramref name="offset" /> and (<paramref name="offset" /> + <paramref name="count" /> - 1) replaced by the bytes read from the current source.</span></span></param>
        <param name="offset"><span data-ttu-id="ba54e-304"><paramref name="buffer" /> 数组中的字节偏移量，其中读取的字节将被替换。</span><span class="sxs-lookup"><span data-stu-id="ba54e-304">The byte offset in the <paramref name="buffer" /> array at which the bytes that are read will be placed.</span></span></param>
        <param name="count"><span data-ttu-id="ba54e-305">最多读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="ba54e-305">The maximum number of bytes to read.</span></span></param>
        <summary><span data-ttu-id="ba54e-306">从指定长度的指定位置开始，从流中读取一个字节块，并将数据写入指定的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="ba54e-306">Reads a block of bytes from a stream and writes the data to a specified buffer starting at a specified position for a specified length.</span></span></summary>
        <returns><span data-ttu-id="ba54e-307">读取到 <paramref name="buffer" /> 的总字节数。</span><span class="sxs-lookup"><span data-stu-id="ba54e-307">The total number of bytes that are read into <paramref name="buffer" />.</span></span> <span data-ttu-id="ba54e-308">如果当前可用的字节数没有请求的那么多，则此数小于请求的字节数；或如果已到达流的末尾，则为零。</span><span class="sxs-lookup"><span data-stu-id="ba54e-308">This might be less than the number of bytes requested if that number of bytes is not currently available, or 0 if the end of the stream is reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-309">使用 <xref:System.IO.Pipes.PipeStream.CanRead%2A> 属性可确定当前 <xref:System.IO.Pipes.PipeStream> 对象是否支持读操作。</span><span class="sxs-lookup"><span data-stu-id="ba54e-309">Use the <xref:System.IO.Pipes.PipeStream.CanRead%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports read operations.</span></span>  
  
 <span data-ttu-id="ba54e-310">调用 <xref:System.IO.Pipes.PipeStream.Read%2A> 方法会阻止，直到 `count` 读取字节或到达流的末尾。</span><span class="sxs-lookup"><span data-stu-id="ba54e-310">Calling the <xref:System.IO.Pipes.PipeStream.Read%2A> method blocks until `count` bytes are read or the end of the stream is reached.</span></span> <span data-ttu-id="ba54e-311">有关异步读取操作，请参阅 <xref:System.IO.Pipes.PipeStream.BeginRead%2A> 和 <xref:System.IO.Pipes.PipeStream.EndRead%2A> 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-311">For asynchronous read operations, see <xref:System.IO.Pipes.PipeStream.BeginRead%2A> and <xref:System.IO.Pipes.PipeStream.EndRead%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba54e-312">下面的示例创建一个匿名管道客户端和管道服务器。</span><span class="sxs-lookup"><span data-stu-id="ba54e-312">The following example creates an anonymous pipe client and pipe server.</span></span> <span data-ttu-id="ba54e-313">管道服务器使用 <xref:System.IO.Pipes.PipeStream.Read%2A> 方法将管道客户端中的一系列字节作为验证代码进行读取。</span><span class="sxs-lookup"><span data-stu-id="ba54e-313">The pipe server uses the <xref:System.IO.Pipes.PipeStream.Read%2A> method to read a series of bytes from the pipe client as a validation code.</span></span> <span data-ttu-id="ba54e-314">管道客户端和管道服务器都属于同一示例。</span><span class="sxs-lookup"><span data-stu-id="ba54e-314">Both the pipe client and the pipe server are part of the same example.</span></span> <span data-ttu-id="ba54e-315">该示例的服务器部分创建一个客户端进程，并将匿名管道句柄作为参数传递。</span><span class="sxs-lookup"><span data-stu-id="ba54e-315">The server portion of the example creates a client process and passes it an anonymous pipe handle as an argument.</span></span>  
  
 [!code-cpp[System.IO.Pipes.PipeStream#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.io.pipes.pipestream/cpp/sample.cpp#1)]
 [!code-csharp[System.IO.Pipes.PipeStream#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.pipes.pipestream/cs/sample.cs#1)]
 [!code-vb[System.IO.Pipes.PipeStream#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.pipes.pipestream/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba54e-316"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ba54e-316"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba54e-317"><paramref name="offset" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="ba54e-317"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="ba54e-318">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ba54e-318">-or-</span></span> 
 <span data-ttu-id="ba54e-319"><paramref name="count" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="ba54e-319"><paramref name="count" /> is less than 0.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba54e-320"><paramref name="count" /> 大于 <paramref name="buffer" /> 中可用的字节数。</span><span class="sxs-lookup"><span data-stu-id="ba54e-320"><paramref name="count" /> is greater than the number of bytes available in <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ba54e-321">管道已关闭。</span><span class="sxs-lookup"><span data-stu-id="ba54e-321">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ba54e-322">管道不支持读操作。</span><span class="sxs-lookup"><span data-stu-id="ba54e-322">The pipe does not support read operations.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ba54e-323">管道已断开连接、正在等待连接或尚未设置句柄。</span><span class="sxs-lookup"><span data-stu-id="ba54e-323">The pipe is disconnected, waiting to connect, or the handle has not been set.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ba54e-324">发生了 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="ba54e-324">Any I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadAsync (buffer As Memory(Of Byte), Optional cancellationToken As CancellationToken = Nothing) As ValueTask(Of Integer)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="pipeStream.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="ba54e-325">要将数据写入的内存区域。</span><span class="sxs-lookup"><span data-stu-id="ba54e-325">The region of memory to write the data into.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="ba54e-326">要监视取消请求的标记。</span><span class="sxs-lookup"><span data-stu-id="ba54e-326">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="ba54e-327">默认值是 <see cref="P:System.Threading.CancellationToken.None" />。</span><span class="sxs-lookup"><span data-stu-id="ba54e-327">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="ba54e-328">从当前流异步读取字节的序列，将其写入字节内存范围，按读取的字节数向前移动流中的位置，并监视取消请求。</span><span class="sxs-lookup"><span data-stu-id="ba54e-328">Asynchronously reads a sequence of bytes from the current stream, writes them to a byte memory range, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="ba54e-329">表示异步读取操作的任务。</span><span class="sxs-lookup"><span data-stu-id="ba54e-329">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="ba54e-330">其 <see cref="P:System.Threading.Tasks.ValueTask`1.Result" /> 属性的值包含读入缓冲区的总字节数。</span><span class="sxs-lookup"><span data-stu-id="ba54e-330">The value of its <see cref="P:System.Threading.Tasks.ValueTask`1.Result" /> property contains the total number of bytes read into the buffer.</span></span> <span data-ttu-id="ba54e-331">如果很多字节当前不可用，则结果值可小于在缓冲区中分配的字节数；如果已到达流结尾，则结果值可以为 0（零）。</span><span class="sxs-lookup"><span data-stu-id="ba54e-331">The result value can be less than the number of bytes allocated in the buffer if that many bytes are not currently available, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="ba54e-332"><xref:System.IO.Pipes.PipeStream.ReadAsync%2A>方法使你可以在不阻塞主线程的情况下执行占用大量资源的 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="ba54e-332">The <xref:System.IO.Pipes.PipeStream.ReadAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="ba54e-333">在 Windows 8.x 应用商店应用或桌面应用中一个耗时的流操作可能阻塞 UI 线程并让应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="ba54e-333">This performance consideration is particularly important in a Windows 8.x Store app or desktop app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="ba54e-334">异步方法与 `async` `await` Visual Basic 和 c # 中的和关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="ba54e-334">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  

<span data-ttu-id="ba54e-335">使用 <xref:System.IO.Pipes.PipeStream.CanRead%2A> 属性可确定当前实例是否支持读取。</span><span class="sxs-lookup"><span data-stu-id="ba54e-335">Use the <xref:System.IO.Pipes.PipeStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>  

<span data-ttu-id="ba54e-336">如果在操作完成前取消该操作，则返回的任务包含 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 属性的值 <xref:System.Threading.Tasks.Task.Status> 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-336">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> value for the <xref:System.Threading.Tasks.Task.Status> property.</span></span>  

          ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ba54e-337">流不支持读取。</span><span class="sxs-lookup"><span data-stu-id="ba54e-337">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ba54e-338">无法访问关闭的管道。</span><span class="sxs-lookup"><span data-stu-id="ba54e-338">Cannot access a closed pipe.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ba54e-339">管道尚未连接。</span><span class="sxs-lookup"><span data-stu-id="ba54e-339">The pipe hasn't been connected yet.</span></span>

<span data-ttu-id="ba54e-340">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ba54e-340">-or-</span></span>

<span data-ttu-id="ba54e-341">管道处于断开连接状态。</span><span class="sxs-lookup"><span data-stu-id="ba54e-341">The pipe is in a disconnected state.</span></span>

<span data-ttu-id="ba54e-342">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ba54e-342">-or-</span></span>

<span data-ttu-id="ba54e-343">尚未设置管道句柄。</span><span class="sxs-lookup"><span data-stu-id="ba54e-343">The pipe handle has not been set.</span></span> <span data-ttu-id="ba54e-344">（你的 <see cref="T:System.IO.Pipes.PipeStream" /> 实现是否调用 <see cref="M:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />？</span><span class="sxs-lookup"><span data-stu-id="ba54e-344">(Did your <see cref="T:System.IO.Pipes.PipeStream" /> implementation call <see cref="M:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />?</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadAsync (buffer As Byte(), offset As Integer, count As Integer, cancellationToken As CancellationToken) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="pipeStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="ba54e-345">要写入数据的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="ba54e-345">The buffer to write the data into.</span></span></param>
        <param name="offset"><span data-ttu-id="ba54e-346"><paramref name="buffer" /> 中的字节偏移量，从该偏移量开始写入从流中读取的数据。</span><span class="sxs-lookup"><span data-stu-id="ba54e-346">The byte offset in <paramref name="buffer" /> at which to begin writing data from the stream.</span></span></param>
        <param name="count"><span data-ttu-id="ba54e-347">最多读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="ba54e-347">The maximum number of bytes to read.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="ba54e-348">要监视取消请求的标记。</span><span class="sxs-lookup"><span data-stu-id="ba54e-348">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="ba54e-349">默认值是 <see cref="P:System.Threading.CancellationToken.None" />。</span><span class="sxs-lookup"><span data-stu-id="ba54e-349">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="ba54e-350">从指定字节数的指定位置开始，将当前流中的字节序列异步读取到字节数组，按读取的字节数向前移动流中的位置，并监视取消请求。</span><span class="sxs-lookup"><span data-stu-id="ba54e-350">Asynchronously reads a sequence of bytes from the current stream to a byte array starting at a specified position for a specified number of bytes, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="ba54e-351">表示异步读取操作的任务。</span><span class="sxs-lookup"><span data-stu-id="ba54e-351">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="ba54e-352">其 <see cref="P:System.Threading.Tasks.Task`1.Result" /> 属性的值包含读入缓冲区的总字节数。</span><span class="sxs-lookup"><span data-stu-id="ba54e-352">The value of its <see cref="P:System.Threading.Tasks.Task`1.Result" /> property contains the total number of bytes read into the buffer.</span></span> <span data-ttu-id="ba54e-353">如果当前可用字节数少于所请求的字节数，则该结果值可小于所请求的字节数；如果已到达流结尾时，则为 0（零）。</span><span class="sxs-lookup"><span data-stu-id="ba54e-353">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="ba54e-354"><xref:System.IO.Pipes.PipeStream.ReadAsync%2A>方法使你可以在不阻塞主线程的情况下执行占用大量资源的 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="ba54e-354">The <xref:System.IO.Pipes.PipeStream.ReadAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="ba54e-355">在 Windows 8.x 应用商店应用或桌面应用中一个耗时的流操作可能阻塞 UI 线程并让应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="ba54e-355">This performance consideration is particularly important in a Windows 8.x Store app or desktop app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="ba54e-356">异步方法与 `async` `await` Visual Basic 和 c # 中的和关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="ba54e-356">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="ba54e-357">使用 <xref:System.IO.Pipes.PipeStream.CanRead%2A> 属性可确定当前实例是否支持读取。</span><span class="sxs-lookup"><span data-stu-id="ba54e-357">Use the <xref:System.IO.Pipes.PipeStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>

<span data-ttu-id="ba54e-358">如果在操作完成前取消该操作，则返回的任务包含 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 属性的值 <xref:System.Threading.Tasks.Task.Status%2A> 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-358">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ba54e-359">流不支持读取。</span><span class="sxs-lookup"><span data-stu-id="ba54e-359">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ba54e-360">无法访问关闭的管道。</span><span class="sxs-lookup"><span data-stu-id="ba54e-360">Cannot access a closed pipe.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ba54e-361">管道尚未连接。</span><span class="sxs-lookup"><span data-stu-id="ba54e-361">The pipe hasn't been connected yet.</span></span>

<span data-ttu-id="ba54e-362">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ba54e-362">-or-</span></span>

<span data-ttu-id="ba54e-363">管道处于断开连接状态。</span><span class="sxs-lookup"><span data-stu-id="ba54e-363">The pipe is in a disconnected state.</span></span>

<span data-ttu-id="ba54e-364">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ba54e-364">-or-</span></span>

<span data-ttu-id="ba54e-365">尚未设置管道句柄。</span><span class="sxs-lookup"><span data-stu-id="ba54e-365">The pipe handle has not been set.</span></span> <span data-ttu-id="ba54e-366">（你的 <see cref="T:System.IO.Pipes.PipeStream" /> 实现是否调用 <see cref="M:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />？</span><span class="sxs-lookup"><span data-stu-id="ba54e-366">(Did your <see cref="T:System.IO.Pipes.PipeStream" /> implementation call <see cref="M:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />?</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="pipeStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba54e-367">从管道读取字节。</span><span class="sxs-lookup"><span data-stu-id="ba54e-367">Reads a byte from a pipe.</span></span></summary>
        <returns><span data-ttu-id="ba54e-368">强制转换为 <see cref="T:System.Int32" /> 的字节或 -1 指示到达流的末尾（管道已关闭）。</span><span class="sxs-lookup"><span data-stu-id="ba54e-368">The byte, cast to <see cref="T:System.Int32" />, or -1 indicates the end of the stream (the pipe has been closed).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-369">使用 <xref:System.IO.Pipes.PipeStream.CanRead%2A> 属性可确定当前 <xref:System.IO.Pipes.PipeStream> 对象是否支持读操作。</span><span class="sxs-lookup"><span data-stu-id="ba54e-369">Use the <xref:System.IO.Pipes.PipeStream.CanRead%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports read operations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ba54e-370">管道已关闭。</span><span class="sxs-lookup"><span data-stu-id="ba54e-370">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ba54e-371">管道不支持读操作。</span><span class="sxs-lookup"><span data-stu-id="ba54e-371">The pipe does not support read operations.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ba54e-372">管道已断开连接、正在等待连接或尚未设置句柄。</span><span class="sxs-lookup"><span data-stu-id="ba54e-372">The pipe is disconnected, waiting to connect, or the handle has not been set.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ba54e-373">发生了 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="ba54e-373">Any I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadMode">
      <MemberSignature Language="C#" Value="public virtual System.IO.Pipes.PipeTransmissionMode ReadMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Pipes.PipeTransmissionMode ReadMode" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.ReadMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ReadMode As PipeTransmissionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::IO::Pipes::PipeTransmissionMode ReadMode { System::IO::Pipes::PipeTransmissionMode get(); void set(System::IO::Pipes::PipeTransmissionMode value); };" />
      <MemberSignature Language="F#" Value="member this.ReadMode : System.IO.Pipes.PipeTransmissionMode with get, set" Usage="System.IO.Pipes.PipeStream.ReadMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[set: System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Pipes.PipeTransmissionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba54e-374">获取或设置 <see cref="T:System.IO.Pipes.PipeStream" /> 对象的读取模式。</span><span class="sxs-lookup"><span data-stu-id="ba54e-374">Gets or sets the reading mode for a <see cref="T:System.IO.Pipes.PipeStream" /> object.</span></span></summary>
        <value><span data-ttu-id="ba54e-375"><see cref="T:System.IO.Pipes.PipeTransmissionMode" /> 值之一，指示如何从管道读取 <see cref="T:System.IO.Pipes.PipeStream" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="ba54e-375">One of the <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> values that indicates how the <see cref="T:System.IO.Pipes.PipeStream" /> object reads from the pipe.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-376">匿名管道不支持 <xref:System.IO.Pipes.PipeTransmissionMode.Message> 模式消息传输。</span><span class="sxs-lookup"><span data-stu-id="ba54e-376">Anonymous pipes do not support <xref:System.IO.Pipes.PipeTransmissionMode.Message> mode message transmission.</span></span>  

 <span data-ttu-id="ba54e-377">若要避免 <xref:System.InvalidOperationException> 访问 `ReadMode` ， <xref:System.IO.Pipes.PipeStream.IsConnected> 可使用来验证管道是否已连接。</span><span class="sxs-lookup"><span data-stu-id="ba54e-377">To avoid an <xref:System.InvalidOperationException> accessing `ReadMode`, <xref:System.IO.Pipes.PipeStream.IsConnected> can be used to verify the pipe is connected.</span></span>
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba54e-378">所提供的值不是有效的 <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> 值。</span><span class="sxs-lookup"><span data-stu-id="ba54e-378">The supplied value is not a valid <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> value.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ba54e-379">提供的值并非此管道流支持的 <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> 值。</span><span class="sxs-lookup"><span data-stu-id="ba54e-379">The supplied value is not a supported <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> value for this pipe stream.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ba54e-380">尚未设置句柄。</span><span class="sxs-lookup"><span data-stu-id="ba54e-380">The handle has not been set.</span></span>  
  
 <span data-ttu-id="ba54e-381">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ba54e-381">-or-</span></span>  
  
 <span data-ttu-id="ba54e-382">管道正在等待连接到命名客户端。</span><span class="sxs-lookup"><span data-stu-id="ba54e-382">The pipe is waiting to connect with a named client.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ba54e-383">管道已中断或命名客户端出现 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="ba54e-383">The pipe is broken or an I/O error occurred with a named client.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SafePipeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafePipeHandle SafePipeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafePipeHandle SafePipeHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.SafePipeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafePipeHandle As SafePipeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafePipeHandle ^ SafePipeHandle { Microsoft::Win32::SafeHandles::SafePipeHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafePipeHandle : Microsoft.Win32.SafeHandles.SafePipeHandle" Usage="System.IO.Pipes.PipeStream.SafePipeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafePipeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba54e-384">获取当前 <see cref="T:System.IO.Pipes.PipeStream" /> 对象所封装的本地管道末端的安全句柄。</span><span class="sxs-lookup"><span data-stu-id="ba54e-384">Gets the safe handle for the local end of the pipe that the current <see cref="T:System.IO.Pipes.PipeStream" /> object encapsulates.</span></span></summary>
        <value><span data-ttu-id="ba54e-385">由当前 <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> 对象所封装的管道的一个 <see cref="T:System.IO.Pipes.PipeStream" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="ba54e-385">A <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> object for the pipe that is encapsulated by the current <see cref="T:System.IO.Pipes.PipeStream" /> object.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ba54e-386">尚未设置管道句柄。</span><span class="sxs-lookup"><span data-stu-id="ba54e-386">The pipe handle has not been set.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ba54e-387">管道已关闭。</span><span class="sxs-lookup"><span data-stu-id="ba54e-387">The pipe is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="pipeStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset"><span data-ttu-id="ba54e-388">相对于 <paramref name="origin" /> 的点，从此处开始查找。</span><span class="sxs-lookup"><span data-stu-id="ba54e-388">The point, relative to <paramref name="origin" />, to begin seeking from.</span></span></param>
        <param name="origin"><span data-ttu-id="ba54e-389">使用 <see cref="T:System.IO.SeekOrigin" /> 类型的值，将开始位置、结束位置或当前位置指定为 <paramref name="offset" /> 的参考点。</span><span class="sxs-lookup"><span data-stu-id="ba54e-389">Specifies the beginning, the end, or the current position as a reference point for <paramref name="offset" />, using a value of type <see cref="T:System.IO.SeekOrigin" />.</span></span></param>
        <summary><span data-ttu-id="ba54e-390">将当前流的当前位置设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="ba54e-390">Sets the current position of the current stream to the specified value.</span></span></summary>
        <returns><span data-ttu-id="ba54e-391">流中的新位置。</span><span class="sxs-lookup"><span data-stu-id="ba54e-391">The new position in the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-392"><xref:System.IO.Pipes.PipeStream.Seek%2A>管道不支持方法，并在 <xref:System.NotSupportedException> 调用时引发。</span><span class="sxs-lookup"><span data-stu-id="ba54e-392">The <xref:System.IO.Pipes.PipeStream.Seek%2A> method is not supported in pipes and raises a <xref:System.NotSupportedException> when it is called.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.IO.Pipes.PipeSecurity pipeSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.IO.Pipes.PipeSecurity pipeSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.SetAccessControl(System.IO.Pipes.PipeSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (pipeSecurity As PipeSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::IO::Pipes::PipeSecurity ^ pipeSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.IO.Pipes.PipeSecurity -&gt; unit" Usage="pipeStream.SetAccessControl pipeSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pipeSecurity" Type="System.IO.Pipes.PipeSecurity" Index="0" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pipeSecurity"><span data-ttu-id="ba54e-393">一个 <see cref="T:System.IO.Pipes.PipeSecurity" /> 对象，该对象指定要应用于当前管道的访问控制列表 (ACL) 项。</span><span class="sxs-lookup"><span data-stu-id="ba54e-393">A <see cref="T:System.IO.Pipes.PipeSecurity" /> object that specifies an access control list (ACL) entry to apply to the current pipe.</span></span></param>
        <summary><span data-ttu-id="ba54e-394">将 <see cref="T:System.IO.Pipes.PipeSecurity" /> 对象所指定的访问控制列表 (ACL) 项应用于由当前 <see cref="T:System.IO.Pipes.PipeStream" /> 对象指定的管道。</span><span class="sxs-lookup"><span data-stu-id="ba54e-394">Applies the access control list (ACL) entries specified by a <see cref="T:System.IO.Pipes.PipeSecurity" /> object to the pipe specified by the current <see cref="T:System.IO.Pipes.PipeStream" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-395"> (ACL) 的访问控制列表描述了在指定文件上执行特定操作的权限（或不具有这些权限）。</span><span class="sxs-lookup"><span data-stu-id="ba54e-395">An access control list (ACL) describes individuals and/or groups that have, or do not have, rights to perform specific actions on a specified file.</span></span> <span data-ttu-id="ba54e-396">有关详细信息，请参阅[如何：添加或删除访问控制列表条目](/dotnet/standard/io/how-to-add-or-remove-access-control-list-entries)。</span><span class="sxs-lookup"><span data-stu-id="ba54e-396">For more information, see [How to: Add or Remove Access Control List Entries](/dotnet/standard/io/how-to-add-or-remove-access-control-list-entries).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ba54e-397">管道已关闭。</span><span class="sxs-lookup"><span data-stu-id="ba54e-397">The pipe is closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba54e-398"><paramref name="pipeSecurity" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ba54e-398"><paramref name="pipeSecurity" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="ba54e-399">用于设置安全信息的基础调用失败。</span><span class="sxs-lookup"><span data-stu-id="ba54e-399">The underlying call to set security information failed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ba54e-400">用于设置安全信息的基础调用失败。</span><span class="sxs-lookup"><span data-stu-id="ba54e-400">The underlying call to set security information failed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ba54e-401">用于设置安全信息的基础调用失败。</span><span class="sxs-lookup"><span data-stu-id="ba54e-401">The underlying call to set security information failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="pipeStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba54e-402">流的新长度。</span><span class="sxs-lookup"><span data-stu-id="ba54e-402">The new length of the stream.</span></span></param>
        <summary><span data-ttu-id="ba54e-403">将当前流的长度设为指定值。</span><span class="sxs-lookup"><span data-stu-id="ba54e-403">Sets the length of the current stream to the specified value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-404"><xref:System.IO.Pipes.PipeStream>类不支持 <xref:System.IO.Pipes.PipeStream.SetLength%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="ba54e-404">The <xref:System.IO.Pipes.PipeStream> class does not support the <xref:System.IO.Pipes.PipeStream.SetLength%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransmissionMode">
      <MemberSignature Language="C#" Value="public virtual System.IO.Pipes.PipeTransmissionMode TransmissionMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Pipes.PipeTransmissionMode TransmissionMode" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.TransmissionMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TransmissionMode As PipeTransmissionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::IO::Pipes::PipeTransmissionMode TransmissionMode { System::IO::Pipes::PipeTransmissionMode get(); };" />
      <MemberSignature Language="F#" Value="member this.TransmissionMode : System.IO.Pipes.PipeTransmissionMode" Usage="System.IO.Pipes.PipeStream.TransmissionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Pipes.PipeTransmissionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba54e-405">获取当前管道支持的管道传输模式。</span><span class="sxs-lookup"><span data-stu-id="ba54e-405">Gets the pipe transmission mode supported by the current pipe.</span></span></summary>
        <value><span data-ttu-id="ba54e-406"><see cref="T:System.IO.Pipes.PipeTransmissionMode" /> 值之一，指示当前管道支持的传输模式。</span><span class="sxs-lookup"><span data-stu-id="ba54e-406">One of the <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> values that indicates the transmission mode supported by the current pipe.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-407">匿名管道不支持 <xref:System.IO.Pipes.PipeTransmissionMode.Message> 模式消息传输。</span><span class="sxs-lookup"><span data-stu-id="ba54e-407">Anonymous pipes do not support <xref:System.IO.Pipes.PipeTransmissionMode.Message> mode message transmission.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ba54e-408">管道已关闭。</span><span class="sxs-lookup"><span data-stu-id="ba54e-408">The pipe is closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ba54e-409">尚未设置句柄。</span><span class="sxs-lookup"><span data-stu-id="ba54e-409">The handle has not been set.</span></span>  
  
 <span data-ttu-id="ba54e-410">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ba54e-410">-or-</span></span>  
  
 <span data-ttu-id="ba54e-411">管道正在等待连接匿名客户端/服务器操作，或正在等待连接命名管道。</span><span class="sxs-lookup"><span data-stu-id="ba54e-411">The pipe is waiting to connect in an anonymous client/server operation or with a named client.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ba54e-412">管道已中断或出现其他 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="ba54e-412">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitForPipeDrain">
      <MemberSignature Language="C#" Value="public void WaitForPipeDrain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForPipeDrain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.WaitForPipeDrain" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForPipeDrain ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForPipeDrain();" />
      <MemberSignature Language="F#" Value="member this.WaitForPipeDrain : unit -&gt; unit" Usage="pipeStream.WaitForPipeDrain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0">
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("windows")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("windows")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba54e-413">等待管道另一端读取所有发送的字节。</span><span class="sxs-lookup"><span data-stu-id="ba54e-413">Waits for the other end of the pipe to read all sent bytes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-414"><xref:System.IO.Pipes.PipeStream.WaitForPipeDrain%2A>方法阻止，直到管道的另一端读取所有发送的字节。</span><span class="sxs-lookup"><span data-stu-id="ba54e-414">The <xref:System.IO.Pipes.PipeStream.WaitForPipeDrain%2A> method blocks until the other end of the pipe has read all sent bytes.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ba54e-415">管道已关闭。</span><span class="sxs-lookup"><span data-stu-id="ba54e-415">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ba54e-416">管道不支持写操作。</span><span class="sxs-lookup"><span data-stu-id="ba54e-416">The pipe does not support write operations.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ba54e-417">管道已中断或出现其他 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="ba54e-417">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Write : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="pipeStream.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="ba54e-418">内存的区域。</span><span class="sxs-lookup"><span data-stu-id="ba54e-418">A region of memory.</span></span> <span data-ttu-id="ba54e-419">此方法将此区域的内容复制到当前流。</span><span class="sxs-lookup"><span data-stu-id="ba54e-419">This method copies the contents of this region to the current stream.</span></span></param>
        <summary><span data-ttu-id="ba54e-420">将字节序列写入当前流，并按写入的字节数向前调整流的当前位置。</span><span class="sxs-lookup"><span data-stu-id="ba54e-420">Writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="ba54e-421">使用 <xref:System.IO.Pipes.PipeStream.CanWrite%2A> 属性可确定当前实例是否支持写入。</span><span class="sxs-lookup"><span data-stu-id="ba54e-421">Use the <xref:System.IO.Pipes.PipeStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span> <span data-ttu-id="ba54e-422">使用 <xref:System.IO.Pipes.PipeStream.WriteAsync%2A> 方法异步写入当前流。</span><span class="sxs-lookup"><span data-stu-id="ba54e-422">Use the <xref:System.IO.Pipes.PipeStream.WriteAsync%2A> method to write asynchronously to the current stream.</span></span>  

<span data-ttu-id="ba54e-423">如果写入操作成功，则流中的位置将按写入的字节数向前推进。</span><span class="sxs-lookup"><span data-stu-id="ba54e-423">If the write operation is successful, the position within the stream advances by the number of bytes written.</span></span> <span data-ttu-id="ba54e-424">如果发生异常，则流中的位置将保持不变。</span><span class="sxs-lookup"><span data-stu-id="ba54e-424">If an exception occurs, the position within the stream remains unchanged.</span></span>  

          ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ba54e-425">流不支持写入。</span><span class="sxs-lookup"><span data-stu-id="ba54e-425">The stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ba54e-426">无法访问关闭的管道。</span><span class="sxs-lookup"><span data-stu-id="ba54e-426">Cannot access a closed pipe.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ba54e-427">管道已断开。</span><span class="sxs-lookup"><span data-stu-id="ba54e-427">The pipe is broken.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ba54e-428">管道尚未连接。</span><span class="sxs-lookup"><span data-stu-id="ba54e-428">The pipe hasn't been connected yet.</span></span>

<span data-ttu-id="ba54e-429">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ba54e-429">-or-</span></span>

<span data-ttu-id="ba54e-430">管道处于断开连接状态。</span><span class="sxs-lookup"><span data-stu-id="ba54e-430">The pipe is in a disconnected state.</span></span>

<span data-ttu-id="ba54e-431">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ba54e-431">-or-</span></span>

<span data-ttu-id="ba54e-432">尚未设置管道句柄。</span><span class="sxs-lookup"><span data-stu-id="ba54e-432">The pipe handle has not been set.</span></span> <span data-ttu-id="ba54e-433">（你的 <see cref="T:System.IO.Pipes.PipeStream" /> 实现是否调用 <see cref="M:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />？</span><span class="sxs-lookup"><span data-stu-id="ba54e-433">(Did your <see cref="T:System.IO.Pipes.PipeStream" /> implementation call <see cref="M:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />?</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="pipeStream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="ba54e-434">包含要写入管道的数据的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="ba54e-434">The buffer that contains data to write to the pipe.</span></span></param>
        <param name="offset"><span data-ttu-id="ba54e-435"><paramref name="buffer" /> 中的从零开始的字节偏移量，从此处开始将字节复制到当前流。</span><span class="sxs-lookup"><span data-stu-id="ba54e-435">The zero-based byte offset in <paramref name="buffer" /> at which to begin copying bytes to the current stream.</span></span></param>
        <param name="count"><span data-ttu-id="ba54e-436">要写入当前流的最大字节数。</span><span class="sxs-lookup"><span data-stu-id="ba54e-436">The maximum number of bytes to write to the current stream.</span></span></param>
        <summary><span data-ttu-id="ba54e-437">使用缓冲区中的数据将字节块写入当前流。</span><span class="sxs-lookup"><span data-stu-id="ba54e-437">Writes a block of bytes to the current stream using data from a buffer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-438">使用 <xref:System.IO.Pipes.PipeStream.CanWrite%2A> 属性可确定当前 <xref:System.IO.Pipes.PipeStream> 对象是否支持写入操作。</span><span class="sxs-lookup"><span data-stu-id="ba54e-438">Use the <xref:System.IO.Pipes.PipeStream.CanWrite%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports write operations.</span></span>  
  
 <span data-ttu-id="ba54e-439">有关异步写入操作，请参阅 <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> 和 <xref:System.IO.Pipes.PipeStream.EndWrite%2A> 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-439">For asynchronous write operations, see <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> and <xref:System.IO.Pipes.PipeStream.EndWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba54e-440"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ba54e-440"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba54e-441"><paramref name="offset" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="ba54e-441"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="ba54e-442">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ba54e-442">-or-</span></span> 
 <span data-ttu-id="ba54e-443"><paramref name="count" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="ba54e-443"><paramref name="count" /> is less than 0.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba54e-444"><paramref name="count" /> 大于 <paramref name="buffer" /> 中可用的字节数。</span><span class="sxs-lookup"><span data-stu-id="ba54e-444"><paramref name="count" /> is greater than the number of bytes available in <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ba54e-445">管道已关闭。</span><span class="sxs-lookup"><span data-stu-id="ba54e-445">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ba54e-446">管道不支持写操作。</span><span class="sxs-lookup"><span data-stu-id="ba54e-446">The pipe does not support write operations.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ba54e-447">管道已中断或出现其他 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="ba54e-447">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function WriteAsync (buffer As ReadOnlyMemory(Of Byte), Optional cancellationToken As CancellationToken = Nothing) As ValueTask" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask" Usage="pipeStream.WriteAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="ba54e-448">从中写入数据的内存区域。</span><span class="sxs-lookup"><span data-stu-id="ba54e-448">The region of memory to write data from.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="ba54e-449">要监视取消请求的标记。</span><span class="sxs-lookup"><span data-stu-id="ba54e-449">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="ba54e-450">默认值是 <see cref="P:System.Threading.CancellationToken.None" />。</span><span class="sxs-lookup"><span data-stu-id="ba54e-450">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="ba54e-451">将字节的序列异步写入当前流，将该流中的当前位置向前移动写入的字节数，并监视取消请求。</span><span class="sxs-lookup"><span data-stu-id="ba54e-451">Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="ba54e-452">表示异步写入操作的任务。</span><span class="sxs-lookup"><span data-stu-id="ba54e-452">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="ba54e-453"><xref:System.IO.Pipes.PipeStream.WriteAsync%2A>方法使你可以在不阻塞主线程的情况下执行占用大量资源的 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="ba54e-453">The <xref:System.IO.Pipes.PipeStream.WriteAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="ba54e-454">在 Windows 8.x 应用商店应用或桌面应用中一个耗时的流操作可能阻塞 UI 线程并让应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="ba54e-454">This performance consideration is particularly important in a Windows 8.x Store app or desktop app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="ba54e-455">异步方法与 `async` `await` Visual Basic 和 c # 中的和关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="ba54e-455">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="ba54e-456">使用 <xref:System.IO.Pipes.PipeStream.CanWrite%2A> 属性可确定当前实例是否支持写入。</span><span class="sxs-lookup"><span data-stu-id="ba54e-456">Use the <xref:System.IO.Pipes.PipeStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>

<span data-ttu-id="ba54e-457">如果在操作完成前取消该操作，则返回的任务包含 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithtype> 属性的值 <xref:System.Threading.Tasks.Task.Status%2A> 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-457">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithtype> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ba54e-458">流不支持写入。</span><span class="sxs-lookup"><span data-stu-id="ba54e-458">Stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ba54e-459">无法访问关闭的管道。</span><span class="sxs-lookup"><span data-stu-id="ba54e-459">Cannot access a closed pipe.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ba54e-460">管道已断开。</span><span class="sxs-lookup"><span data-stu-id="ba54e-460">The pipe is broken.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ba54e-461">管道尚未连接。</span><span class="sxs-lookup"><span data-stu-id="ba54e-461">The pipe hasn't been connected yet.</span></span>

<span data-ttu-id="ba54e-462">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ba54e-462">-or-</span></span>

<span data-ttu-id="ba54e-463">管道处于断开连接状态。</span><span class="sxs-lookup"><span data-stu-id="ba54e-463">The pipe is in a disconnected state.</span></span>

<span data-ttu-id="ba54e-464">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ba54e-464">-or-</span></span>

<span data-ttu-id="ba54e-465">尚未设置管道句柄。</span><span class="sxs-lookup"><span data-stu-id="ba54e-465">The pipe handle has not been set.</span></span> <span data-ttu-id="ba54e-466">（你的 <see cref="T:System.IO.Pipes.PipeStream" /> 实现是否调用 <see cref="M:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />？</span><span class="sxs-lookup"><span data-stu-id="ba54e-466">(Did your <see cref="T:System.IO.Pipes.PipeStream" /> implementation call <see cref="M:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />?</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function WriteAsync (buffer As Byte(), offset As Integer, count As Integer, cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="pipeStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="ba54e-467">从中写入数据的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="ba54e-467">The buffer to write data from.</span></span></param>
        <param name="offset"><span data-ttu-id="ba54e-468"><paramref name="buffer" /> 中的从零开始的字节偏移量，从此处开始将字节复制到该流。</span><span class="sxs-lookup"><span data-stu-id="ba54e-468">The zero-based byte offset in <paramref name="buffer" /> from which to begin copying bytes to the stream.</span></span></param>
        <param name="count"><span data-ttu-id="ba54e-469">最多写入的字节数。</span><span class="sxs-lookup"><span data-stu-id="ba54e-469">The maximum number of bytes to write.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="ba54e-470">要监视取消请求的标记。</span><span class="sxs-lookup"><span data-stu-id="ba54e-470">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="ba54e-471">默认值是 <see cref="P:System.Threading.CancellationToken.None" />。</span><span class="sxs-lookup"><span data-stu-id="ba54e-471">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="ba54e-472">从字节数组的指定位置开始异步写入指定字节数，按写入的字节数向前移动此流中的当前位置，并监视取消请求。</span><span class="sxs-lookup"><span data-stu-id="ba54e-472">Asynchronously writes a specified number of bytes from a byte array starting at a specified position, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="ba54e-473">表示异步写入操作的任务。</span><span class="sxs-lookup"><span data-stu-id="ba54e-473">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="ba54e-474"><xref:System.IO.Pipes.PipeStream.WriteAsync%2A>方法使你可以在不阻塞主线程的情况下执行占用大量资源的 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="ba54e-474">The <xref:System.IO.Pipes.PipeStream.WriteAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="ba54e-475">在 Windows 8.x 应用商店应用或桌面应用中一个耗时的流操作可能阻塞 UI 线程并让应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="ba54e-475">This performance consideration is particularly important in a Windows 8.x Store app or desktop app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="ba54e-476">异步方法与 `async` `await` Visual Basic 和 c # 中的和关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="ba54e-476">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="ba54e-477">使用 <xref:System.IO.Pipes.PipeStream.CanWrite%2A> 属性可确定当前实例是否支持写入。</span><span class="sxs-lookup"><span data-stu-id="ba54e-477">Use the <xref:System.IO.Pipes.PipeStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>

<span data-ttu-id="ba54e-478">如果在操作完成前取消该操作，则返回的任务包含 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 属性的值 <xref:System.Threading.Tasks.Task.Status%2A> 。</span><span class="sxs-lookup"><span data-stu-id="ba54e-478">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba54e-479"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ba54e-479"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba54e-480"><paramref name="offset" /> 为负。</span><span class="sxs-lookup"><span data-stu-id="ba54e-480">The <paramref name="offset" /> is negative.</span></span>

<span data-ttu-id="ba54e-481">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ba54e-481">-or-</span></span>

<span data-ttu-id="ba54e-482"><paramref name="count" /> 为负。</span><span class="sxs-lookup"><span data-stu-id="ba54e-482">The <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba54e-483"><paramref name="buffer" />.Length - <paramref name="offset" /> 小于 <paramref name="count" />。</span><span class="sxs-lookup"><span data-stu-id="ba54e-483"><paramref name="buffer" />.Length - <paramref name="offset" /> is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ba54e-484">流不支持写入。</span><span class="sxs-lookup"><span data-stu-id="ba54e-484">Stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ba54e-485">无法访问关闭的管道。</span><span class="sxs-lookup"><span data-stu-id="ba54e-485">Cannot access a closed pipe.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ba54e-486">管道已断开。</span><span class="sxs-lookup"><span data-stu-id="ba54e-486">The pipe is broken.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ba54e-487">管道尚未连接。</span><span class="sxs-lookup"><span data-stu-id="ba54e-487">The pipe hasn't been connected yet.</span></span>

<span data-ttu-id="ba54e-488">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ba54e-488">-or-</span></span>

<span data-ttu-id="ba54e-489">管道处于断开连接状态。</span><span class="sxs-lookup"><span data-stu-id="ba54e-489">The pipe is in a disconnected state.</span></span>

<span data-ttu-id="ba54e-490">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ba54e-490">-or-</span></span>

<span data-ttu-id="ba54e-491">尚未设置管道句柄。</span><span class="sxs-lookup"><span data-stu-id="ba54e-491">The pipe handle has not been set.</span></span> <span data-ttu-id="ba54e-492">（你的 <see cref="T:System.IO.Pipes.PipeStream" /> 实现是否调用 <see cref="M:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />？</span><span class="sxs-lookup"><span data-stu-id="ba54e-492">(Did your <see cref="T:System.IO.Pipes.PipeStream" /> implementation call <see cref="M:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />?</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="pipeStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ba54e-493">要写入流中的字节。</span><span class="sxs-lookup"><span data-stu-id="ba54e-493">The byte to write to the stream.</span></span></param>
        <summary><span data-ttu-id="ba54e-494">将字节写入当前流。</span><span class="sxs-lookup"><span data-stu-id="ba54e-494">Writes a byte to the current stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba54e-495">使用 <xref:System.IO.Pipes.PipeStream.CanWrite%2A> 属性可确定当前 <xref:System.IO.Pipes.PipeStream> 对象是否支持写入操作。</span><span class="sxs-lookup"><span data-stu-id="ba54e-495">Use the <xref:System.IO.Pipes.PipeStream.CanWrite%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports write operations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ba54e-496">管道已关闭。</span><span class="sxs-lookup"><span data-stu-id="ba54e-496">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ba54e-497">管道不支持写操作。</span><span class="sxs-lookup"><span data-stu-id="ba54e-497">The pipe does not support write operations.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ba54e-498">管道已断开连接、正在等待连接或尚未设置句柄。</span><span class="sxs-lookup"><span data-stu-id="ba54e-498">The pipe is disconnected, waiting to connect, or the handle has not been set.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ba54e-499">管道已中断或出现其他 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="ba54e-499">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
