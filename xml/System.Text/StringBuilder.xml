<Type Name="StringBuilder" FullName="System.Text.StringBuilder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5c9779b9fd5221ee1dc8f6f3ac64c26122efbc72" /><Meta Name="ms.sourcegitcommit" Value="a372e6accee5099e1c114f8589ca6b4537f1caaa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/20/2020" /><Meta Name="ms.locfileid" Value="88655735" /></Metadata><TypeSignature Language="C#" Value="public sealed class StringBuilder" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit StringBuilder extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="DocId" Value="T:System.Text.StringBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StringBuilder" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C++ CLI" Value="public ref class StringBuilder sealed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="F#" Value="type StringBuilder = class" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C#" Value="public sealed class StringBuilder : System.Runtime.Serialization.ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StringBuilder&#xA;Implements ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class StringBuilder sealed : System::Runtime::Serialization::ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type StringBuilder = class&#xA;    interface ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit StringBuilder extends System.Object" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="c1488-101">表示可变字符字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-101">Represents a mutable string of characters.</span></span> <span data-ttu-id="c1488-102">此类不能被继承。</span><span class="sxs-lookup"><span data-stu-id="c1488-102">This class cannot be inherited.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-103">此类表示一个类似字符串的对象，其值为可变字符序列。</span><span class="sxs-lookup"><span data-stu-id="c1488-103">This class represents a string-like object whose value is a mutable sequence of characters.</span></span>

 <span data-ttu-id="c1488-104">本部分内容：</span><span class="sxs-lookup"><span data-stu-id="c1488-104">In this section:</span></span>

-   [<span data-ttu-id="c1488-105">String 和 StringBuilder 类型</span><span class="sxs-lookup"><span data-stu-id="c1488-105">The String and StringBuilder types</span></span>](#StringAndSB)

-   [<span data-ttu-id="c1488-106">StringBuilder 的工作方式</span><span class="sxs-lookup"><span data-stu-id="c1488-106">How StringBuilder works</span></span>](#HowWorks)

-   [<span data-ttu-id="c1488-107">内存分配</span><span class="sxs-lookup"><span data-stu-id="c1488-107">Memory allocation</span></span>](#Memory)

-   [<span data-ttu-id="c1488-108">实例化 StringBuilder 对象</span><span class="sxs-lookup"><span data-stu-id="c1488-108">Instantiating a StringBuilder object</span></span>](#Instantiating)

-   [<span data-ttu-id="c1488-109">调用 StringBuilder 方法</span><span class="sxs-lookup"><span data-stu-id="c1488-109">Calling StringBuilder methods</span></span>](#Calling)

-   [<span data-ttu-id="c1488-110">执行 StringBuilder 操作</span><span class="sxs-lookup"><span data-stu-id="c1488-110">Performing StringBuilder operations</span></span>](#Operations)

    -   [<span data-ttu-id="c1488-111">迭代 StringBuilder 字符</span><span class="sxs-lookup"><span data-stu-id="c1488-111">Iterating StringBuilder characters</span></span>](#Iterating)

    -   [<span data-ttu-id="c1488-112">向 StringBuilder 对象添加文本</span><span class="sxs-lookup"><span data-stu-id="c1488-112">Adding text to a StringBuilder object</span></span>](#Adding)

    -   [<span data-ttu-id="c1488-113">从 StringBuilder 对象中删除文本</span><span class="sxs-lookup"><span data-stu-id="c1488-113">Deleting text from a StringBuilder object</span></span>](#Deleting)

    -   [<span data-ttu-id="c1488-114">修改 StringBuilder 对象中的文本</span><span class="sxs-lookup"><span data-stu-id="c1488-114">Modifying the text in a StringBuilder object</span></span>](#Modifying)

-   [<span data-ttu-id="c1488-115">在 StringBuilder 对象中搜索文本</span><span class="sxs-lookup"><span data-stu-id="c1488-115">Searching the text in a StringBuilder object</span></span>](#Searching)

-   [<span data-ttu-id="c1488-116">将 StringBuilder 对象转换为字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-116">Converting the StringBuilder object to a string</span></span>](#Converting)

<a name="StringAndSB"></a>
## <a name="the-string-and-stringbuilder-types"></a><span data-ttu-id="c1488-117">String 和 StringBuilder 类型</span><span class="sxs-lookup"><span data-stu-id="c1488-117">The String and StringBuilder types</span></span>
 <span data-ttu-id="c1488-118">尽管 <xref:System.Text.StringBuilder> 和 <xref:System.String> 都表示字符序列，但它们的实现方式不同。</span><span class="sxs-lookup"><span data-stu-id="c1488-118">Although <xref:System.Text.StringBuilder> and <xref:System.String> both represent sequences of characters, they are implemented differently.</span></span> <span data-ttu-id="c1488-119"><xref:System.String> 是不可变类型。</span><span class="sxs-lookup"><span data-stu-id="c1488-119"><xref:System.String> is an immutable type.</span></span> <span data-ttu-id="c1488-120">也就是说，出现的用于修改对象的每个操作 <xref:System.String> 实际上都会创建一个新的字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-120">That is, each operation that appears to modify a <xref:System.String> object actually creates a new string.</span></span>

 <span data-ttu-id="c1488-121">例如， <xref:System.String.Concat%2A?displayProperty=nameWithType> 以下 c # 示例中的方法调用将显示为更改名为的字符串变量的值 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-121">For example, the call to the <xref:System.String.Concat%2A?displayProperty=nameWithType> method in the following C# example appears to change the value of a string variable named `value`.</span></span> <span data-ttu-id="c1488-122">事实上，该 <xref:System.String.Concat%2A> 方法将返回一个 `value` 对象，该对象具有与 `value` 传递给该方法的对象不同的值和地址。</span><span class="sxs-lookup"><span data-stu-id="c1488-122">In fact, the <xref:System.String.Concat%2A> method returns a `value` object that has a different value and address from the `value` object that was passed to the method.</span></span> <span data-ttu-id="c1488-123">请注意，必须使用编译器选项编译该示例 `/unsafe` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-123">Note that the example must be compiled using the `/unsafe` compiler option.</span></span>

 [!code-csharp[System.Text.StringBuilder.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/immutability2.cs#1)]

 <span data-ttu-id="c1488-124">对于执行大量字符串操作的例程 (例如在循环中多次修改字符串的应用程序) ，重复修改字符串可能会显著降低性能。</span><span class="sxs-lookup"><span data-stu-id="c1488-124">For routines that perform extensive string manipulation (such as apps that modify a string numerous times in a loop), modifying a string repeatedly can exact a significant performance penalty.</span></span> <span data-ttu-id="c1488-125">替代方法是使用 <xref:System.Text.StringBuilder> ，它是一个可变字符串类。</span><span class="sxs-lookup"><span data-stu-id="c1488-125">The alternative is to use <xref:System.Text.StringBuilder>, which is a mutable string class.</span></span> <span data-ttu-id="c1488-126">可变性是指在创建类的实例后，可以通过追加、移除、替换或插入字符来修改它。</span><span class="sxs-lookup"><span data-stu-id="c1488-126">Mutability means that once an instance of the class has been created, it can be modified by appending, removing, replacing, or inserting characters.</span></span> <span data-ttu-id="c1488-127"><xref:System.Text.StringBuilder>对象维护缓冲区以容纳对字符串的扩展。</span><span class="sxs-lookup"><span data-stu-id="c1488-127">A <xref:System.Text.StringBuilder> object maintains a buffer to accommodate expansions to the string.</span></span> <span data-ttu-id="c1488-128">如果空间可用，则会将新数据追加到缓冲区;否则，将分配一个新的更大的缓冲区，将原始缓冲区中的数据复制到新缓冲区，然后将新数据追加到新缓冲区。</span><span class="sxs-lookup"><span data-stu-id="c1488-128">New data is appended to the buffer if room is available; otherwise, a new, larger buffer is allocated, data from the original buffer is copied to the new buffer, and the new data is then appended to the new buffer.</span></span>

> [!IMPORTANT]
>  <span data-ttu-id="c1488-129">尽管 <xref:System.Text.StringBuilder> 类通常比类提供更好的性能 <xref:System.String> ，但你不应在 <xref:System.String> <xref:System.Text.StringBuilder> 每次需要操作字符串时自动将替换为。</span><span class="sxs-lookup"><span data-stu-id="c1488-129">Although the <xref:System.Text.StringBuilder> class generally offers better performance than the <xref:System.String> class, you should not automatically replace <xref:System.String> with <xref:System.Text.StringBuilder> whenever you want to manipulate strings.</span></span> <span data-ttu-id="c1488-130">性能取决于字符串的大小、要为新字符串分配的内存量、正在执行应用程序的系统以及操作的类型。</span><span class="sxs-lookup"><span data-stu-id="c1488-130">Performance depends on the size of the string, the amount of memory to be allocated for the new string, the system on which your app is executing, and the type of operation.</span></span> <span data-ttu-id="c1488-131">应该准备好测试应用程序，以确定实际是否 <xref:System.Text.StringBuilder> 提供显著的性能改进。</span><span class="sxs-lookup"><span data-stu-id="c1488-131">You should be prepared to test your app to determine whether <xref:System.Text.StringBuilder> actually offers a significant performance improvement.</span></span>

 <span data-ttu-id="c1488-132">请考虑 <xref:System.String> 在以下情况下使用类：</span><span class="sxs-lookup"><span data-stu-id="c1488-132">Consider using the <xref:System.String> class under these conditions:</span></span>

-   <span data-ttu-id="c1488-133">当你的应用将对字符串进行的更改数量很小时。</span><span class="sxs-lookup"><span data-stu-id="c1488-133">When the number of changes that your app will make to a string is small.</span></span> <span data-ttu-id="c1488-134">在这些情况下， <xref:System.Text.StringBuilder> 可能会提供可忽略或不会提高性能的性能 <xref:System.String> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-134">In these cases, <xref:System.Text.StringBuilder> might offer negligible or no performance improvement over <xref:System.String>.</span></span>

-   <span data-ttu-id="c1488-135">当你执行固定数量的串联操作时，尤其是字符串文本。</span><span class="sxs-lookup"><span data-stu-id="c1488-135">When you are performing a fixed number of concatenation operations, particularly with string literals.</span></span> <span data-ttu-id="c1488-136">在这种情况下，编译器可能会将串联操作合并为单个操作。</span><span class="sxs-lookup"><span data-stu-id="c1488-136">In this case, the compiler might combine the concatenation operations into a single operation.</span></span>

-   <span data-ttu-id="c1488-137">在生成字符串时，必须执行大量的搜索操作。</span><span class="sxs-lookup"><span data-stu-id="c1488-137">When you have to perform extensive search operations while you are building your string.</span></span> <span data-ttu-id="c1488-138"><xref:System.Text.StringBuilder>类缺少搜索方法，如 `IndexOf` 或 `StartsWith` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-138">The <xref:System.Text.StringBuilder> class lacks search methods such as `IndexOf` or `StartsWith`.</span></span> <span data-ttu-id="c1488-139"><xref:System.Text.StringBuilder>对于这些操作，必须将对象转换为 <xref:System.String> ，这可能会使使用不会带来性能优势 <xref:System.Text.StringBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-139">You'll have to convert the <xref:System.Text.StringBuilder> object to a <xref:System.String> for these operations, and this can negate the performance benefit from using <xref:System.Text.StringBuilder>.</span></span> <span data-ttu-id="c1488-140">有关详细信息，请参阅在 [StringBuilder 对象中搜索文本](#Searching) 部分。</span><span class="sxs-lookup"><span data-stu-id="c1488-140">For more information, see the [Searching the text in a StringBuilder object](#Searching) section.</span></span>

 <span data-ttu-id="c1488-141">请考虑 <xref:System.Text.StringBuilder> 在以下情况下使用类：</span><span class="sxs-lookup"><span data-stu-id="c1488-141">Consider using the <xref:System.Text.StringBuilder> class under these conditions:</span></span>

-   <span data-ttu-id="c1488-142">如果希望应用在设计时对字符串进行未知数量的更改 (例如，当你使用循环来连接包含用户输入) 的随机数量的字符串时。</span><span class="sxs-lookup"><span data-stu-id="c1488-142">When you expect your app to make an unknown number of changes to a string at design time (for example, when you are using a loop to concatenate a random number of strings that contain user input).</span></span>

-   <span data-ttu-id="c1488-143">希望应用对字符串进行大量更改时。</span><span class="sxs-lookup"><span data-stu-id="c1488-143">When you expect your app to make a significant number of changes to a string.</span></span>

<a name="HowWorks"></a>
## <a name="how-stringbuilder-works"></a><span data-ttu-id="c1488-144">StringBuilder 的工作方式</span><span class="sxs-lookup"><span data-stu-id="c1488-144">How StringBuilder works</span></span>
 <span data-ttu-id="c1488-145"><xref:System.Text.StringBuilder.Length%2A?displayProperty=nameWithType>属性指示对象当前包含的字符数 <xref:System.Text.StringBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-145">The <xref:System.Text.StringBuilder.Length%2A?displayProperty=nameWithType> property indicates the number of characters the <xref:System.Text.StringBuilder> object currently contains.</span></span> <span data-ttu-id="c1488-146">如果向对象添加字符 <xref:System.Text.StringBuilder> ，则其长度将增加，直到它等于属性的大小 <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> ，该大小定义对象可以包含的字符数。</span><span class="sxs-lookup"><span data-stu-id="c1488-146">If you add characters to the <xref:System.Text.StringBuilder> object, its length increases until it equals the size of the <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> property, which defines the number of characters that the object can contain.</span></span> <span data-ttu-id="c1488-147">如果添加的字符数导致对象的长度 <xref:System.Text.StringBuilder> 超过其当前容量，则分配新内存，属性的值 <xref:System.Text.StringBuilder.Capacity%2A> 翻倍，新字符将添加到 <xref:System.Text.StringBuilder> 对象中，并 <xref:System.Text.StringBuilder.Length%2A> 调整其属性。</span><span class="sxs-lookup"><span data-stu-id="c1488-147">If the number of added characters causes the length of the <xref:System.Text.StringBuilder> object to exceed its current capacity, new memory is allocated, the value of the <xref:System.Text.StringBuilder.Capacity%2A> property is doubled, new characters are added to the <xref:System.Text.StringBuilder> object, and its <xref:System.Text.StringBuilder.Length%2A> property is adjusted.</span></span> <span data-ttu-id="c1488-148">对象的额外内存 <xref:System.Text.StringBuilder> 会动态分配，直到达到属性定义的值 <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-148">Additional memory for the <xref:System.Text.StringBuilder> object is allocated dynamically until it reaches the value defined by the <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="c1488-149">达到最大容量时，不能为该对象分配更多的内存 <xref:System.Text.StringBuilder> ，尝试添加字符或将其扩展到超出其最大容量后，会引发 <xref:System.ArgumentOutOfRangeException> 或 <xref:System.OutOfMemoryException> 例外。</span><span class="sxs-lookup"><span data-stu-id="c1488-149">When the maximum capacity is reached, no further memory can be allocated for the <xref:System.Text.StringBuilder> object, and trying to add characters or expand it beyond its maximum capacity throws either an <xref:System.ArgumentOutOfRangeException> or an <xref:System.OutOfMemoryException> exception.</span></span>

 <span data-ttu-id="c1488-150">下面的示例演示了 <xref:System.Text.StringBuilder> 对象如何分配新内存并动态增加其容量，因为分配给对象的字符串会展开。</span><span class="sxs-lookup"><span data-stu-id="c1488-150">The following example illustrates how a <xref:System.Text.StringBuilder> object allocates new memory and increases its capacity dynamically as the string assigned to the object expands.</span></span> <span data-ttu-id="c1488-151">该代码 <xref:System.Text.StringBuilder> 通过调用默认 (无参数) 构造函数来创建对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-151">The code creates a <xref:System.Text.StringBuilder> object by calling its default (parameterless) constructor.</span></span> <span data-ttu-id="c1488-152">此对象的默认容量为16个字符，其最大容量超过2000000000个字符。</span><span class="sxs-lookup"><span data-stu-id="c1488-152">The default capacity of this object is 16 characters, and its maximum capacity is more than 2 billion characters.</span></span> <span data-ttu-id="c1488-153">追加字符串 "This is a 句子"。</span><span class="sxs-lookup"><span data-stu-id="c1488-153">Appending the string "This is a sentence."</span></span> <span data-ttu-id="c1488-154">导致新的内存分配，因为字符串长度 (19 个字符) 超过对象的默认容量 <xref:System.Text.StringBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-154">results in a new memory allocation because the string length (19 characters) exceeds the default capacity of the <xref:System.Text.StringBuilder> object.</span></span> <span data-ttu-id="c1488-155">对象的容量长度为32个字符，添加新字符串，并且对象的长度现在等于19个字符。</span><span class="sxs-lookup"><span data-stu-id="c1488-155">The capacity of the object doubles to 32 characters, the new string is added, and the length of the object now equals 19 characters.</span></span> <span data-ttu-id="c1488-156">然后，该代码将追加字符串 "This is 其他句子"。</span><span class="sxs-lookup"><span data-stu-id="c1488-156">The code then appends the string "This is an additional sentence."</span></span> <span data-ttu-id="c1488-157">对象的值 <xref:System.Text.StringBuilder> 11 次。</span><span class="sxs-lookup"><span data-stu-id="c1488-157">to the value of the <xref:System.Text.StringBuilder> object 11 times.</span></span> <span data-ttu-id="c1488-158">每当追加操作导致对象的长度 <xref:System.Text.StringBuilder> 超过其容量时，其现有容量就会加倍， <xref:System.Text.StringBuilder.Append%2A> 操作成功。</span><span class="sxs-lookup"><span data-stu-id="c1488-158">Whenever the append operation causes the length of the <xref:System.Text.StringBuilder> object to exceed its capacity, its existing capacity is doubled and the <xref:System.Text.StringBuilder.Append%2A> operation succeeds.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/default1.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/default1.vb" id="Snippet3":::

<a name="Memory"></a>
## <a name="memory-allocation"></a><span data-ttu-id="c1488-159">内存分配</span><span class="sxs-lookup"><span data-stu-id="c1488-159">Memory allocation</span></span>
 <span data-ttu-id="c1488-160">对象的默认容量 <xref:System.Text.StringBuilder> 是16个字符，默认的最大容量为 <xref:System.Int32.MaxValue?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-160">The default capacity of a <xref:System.Text.StringBuilder> object is 16 characters, and its default maximum capacity is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c1488-161">如果调用 <xref:System.Text.StringBuilder.%23ctor> 和构造函数，则使用这些默认值 <xref:System.Text.StringBuilder.%23ctor%28System.String%29> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-161">These default values are used if you call the <xref:System.Text.StringBuilder.%23ctor> and <xref:System.Text.StringBuilder.%23ctor%28System.String%29> constructors.</span></span>

 <span data-ttu-id="c1488-162">可以通过以下方式显式定义对象的初始容量 <xref:System.Text.StringBuilder> ：</span><span class="sxs-lookup"><span data-stu-id="c1488-162">You can explicitly define the initial capacity of a <xref:System.Text.StringBuilder> object in the following ways:</span></span>

-   <span data-ttu-id="c1488-163">通过在 <xref:System.Text.StringBuilder> 创建对象时调用包含参数的任何构造函数 `capacity` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-163">By calling any of the <xref:System.Text.StringBuilder> constructors that includes a `capacity` parameter when you create the object.</span></span>

-   <span data-ttu-id="c1488-164">通过将新值显式分配给 <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> 属性来展开现有 <xref:System.Text.StringBuilder> 对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-164">By explicitly assigning a new value to the <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> property to expand an existing <xref:System.Text.StringBuilder> object.</span></span> <span data-ttu-id="c1488-165">请注意，如果新容量小于现有容量或大于 <xref:System.Text.StringBuilder> 对象的最大容量，则属性引发异常。</span><span class="sxs-lookup"><span data-stu-id="c1488-165">Note that the property throws an exception if the new capacity is less than the existing capacity or greater than the <xref:System.Text.StringBuilder> object's maximum capacity.</span></span>

-   <span data-ttu-id="c1488-166">通过 <xref:System.Text.StringBuilder.EnsureCapacity%2A?displayProperty=nameWithType> 使用新容量调用方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-166">By calling the <xref:System.Text.StringBuilder.EnsureCapacity%2A?displayProperty=nameWithType> method with the new capacity.</span></span> <span data-ttu-id="c1488-167">新容量不得大于 <xref:System.Text.StringBuilder> 对象的最大容量。</span><span class="sxs-lookup"><span data-stu-id="c1488-167">The new capacity must not be greater than the <xref:System.Text.StringBuilder> object's maximum capacity.</span></span> <span data-ttu-id="c1488-168">但是，与对属性的赋值不同 <xref:System.Text.StringBuilder.Capacity%2A> ， <xref:System.Text.StringBuilder.EnsureCapacity%2A> 如果所需的新容量小于现有容量，则不会引发异常; 在这种情况下，方法调用不起作用。</span><span class="sxs-lookup"><span data-stu-id="c1488-168">However, unlike an assignment to the <xref:System.Text.StringBuilder.Capacity%2A> property, <xref:System.Text.StringBuilder.EnsureCapacity%2A> does not throw an exception if the desired new capacity is less than the existing capacity; in this case, the method call has no effect.</span></span>

 <span data-ttu-id="c1488-169">如果分配给 <xref:System.Text.StringBuilder> 构造函数调用中的对象的字符串长度超过默认容量或指定的容量，则将 <xref:System.Text.StringBuilder.Capacity%2A> 属性设置为与参数一起指定的字符串长度 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-169">If the length of the string assigned to the <xref:System.Text.StringBuilder> object in the constructor call exceeds either the default capacity or the specified capacity, the <xref:System.Text.StringBuilder.Capacity%2A> property is set to the length of the string specified with the `value` parameter.</span></span>

 <span data-ttu-id="c1488-170">可以 <xref:System.Text.StringBuilder> 通过调用构造函数来显式定义对象的最大容量 <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-170">You can explicitly define the maximum capacity of a <xref:System.Text.StringBuilder> object by calling the <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> constructor.</span></span> <span data-ttu-id="c1488-171">不能通过为属性分配新值来更改最大容量 <xref:System.Text.StringBuilder.MaxCapacity%2A> ，因为它是只读的。</span><span class="sxs-lookup"><span data-stu-id="c1488-171">You can't change the maximum capacity by assigning a new value to the <xref:System.Text.StringBuilder.MaxCapacity%2A> property, because it is read-only.</span></span>

 <span data-ttu-id="c1488-172">如上一节所示，只要现有容量不足，就会分配额外的内存，并且对象的容量将与 <xref:System.Text.StringBuilder> 属性定义的值加倍 <xref:System.Text.StringBuilder.MaxCapacity%2A> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-172">As the previous section shows, whenever the existing capacity is inadequate, additional memory is allocated and the capacity of a <xref:System.Text.StringBuilder> object doubles up to the value defined by the <xref:System.Text.StringBuilder.MaxCapacity%2A> property.</span></span>

 <span data-ttu-id="c1488-173">通常，默认容量和最大容量适用于大多数应用。</span><span class="sxs-lookup"><span data-stu-id="c1488-173">In general, the default capacity and maximum capacity are adequate for most apps.</span></span> <span data-ttu-id="c1488-174">可以考虑在以下条件下设置这些值：</span><span class="sxs-lookup"><span data-stu-id="c1488-174">You might consider setting these values under the following conditions:</span></span>

-   <span data-ttu-id="c1488-175">如果对象的最终大小 <xref:System.Text.StringBuilder> 可能会变得非常大，通常会超出几兆字节。</span><span class="sxs-lookup"><span data-stu-id="c1488-175">If the eventual size of the <xref:System.Text.StringBuilder> object is likely to grow exceedingly large, typically in excess of several megabytes.</span></span> <span data-ttu-id="c1488-176">在这种情况下，将初始属性设置为明显较高的值可能会提高性能， <xref:System.Text.StringBuilder.Capacity%2A> 从而无需过多的内存重新分配。</span><span class="sxs-lookup"><span data-stu-id="c1488-176">In this case, there may be some performance benefit from setting the initial <xref:System.Text.StringBuilder.Capacity%2A> property to a significantly high value to eliminate the need for too many memory reallocations.</span></span>

-   <span data-ttu-id="c1488-177">如果你的应用在内存有限的系统上运行。</span><span class="sxs-lookup"><span data-stu-id="c1488-177">If your app is running on a system with limited memory.</span></span> <span data-ttu-id="c1488-178">在这种情况下，您可能需要考虑将 <xref:System.Text.StringBuilder.MaxCapacity%2A> 属性设置为小于 <xref:System.Int32.MaxValue?displayProperty=nameWithType> 您的应用程序处理可能导致它在内存约束的环境中执行的大型字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-178">In this case, you may want to consider setting the <xref:System.Text.StringBuilder.MaxCapacity%2A> property to less than <xref:System.Int32.MaxValue?displayProperty=nameWithType> if your app is handling large strings that may cause it to execute in a memory-constrained environment.</span></span>

<a name="Instantiating"></a>
## <a name="instantiating-a-stringbuilder-object"></a><span data-ttu-id="c1488-179">实例化 StringBuilder 对象</span><span class="sxs-lookup"><span data-stu-id="c1488-179">Instantiating a StringBuilder object</span></span>
 <span data-ttu-id="c1488-180">可以 <xref:System.Text.StringBuilder> 通过调用下表中列出的六个重载类构造函数之一来实例化对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-180">You instantiate a <xref:System.Text.StringBuilder> object by calling one of its six overloaded class constructors, which are listed in the following table.</span></span> <span data-ttu-id="c1488-181">三个构造函数实例化一个 <xref:System.Text.StringBuilder> 对象，该对象的值为空字符串，但 <xref:System.Text.StringBuilder.Capacity%2A> 以不同的方式设置其和 <xref:System.Text.StringBuilder.MaxCapacity%2A> 值。</span><span class="sxs-lookup"><span data-stu-id="c1488-181">Three of the constructors instantiate a <xref:System.Text.StringBuilder> object whose value is an empty string, but set its <xref:System.Text.StringBuilder.Capacity%2A> and <xref:System.Text.StringBuilder.MaxCapacity%2A> values differently.</span></span> <span data-ttu-id="c1488-182">其余三个构造函数定义一个 <xref:System.Text.StringBuilder> 对象，该对象具有特定的字符串值和容量。</span><span class="sxs-lookup"><span data-stu-id="c1488-182">The remaining three constructors define a <xref:System.Text.StringBuilder> object that has a specific string value and capacity.</span></span> <span data-ttu-id="c1488-183">这三个构造函数中的两个使用默认的最大容量 <xref:System.Int32.MaxValue?displayProperty=nameWithType> ，而第三个构造函数可设置最大容量。</span><span class="sxs-lookup"><span data-stu-id="c1488-183">Two of the three constructors use the default maximum capacity of <xref:System.Int32.MaxValue?displayProperty=nameWithType>, whereas the third allows you to set the maximum capacity.</span></span>

|<span data-ttu-id="c1488-184">构造函数</span><span class="sxs-lookup"><span data-stu-id="c1488-184">Constructor</span></span>|<span data-ttu-id="c1488-185">字符串值</span><span class="sxs-lookup"><span data-stu-id="c1488-185">String value</span></span>|<span data-ttu-id="c1488-186">容量</span><span class="sxs-lookup"><span data-stu-id="c1488-186">Capacity</span></span>|<span data-ttu-id="c1488-187">最大容量</span><span class="sxs-lookup"><span data-stu-id="c1488-187">Maximum capacity</span></span>|
|-----------------|------------------|--------------|----------------------|
|<xref:System.Text.StringBuilder.%23ctor>|<xref:System.String.Empty?displayProperty=nameWithType>|<span data-ttu-id="c1488-188">16</span><span class="sxs-lookup"><span data-stu-id="c1488-188">16</span></span>|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|<span data-ttu-id="c1488-189">由参数定义 `capacity`</span><span class="sxs-lookup"><span data-stu-id="c1488-189">Defined by the `capacity` parameter</span></span>|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|<span data-ttu-id="c1488-190">由参数定义 `capacity`</span><span class="sxs-lookup"><span data-stu-id="c1488-190">Defined by the `capacity` parameter</span></span>|<span data-ttu-id="c1488-191">由参数定义 `maxCapacity`</span><span class="sxs-lookup"><span data-stu-id="c1488-191">Defined by the `maxCapacity` parameter</span></span>|
|<xref:System.Text.StringBuilder.%23ctor%28System.String%29>|<span data-ttu-id="c1488-192">由参数定义 `value`</span><span class="sxs-lookup"><span data-stu-id="c1488-192">Defined by the `value` parameter</span></span>|<span data-ttu-id="c1488-193">16或 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-193">16 or `value`.</span></span> <span data-ttu-id="c1488-194"><xref:System.String.Length%2A>，以较大者为准</span><span class="sxs-lookup"><span data-stu-id="c1488-194"><xref:System.String.Length%2A>, whichever is greater</span></span>|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%29>|<span data-ttu-id="c1488-195">由参数定义 `value`</span><span class="sxs-lookup"><span data-stu-id="c1488-195">Defined by the `value` parameter</span></span>|<span data-ttu-id="c1488-196">由 `capacity` 参数或定义 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-196">Defined by the `capacity` parameter or `value`.</span></span> <span data-ttu-id="c1488-197"><xref:System.String.Length%2A>，以较大者为准。</span><span class="sxs-lookup"><span data-stu-id="c1488-197"><xref:System.String.Length%2A>, whichever is greater.</span></span>|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>|<span data-ttu-id="c1488-198">由 `value` 定义。</span><span class="sxs-lookup"><span data-stu-id="c1488-198">Defined by `value`.</span></span> <span data-ttu-id="c1488-199"><xref:System.String.Substring%2A>(`startIndex`, `length`)</span><span class="sxs-lookup"><span data-stu-id="c1488-199"><xref:System.String.Substring%2A>(`startIndex`, `length`)</span></span>|<span data-ttu-id="c1488-200">由 `capacity` 参数或定义 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-200">Defined by the `capacity` parameter or `value`.</span></span> <span data-ttu-id="c1488-201"><xref:System.String.Length%2A>，以较大者为准。</span><span class="sxs-lookup"><span data-stu-id="c1488-201"><xref:System.String.Length%2A>, whichever is greater.</span></span>|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|

 <span data-ttu-id="c1488-202">下面的示例使用三个构造函数重载来实例化 <xref:System.Text.StringBuilder> 对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-202">The following example uses three of these constructor overloads to instantiate <xref:System.Text.StringBuilder> objects.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/instantiate1.cs" interactive="try-dotnet" id="Snippet6":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/instantiate1.vb" id="Snippet6":::

<a name="Calling"></a>
## <a name="calling-stringbuilder-methods"></a><span data-ttu-id="c1488-203">调用 StringBuilder 方法</span><span class="sxs-lookup"><span data-stu-id="c1488-203">Calling StringBuilder methods</span></span>
 <span data-ttu-id="c1488-204">修改实例中的字符串的大多数方法都将 <xref:System.Text.StringBuilder> 返回对同一实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-204">Most of the methods that modify the string in a <xref:System.Text.StringBuilder> instance return a reference to that same instance.</span></span> <span data-ttu-id="c1488-205">这使您可以通过 <xref:System.Text.StringBuilder> 两种方式调用方法：</span><span class="sxs-lookup"><span data-stu-id="c1488-205">This enables you to call <xref:System.Text.StringBuilder> methods in two ways:</span></span>

-   <span data-ttu-id="c1488-206">可以进行单个方法调用并忽略返回值，如下例所示。</span><span class="sxs-lookup"><span data-stu-id="c1488-206">You can make individual method calls and ignore the return value, as the following example does.</span></span>

     :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call1.cs" interactive="try-dotnet" id="Snippet4":::
     :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call1.vb" id="Snippet4":::

-   <span data-ttu-id="c1488-207">可以在单个语句中执行一系列方法调用。</span><span class="sxs-lookup"><span data-stu-id="c1488-207">You can make a series of method calls in a single statement.</span></span> <span data-ttu-id="c1488-208">如果要编写一条链接连续操作的语句，这会很方便。</span><span class="sxs-lookup"><span data-stu-id="c1488-208">This can be convenient if you want to write a single statement that chains successive operations.</span></span> <span data-ttu-id="c1488-209">下面的示例将上一示例中的三个方法调用合并为单个代码行。</span><span class="sxs-lookup"><span data-stu-id="c1488-209">The following example consolidates three method calls from the previous example into a single line of code.</span></span>

     :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call2.cs" interactive="try-dotnet" id="Snippet5":::
     :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call2.vb" id="Snippet5":::

<a name="Operations"></a>
## <a name="performing-stringbuilder-operations"></a><span data-ttu-id="c1488-210">执行 StringBuilder 操作</span><span class="sxs-lookup"><span data-stu-id="c1488-210">Performing StringBuilder operations</span></span>
 <span data-ttu-id="c1488-211">您可以使用类的方法 <xref:System.Text.StringBuilder> 来循环访问、添加、删除或修改对象中的字符 <xref:System.Text.StringBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-211">You can use the methods of the <xref:System.Text.StringBuilder> class to iterate, add, delete, or modify characters in a <xref:System.Text.StringBuilder> object.</span></span>

<a name="Iterating"></a>
### <a name="iterating-stringbuilder-characters"></a><span data-ttu-id="c1488-212">迭代 StringBuilder 字符</span><span class="sxs-lookup"><span data-stu-id="c1488-212">Iterating StringBuilder characters</span></span>
 <span data-ttu-id="c1488-213">可以 <xref:System.Text.StringBuilder> 通过使用属性访问对象中的字符 <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-213">You can access the characters in a <xref:System.Text.StringBuilder> object by using the <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="c1488-214">在 c # 中， <xref:System.Text.StringBuilder.Chars%2A> 是索引器; 在 Visual Basic 中，它是类的默认属性 <xref:System.Text.StringBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-214">In C#, <xref:System.Text.StringBuilder.Chars%2A> is an indexer; in Visual Basic, it is the default property of the <xref:System.Text.StringBuilder> class.</span></span> <span data-ttu-id="c1488-215">这使您可以仅使用索引来设置或检索单个字符，而无需显式引用 <xref:System.Text.StringBuilder.Chars%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="c1488-215">This enables you to set or retrieve individual characters by using their index only, without explicitly referencing the <xref:System.Text.StringBuilder.Chars%2A> property.</span></span> <span data-ttu-id="c1488-216">对象中的字符从 <xref:System.Text.StringBuilder> 索引0开始 (零) 并继续到索引 <xref:System.Text.StringBuilder.Length%2A> -1。</span><span class="sxs-lookup"><span data-stu-id="c1488-216">Characters in a <xref:System.Text.StringBuilder> object begin at index 0 (zero) and continue to index <xref:System.Text.StringBuilder.Length%2A> - 1.</span></span>

 <span data-ttu-id="c1488-217">下面的示例阐释了 <xref:System.Text.StringBuilder.Chars%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="c1488-217">The following example illustrates the <xref:System.Text.StringBuilder.Chars%2A> property.</span></span> <span data-ttu-id="c1488-218">它将10个随机数追加到 <xref:System.Text.StringBuilder> 对象，然后循环访问每个字符。</span><span class="sxs-lookup"><span data-stu-id="c1488-218">It appends ten random numbers to a <xref:System.Text.StringBuilder> object, and then iterates each character.</span></span> <span data-ttu-id="c1488-219">如果该字符的 Unicode 类别为 <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType> ，则将该数字减小 1 (或者将其值为 0) 将其更改为9。</span><span class="sxs-lookup"><span data-stu-id="c1488-219">If the character's Unicode category is <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>, it decreases the number by 1 (or changes the number to 9 if its value is 0).</span></span> <span data-ttu-id="c1488-220">此示例在 <xref:System.Text.StringBuilder> 更改各个字符的值之前和之后都显示对象的内容。</span><span class="sxs-lookup"><span data-stu-id="c1488-220">The example displays the contents of the <xref:System.Text.StringBuilder> object both before and after the values of individual characters were changed.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/chars1.cs" interactive="try-dotnet" id="Snippet7":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/chars1.vb" id="Snippet7":::

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]

<a name="Adding"></a>
### <a name="adding-text-to-a-stringbuilder-object"></a><span data-ttu-id="c1488-221">向 StringBuilder 对象添加文本</span><span class="sxs-lookup"><span data-stu-id="c1488-221">Adding text to a StringBuilder object</span></span>
 <span data-ttu-id="c1488-222">此 <xref:System.Text.StringBuilder> 类包括以下方法来扩展对象的内容 <xref:System.Text.StringBuilder> ：</span><span class="sxs-lookup"><span data-stu-id="c1488-222">The <xref:System.Text.StringBuilder> class includes the following methods for expanding the contents of a <xref:System.Text.StringBuilder> object:</span></span>

-   <span data-ttu-id="c1488-223"><xref:System.Text.StringBuilder.Append%2A>方法追加字符串、子字符串、字符数组、字符数组的一部分、多次重复的单个字符或基元数据类型到对象的字符串表示形式 <xref:System.Text.StringBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-223">The <xref:System.Text.StringBuilder.Append%2A> method appends a string, a substring, a character array, a portion of a character array, a single character repeated multiple times, or the string representation of a primitive data type to a <xref:System.Text.StringBuilder> object.</span></span>

-   <span data-ttu-id="c1488-224"><xref:System.Text.StringBuilder.AppendLine%2A>方法将行终止符或字符串及行结束符一起追加到 <xref:System.Text.StringBuilder> 对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-224">The <xref:System.Text.StringBuilder.AppendLine%2A> method appends a line terminator or a string along with a line terminator to a <xref:System.Text.StringBuilder> object.</span></span>

-   <span data-ttu-id="c1488-225"><xref:System.Text.StringBuilder.AppendFormat%2A>方法将[复合格式字符串](/dotnet/standard/base-types/composite-formatting)追加到 <xref:System.Text.StringBuilder> 对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-225">The <xref:System.Text.StringBuilder.AppendFormat%2A> method appends a [composite format string](/dotnet/standard/base-types/composite-formatting) to a <xref:System.Text.StringBuilder> object.</span></span> <span data-ttu-id="c1488-226">结果字符串中包含的对象的字符串表示形式可以反映当前系统区域性或指定区域性的格式设置约定。</span><span class="sxs-lookup"><span data-stu-id="c1488-226">The string representations of objects included in the result string can reflect the formatting conventions of the current system culture or a specified culture.</span></span>

-   <span data-ttu-id="c1488-227"><xref:System.Text.StringBuilder.Insert%2A>方法在对象中的指定位置插入字符串、子串、字符串的多个重复项、字符数组、部分字符数组或基元数据类型的字符串表示形式 <xref:System.Text.StringBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-227">The <xref:System.Text.StringBuilder.Insert%2A> method inserts a string, a substring, multiple repetitions of a string, a character array, a portion of a character array, or the string representation of a primitive data type at a specified position in the <xref:System.Text.StringBuilder> object.</span></span> <span data-ttu-id="c1488-228">位置由从零开始的索引定义。</span><span class="sxs-lookup"><span data-stu-id="c1488-228">The position is defined by a zero-based index.</span></span>

 <span data-ttu-id="c1488-229">下面的示例使用 <xref:System.Text.StringBuilder.Append%2A> 、 <xref:System.Text.StringBuilder.AppendLine%2A> 、 <xref:System.Text.StringBuilder.AppendFormat%2A> 和 <xref:System.Text.StringBuilder.Insert%2A> 方法展开对象的文本 <xref:System.Text.StringBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-229">The following example uses the <xref:System.Text.StringBuilder.Append%2A>, <xref:System.Text.StringBuilder.AppendLine%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>, and <xref:System.Text.StringBuilder.Insert%2A> methods to expand the text of a <xref:System.Text.StringBuilder> object.</span></span>

  :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/expand1.cs" interactive="try-dotnet" id="Snippet9":::
  :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/expand1.vb" id="Snippet9":::

<a name="Deleting"></a>
### <a name="deleting-text-from-a-stringbuilder-object"></a><span data-ttu-id="c1488-230">从 StringBuilder 对象中删除文本</span><span class="sxs-lookup"><span data-stu-id="c1488-230">Deleting text from a StringBuilder object</span></span>
 <span data-ttu-id="c1488-231"><xref:System.Text.StringBuilder>类包括可以减少的当前大小的方法<xref:System.Text.StringBuilder>实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-231">The <xref:System.Text.StringBuilder> class includes methods that can reduce the size of the current <xref:System.Text.StringBuilder> instance.</span></span> <span data-ttu-id="c1488-232"><xref:System.Text.StringBuilder.Clear%2A>方法中删除所有字符，并设置<xref:System.Text.StringBuilder.Length%2A>属性设置为零。</span><span class="sxs-lookup"><span data-stu-id="c1488-232">The <xref:System.Text.StringBuilder.Clear%2A> method removes all characters and sets the <xref:System.Text.StringBuilder.Length%2A> property to zero.</span></span> <span data-ttu-id="c1488-233"><xref:System.Text.StringBuilder.Remove%2A>方法中删除指定的数量的特定索引位置开始的字符。</span><span class="sxs-lookup"><span data-stu-id="c1488-233">The <xref:System.Text.StringBuilder.Remove%2A> method deletes a specified number of characters starting at a particular index position.</span></span> <span data-ttu-id="c1488-234">此外，从末尾删除字符<xref:System.Text.StringBuilder>对象通过设置其<xref:System.Text.StringBuilder.Length%2A>属性的值小于当前实例的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-234">In addition, you can remove characters from the end of a <xref:System.Text.StringBuilder> object by setting its <xref:System.Text.StringBuilder.Length%2A> property to a value that is less than the length of the current instance.</span></span>

 <span data-ttu-id="c1488-235">下面的示例从对象中删除一些文本 <xref:System.Text.StringBuilder> 、显示其生成的容量、最大容量和 length 属性值，然后调用 <xref:System.Text.StringBuilder.Clear%2A> 方法从对象中删除所有字符 <xref:System.Text.StringBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-235">The following example removes some of the text from a <xref:System.Text.StringBuilder> object, displays its resulting capacity, maximum capacity, and length property values, and then calls the <xref:System.Text.StringBuilder.Clear%2A> method to remove all the characters from the <xref:System.Text.StringBuilder> object.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/delete1.cs" interactive="try-dotnet" id="Snippet10":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/delete1.vb" id="Snippet10":::

<a name="Modifying"></a>
### <a name="modifying-the-text-in-a-stringbuilder-object"></a><span data-ttu-id="c1488-236">修改 StringBuilder 对象中的文本</span><span class="sxs-lookup"><span data-stu-id="c1488-236">Modifying the text in a StringBuilder object</span></span>
 <span data-ttu-id="c1488-237"><xref:System.Text.StringBuilder.Replace%2A?displayProperty=nameWithType>方法将替换整个 <xref:System.Text.StringBuilder> 对象或特定字符范围内出现的所有字符或字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-237">The <xref:System.Text.StringBuilder.Replace%2A?displayProperty=nameWithType> method replaces all occurrences of a character or a string in the entire <xref:System.Text.StringBuilder> object or in a particular character range.</span></span> <span data-ttu-id="c1488-238">下面的示例使用 <xref:System.Text.StringBuilder.Replace%2A> 方法在对象中用问号 (？ ) 来替换所有惊叹号 (！ ) <xref:System.Text.StringBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-238">The following example uses the <xref:System.Text.StringBuilder.Replace%2A> method to replace all exclamation points (!) with question marks (?) in the <xref:System.Text.StringBuilder> object.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/replace1.cs" interactive="try-dotnet" id="Snippet11":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/replace1.vb" id="Snippet11":::

<a name="Searching"></a>
## <a name="searching-the-text-in-a-stringbuilder-object"></a><span data-ttu-id="c1488-239">在 StringBuilder 对象中搜索文本</span><span class="sxs-lookup"><span data-stu-id="c1488-239">Searching the text in a StringBuilder object</span></span>
 <span data-ttu-id="c1488-240"><xref:System.Text.StringBuilder>类不包括与 <xref:System.String.Contains%2A?displayProperty=nameWithType> 类提供的、和方法类似的方法 <xref:System.String.IndexOf%2A?displayProperty=nameWithType> <xref:System.String.StartsWith%2A?displayProperty=nameWithType> <xref:System.String> ，这允许您在对象中搜索特定字符或子字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-240">The <xref:System.Text.StringBuilder> class does not include methods similar to the <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, and <xref:System.String.StartsWith%2A?displayProperty=nameWithType> methods provided by the <xref:System.String> class, which allow you to search the object for a particular character or a substring.</span></span> <span data-ttu-id="c1488-241">若要确定子字符串的存在或起始字符位置，需要 <xref:System.String> 使用字符串搜索方法或正则表达式方法搜索某个值。</span><span class="sxs-lookup"><span data-stu-id="c1488-241">Determining the presence or starting character position of a substring requires that you search a <xref:System.String> value by using either a string search method or a regular expression method.</span></span> <span data-ttu-id="c1488-242">可通过四种方式实现此类搜索，如下表所示。</span><span class="sxs-lookup"><span data-stu-id="c1488-242">There are four ways to implement such searches, as the following table shows.</span></span>

|<span data-ttu-id="c1488-243">方法</span><span class="sxs-lookup"><span data-stu-id="c1488-243">Technique</span></span>|<span data-ttu-id="c1488-244">优点</span><span class="sxs-lookup"><span data-stu-id="c1488-244">Pros</span></span>|<span data-ttu-id="c1488-245">缺点</span><span class="sxs-lookup"><span data-stu-id="c1488-245">Cons</span></span>|
|---------------|----------|----------|
|<span data-ttu-id="c1488-246">搜索字符串值，然后将其添加到 <xref:System.Text.StringBuilder> 对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-246">Search string values before adding them to the <xref:System.Text.StringBuilder> object.</span></span>|<span data-ttu-id="c1488-247">适用于确定子字符串是否存在。</span><span class="sxs-lookup"><span data-stu-id="c1488-247">Useful for determining whether a substring exists.</span></span>|<span data-ttu-id="c1488-248">子字符串的索引位置非常重要时，不能使用。</span><span class="sxs-lookup"><span data-stu-id="c1488-248">Cannot be used when the index position of a substring is important.</span></span>|
|<span data-ttu-id="c1488-249">调用 <xref:System.Text.StringBuilder.ToString%2A> 并搜索返回的 <xref:System.String> 对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-249">Call <xref:System.Text.StringBuilder.ToString%2A> and search the returned <xref:System.String> object.</span></span>|<span data-ttu-id="c1488-250">如果将所有文本分配到 <xref:System.Text.StringBuilder> 对象，然后开始对其进行修改，则可轻松使用。</span><span class="sxs-lookup"><span data-stu-id="c1488-250">Easy to use if you assign all the text to a <xref:System.Text.StringBuilder> object, and then begin to modify it.</span></span>|<span data-ttu-id="c1488-251"><xref:System.Text.StringBuilder.ToString%2A>如果您必须在将所有文本添加到对象之前进行修改，则重复调用会很繁琐 <xref:System.Text.StringBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-251">Cumbersome to repeatedly call <xref:System.Text.StringBuilder.ToString%2A> if you must make modifications before all text is added to the <xref:System.Text.StringBuilder> object.</span></span><br /><br /> <span data-ttu-id="c1488-252">如果要进行更改，则必须记得从对象的文本末尾进行操作 <xref:System.Text.StringBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-252">You must remember to work from the end of the <xref:System.Text.StringBuilder> object's text if you're making changes.</span></span>|
|<span data-ttu-id="c1488-253">使用 <xref:System.Text.StringBuilder.Chars%2A> 属性按顺序搜索字符范围。</span><span class="sxs-lookup"><span data-stu-id="c1488-253">Use the <xref:System.Text.StringBuilder.Chars%2A> property to sequentially search a range of characters.</span></span>|<span data-ttu-id="c1488-254">如果您担心单个字符或小型子字符串，此方法非常有用。</span><span class="sxs-lookup"><span data-stu-id="c1488-254">Useful if you're concerned with individual characters or a small substring.</span></span>|<span data-ttu-id="c1488-255">如果搜索的字符数很大或者搜索逻辑很复杂，则这种情况很繁琐。</span><span class="sxs-lookup"><span data-stu-id="c1488-255">Cumbersome if the number of characters to search is large or if the search logic is complex.</span></span><br /><br /><span data-ttu-id="c1488-256">通过重复方法调用，导致非常大的对象性能非常差。</span><span class="sxs-lookup"><span data-stu-id="c1488-256">Results in very poor performance for objects that have grown very large through repeated method calls.</span></span>  |
|<span data-ttu-id="c1488-257">将 <xref:System.Text.StringBuilder> 对象转换为 <xref:System.String> 对象，并对对象执行修改 <xref:System.String> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-257">Convert the <xref:System.Text.StringBuilder> object to a <xref:System.String> object, and perform modifications on the <xref:System.String> object.</span></span>|<span data-ttu-id="c1488-258">如果修改次数较小，则此方法很有用。</span><span class="sxs-lookup"><span data-stu-id="c1488-258">Useful if the number of modifications is small.</span></span>|<span data-ttu-id="c1488-259">如果修改的数量较大，则会使类的性能优势抵消 <xref:System.Text.StringBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-259">Negates the performance benefit of the <xref:System.Text.StringBuilder> class if the number of modifications is large.</span></span>|

 <span data-ttu-id="c1488-260">让我们更详细地研究一下这些方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-260">Let's examine these techniques in greater detail.</span></span>

-   <span data-ttu-id="c1488-261">如果搜索的目标是确定特定的子字符串是否存在 (也就是说，如果不感兴趣) 子字符串的位置，则可以在将字符串存储到对象之前对其进行搜索 <xref:System.Text.StringBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-261">If the goal of the search is to determine whether a particular substring exists (that is, if you aren't interested in the position of the substring), you can search strings before storing them in the <xref:System.Text.StringBuilder> object.</span></span> <span data-ttu-id="c1488-262">下面的示例提供了一个可能的实现。</span><span class="sxs-lookup"><span data-stu-id="c1488-262">The following example provides one possible implementation.</span></span> <span data-ttu-id="c1488-263">它定义一个 `StringBuilderFinder` 类，该类的构造函数传递对对象的引用 <xref:System.Text.StringBuilder> 以及要在字符串中查找的子字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-263">It defines a `StringBuilderFinder` class whose constructor is passed a reference to a <xref:System.Text.StringBuilder> object and the substring to find in the string.</span></span> <span data-ttu-id="c1488-264">在这种情况下，该示例将尝试确定是否已记录温度为华氏温度或摄氏温度，并将相应的引导文本添加到对象的开头 <xref:System.Text.StringBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-264">In this case, the example tries to determine whether recorded temperatures are in Fahrenheit or Celsius, and adds the appropriate introductory text to the beginning of the <xref:System.Text.StringBuilder> object.</span></span> <span data-ttu-id="c1488-265">随机数生成器用于选择以摄氏或华氏度为单位包含数据的数组。</span><span class="sxs-lookup"><span data-stu-id="c1488-265">A random number generator is used to select an array that contains data in either degrees Celsius or degrees Fahrenheit.</span></span>

     :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern1.cs" interactive="try-dotnet" id="Snippet12":::
     :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern1.vb" id="Snippet12":::

-   <span data-ttu-id="c1488-266">调用 <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> 方法将 <xref:System.Text.StringBuilder> 对象转换为 <xref:System.String> 对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-266">Call the <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> method to convert the <xref:System.Text.StringBuilder> object to a <xref:System.String> object.</span></span> <span data-ttu-id="c1488-267">您可以使用或等方法搜索字符串 <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> <xref:System.String.StartsWith%2A?displayProperty=nameWithType> ，也可以使用正则表达式和 <xref:System.Text.RegularExpressions.Regex> 类搜索模式。</span><span class="sxs-lookup"><span data-stu-id="c1488-267">You can search the string by using methods such as <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> or <xref:System.String.StartsWith%2A?displayProperty=nameWithType>, or you can use regular expressions and the <xref:System.Text.RegularExpressions.Regex> class to search for patterns.</span></span> <span data-ttu-id="c1488-268">由于 <xref:System.Text.StringBuilder> 和 <xref:System.String> 对象使用 utf-16 编码存储字符，因此字符、子字符串和正则表达式匹配项的索引位置在这两个对象中是相同的。</span><span class="sxs-lookup"><span data-stu-id="c1488-268">Because both <xref:System.Text.StringBuilder> and <xref:System.String> objects use UTF-16 encoding to store characters, the index positions of characters, substrings, and regular expression matches are the same in both objects.</span></span> <span data-ttu-id="c1488-269">这使您可以使用 <xref:System.Text.StringBuilder> 方法在对象中找到该文本的同一位置进行更改 <xref:System.String> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-269">This enables you to use <xref:System.Text.StringBuilder> methods to make changes at the same position at which that text is found in the <xref:System.String> object.</span></span>

    > [!NOTE]
    >  <span data-ttu-id="c1488-270">如果采用这种方法，应从对象的末尾开始工作， <xref:System.Text.StringBuilder> 这样就不必反复将 <xref:System.Text.StringBuilder> 对象转换为字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-270">If you adopt this approach, you should work from the end of the <xref:System.Text.StringBuilder> object to its beginning so that you don't have to repeatedly convert the <xref:System.Text.StringBuilder> object to a string.</span></span>

     <span data-ttu-id="c1488-271">下面的示例阐释了这种方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-271">The following example illustrates this approach.</span></span> <span data-ttu-id="c1488-272">它在对象中存储每个英文字母的四个匹配项 <xref:System.Text.StringBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-272">It stores four occurrences of each letter of the English alphabet in a <xref:System.Text.StringBuilder> object.</span></span> <span data-ttu-id="c1488-273">然后，它将文本转换为 <xref:System.String> 对象，并使用正则表达式标识每个四字符序列的起始位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-273">It then converts the text to a <xref:System.String> object and uses a regular expression to identify the starting position of each four-character sequence.</span></span> <span data-ttu-id="c1488-274">最后，在除第一个序列外的每个四字符序列之前添加下划线，并将序列的第一个字符转换为大写。</span><span class="sxs-lookup"><span data-stu-id="c1488-274">Finally, it adds an underscore before each four-character sequence except for the first sequence, and converts the first character of the sequence to uppercase.</span></span>

     :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern2.cs" interactive="try-dotnet" id="Snippet13":::
     :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern2.vb" id="Snippet13":::

-   <span data-ttu-id="c1488-275">使用 <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> 属性可按顺序在对象中搜索一定范围内的字符 <xref:System.Text.StringBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-275">Use the <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> property to sequentially search a range of characters in a <xref:System.Text.StringBuilder> object.</span></span> <span data-ttu-id="c1488-276">如果要搜索的字符数很大或者搜索逻辑特别复杂，则这种方法可能不可行。</span><span class="sxs-lookup"><span data-stu-id="c1488-276">This approach may not be practical if the number of characters to be searched is large or the search logic is particularly complex.</span></span> <span data-ttu-id="c1488-277">对于非常大的分块对象的基于字符索引的访问的性能影响 <xref:System.Text.StringBuilder> ，请参阅属性的文档 <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-277">For the performance implications of character-by-character index-based access for very large, chunked <xref:System.Text.StringBuilder> objects, see the documentation for the <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> property.</span></span>

     <span data-ttu-id="c1488-278">下面的示例与上一个示例的功能相同，但实现方式不同。</span><span class="sxs-lookup"><span data-stu-id="c1488-278">The following example is identical in functionality to the previous example but differs in implementation.</span></span> <span data-ttu-id="c1488-279">它使用 <xref:System.Text.StringBuilder.Chars%2A> 属性来检测某个字符值已更改的时间，在该位置插入一个下划线，并将新序列中的第一个字符转换为大写。</span><span class="sxs-lookup"><span data-stu-id="c1488-279">It uses the <xref:System.Text.StringBuilder.Chars%2A> property to detect when a character value has changed, inserts an underscore at that position, and converts the first character in the new sequence to uppercase.</span></span>

     :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern3.cs" interactive="try-dotnet" id="Snippet14":::
     :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern3.vb" id="Snippet14":::

-   <span data-ttu-id="c1488-280">将所有未修改的文本存储在 <xref:System.Text.StringBuilder> 对象中，调用 <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> 方法将对象转换 <xref:System.Text.StringBuilder> 为 <xref:System.String> 对象，然后对对象执行修改 <xref:System.String> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-280">Store all the unmodified text in the <xref:System.Text.StringBuilder> object, call the <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> method to convert the <xref:System.Text.StringBuilder> object to a <xref:System.String> object, and perform the modifications on the <xref:System.String> object.</span></span> <span data-ttu-id="c1488-281">如果只有少量的修改，可以使用此方法;否则，使用不可变字符串的成本可能会抵消使用对象的性能优势 <xref:System.Text.StringBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-281">You can use this approach if you have only a few modifications; otherwise, the cost of working with immutable strings may negate the performance benefits of using a <xref:System.Text.StringBuilder> object.</span></span>

     <span data-ttu-id="c1488-282">下面的示例在功能上与前面两个示例相同，但实现方式不同。</span><span class="sxs-lookup"><span data-stu-id="c1488-282">The following example is identical in functionality to the previous two examples but differs in implementation.</span></span> <span data-ttu-id="c1488-283">它将创建一个 <xref:System.Text.StringBuilder> 对象，将其转换为 <xref:System.String> 对象，然后使用正则表达式对该字符串执行所有剩余的修改。</span><span class="sxs-lookup"><span data-stu-id="c1488-283">It creates a <xref:System.Text.StringBuilder> object, converts it to a <xref:System.String> object, and then uses a regular expression to perform all remaining modifications on the string.</span></span> <span data-ttu-id="c1488-284"><xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType>方法使用 lambda 表达式对每个匹配项执行替换。</span><span class="sxs-lookup"><span data-stu-id="c1488-284">The <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> method uses a lambda expression to perform the replacement on each match.</span></span>

     :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern4.cs" interactive="try-dotnet" id="Snippet15":::
     :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern4.vb" id="Snippet15":::

<a name="Converting"></a>
## <a name="converting-the-stringbuilder-object-to-a-string"></a><span data-ttu-id="c1488-285">将 StringBuilder 对象转换为字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-285">Converting the StringBuilder object to a string</span></span>
 <span data-ttu-id="c1488-286">必须先将 <xref:System.Text.StringBuilder> 对象转换为 <xref:System.String> 对象，然后才能将 <xref:System.Text.StringBuilder> 对象表示的字符串传递给包含 <xref:System.String> 参数的方法，或在用户界面中显示它。</span><span class="sxs-lookup"><span data-stu-id="c1488-286">You must convert the <xref:System.Text.StringBuilder> object to a <xref:System.String> object before you can pass the string represented by the <xref:System.Text.StringBuilder> object to a method that has a <xref:System.String> parameter or display it in the user interface.</span></span> <span data-ttu-id="c1488-287">可以通过调用方法来执行此转换 <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-287">You perform this conversion by calling the <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c1488-288">有关说明，请参阅前面的示例，该示例调用 <xref:System.Text.StringBuilder.ToString%2A> 方法将对象转换 <xref:System.Text.StringBuilder> 为字符串，以便可以将其传递给正则表达式方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-288">For an illustration, see the previous example, which calls the <xref:System.Text.StringBuilder.ToString%2A> method to convert a <xref:System.Text.StringBuilder> object to a string so that it can be passed to a regular expression method.</span></span>



## Examples
 <span data-ttu-id="c1488-289">下面的示例演示如何调用类定义的多个方法 <xref:System.Text.StringBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-289">The following example shows how to call many of the methods defined by the <xref:System.Text.StringBuilder> class.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb" id="Snippet1":::

 ]]></format>
    </remarks>
    <block subset="none" type="usage"><para><span data-ttu-id="c1488-290">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-290">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-291">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-291">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c1488-292">初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-292">Initializes a new instance of the <see cref="T:System.Text.StringBuilder" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c1488-293">初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-293">Initializes a new instance of the <see cref="T:System.Text.StringBuilder" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-294">此实例的字符串值设置为 <xref:System.String.Empty?displayProperty=nameWithType> ，容量设置为特定于实现的默认容量。</span><span class="sxs-lookup"><span data-stu-id="c1488-294">The string value of this instance is set to <xref:System.String.Empty?displayProperty=nameWithType>, and the capacity is set to the implementation-specific default capacity.</span></span>



## Examples
 <span data-ttu-id="c1488-295">下面的示例演示如何调用 <xref:System.Text.StringBuilder.%23ctor%2A> 不带参数的构造函数。</span><span class="sxs-lookup"><span data-stu-id="c1488-295">The following example demonstrates how to call the <xref:System.Text.StringBuilder.%23ctor%2A> constructor with no parameters.</span></span>

 [!code-cpp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#1)]
 [!code-csharp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#1)]
 [!code-vb[System.Text.StringBuilder.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity"><span data-ttu-id="c1488-296">此实例的建议起始大小。</span><span class="sxs-lookup"><span data-stu-id="c1488-296">The suggested starting size of this instance.</span></span></param>
        <summary><span data-ttu-id="c1488-297">使用指定的容量初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-297">Initializes a new instance of the <see cref="T:System.Text.StringBuilder" /> class using the specified capacity.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-298">`capacity`参数定义可存储在当前实例所分配的内存中的最大字符数。</span><span class="sxs-lookup"><span data-stu-id="c1488-298">The `capacity` parameter defines the maximum number of characters that can be stored in the memory allocated by the current instance.</span></span> <span data-ttu-id="c1488-299">它的值被分配给 <xref:System.Text.StringBuilder.Capacity%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="c1488-299">Its value is assigned to the <xref:System.Text.StringBuilder.Capacity%2A> property.</span></span> <span data-ttu-id="c1488-300">如果要存储在当前实例中的字符数超出此 `capacity` 值，则对象将 <xref:System.Text.StringBuilder> 分配额外的内存来存储它们。</span><span class="sxs-lookup"><span data-stu-id="c1488-300">If the number of characters to be stored in the current instance exceeds this `capacity` value, the <xref:System.Text.StringBuilder> object allocates additional memory to store them.</span></span>

 <span data-ttu-id="c1488-301">此实例的字符串值设置为 <xref:System.String.Empty?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-301">The string value of this instance is set to <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c1488-302">如果 `capacity` 为零，则使用特定于实现的默认容量。</span><span class="sxs-lookup"><span data-stu-id="c1488-302">If `capacity` is zero, the implementation-specific default capacity is used.</span></span>



## Examples
 <span data-ttu-id="c1488-303">下面的示例演示如何 <xref:System.Text.StringBuilder.%23ctor%2A> 使用指定的容量调用构造函数。</span><span class="sxs-lookup"><span data-stu-id="c1488-303">The following example demonstrates how to call the <xref:System.Text.StringBuilder.%23ctor%2A> constructor with a specified capacity.</span></span>

 [!code-cpp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#3)]
 [!code-csharp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#3)]
 [!code-vb[System.Text.StringBuilder.Constructors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#3)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-304"><paramref name="capacity" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="c1488-304"><paramref name="capacity" /> is less than zero.</span></span></exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="c1488-305">用于初始化实例值的字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-305">The string used to initialize the value of the instance.</span></span> <span data-ttu-id="c1488-306">如果 <paramref name="value" /> 为 <see langword="null" />，则新的 <see cref="T:System.Text.StringBuilder" /> 将包含空字符串（即包含 <see cref="F:System.String.Empty" />）。</span><span class="sxs-lookup"><span data-stu-id="c1488-306">If <paramref name="value" /> is <see langword="null" />, the new <see cref="T:System.Text.StringBuilder" /> will contain the empty string (that is, it contains <see cref="F:System.String.Empty" />).</span></span></param>
        <summary><span data-ttu-id="c1488-307">使用指定的字符串初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-307">Initializes a new instance of the <see cref="T:System.Text.StringBuilder" /> class using the specified string.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-308">如果 `value` 为 `null`，则新的 <xref:System.Text.StringBuilder> 将包含空字符串（即包含 <xref:System.String.Empty>）。</span><span class="sxs-lookup"><span data-stu-id="c1488-308">If `value` is `null`, the new <xref:System.Text.StringBuilder> will contain the empty string (that is, it contains <xref:System.String.Empty>).</span></span>



## Examples
 <span data-ttu-id="c1488-309">下面的示例演示如何调用 <xref:System.Text.StringBuilder.%23ctor%2A> 具有指定字符串的构造函数。</span><span class="sxs-lookup"><span data-stu-id="c1488-309">The following example demonstrates how to call the <xref:System.Text.StringBuilder.%23ctor%2A> constructor with the specified string.</span></span>

 [!code-cpp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#4)]
 [!code-csharp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#4)]
 [!code-vb[System.Text.StringBuilder.Constructors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#4)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity, int maxCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, int32 maxCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, maxCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity, int maxCapacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (capacity, maxCapacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="maxCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity"><span data-ttu-id="c1488-310"><see cref="T:System.Text.StringBuilder" /> 的建议起始大小。</span><span class="sxs-lookup"><span data-stu-id="c1488-310">The suggested starting size of the <see cref="T:System.Text.StringBuilder" />.</span></span></param>
        <param name="maxCapacity"><span data-ttu-id="c1488-311">当前字符串可包含的最大字符数。</span><span class="sxs-lookup"><span data-stu-id="c1488-311">The maximum number of characters the current string can contain.</span></span></param>
        <summary><span data-ttu-id="c1488-312">初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例，该类起始于指定容量并且可增长到指定的最大容量。</span><span class="sxs-lookup"><span data-stu-id="c1488-312">Initializes a new instance of the <see cref="T:System.Text.StringBuilder" /> class that starts with a specified capacity and can grow to a specified maximum.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-313">`capacity`参数定义可存储在当前实例所分配的内存中的最大字符数。</span><span class="sxs-lookup"><span data-stu-id="c1488-313">The `capacity` parameter defines the maximum number of characters that can be stored in the memory allocated by the current instance.</span></span> <span data-ttu-id="c1488-314">它的值被分配给 <xref:System.Text.StringBuilder.Capacity%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="c1488-314">Its value is assigned to the <xref:System.Text.StringBuilder.Capacity%2A> property.</span></span> <span data-ttu-id="c1488-315">如果要存储在当前实例中的字符数超出此 `capacity` 值，则对象将 <xref:System.Text.StringBuilder> 分配额外的内存来存储它们。</span><span class="sxs-lookup"><span data-stu-id="c1488-315">If the number of characters to be stored in the current instance exceeds this `capacity` value, the <xref:System.Text.StringBuilder> object allocates additional memory to store them.</span></span>

 <span data-ttu-id="c1488-316">如果 `capacity` 为零，则使用特定于实现的默认容量。</span><span class="sxs-lookup"><span data-stu-id="c1488-316">If `capacity` is zero, the implementation-specific default capacity is used.</span></span>

 <span data-ttu-id="c1488-317">`maxCapacity`属性定义当前实例可以容纳的最大字符数。</span><span class="sxs-lookup"><span data-stu-id="c1488-317">The `maxCapacity` property defines the maximum number of characters that the current instance can hold.</span></span> <span data-ttu-id="c1488-318">它的值被分配给 <xref:System.Text.StringBuilder.MaxCapacity%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="c1488-318">Its value is assigned to the <xref:System.Text.StringBuilder.MaxCapacity%2A> property.</span></span> <span data-ttu-id="c1488-319">如果要在当前实例中存储的字符数超过此 `maxCapacity` 值，则对象不 <xref:System.Text.StringBuilder> 会分配额外的内存，而是引发异常。</span><span class="sxs-lookup"><span data-stu-id="c1488-319">If the number of characters to be stored in the current instance exceeds this `maxCapacity` value, the <xref:System.Text.StringBuilder> object does not allocate additional memory, but instead throws an exception.</span></span>



## Examples
 <span data-ttu-id="c1488-320">下面的示例演示如何 <xref:System.Text.StringBuilder.%23ctor%2A> 使用指定的容量和最大容量调用构造函数。</span><span class="sxs-lookup"><span data-stu-id="c1488-320">The following example demonstrates how to call the <xref:System.Text.StringBuilder.%23ctor%2A> constructor with a specified capacity and maximum capacity.</span></span>

 [!code-cpp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#5)]
 [!code-csharp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#5)]
 [!code-vb[System.Text.StringBuilder.Constructors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#5)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-321"><paramref name="maxCapacity" /> 小于一，<paramref name="capacity" /> 小于零，或 <paramref name="capacity" /> 大于 <paramref name="maxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-321"><paramref name="maxCapacity" /> is less than one, <paramref name="capacity" /> is less than zero, or <paramref name="capacity" /> is greater than <paramref name="maxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-322">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-322">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-323">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-323">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
        <altmember cref="P:System.Text.StringBuilder.MaxCapacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="c1488-324">用于初始化实例值的字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-324">The string used to initialize the value of the instance.</span></span> <span data-ttu-id="c1488-325">如果 <paramref name="value" /> 为 <see langword="null" />，则新的 <see cref="T:System.Text.StringBuilder" /> 将包含空字符串（即包含 <see cref="F:System.String.Empty" />）。</span><span class="sxs-lookup"><span data-stu-id="c1488-325">If <paramref name="value" /> is <see langword="null" />, the new <see cref="T:System.Text.StringBuilder" /> will contain the empty string (that is, it contains <see cref="F:System.String.Empty" />).</span></span></param>
        <param name="capacity"><span data-ttu-id="c1488-326"><see cref="T:System.Text.StringBuilder" /> 的建议起始大小。</span><span class="sxs-lookup"><span data-stu-id="c1488-326">The suggested starting size of the <see cref="T:System.Text.StringBuilder" />.</span></span></param>
        <summary><span data-ttu-id="c1488-327">使用指定的字符串和容量初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-327">Initializes a new instance of the <see cref="T:System.Text.StringBuilder" /> class using the specified string and capacity.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-328">`capacity`参数定义可存储在当前实例所分配的内存中的最大字符数。</span><span class="sxs-lookup"><span data-stu-id="c1488-328">The `capacity` parameter defines the maximum number of characters that can be stored in the memory allocated by the current instance.</span></span> <span data-ttu-id="c1488-329">它的值被分配给 <xref:System.Text.StringBuilder.Capacity%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="c1488-329">Its value is assigned to the <xref:System.Text.StringBuilder.Capacity%2A> property.</span></span> <span data-ttu-id="c1488-330">如果要存储在当前实例中的字符数超出此 `capacity` 值，则对象将 <xref:System.Text.StringBuilder> 分配额外的内存来存储它们。</span><span class="sxs-lookup"><span data-stu-id="c1488-330">If the number of characters to be stored in the current instance exceeds this `capacity` value, the <xref:System.Text.StringBuilder> object allocates additional memory to store them.</span></span>

 <span data-ttu-id="c1488-331">如果 `capacity` 为零，则使用特定于实现的默认容量。</span><span class="sxs-lookup"><span data-stu-id="c1488-331">If `capacity` is zero, the implementation-specific default capacity is used.</span></span>



## Examples
 <span data-ttu-id="c1488-332">下面的示例演示如何 <xref:System.Text.StringBuilder.%23ctor%2A> 使用初始字符串和指定的容量调用构造函数。</span><span class="sxs-lookup"><span data-stu-id="c1488-332">The following example demonstrates how to call the <xref:System.Text.StringBuilder.%23ctor%2A> constructor with an initial string and a specified capacity.</span></span>

 [!code-cpp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#7)]
 [!code-csharp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#7)]
 [!code-vb[System.Text.StringBuilder.Constructors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#7)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-333"><paramref name="capacity" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="c1488-333"><paramref name="capacity" /> is less than zero.</span></span></exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 startIndex, int32 length, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, startIndex As Integer, length As Integer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int * int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, startIndex, length, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="c1488-334">字符串包含用于初始化此实例值的子字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-334">The string that contains the substring used to initialize the value of this instance.</span></span> <span data-ttu-id="c1488-335">如果 <paramref name="value" /> 为 <see langword="null" />，则新的 <see cref="T:System.Text.StringBuilder" /> 将包含空字符串（即包含 <see cref="F:System.String.Empty" />）。</span><span class="sxs-lookup"><span data-stu-id="c1488-335">If <paramref name="value" /> is <see langword="null" />, the new <see cref="T:System.Text.StringBuilder" /> will contain the empty string (that is, it contains <see cref="F:System.String.Empty" />).</span></span></param>
        <param name="startIndex"><span data-ttu-id="c1488-336"><paramref name="value" /> 中子字符串开始的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-336">The position within <paramref name="value" /> where the substring begins.</span></span></param>
        <param name="length"><span data-ttu-id="c1488-337">子字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="c1488-337">The number of characters in the substring.</span></span></param>
        <param name="capacity"><span data-ttu-id="c1488-338"><see cref="T:System.Text.StringBuilder" /> 的建议起始大小。</span><span class="sxs-lookup"><span data-stu-id="c1488-338">The suggested starting size of the <see cref="T:System.Text.StringBuilder" />.</span></span></param>
        <summary><span data-ttu-id="c1488-339">从指定的子字符串和容量初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-339">Initializes a new instance of the <see cref="T:System.Text.StringBuilder" /> class from the specified substring and capacity.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-340">`capacity`参数定义可存储在当前实例所分配的内存中的最大字符数。</span><span class="sxs-lookup"><span data-stu-id="c1488-340">The `capacity` parameter defines the maximum number of characters that can be stored in the memory allocated by the current instance.</span></span> <span data-ttu-id="c1488-341">它的值被分配给 <xref:System.Text.StringBuilder.Capacity%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="c1488-341">Its value is assigned to the <xref:System.Text.StringBuilder.Capacity%2A> property.</span></span> <span data-ttu-id="c1488-342">如果要存储在当前实例中的字符数超出此 `capacity` 值，则对象将 <xref:System.Text.StringBuilder> 分配额外的内存来存储它们。</span><span class="sxs-lookup"><span data-stu-id="c1488-342">If the number of characters to be stored in the current instance exceeds this `capacity` value, the <xref:System.Text.StringBuilder> object allocates additional memory to store them.</span></span>

 <span data-ttu-id="c1488-343">如果 `capacity` 为零，则使用特定于实现的默认容量。</span><span class="sxs-lookup"><span data-stu-id="c1488-343">If `capacity` is zero, the implementation-specific default capacity is used.</span></span>



## Examples
 <span data-ttu-id="c1488-344">下面的示例演示如何调用 <xref:System.Text.StringBuilder.%23ctor%2A> 具有指定字符串的构造函数。</span><span class="sxs-lookup"><span data-stu-id="c1488-344">The following example demonstrates how to call the <xref:System.Text.StringBuilder.%23ctor%2A> constructor with the specified string.</span></span>

 [!code-cpp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#6)]
 [!code-csharp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#6)]
 [!code-vb[System.Text.StringBuilder.Constructors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#6)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-345"><paramref name="capacity" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="c1488-345"><paramref name="capacity" /> is less than zero.</span></span>

<span data-ttu-id="c1488-346">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-346">-or-</span></span>

 <span data-ttu-id="c1488-347"><paramref name="startIndex" /> 加 <paramref name="length" /> 不是 <paramref name="value" /> 中的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-347"><paramref name="startIndex" /> plus <paramref name="length" /> is not a position within <paramref name="value" />.</span></span></exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c1488-348">向此实例追加指定对象的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-348">Appends the string representation of a specified object to this instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(bool value);" />
      <MemberSignature Language="F#" Value="member this.Append : bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="c1488-349">要追加的布尔值。</span><span class="sxs-lookup"><span data-stu-id="c1488-349">The Boolean value to append.</span></span></param>
        <summary><span data-ttu-id="c1488-350">向此实例追加指定的布尔值的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-350">Appends the string representation of a specified Boolean value to this instance.</span></span></summary>
        <returns><span data-ttu-id="c1488-351">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-351">A reference to this instance after the append operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-352"><xref:System.Text.StringBuilder.Append%28System.Boolean%29>方法修改此类的现有实例，而不返回新的类实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-352">The <xref:System.Text.StringBuilder.Append%28System.Boolean%29> method modifies the existing instance of this class; it does not return a new class instance.</span></span> <span data-ttu-id="c1488-353">因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="c1488-353">Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <xref:System.Text.StringBuilder> object, as the following example illustrates.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb" id="Snippet2"::: 

 <span data-ttu-id="c1488-354"><xref:System.Text.StringBuilder.Append%28System.Boolean%29>方法调用 <xref:System.Boolean.ToString?displayProperty=nameWithType> 方法来获取的字符串表示形式 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-354">The <xref:System.Text.StringBuilder.Append%28System.Boolean%29> method calls the <xref:System.Boolean.ToString?displayProperty=nameWithType> method to get the string representation of `value`.</span></span> <span data-ttu-id="c1488-355">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-355">The capacity of this instance is adjusted as needed.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-356">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-356">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-357">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-357">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-358">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-358">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Append : byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="c1488-359">要追加的值。</span><span class="sxs-lookup"><span data-stu-id="c1488-359">The value to append.</span></span></param>
        <summary><span data-ttu-id="c1488-360">向此实例追加指定的 8 位无符号整数的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-360">Appends the string representation of a specified 8-bit unsigned integer to this instance.</span></span></summary>
        <returns><span data-ttu-id="c1488-361">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-361">A reference to this instance after the append operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-362"><xref:System.Text.StringBuilder.Append%28System.Byte%29>方法修改此类的现有实例，而不返回新的类实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-362">The <xref:System.Text.StringBuilder.Append%28System.Byte%29> method modifies the existing instance of this class; it does not return a new class instance.</span></span> <span data-ttu-id="c1488-363">因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="c1488-363">Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <xref:System.Text.StringBuilder> object, as the following example illustrates.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs" interactive="try-dotnet-method" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb" id="Snippet3":::

 <span data-ttu-id="c1488-364"><xref:System.Text.StringBuilder.Append%28System.Byte%29>方法调用 <xref:System.Byte.ToString%28System.IFormatProvider%29> 方法为当前区域性获取的字符串表示形式 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-364">The <xref:System.Text.StringBuilder.Append%28System.Byte%29> method calls the <xref:System.Byte.ToString%28System.IFormatProvider%29> method to get the string representation of `value` for the current culture.</span></span> <span data-ttu-id="c1488-365">若要控制的格式 `value` ，请调用 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-365">To control the formatting of `value`, call the <xref:System.Text.StringBuilder.AppendFormat%2A> method.</span></span>

 <span data-ttu-id="c1488-366">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-366">The capacity of this instance is adjusted as needed.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-367">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-367">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-368">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-368">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-369">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-369">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value);" />
      <MemberSignature Language="F#" Value="member this.Append : char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="c1488-370">要追加的 UTF 16 编码的代码单元。</span><span class="sxs-lookup"><span data-stu-id="c1488-370">The UTF-16-encoded code unit to append.</span></span></param>
        <summary><span data-ttu-id="c1488-371">将指定的 <see cref="T:System.Char" /> 对象的字符串表示形式追加到此实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-371">Appends the string representation of a specified <see cref="T:System.Char" /> object to this instance.</span></span></summary>
        <returns><span data-ttu-id="c1488-372">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-372">A reference to this instance after the append operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-373"><xref:System.Text.StringBuilder.Append%28System.Char%29>方法修改此类的现有实例，而不返回新的类实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-373">The <xref:System.Text.StringBuilder.Append%28System.Char%29> method modifies the existing instance of this class; it does not return a new class instance.</span></span> <span data-ttu-id="c1488-374">因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="c1488-374">Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <xref:System.Text.StringBuilder> object, as the following example illustrates.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs" interactive="try-dotnet-method" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb" id="Snippet4":::

 <span data-ttu-id="c1488-375">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-375">The capacity of this instance is adjusted as needed.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-376">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-376">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-377">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-377">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-378">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-378">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[]? value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="c1488-379">要追加的字符数组。</span><span class="sxs-lookup"><span data-stu-id="c1488-379">The array of characters to append.</span></span></param>
        <summary><span data-ttu-id="c1488-380">向此实例追加指定数组中的 Unicode 字符的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-380">Appends the string representation of the Unicode characters in a specified array to this instance.</span></span></summary>
        <returns><span data-ttu-id="c1488-381">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-381">A reference to this instance after the append operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-382">此方法将指定数组中的所有字符追加到当前实例，其顺序与它们在中出现的顺序相同 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-382">This method appends all the characters in the specified array to the current instance in the same order as they appear in `value`.</span></span> <span data-ttu-id="c1488-383">如果 `value` 为 `null` ，则不进行任何更改。</span><span class="sxs-lookup"><span data-stu-id="c1488-383">If `value` is `null`, no changes are made.</span></span>

 <span data-ttu-id="c1488-384"><xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%29>方法修改此类的现有实例，而不返回新的类实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-384">The <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%29> method modifies the existing instance of this class; it does not return a new class instance.</span></span> <span data-ttu-id="c1488-385">因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="c1488-385">Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <xref:System.Text.StringBuilder> object, as the following example illustrates.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs" interactive="try-dotnet-method" id="Snippet6":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb" id="Snippet6"::: 

 <span data-ttu-id="c1488-386">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-386">The capacity of this instance is adjusted as needed.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-387">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-387">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-388">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-388">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-389">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-389">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Append : decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="c1488-390">要追加的值。</span><span class="sxs-lookup"><span data-stu-id="c1488-390">The value to append.</span></span></param>
        <summary><span data-ttu-id="c1488-391">向此实例追加指定的十进制数的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-391">Appends the string representation of a specified decimal number to this instance.</span></span></summary>
        <returns><span data-ttu-id="c1488-392">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-392">A reference to this instance after the append operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-393"><xref:System.Text.StringBuilder.Append%28System.Decimal%29>方法修改此类的现有实例，而不返回新的类实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-393">The <xref:System.Text.StringBuilder.Append%28System.Decimal%29> method modifies the existing instance of this class; it does not return a new class instance.</span></span> <span data-ttu-id="c1488-394">因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="c1488-394">Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <xref:System.Text.StringBuilder> object, as the following example illustrates.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs" interactive="try-dotnet-method" id="Snippet8":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb" id="Snippet8":::

 <span data-ttu-id="c1488-395"><xref:System.Text.StringBuilder.Append%28System.Decimal%29>方法调用 <xref:System.Decimal.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 方法为当前区域性获取的字符串表示形式 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-395">The <xref:System.Text.StringBuilder.Append%28System.Decimal%29> method calls the <xref:System.Decimal.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> method to get the string representation of `value` for the current culture.</span></span> <span data-ttu-id="c1488-396">若要控制的格式 `value` ，请调用 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-396">To control the formatting of `value`, call the <xref:System.Text.StringBuilder.AppendFormat%2A> method.</span></span>

 <span data-ttu-id="c1488-397">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-397">The capacity of this instance is adjusted as needed.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-398">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-398">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-399">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-399">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-400">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-400">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(double value);" />
      <MemberSignature Language="F#" Value="member this.Append : double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="c1488-401">要追加的值。</span><span class="sxs-lookup"><span data-stu-id="c1488-401">The value to append.</span></span></param>
        <summary><span data-ttu-id="c1488-402">向此实例追加指定的双精度浮点数的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-402">Appends the string representation of a specified double-precision floating-point number to this instance.</span></span></summary>
        <returns><span data-ttu-id="c1488-403">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-403">A reference to this instance after the append operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-404"><xref:System.Text.StringBuilder.Append%28System.Double%29>方法修改此类的现有实例，而不返回新的类实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-404">The <xref:System.Text.StringBuilder.Append%28System.Double%29> method modifies the existing instance of this class; it does not return a new class instance.</span></span> <span data-ttu-id="c1488-405">因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="c1488-405">Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <xref:System.Text.StringBuilder> object, as the following example illustrates.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs" interactive="try-dotnet-method" id="Snippet9":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb" id="Snippet9":::

 <span data-ttu-id="c1488-406"><xref:System.Text.StringBuilder.Append%28System.Double%29>方法调用 <xref:System.Double.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 方法为当前区域性获取的字符串表示形式 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-406">The <xref:System.Text.StringBuilder.Append%28System.Double%29> method calls the <xref:System.Double.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> method to get the string representation of `value` for the current culture.</span></span> <span data-ttu-id="c1488-407">若要控制的格式 `value` ，请调用 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-407">To control the formatting of `value`, call the <xref:System.Text.StringBuilder.AppendFormat%2A> method.</span></span>

 <span data-ttu-id="c1488-408">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-408">The capacity of this instance is adjusted as needed.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-409">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-409">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-410">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-410">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-411">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-411">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(short value);" />
      <MemberSignature Language="F#" Value="member this.Append : int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="c1488-412">要追加的值。</span><span class="sxs-lookup"><span data-stu-id="c1488-412">The value to append.</span></span></param>
        <summary><span data-ttu-id="c1488-413">向此实例追加指定的 16 位有符号整数的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-413">Appends the string representation of a specified 16-bit signed integer to this instance.</span></span></summary>
        <returns><span data-ttu-id="c1488-414">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-414">A reference to this instance after the append operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-415"><xref:System.Text.StringBuilder.Append%28System.Int16%29>方法修改此类的现有实例，而不返回新的类实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-415">The <xref:System.Text.StringBuilder.Append%28System.Int16%29> method modifies the existing instance of this class; it does not return a new class instance.</span></span> <span data-ttu-id="c1488-416">因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="c1488-416">Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <xref:System.Text.StringBuilder> object, as the following example illustrates.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs" interactive="try-dotnet-method" id="Snippet10":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb" id="Snippet10":::

 <span data-ttu-id="c1488-417"><xref:System.Text.StringBuilder.Append%28System.Int16%29>方法调用 <xref:System.Int16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 方法为当前区域性获取的字符串表示形式 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-417">The <xref:System.Text.StringBuilder.Append%28System.Int16%29> method calls the <xref:System.Int16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> method to get the string representation of `value` for the current culture.</span></span> <span data-ttu-id="c1488-418">若要控制的格式 `value` ，请调用 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-418">To control the formatting of `value`, call the <xref:System.Text.StringBuilder.AppendFormat%2A> method.</span></span>

 <span data-ttu-id="c1488-419">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-419">The capacity of this instance is adjusted as needed.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-420">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-420">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-421">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-421">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-422">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-422">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(int value);" />
      <MemberSignature Language="F#" Value="member this.Append : int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="c1488-423">要追加的值。</span><span class="sxs-lookup"><span data-stu-id="c1488-423">The value to append.</span></span></param>
        <summary><span data-ttu-id="c1488-424">向此实例追加指定的 32 位有符号整数的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-424">Appends the string representation of a specified 32-bit signed integer to this instance.</span></span></summary>
        <returns><span data-ttu-id="c1488-425">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-425">A reference to this instance after the append operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-426"><xref:System.Text.StringBuilder.Append%28System.Int32%29>方法修改此类的现有实例，而不返回新的类实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-426">The <xref:System.Text.StringBuilder.Append%28System.Int32%29> method modifies the existing instance of this class; it does not return a new class instance.</span></span> <span data-ttu-id="c1488-427">因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="c1488-427">Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <xref:System.Text.StringBuilder> object, as the following example illustrates.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs" interactive="try-dotnet-method" id="Snippet11":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb" id="Snippet11"::: 

 <span data-ttu-id="c1488-428"><xref:System.Text.StringBuilder.Append%28System.Int32%29>方法调用 <xref:System.Int32.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 方法为当前区域性获取的字符串表示形式 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-428">The <xref:System.Text.StringBuilder.Append%28System.Int32%29> method calls the <xref:System.Int32.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> method to get the string representation of `value` for the current culture.</span></span> <span data-ttu-id="c1488-429">若要控制的格式 `value` ，请调用 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-429">To control the formatting of `value`, call the <xref:System.Text.StringBuilder.AppendFormat%2A> method.</span></span>

 <span data-ttu-id="c1488-430">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-430">The capacity of this instance is adjusted as needed.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-431">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-431">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-432">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-432">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-433">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-433">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(long value);" />
      <MemberSignature Language="F#" Value="member this.Append : int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="c1488-434">要追加的值。</span><span class="sxs-lookup"><span data-stu-id="c1488-434">The value to append.</span></span></param>
        <summary><span data-ttu-id="c1488-435">向此实例追加指定的 64 位有符号整数的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-435">Appends the string representation of a specified 64-bit signed integer to this instance.</span></span></summary>
        <returns><span data-ttu-id="c1488-436">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-436">A reference to this instance after the append operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-437"><xref:System.Text.StringBuilder.Append%28System.Int64%29>方法修改此类的现有实例，而不返回新的类实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-437">The <xref:System.Text.StringBuilder.Append%28System.Int64%29> method modifies the existing instance of this class; it does not return a new class instance.</span></span> <span data-ttu-id="c1488-438">因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="c1488-438">Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <xref:System.Text.StringBuilder> object, as the following example illustrates.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs" interactive="try-dotnet-method" id="Snippet12":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb" id="Snippet12":::

 <span data-ttu-id="c1488-439"><xref:System.Text.StringBuilder.Append%28System.Int64%29>方法调用 <xref:System.Int64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 以获取当前区域性的的字符串表示形式 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-439">The <xref:System.Text.StringBuilder.Append%28System.Int64%29> method calls the <xref:System.Int64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> to get the string representation of `value` for the current culture.</span></span> <span data-ttu-id="c1488-440">若要控制的格式 `value` ，请调用 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-440">To control the formatting of `value`, call the <xref:System.Text.StringBuilder.AppendFormat%2A> method.</span></span>

 <span data-ttu-id="c1488-441">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-441">The capacity of this instance is adjusted as needed.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-442">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-442">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-443">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-443">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-444">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-444">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (object value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (object? value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="c1488-445">要追加的对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-445">The object to append.</span></span></param>
        <summary><span data-ttu-id="c1488-446">向此实例追加指定对象的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-446">Appends the string representation of a specified object to this instance.</span></span></summary>
        <returns><span data-ttu-id="c1488-447">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-447">A reference to this instance after the append operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-448"><xref:System.Text.StringBuilder.Append%28System.Object%29>方法修改此类的现有实例，而不返回新的类实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-448">The <xref:System.Text.StringBuilder.Append%28System.Object%29> method modifies the existing instance of this class; it does not return a new class instance.</span></span> <span data-ttu-id="c1488-449">因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="c1488-449">Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <xref:System.Text.StringBuilder> object, as the following example illustrates.</span></span> <span data-ttu-id="c1488-450">它定义了一个 `Dog` 类，创建一个 `Dog` 对象，并对方法进行了三次调用， <xref:System.Text.StringBuilder.Append%2A> 以创建一个包含狗名称和同类的字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-450">It defines a `Dog` class, creates a `Dog` object, and makes three calls to the <xref:System.Text.StringBuilder.Append%2A> method to create a string that contains the dog's name and breed.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append4.cs" interactive="try-dotnet" id="Snippet18":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append4.vb" id="Snippet18":::

 <span data-ttu-id="c1488-451"><xref:System.Text.StringBuilder.Append%28System.Object%29>方法调用 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法来获取的字符串表示形式 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-451">The <xref:System.Text.StringBuilder.Append%28System.Object%29> method calls the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to get the string representation of `value`.</span></span> <span data-ttu-id="c1488-452">如果 `value` 为 `null` ，则不会对对象进行任何更改 <xref:System.Text.StringBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-452">If `value` is `null`, no changes are made to the <xref:System.Text.StringBuilder> object.</span></span>

 <span data-ttu-id="c1488-453">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-453">The capacity of this instance is adjusted as needed.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-454">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-454">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-455">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-455">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-456">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-456">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder? Append (ReadOnlyMemory&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlyMemory`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlyMemory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlyMemory(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlyMemory&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlyMemory&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlyMemory&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="c1488-457">要追加的只读字符内存区域。</span><span class="sxs-lookup"><span data-stu-id="c1488-457">The read-only character memory region to append.</span></span></param>
        <summary><span data-ttu-id="c1488-458">向此实例追加指定的只读字符内存区域的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-458">Appends the string representation of a specified read-only character memory region to this instance.</span></span></summary>
        <returns><span data-ttu-id="c1488-459">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-459">A reference to this instance after the append operation is completed.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder? Append (ReadOnlySpan&lt;char&gt; value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlySpan&lt;char&gt; value);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="c1488-460">要追加的只读字符范围。</span><span class="sxs-lookup"><span data-stu-id="c1488-460">The read-only character span to append.</span></span></param>
        <summary><span data-ttu-id="c1488-461">向此实例追加指定的只读字符范围的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-461">Appends the string representation of a specified read-only character span to this instance.</span></span></summary>
        <returns><span data-ttu-id="c1488-462">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-462">A reference to this instance after the append operation is completed.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Append : sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="c1488-463">要追加的值。</span><span class="sxs-lookup"><span data-stu-id="c1488-463">The value to append.</span></span></param>
        <summary><span data-ttu-id="c1488-464">向此实例追加指定的 8 位有符号整数的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-464">Appends the string representation of a specified 8-bit signed integer to this instance.</span></span></summary>
        <returns><span data-ttu-id="c1488-465">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-465">A reference to this instance after the append operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-466"><xref:System.Text.StringBuilder.Append%28System.SByte%29>方法修改此类的现有实例，而不返回新的类实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-466">The <xref:System.Text.StringBuilder.Append%28System.SByte%29> method modifies the existing instance of this class; it does not return a new class instance.</span></span> <span data-ttu-id="c1488-467">因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="c1488-467">Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <xref:System.Text.StringBuilder> object, as the following example illustrates.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs" interactive="try-dotnet-method" id="Snippet13":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb" id="Snippet13"::: 

 <span data-ttu-id="c1488-468"><xref:System.Text.StringBuilder.Append%28System.SByte%29>方法调用 <xref:System.SByte.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 方法为当前区域性获取的字符串表示形式 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-468">The <xref:System.Text.StringBuilder.Append%28System.SByte%29> method calls the <xref:System.SByte.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> method  to get the string representation of `value` for the current culture.</span></span> <span data-ttu-id="c1488-469">若要控制的格式 `value` ，请调用 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-469">To control the formatting of `value`, call the <xref:System.Text.StringBuilder.AppendFormat%2A> method.</span></span>

 <span data-ttu-id="c1488-470">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-470">The capacity of this instance is adjusted as needed.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-471">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-471">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-472">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-472">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-473">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-473">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(float value);" />
      <MemberSignature Language="F#" Value="member this.Append : single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="c1488-474">要追加的值。</span><span class="sxs-lookup"><span data-stu-id="c1488-474">The value to append.</span></span></param>
        <summary><span data-ttu-id="c1488-475">向此实例追加指定的单精度浮点数的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-475">Appends the string representation of a specified single-precision floating-point number to this instance.</span></span></summary>
        <returns><span data-ttu-id="c1488-476">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-476">A reference to this instance after the append operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-477"><xref:System.Text.StringBuilder.Append%28System.Single%29>方法修改此类的现有实例，而不返回新的类实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-477">The <xref:System.Text.StringBuilder.Append%28System.Single%29> method modifies the existing instance of this class; it does not return a new class instance.</span></span> <span data-ttu-id="c1488-478">因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="c1488-478">Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <xref:System.Text.StringBuilder> object, as the following example illustrates.</span></span>

 [!code-csharp[System.Text.StringBuilder.Append#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#14)]
 [!code-vb[System.Text.StringBuilder.Append#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#14)]

 <span data-ttu-id="c1488-479"><xref:System.Text.StringBuilder.Append%28System.Single%29>方法调用 <xref:System.Single.ToString%2A?displayProperty=nameWithType> 方法为当前区域性获取的字符串表示形式 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-479">The <xref:System.Text.StringBuilder.Append%28System.Single%29> method calls the <xref:System.Single.ToString%2A?displayProperty=nameWithType> method to get the string representation of `value` for the current culture.</span></span> <span data-ttu-id="c1488-480">若要控制的格式 `value` ，请调用 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-480">To control the formatting of `value`, call the <xref:System.Text.StringBuilder.AppendFormat%2A> method.</span></span>

 <span data-ttu-id="c1488-481">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-481">The capacity of this instance is adjusted as needed.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-482">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-482">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-483">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-483">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-484">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-484">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string? value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="c1488-485">要追加的字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-485">The string to append.</span></span></param>
        <summary><span data-ttu-id="c1488-486">向此实例追加指定字符串的副本。</span><span class="sxs-lookup"><span data-stu-id="c1488-486">Appends a copy of the specified string to this instance.</span></span></summary>
        <returns><span data-ttu-id="c1488-487">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-487">A reference to this instance after the append operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-488"><xref:System.Text.StringBuilder.Append%28System.String%29>方法修改此类的现有实例，而不返回新的类实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-488">The <xref:System.Text.StringBuilder.Append%28System.String%29> method modifies the existing instance of this class; it does not return a new class instance.</span></span> <span data-ttu-id="c1488-489">因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="c1488-489">Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <xref:System.Text.StringBuilder> object, as the following example illustrates.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb" id="Snippet2"::: 

 <span data-ttu-id="c1488-490">如果 `value` 为 `null` ，则不进行任何更改。</span><span class="sxs-lookup"><span data-stu-id="c1488-490">If `value` is `null`, no changes are made.</span></span>

 <span data-ttu-id="c1488-491">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-491">The capacity of this instance is adjusted as needed.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-492">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-492">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-493">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-493">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-494">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-494">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder? value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="c1488-495">要追加的字符串生成器。</span><span class="sxs-lookup"><span data-stu-id="c1488-495">The string builder to append.</span></span></param>
        <summary><span data-ttu-id="c1488-496">向此实例追加指定的字符串生成器的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-496">Appends the string representation of a specified string builder to this instance.</span></span></summary>
        <returns><span data-ttu-id="c1488-497">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-497">A reference to this instance after the append operation is completed.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="c1488-498">要追加的值。</span><span class="sxs-lookup"><span data-stu-id="c1488-498">The value to append.</span></span></param>
        <summary><span data-ttu-id="c1488-499">向此实例追加指定的 16 位无符号整数的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-499">Appends the string representation of a specified 16-bit unsigned integer to this instance.</span></span></summary>
        <returns><span data-ttu-id="c1488-500">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-500">A reference to this instance after the append operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-501"><xref:System.Text.StringBuilder.Append%28System.UInt16%29>方法修改此类的现有实例，而不返回新的类实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-501">The <xref:System.Text.StringBuilder.Append%28System.UInt16%29> method modifies the existing instance of this class; it does not return a new class instance.</span></span> <span data-ttu-id="c1488-502">因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="c1488-502">Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <xref:System.Text.StringBuilder> object, as the following example illustrates.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs" interactive="try-dotnet-method" id="Snippet15":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb" id="Snippet15":::

 <span data-ttu-id="c1488-503"><xref:System.Text.StringBuilder.Append%28System.UInt16%29>方法调用 <xref:System.UInt16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 方法来获取的字符串表示形式 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-503">The <xref:System.Text.StringBuilder.Append%28System.UInt16%29> method calls the <xref:System.UInt16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> method to get the string representation of `value`.</span></span> <span data-ttu-id="c1488-504">若要控制的格式 `value` ，请调用 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-504">To control the formatting of `value`, call the <xref:System.Text.StringBuilder.AppendFormat%2A> method.</span></span>

 <span data-ttu-id="c1488-505">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-505">The capacity of this instance is adjusted as needed.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-506">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-506">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-507">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-507">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-508">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-508">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="c1488-509">要追加的值。</span><span class="sxs-lookup"><span data-stu-id="c1488-509">The value to append.</span></span></param>
        <summary><span data-ttu-id="c1488-510">向此实例追加指定的 32 位无符号整数的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-510">Appends the string representation of a specified 32-bit unsigned integer to this instance.</span></span></summary>
        <returns><span data-ttu-id="c1488-511">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-511">A reference to this instance after the append operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-512"><xref:System.Text.StringBuilder.Append%28System.UInt32%29>方法修改此类的现有实例，而不返回新的类实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-512">The <xref:System.Text.StringBuilder.Append%28System.UInt32%29> method modifies the existing instance of this class; it does not return a new class instance.</span></span> <span data-ttu-id="c1488-513">因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="c1488-513">Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <xref:System.Text.StringBuilder> object, as the following example illustrates.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs" interactive="try-dotnet-method" id="Snippet16":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb" id="Snippet16":::

 <span data-ttu-id="c1488-514"><xref:System.Text.StringBuilder.Append%28System.UInt32%29>调用 <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> 方法为当前区域性获取的字符串表示形式 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-514">The <xref:System.Text.StringBuilder.Append%28System.UInt32%29> calls the <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> method to get the string representation of `value` for the current culture.</span></span> <span data-ttu-id="c1488-515">若要控制的格式 `value` ，请调用 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-515">To control the formatting of `value`, call the <xref:System.Text.StringBuilder.AppendFormat%2A> method.</span></span>

 <span data-ttu-id="c1488-516">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-516">The capacity of this instance is adjusted as needed.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-517">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-517">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-518">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-518">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-519">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-519">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="c1488-520">要追加的值。</span><span class="sxs-lookup"><span data-stu-id="c1488-520">The value to append.</span></span></param>
        <summary><span data-ttu-id="c1488-521">向此实例追加指定的 64 位无符号整数的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-521">Appends the string representation of a specified 64-bit unsigned integer to this instance.</span></span></summary>
        <returns><span data-ttu-id="c1488-522">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-522">A reference to this instance after the append operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-523"><xref:System.Text.StringBuilder.Append%28System.UInt64%29>方法修改此类的现有实例，而不返回新的类实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-523">The <xref:System.Text.StringBuilder.Append%28System.UInt64%29> method modifies the existing instance of this class; it does not return a new class instance.</span></span> <span data-ttu-id="c1488-524">因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="c1488-524">Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <xref:System.Text.StringBuilder> object, as the following example illustrates.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs" interactive="try-dotnet-method" id="Snippet17":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb" id="Snippet17":::

 <span data-ttu-id="c1488-525"><xref:System.Text.StringBuilder.Append%28System.UInt64%29>方法调用 <xref:System.UInt64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 方法为当前区域性获取的字符串表示形式 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-525">The <xref:System.Text.StringBuilder.Append%28System.UInt64%29> method calls the <xref:System.UInt64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> method to get the string representation of `value` for the current culture.</span></span> <span data-ttu-id="c1488-526">若要控制的格式 `value` ，请调用 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-526">To control the formatting of `value`, call the <xref:System.Text.StringBuilder.AppendFormat%2A> method.</span></span>

 <span data-ttu-id="c1488-527">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-527">The capacity of this instance is adjusted as needed.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-528">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-528">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-529">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-529">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-530">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-530">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value, int repeatCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value, int32 repeatCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char, repeatCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value, int repeatCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, repeatCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="repeatCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="c1488-531">要追加的字符。</span><span class="sxs-lookup"><span data-stu-id="c1488-531">The character to append.</span></span></param>
        <param name="repeatCount"><span data-ttu-id="c1488-532">要追加 <paramref name="value" /> 的次数。</span><span class="sxs-lookup"><span data-stu-id="c1488-532">The number of times to append <paramref name="value" />.</span></span></param>
        <summary><span data-ttu-id="c1488-533">向此实例追加 Unicode 字符的字符串表示形式指定数目的副本。</span><span class="sxs-lookup"><span data-stu-id="c1488-533">Appends a specified number of copies of the string representation of a Unicode character to this instance.</span></span></summary>
        <returns><span data-ttu-id="c1488-534">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-534">A reference to this instance after the append operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-535"><xref:System.Text.StringBuilder.Append%28System.Char%2CSystem.Int32%29>方法修改此类的现有实例，而不返回新的类实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-535">The <xref:System.Text.StringBuilder.Append%28System.Char%2CSystem.Int32%29> method modifies the existing instance of this class; it does not return a new class instance.</span></span> <span data-ttu-id="c1488-536">因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="c1488-536">Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <xref:System.Text.StringBuilder> object, as the following example illustrates.</span></span>

 [!code-csharp[System.Text.StringBuilder.Append#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#5)]
 [!code-vb[System.Text.StringBuilder.Append#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#5)]

 <span data-ttu-id="c1488-537">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-537">The capacity of this instance is adjusted as needed.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-538"><paramref name="repeatCount" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="c1488-538"><paramref name="repeatCount" /> is less than zero.</span></span>

<span data-ttu-id="c1488-539">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-539">-or-</span></span>

<span data-ttu-id="c1488-540">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-540">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c1488-541">内存不足。</span><span class="sxs-lookup"><span data-stu-id="c1488-541">Out of memory.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-542">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-542">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-543">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-543">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char* value, int valueCount);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char* value, int32 valueCount) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char*,System.Int32)" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char* value, int valueCount);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.Append : nativeptr&lt;char&gt; * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, valueCount)" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder? Append (char* value, int valueCount);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="c1488-544">指向字符数组的指针。</span><span class="sxs-lookup"><span data-stu-id="c1488-544">A pointer to an array of characters.</span></span></param>
        <param name="valueCount"><span data-ttu-id="c1488-545">数组中的字符数。</span><span class="sxs-lookup"><span data-stu-id="c1488-545">The number of characters in the array.</span></span></param>
        <summary><span data-ttu-id="c1488-546">将从指定地址开始的 Unicode 字符数组追加到此实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-546">Appends an array of Unicode characters starting at a specified address to this instance.</span></span></summary>
        <returns><span data-ttu-id="c1488-547">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-547">A reference to this instance after the append operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-548">此方法 `valueCount` 将从 address 开始的字符追加 `value` 到当前实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-548">This method appends `valueCount` characters starting at address `value` to the current instance.</span></span>

 <span data-ttu-id="c1488-549"><xref:System.Text.StringBuilder.Append%28System.Char%2A%2CSystem.Int32%29>方法修改此类的现有实例，而不返回新的类实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-549">The <xref:System.Text.StringBuilder.Append%28System.Char%2A%2CSystem.Int32%29> method modifies the existing instance of this class; it does not return a new class instance.</span></span> <span data-ttu-id="c1488-550">因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-550">Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <xref:System.Text.StringBuilder> object.</span></span>

 <span data-ttu-id="c1488-551">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-551">The capacity of this instance is adjusted as needed.</span></span>

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-552"><paramref name="valueCount" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="c1488-552"><paramref name="valueCount" /> is less than zero.</span></span>

<span data-ttu-id="c1488-553">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-553">-or-</span></span>

<span data-ttu-id="c1488-554">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-554">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="c1488-555"><paramref name="value" /> 为 null 指针。</span><span class="sxs-lookup"><span data-stu-id="c1488-555"><paramref name="value" /> is a null pointer.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-556">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-556">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-557">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-557">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value, int startIndex, int charCount);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, charCount)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[]? value, int startIndex, int charCount);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="c1488-558">字符数组。</span><span class="sxs-lookup"><span data-stu-id="c1488-558">A character array.</span></span></param>
        <param name="startIndex"><span data-ttu-id="c1488-559"><paramref name="value" /> 中的起始位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-559">The starting position in <paramref name="value" />.</span></span></param>
        <param name="charCount"><span data-ttu-id="c1488-560">要追加的字符数。</span><span class="sxs-lookup"><span data-stu-id="c1488-560">The number of characters to append.</span></span></param>
        <summary><span data-ttu-id="c1488-561">向此实例追加指定的 Unicode 字符子数组的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-561">Appends the string representation of a specified subarray of Unicode characters to this instance.</span></span></summary>
        <returns><span data-ttu-id="c1488-562">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-562">A reference to this instance after the append operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-563">此方法将指定范围的字符追加 `value` 到当前实例中。</span><span class="sxs-lookup"><span data-stu-id="c1488-563">This method appends the specified range of characters in `value` to the current instance.</span></span> <span data-ttu-id="c1488-564">如果 `value` 为 `null` 和 `startIndex` 且 `count` 均为零，则不进行任何更改。</span><span class="sxs-lookup"><span data-stu-id="c1488-564">If `value` is `null` and `startIndex` and `count` are both zero, no changes are made.</span></span>

 <span data-ttu-id="c1488-565"><xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>方法修改此类的现有实例，而不返回新的类实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-565">The <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method modifies the existing instance of this class; it does not return a new class instance.</span></span> <span data-ttu-id="c1488-566">因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="c1488-566">Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <xref:System.Text.StringBuilder> object, as the following example illustrates.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs" interactive="try-dotnet-method" id="Snippet7":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb" id="Snippet7":::

 <span data-ttu-id="c1488-567">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-567">The capacity of this instance is adjusted as needed.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c1488-568"><paramref name="value" /> 为 <see langword="null" />，且 <paramref name="startIndex" /> 和 <paramref name="charCount" /> 不为零。</span><span class="sxs-lookup"><span data-stu-id="c1488-568"><paramref name="value" /> is <see langword="null" />, and <paramref name="startIndex" /> and <paramref name="charCount" /> are not zero.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-569"><paramref name="charCount" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="c1488-569"><paramref name="charCount" /> is less than zero.</span></span>

<span data-ttu-id="c1488-570">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-570">-or-</span></span>

 <span data-ttu-id="c1488-571"><paramref name="startIndex" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="c1488-571"><paramref name="startIndex" /> is less than zero.</span></span>

<span data-ttu-id="c1488-572">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-572">-or-</span></span>

 <span data-ttu-id="c1488-573"><paramref name="startIndex" /> + <paramref name="charCount" /> 大于 <paramref name="value" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-573"><paramref name="startIndex" /> + <paramref name="charCount" /> is greater than the length of <paramref name="value" />.</span></span>

<span data-ttu-id="c1488-574">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-574">-or-</span></span>

<span data-ttu-id="c1488-575">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-575">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-576">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-576">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-577">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-577">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value, int startIndex, int count);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string? value, int startIndex, int count);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="c1488-578">包含要追加的子字符串的字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-578">The string that contains the substring to append.</span></span></param>
        <param name="startIndex"><span data-ttu-id="c1488-579"><paramref name="value" /> 中子字符串开始的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-579">The starting position of the substring within <paramref name="value" />.</span></span></param>
        <param name="count"><span data-ttu-id="c1488-580">要追加的 <paramref name="value" /> 中的字符数。</span><span class="sxs-lookup"><span data-stu-id="c1488-580">The number of characters in <paramref name="value" /> to append.</span></span></param>
        <summary><span data-ttu-id="c1488-581">向此实例追加指定子字符串的副本。</span><span class="sxs-lookup"><span data-stu-id="c1488-581">Appends a copy of a specified substring to this instance.</span></span></summary>
        <returns><span data-ttu-id="c1488-582">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-582">A reference to this instance after the append operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-583">此方法将指定范围的字符追加 `value` 到当前实例中。</span><span class="sxs-lookup"><span data-stu-id="c1488-583">This method appends the specified range of characters in `value` to the current instance.</span></span> <span data-ttu-id="c1488-584">如果 `value` 为 `null` 和 `startIndex` 且 `count` 均为零，则不进行任何更改。</span><span class="sxs-lookup"><span data-stu-id="c1488-584">If `value` is `null` and `startIndex` and `count` are both zero, no changes are made.</span></span>

 <span data-ttu-id="c1488-585"><xref:System.Text.StringBuilder.Append%28System.String%2CSystem.Int32%2CSystem.Int32%29>方法修改此类的现有实例，而不返回新的类实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-585">The <xref:System.Text.StringBuilder.Append%28System.String%2CSystem.Int32%2CSystem.Int32%29> method modifies the existing instance of this class; it does not return a new class instance.</span></span> <span data-ttu-id="c1488-586">因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="c1488-586">Because of this, you can call a method or property on the existing reference and you do not have to assign the return value to a <xref:System.Text.StringBuilder> object, as the following example illustrates.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs" interactive="try-dotnet-method" id="Snippet19":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb" id="Snippet19"::: 

 <span data-ttu-id="c1488-587">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-587">The capacity of this instance is adjusted as needed.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c1488-588"><paramref name="value" /> 为 <see langword="null" />，且 <paramref name="startIndex" /> 和 <paramref name="count" /> 不为零。</span><span class="sxs-lookup"><span data-stu-id="c1488-588"><paramref name="value" /> is <see langword="null" />, and <paramref name="startIndex" /> and <paramref name="count" /> are not zero.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-589"><paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="c1488-589"><paramref name="count" /> less than zero.</span></span>

<span data-ttu-id="c1488-590">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-590">-or-</span></span>

 <span data-ttu-id="c1488-591"><paramref name="startIndex" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="c1488-591"><paramref name="startIndex" /> less than zero.</span></span>

<span data-ttu-id="c1488-592">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-592">-or-</span></span>

 <span data-ttu-id="c1488-593"><paramref name="startIndex" /> + <paramref name="count" /> 大于 <paramref name="value" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-593"><paramref name="startIndex" /> + <paramref name="count" /> is greater than the length of <paramref name="value" />.</span></span>

<span data-ttu-id="c1488-594">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-594">-or-</span></span>

<span data-ttu-id="c1488-595">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-595">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-596">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-596">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-597">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-597">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder? value, int startIndex, int count);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value, int startIndex, int count);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="c1488-598">包含要追加的子字符串的字符串生成器。</span><span class="sxs-lookup"><span data-stu-id="c1488-598">The string builder that contains the substring to append.</span></span></param>
        <param name="startIndex"><span data-ttu-id="c1488-599"><paramref name="value" /> 中子字符串开始的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-599">The starting position of the substring within <paramref name="value" />.</span></span></param>
        <param name="count"><span data-ttu-id="c1488-600">要追加的 <paramref name="value" /> 中的字符数。</span><span class="sxs-lookup"><span data-stu-id="c1488-600">The number of characters in <paramref name="value" /> to append.</span></span></param>
        <summary><span data-ttu-id="c1488-601">向此实例追加指定字符串生成器中的子字符串副本。</span><span class="sxs-lookup"><span data-stu-id="c1488-601">Appends a copy of a substring within a specified string builder to this instance.</span></span></summary>
        <returns><span data-ttu-id="c1488-602">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-602">A reference to this instance after the append operation has completed.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendFormat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c1488-603">向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-603">Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance.</span></span> <span data-ttu-id="c1488-604">每个格式项都由相应的对象自变量的字符串表示形式替换。</span><span class="sxs-lookup"><span data-stu-id="c1488-604">Each format item is replaced by the string representation of a corresponding object argument.</span></span></summary>
        <related type="Article" href="/dotnet/standard/base-types/composite-formatting"><span data-ttu-id="c1488-605">复合格式设置</span><span class="sxs-lookup"><span data-stu-id="c1488-605">Composite Formatting</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings"><span data-ttu-id="c1488-606">标准数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-606">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings"><span data-ttu-id="c1488-607">自定义数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-607">Custom Numeric Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-date-and-time-format-strings"><span data-ttu-id="c1488-608">标准日期和时间格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-608">Standard Date and Time Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-date-and-time-format-strings"><span data-ttu-id="c1488-609">自定义日期和时间格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-609">Custom Date and Time Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-timespan-format-strings"><span data-ttu-id="c1488-610">标准 TimeSpan 格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-610">Standard TimeSpan Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-timespan-format-strings"><span data-ttu-id="c1488-611">自定义的 TimeSpan 格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-611">Custom TimeSpan Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/enumeration-format-strings"><span data-ttu-id="c1488-612">枚举格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-612">Enumeration Format Strings</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object? arg0);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="c1488-613">复合格式字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-613">A composite format string.</span></span></param>
        <param name="arg0"><span data-ttu-id="c1488-614">要设置其格式的对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-614">An object to format.</span></span></param>
        <summary><span data-ttu-id="c1488-615">向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-615">Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance.</span></span> <span data-ttu-id="c1488-616">每个格式项都替换为一个自变量的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-616">Each format item is replaced by the string representation of a single argument.</span></span></summary>
        <returns><span data-ttu-id="c1488-617">对追加了 <paramref name="format" /> 的此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-617">A reference to this instance with <paramref name="format" /> appended.</span></span> <span data-ttu-id="c1488-618"><paramref name="format" /> 中的每个格式项都替换为 <paramref name="arg0" /> 的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-618">Each format item in <paramref name="format" /> is replaced by the string representation of <paramref name="arg0" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-619">此方法使用 .NET Framework 的 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将对象的值转换为其文本表示形式，并将该表示形式嵌入到当前 <xref:System.Text.StringBuilder> 对象中。</span><span class="sxs-lookup"><span data-stu-id="c1488-619">This method uses the [composite formatting feature](/dotnet/standard/base-types/composite-formatting) of the .NET Framework to convert the value of an object to its text representation and embed that representation in the current <xref:System.Text.StringBuilder> object.</span></span>

 <span data-ttu-id="c1488-620">`format`参数包含与零个或多个索引占位符（称为格式项）混合的零个或多个文本的运行。</span><span class="sxs-lookup"><span data-stu-id="c1488-620">The `format` parameter consists of zero or more runs of text intermixed with zero or more indexed placeholders, called format items.</span></span> <span data-ttu-id="c1488-621">格式项的索引必须为0，以对应于 `arg0` 此方法的参数列表中的单个对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-621">The index of the format items must be 0, to correspond to `arg0`, the single object in the parameter list of this method.</span></span> <span data-ttu-id="c1488-622">格式设置过程将每个格式项替换为的字符串表示形式 `arg0` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-622">The formatting process replaces each format item with the string representation of `arg0`.</span></span>

 <span data-ttu-id="c1488-623">格式项的语法如下所示：</span><span class="sxs-lookup"><span data-stu-id="c1488-623">The syntax of a format item is as follows:</span></span>

 <span data-ttu-id="c1488-624">{*index*[，*length*] [：*格式字符串*]}</span><span class="sxs-lookup"><span data-stu-id="c1488-624">{*index*[,*length*][:*formatString*]}</span></span>

 <span data-ttu-id="c1488-625">括号中的元素是可选的。</span><span class="sxs-lookup"><span data-stu-id="c1488-625">Elements in square brackets are optional.</span></span> <span data-ttu-id="c1488-626">下表对每个元素进行了描述。</span><span class="sxs-lookup"><span data-stu-id="c1488-626">The following table describes each element.</span></span>

|<span data-ttu-id="c1488-627">元素</span><span class="sxs-lookup"><span data-stu-id="c1488-627">Element</span></span>|<span data-ttu-id="c1488-628">描述</span><span class="sxs-lookup"><span data-stu-id="c1488-628">Description</span></span>|
|-------------|-----------------|
|<span data-ttu-id="c1488-629">*index*</span><span class="sxs-lookup"><span data-stu-id="c1488-629">*index*</span></span>|<span data-ttu-id="c1488-630">要设置格式的对象的参数列表中的从零开始的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-630">The zero-based position in the parameter list of the object to be formatted.</span></span> <span data-ttu-id="c1488-631">如果由 *index* 指定的对象为 `null` ，则会将格式项替换为 <xref:System.String.Empty?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-631">If the object specified by *index* is `null`, the format item is replaced by <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c1488-632">如果 *索引* 位置中没有参数， <xref:System.FormatException> 则会引发。</span><span class="sxs-lookup"><span data-stu-id="c1488-632">If there is no parameter in the *index* position, a <xref:System.FormatException> is thrown.</span></span>|
|<span data-ttu-id="c1488-633">，*长度*</span><span class="sxs-lookup"><span data-stu-id="c1488-633">,*length*</span></span>|<span data-ttu-id="c1488-634">参数的字符串表示形式中的最小字符数。</span><span class="sxs-lookup"><span data-stu-id="c1488-634">The minimum number of characters in the string representation of the parameter.</span></span> <span data-ttu-id="c1488-635">如果为正，则参数为右对齐; 否则为。如果为负，则为左对齐。</span><span class="sxs-lookup"><span data-stu-id="c1488-635">If positive, the parameter is right-aligned; if negative, it is left-aligned.</span></span>|
|<span data-ttu-id="c1488-636">：*格式字符串*</span><span class="sxs-lookup"><span data-stu-id="c1488-636">:*formatString*</span></span>|<span data-ttu-id="c1488-637">参数支持的标准或自定义格式字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-637">A standard or custom format string that is supported by the parameter.</span></span>|

> [!NOTE]
>  <span data-ttu-id="c1488-638">对于用于日期和时间值的标准和自定义格式字符串，请参阅 [标准日期和时间格式](/dotnet/standard/base-types/standard-date-and-time-format-strings) 字符串和 [自定义日期和时间格式字符串](/dotnet/standard/base-types/custom-date-and-time-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="c1488-638">For the standard and custom format strings used with date and time values, see [Standard Date and Time Format Strings](/dotnet/standard/base-types/standard-date-and-time-format-strings) and [Custom Date and Time Format Strings](/dotnet/standard/base-types/custom-date-and-time-format-strings).</span></span> <span data-ttu-id="c1488-639">对于与数值一起使用的标准和自定义格式字符串，请参阅 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 和 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="c1488-639">For the standard and custom format strings used with numeric values, see [Standard Numeric Format Strings](/dotnet/standard/base-types/standard-numeric-format-strings) and [Custom Numeric Format Strings](/dotnet/standard/base-types/custom-numeric-format-strings).</span></span> <span data-ttu-id="c1488-640">对于用于枚举的标准格式字符串，请参阅 [枚举格式字符串](/dotnet/standard/base-types/enumeration-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="c1488-640">For the standard format strings used with enumerations, see [Enumeration Format Strings](/dotnet/standard/base-types/enumeration-format-strings).</span></span>

 <span data-ttu-id="c1488-641">`arg0` 表示要设置格式的对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-641">`arg0` represents the object to be formatted.</span></span> <span data-ttu-id="c1488-642">中的每个格式项 `format` 都替换为的字符串表示形式 `arg0` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-642">Each format item in `format` is replaced with the string representation of `arg0`.</span></span> <span data-ttu-id="c1488-643">如果格式项包含 `formatString` 并 `arg0` 实现 <xref:System.IFormattable> 接口，则 `arg0.ToString(formatString, null)` 定义格式设置。</span><span class="sxs-lookup"><span data-stu-id="c1488-643">If the format item includes `formatString` and `arg0` implements the <xref:System.IFormattable> interface, then `arg0.ToString(formatString, null)` defines the formatting.</span></span> <span data-ttu-id="c1488-644">否则，会 `arg0.ToString()` 定义格式设置。</span><span class="sxs-lookup"><span data-stu-id="c1488-644">Otherwise, `arg0.ToString()` defines the formatting.</span></span>

 <span data-ttu-id="c1488-645">如果分配给的字符串 `format` 为 "感谢你向慈善组织捐赠 {0： # # # #} 个食物</span><span class="sxs-lookup"><span data-stu-id="c1488-645">If the string assigned to `format` is "Thank you for your donation of {0:####} cans of food to our charitable organization."</span></span> <span data-ttu-id="c1488-646">和 `arg0` 是一个值为10的整数，则返回值将为 "感谢你向慈善组织捐赠10罐食物"。</span><span class="sxs-lookup"><span data-stu-id="c1488-646">and `arg0` is an integer with the value 10, the return value will be "Thank you for your donation of 10 cans of food to our charitable organization."</span></span>



## Examples
 <span data-ttu-id="c1488-647">下面的示例演示 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-647">The following example demonstrates the <xref:System.Text.StringBuilder.AppendFormat%2A> method.</span></span>

 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c1488-648"><paramref name="format" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-648"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="c1488-649"><paramref name="format" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="c1488-649"><paramref name="format" /> is invalid.</span></span>

<span data-ttu-id="c1488-650">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-650">-or-</span></span>

<span data-ttu-id="c1488-651">格式项的索引小于 0（零），或者大于或等于 1。</span><span class="sxs-lookup"><span data-stu-id="c1488-651">The index of a format item is less than 0 (zero), or greater than or equal to 1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-652">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-652">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-653">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-653">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-654">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-654">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
        <related type="Article" href="/dotnet/standard/base-types/formatting-types"><span data-ttu-id="c1488-655">设置 .NET 中类型的格式</span><span class="sxs-lookup"><span data-stu-id="c1488-655">Formatting Types in .NET</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/composite-formatting"><span data-ttu-id="c1488-656">复合格式设置</span><span class="sxs-lookup"><span data-stu-id="c1488-656">Composite Formatting</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings"><span data-ttu-id="c1488-657">标准数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-657">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings"><span data-ttu-id="c1488-658">自定义数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-658">Custom Numeric Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-date-and-time-format-strings"><span data-ttu-id="c1488-659">标准日期和时间格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-659">Standard Date and Time Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-date-and-time-format-strings"><span data-ttu-id="c1488-660">自定义日期和时间格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-660">Custom Date and Time Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-timespan-format-strings"><span data-ttu-id="c1488-661">标准 TimeSpan 格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-661">Standard TimeSpan Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-timespan-format-strings"><span data-ttu-id="c1488-662">自定义的 TimeSpan 格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-662">Custom TimeSpan Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/enumeration-format-strings"><span data-ttu-id="c1488-663">枚举格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-663">Enumeration Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, params object[] args);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, args)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, params object[]? args);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="c1488-664">复合格式字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-664">A composite format string.</span></span></param>
        <param name="args"><span data-ttu-id="c1488-665">要设置其格式的对象的数组。</span><span class="sxs-lookup"><span data-stu-id="c1488-665">An array of objects to format.</span></span></param>
        <summary><span data-ttu-id="c1488-666">向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-666">Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance.</span></span> <span data-ttu-id="c1488-667">每个格式项都由参数数组中相应参数的字符串表示形式替换。</span><span class="sxs-lookup"><span data-stu-id="c1488-667">Each format item is replaced by the string representation of a corresponding argument in a parameter array.</span></span></summary>
        <returns><span data-ttu-id="c1488-668">对追加了 <paramref name="format" /> 的此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-668">A reference to this instance with <paramref name="format" /> appended.</span></span> <span data-ttu-id="c1488-669"><paramref name="format" /> 中的每个格式项都由相应的对象参数的字符串表示形式替换。</span><span class="sxs-lookup"><span data-stu-id="c1488-669">Each format item in <paramref name="format" /> is replaced by the string representation of the corresponding object argument.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-670">此方法使用 .NET Framework 的 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将对象的值转换为其文本表示形式，并将该表示形式嵌入到当前 <xref:System.Text.StringBuilder> 对象中。</span><span class="sxs-lookup"><span data-stu-id="c1488-670">This method uses the [composite formatting feature](/dotnet/standard/base-types/composite-formatting) of the .NET Framework to convert the value of an object to its text representation and embed that representation in the current <xref:System.Text.StringBuilder> object.</span></span>

 <span data-ttu-id="c1488-671">`format`参数包含与零个或多个索引占位符（称为格式项）混合的零个或多个文本的运行，这些占位符与此方法的参数列表中的对象相对应。</span><span class="sxs-lookup"><span data-stu-id="c1488-671">The `format` parameter consists of zero or more runs of text intermixed with zero or more indexed placeholders, called format items, that correspond to objects in the parameter list of this method.</span></span> <span data-ttu-id="c1488-672">格式设置过程将每个格式项替换为相应对象的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-672">The formatting process replaces each format item with the string representation of the corresponding object.</span></span>

 <span data-ttu-id="c1488-673">格式项的语法如下所示：</span><span class="sxs-lookup"><span data-stu-id="c1488-673">The syntax of a format item is as follows:</span></span>

 <span data-ttu-id="c1488-674">{*index*[，*length*] [：*格式字符串*]}</span><span class="sxs-lookup"><span data-stu-id="c1488-674">{*index*[,*length*][:*formatString*]}</span></span>

 <span data-ttu-id="c1488-675">括号中的元素是可选的。</span><span class="sxs-lookup"><span data-stu-id="c1488-675">Elements in square brackets are optional.</span></span> <span data-ttu-id="c1488-676">下表对每个元素进行了描述。</span><span class="sxs-lookup"><span data-stu-id="c1488-676">The following table describes each element.</span></span>

|<span data-ttu-id="c1488-677">元素</span><span class="sxs-lookup"><span data-stu-id="c1488-677">Element</span></span>|<span data-ttu-id="c1488-678">描述</span><span class="sxs-lookup"><span data-stu-id="c1488-678">Description</span></span>|
|-------------|-----------------|
|<span data-ttu-id="c1488-679">*index*</span><span class="sxs-lookup"><span data-stu-id="c1488-679">*index*</span></span>|<span data-ttu-id="c1488-680">要设置格式的对象的参数列表中的从零开始的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-680">The zero-based position in the parameter list of the object to be formatted.</span></span> <span data-ttu-id="c1488-681">如果由 *index* 指定的对象为 `null` ，则会将格式项替换为 <xref:System.String.Empty?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-681">If the object specified by *index* is `null`, the format item is replaced by <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c1488-682">如果 *索引* 位置中没有参数， <xref:System.FormatException> 则会引发。</span><span class="sxs-lookup"><span data-stu-id="c1488-682">If there is no parameter in the *index* position, a <xref:System.FormatException> is thrown.</span></span>|
|<span data-ttu-id="c1488-683">，*长度*</span><span class="sxs-lookup"><span data-stu-id="c1488-683">,*length*</span></span>|<span data-ttu-id="c1488-684">参数的字符串表示形式中的最小字符数。</span><span class="sxs-lookup"><span data-stu-id="c1488-684">The minimum number of characters in the string representation of the parameter.</span></span> <span data-ttu-id="c1488-685">如果为正，则参数为右对齐; 否则为。如果为负，则为左对齐。</span><span class="sxs-lookup"><span data-stu-id="c1488-685">If positive, the parameter is right-aligned; if negative, it is left-aligned.</span></span>|
|<span data-ttu-id="c1488-686">：*格式字符串*</span><span class="sxs-lookup"><span data-stu-id="c1488-686">:*formatString*</span></span>|<span data-ttu-id="c1488-687">参数支持的标准或自定义格式字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-687">A standard or custom format string that is supported by the parameter.</span></span>|

> [!NOTE]
>  <span data-ttu-id="c1488-688">对于用于日期和时间值的标准和自定义格式字符串，请参阅 [标准日期和时间格式](/dotnet/standard/base-types/standard-date-and-time-format-strings) 字符串和 [自定义日期和时间格式字符串](/dotnet/standard/base-types/custom-date-and-time-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="c1488-688">For the standard and custom format strings used with date and time values, see [Standard Date and Time Format Strings](/dotnet/standard/base-types/standard-date-and-time-format-strings) and [Custom Date and Time Format Strings](/dotnet/standard/base-types/custom-date-and-time-format-strings).</span></span> <span data-ttu-id="c1488-689">对于与数值一起使用的标准和自定义格式字符串，请参阅 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 和 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="c1488-689">For the standard and custom format strings used with numeric values, see [Standard Numeric Format Strings](/dotnet/standard/base-types/standard-numeric-format-strings) and [Custom Numeric Format Strings](/dotnet/standard/base-types/custom-numeric-format-strings).</span></span> <span data-ttu-id="c1488-690">对于用于枚举的标准格式字符串，请参阅 [枚举格式字符串](/dotnet/standard/base-types/enumeration-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="c1488-690">For the standard format strings used with enumerations, see [Enumeration Format Strings](/dotnet/standard/base-types/enumeration-format-strings).</span></span>

 <span data-ttu-id="c1488-691">`args` 表示要设置格式的对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-691">`args` represents the objects to be formatted.</span></span> <span data-ttu-id="c1488-692">中的每个格式项 `format` 都替换为中相应对象的字符串表示形式 `args` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-692">Each format item in `format` is replaced with the string representation of the corresponding object in `args`.</span></span> <span data-ttu-id="c1488-693">如果格式项包括 `formatString` ，并且中的相应对象 `args` 实现 <xref:System.IFormattable> 接口，则 `args[index].ToString(formatString, provider)` 定义格式设置。</span><span class="sxs-lookup"><span data-stu-id="c1488-693">If the format item includes `formatString` and the corresponding object in `args` implements the <xref:System.IFormattable> interface, then `args[index].ToString(formatString, provider)` defines the formatting.</span></span> <span data-ttu-id="c1488-694">否则，会 `args[index].ToString()` 定义格式设置。</span><span class="sxs-lookup"><span data-stu-id="c1488-694">Otherwise, `args[index].ToString()` defines the formatting.</span></span>

 <span data-ttu-id="c1488-695">如果分配给的字符串 `format` 为 "感谢你向慈善组织捐赠 {0： # # # #} 个食物</span><span class="sxs-lookup"><span data-stu-id="c1488-695">If the string assigned to `format` is "Thank you for your donation of {0:####} cans of food to our charitable organization."</span></span> <span data-ttu-id="c1488-696">和 `arg0` 是一个值为10的整数，则返回值将为 "感谢你向慈善组织捐赠10罐食物"。</span><span class="sxs-lookup"><span data-stu-id="c1488-696">and `arg0` is an integer with the value 10, the return value will be "Thank you for your donation of 10 cans of food to our charitable organization."</span></span>



## Examples
 <span data-ttu-id="c1488-697">下面的示例演示 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-697">The following example demonstrates the <xref:System.Text.StringBuilder.AppendFormat%2A> method.</span></span>

 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c1488-698"><paramref name="format" /> 或 <paramref name="args" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-698"><paramref name="format" /> or <paramref name="args" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="c1488-699"><paramref name="format" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="c1488-699"><paramref name="format" /> is invalid.</span></span>

<span data-ttu-id="c1488-700">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-700">-or-</span></span>

<span data-ttu-id="c1488-701">格式项的索引小于 0（零），或者大于或等于 <paramref name="args" /> 数组的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-701">The index of a format item is less than 0 (zero), or greater than or equal to the length of the <paramref name="args" /> array.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-702">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-702">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-703">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-703">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-704">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-704">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
        <related type="Article" href="/dotnet/standard/base-types/formatting-types"><span data-ttu-id="c1488-705">设置 .NET 中类型的格式</span><span class="sxs-lookup"><span data-stu-id="c1488-705">Formatting Types in .NET</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/composite-formatting"><span data-ttu-id="c1488-706">复合格式设置</span><span class="sxs-lookup"><span data-stu-id="c1488-706">Composite Formatting</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings"><span data-ttu-id="c1488-707">标准数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-707">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings"><span data-ttu-id="c1488-708">自定义数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-708">Custom Numeric Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-date-and-time-format-strings"><span data-ttu-id="c1488-709">标准日期和时间格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-709">Standard Date and Time Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-date-and-time-format-strings"><span data-ttu-id="c1488-710">自定义日期和时间格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-710">Custom Date and Time Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-timespan-format-strings"><span data-ttu-id="c1488-711">标准 TimeSpan 格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-711">Standard TimeSpan Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-timespan-format-strings"><span data-ttu-id="c1488-712">自定义的 TimeSpan 格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-712">Custom TimeSpan Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/enumeration-format-strings"><span data-ttu-id="c1488-713">枚举格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-713">Enumeration Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider? provider, string format, object? arg0);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="c1488-714">一个提供区域性特定的格式设置信息的对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-714">An object that supplies culture-specific formatting information.</span></span></param>
        <param name="format"><span data-ttu-id="c1488-715">复合格式字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-715">A composite format string.</span></span></param>
        <param name="arg0"><span data-ttu-id="c1488-716">要设置格式的对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-716">The object to format.</span></span></param>
        <summary><span data-ttu-id="c1488-717">向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-717">Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance.</span></span> <span data-ttu-id="c1488-718">每个格式项都使用指定的格式提供程序替换为单个参数的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-718">Each format item is replaced by the string representation of a single argument using a specified format provider.</span></span></summary>
        <returns><span data-ttu-id="c1488-719">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-719">A reference to this instance after the append operation has completed.</span></span> <span data-ttu-id="c1488-720">完成追加操作后，此实例包含执行该操作之前已存在的任何数据，并且有一个 <paramref name="format" /> 的副本作为后缀，其中任何格式规范都由 <paramref name="arg0" /> 的字符串表示形式替换。</span><span class="sxs-lookup"><span data-stu-id="c1488-720">After the append operation, this instance contains any data that existed before the operation, suffixed by a copy of <paramref name="format" /> in which any format specification is replaced by the string representation of <paramref name="arg0" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-721">此方法使用 .NET Framework 的  [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将的值转换 `arg0` 为其文本表示形式，并将该表示形式嵌入到当前 <xref:System.Text.StringBuilder> 对象中。</span><span class="sxs-lookup"><span data-stu-id="c1488-721">This method uses the  [composite formatting feature](/dotnet/standard/base-types/composite-formatting) of the .NET Framework to convert the value of `arg0` to its text representation and embed that representation in the current <xref:System.Text.StringBuilder> object.</span></span>

 <span data-ttu-id="c1488-722">`format`参数包含与零个或多个索引占位符（称为格式项）混合的零个或多个文本的运行。</span><span class="sxs-lookup"><span data-stu-id="c1488-722">The `format` parameter consists of zero or more runs of text intermixed with zero or more indexed placeholders, called format items.</span></span> <span data-ttu-id="c1488-723">每个格式项的索引必须为零 (0) ，因为此方法包含一个带有单个参数的参数列表。</span><span class="sxs-lookup"><span data-stu-id="c1488-723">The index of each format item must be zero (0) since this method includes an argument list with a single argument.</span></span> <span data-ttu-id="c1488-724">格式设置过程将每个格式项替换为的字符串表示形式 `arg0` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-724">The formatting process replaces each format item with the string representation of `arg0`.</span></span>

 <span data-ttu-id="c1488-725">格式项的语法如下所示：</span><span class="sxs-lookup"><span data-stu-id="c1488-725">The syntax of a format item is as follows:</span></span>

 <span data-ttu-id="c1488-726">{*index*[，*length*] [：*格式字符串*]}</span><span class="sxs-lookup"><span data-stu-id="c1488-726">{*index*[,*length*][:*formatString*]}</span></span>

 <span data-ttu-id="c1488-727">括号中的元素是可选的。</span><span class="sxs-lookup"><span data-stu-id="c1488-727">Elements in square brackets are optional.</span></span> <span data-ttu-id="c1488-728">下表对每个元素进行了描述。</span><span class="sxs-lookup"><span data-stu-id="c1488-728">The following table describes each element.</span></span>

|<span data-ttu-id="c1488-729">元素</span><span class="sxs-lookup"><span data-stu-id="c1488-729">Element</span></span>|<span data-ttu-id="c1488-730">描述</span><span class="sxs-lookup"><span data-stu-id="c1488-730">Description</span></span>|
|-------------|-----------------|
|<span data-ttu-id="c1488-731">*index*</span><span class="sxs-lookup"><span data-stu-id="c1488-731">*index*</span></span>|<span data-ttu-id="c1488-732">要设置格式的对象的参数列表中的从零开始的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-732">The zero-based position in the parameter list of the object to be formatted.</span></span> <span data-ttu-id="c1488-733">如果由 *index* 指定的对象为 `null` ，则会将格式项替换为 <xref:System.String.Empty?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-733">If the object specified by *index* is `null`, the format item is replaced by <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c1488-734">在这种情况下，因为 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> 方法在参数列表中有一个参数，所以 *index* 的值必须始终为0。</span><span class="sxs-lookup"><span data-stu-id="c1488-734">In this case, since the <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> method has a single argument in the argument list, the value of *index* must always be 0.</span></span> <span data-ttu-id="c1488-735">如果不是，则 <xref:System.FormatException> 会引发。</span><span class="sxs-lookup"><span data-stu-id="c1488-735">If it is not, a <xref:System.FormatException> is thrown.</span></span>|
|<span data-ttu-id="c1488-736">，*长度*</span><span class="sxs-lookup"><span data-stu-id="c1488-736">,*length*</span></span>|<span data-ttu-id="c1488-737">参数的字符串表示形式中的最小字符数。</span><span class="sxs-lookup"><span data-stu-id="c1488-737">The minimum number of characters in the string representation of the parameter.</span></span> <span data-ttu-id="c1488-738">如果为正，则参数为右对齐; 否则为。如果为负，则为左对齐。</span><span class="sxs-lookup"><span data-stu-id="c1488-738">If positive, the parameter is right-aligned; if negative, it is left-aligned.</span></span>|
|<span data-ttu-id="c1488-739">：*格式字符串*</span><span class="sxs-lookup"><span data-stu-id="c1488-739">:*formatString*</span></span>|<span data-ttu-id="c1488-740">参数支持的标准或自定义格式字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-740">A standard or custom format string that is supported by the parameter.</span></span>|

> [!NOTE]
>  <span data-ttu-id="c1488-741">对于用于日期和时间值的标准和自定义格式字符串，请参阅 [标准日期和时间格式](/dotnet/standard/base-types/standard-date-and-time-format-strings) 字符串和 [自定义日期和时间格式字符串](/dotnet/standard/base-types/custom-date-and-time-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="c1488-741">For the standard and custom format strings used with date and time values, see [Standard Date and Time Format Strings](/dotnet/standard/base-types/standard-date-and-time-format-strings) and [Custom Date and Time Format Strings](/dotnet/standard/base-types/custom-date-and-time-format-strings).</span></span> <span data-ttu-id="c1488-742">对于与数值一起使用的标准和自定义格式字符串，请参阅 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 和 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="c1488-742">For the standard and custom format strings used with numeric values, see [Standard Numeric Format Strings](/dotnet/standard/base-types/standard-numeric-format-strings) and [Custom Numeric Format Strings](/dotnet/standard/base-types/custom-numeric-format-strings).</span></span> <span data-ttu-id="c1488-743">对于用于枚举的标准格式字符串，请参阅 [枚举格式字符串](/dotnet/standard/base-types/enumeration-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="c1488-743">For the standard format strings used with enumerations, see [Enumeration Format Strings](/dotnet/standard/base-types/enumeration-format-strings).</span></span>

 <span data-ttu-id="c1488-744">`provider`参数指定一个 <xref:System.IFormatProvider> 实现，该实现可以为中的对象提供格式设置信息 `args` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-744">The `provider` parameter specifies an <xref:System.IFormatProvider> implementation that can provide formatting information for the objects in `args`.</span></span> <span data-ttu-id="c1488-745">`provider` 可以是以下任意形式：</span><span class="sxs-lookup"><span data-stu-id="c1488-745">`provider` can be any of the following:</span></span>

-   <span data-ttu-id="c1488-746">一个 <xref:System.Globalization.CultureInfo> 对象，提供区域性特定的格式设置信息。</span><span class="sxs-lookup"><span data-stu-id="c1488-746">A <xref:System.Globalization.CultureInfo> object that provides culture-specific formatting information.</span></span>

-   <span data-ttu-id="c1488-747">一个 <xref:System.Globalization.NumberFormatInfo> 对象，它提供有关的区域性特定格式设置信息 `arg0` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-747">A <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific formatting information for `arg0` if it is a numeric value.</span></span>

-   <span data-ttu-id="c1488-748">一个 <xref:System.Globalization.DateTimeFormatInfo> 对象，它提供有关的区域性特定格式设置信息 `arg0` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-748">A <xref:System.Globalization.DateTimeFormatInfo> object that provides culture-specific formatting information for `arg0` if it is a date and time value.</span></span>

-   <span data-ttu-id="c1488-749"><xref:System.IFormatProvider>为提供格式设置信息的自定义 `arg0` 实现。</span><span class="sxs-lookup"><span data-stu-id="c1488-749">A custom <xref:System.IFormatProvider> implementation that provides formatting information for `arg0`.</span></span> <span data-ttu-id="c1488-750">通常，此类实现还实现 <xref:System.ICustomFormatter> 接口。</span><span class="sxs-lookup"><span data-stu-id="c1488-750">Typically, such an implementation also implements the <xref:System.ICustomFormatter> interface.</span></span>

 <span data-ttu-id="c1488-751">如果 `provider` 参数为 `null` ，则从当前区域性获取格式设置信息。</span><span class="sxs-lookup"><span data-stu-id="c1488-751">If the `provider` parameter is `null`, formatting information is obtained from the current culture.</span></span>

 <span data-ttu-id="c1488-752">`arg0` 表示要设置格式的对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-752">`arg0` represents the object to be formatted.</span></span> <span data-ttu-id="c1488-753">中的每个格式项 `format` 都替换为的字符串表示形式 `arg0` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-753">Each format item in `format` is replaced with the string representation of `arg0`.</span></span> <span data-ttu-id="c1488-754">如果格式项包含 `formatString` 并 `arg0` 实现 <xref:System.IFormattable> 接口，则 `arg0.ToString(formatString, provider)` 定义格式设置。</span><span class="sxs-lookup"><span data-stu-id="c1488-754">If the format item includes `formatString` and `arg0` implements the <xref:System.IFormattable> interface, then `arg0.ToString(formatString, provider)` defines the formatting.</span></span> <span data-ttu-id="c1488-755">否则，会 `arg0.ToString()` 定义格式设置。</span><span class="sxs-lookup"><span data-stu-id="c1488-755">Otherwise, `arg0.ToString()` defines the formatting.</span></span>



## Examples
 <span data-ttu-id="c1488-756">下面包括对方法的两次调用 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-756">The following includes two calls to the <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> method.</span></span> <span data-ttu-id="c1488-757">两者都使用英语-英国 (en-GB) 区域性的格式设置约定。</span><span class="sxs-lookup"><span data-stu-id="c1488-757">Both use the formatting conventions of the English-Great Britain (en-GB) culture.</span></span> <span data-ttu-id="c1488-758">第一个在 <xref:System.Decimal> 结果字符串中插入货币值的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-758">The first inserts the string representation of a <xref:System.Decimal> value currency in a result string.</span></span> <span data-ttu-id="c1488-759">第二个将 <xref:System.DateTime> 值插入到结果字符串中的两个位置，第一个是只包含短日期字符串，第二个在短时间字符串中。</span><span class="sxs-lookup"><span data-stu-id="c1488-759">The second inserts a <xref:System.DateTime> value in two places in a result string, the first including only the short date string and the second the short time string.</span></span>

 [!code-csharp[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat1.cs#2)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat1.vb#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c1488-760"><paramref name="format" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-760"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="c1488-761"><paramref name="format" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="c1488-761"><paramref name="format" /> is invalid.</span></span>

<span data-ttu-id="c1488-762">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-762">-or-</span></span>

<span data-ttu-id="c1488-763">格式项的索引小于 0（零），或者大于等于一 (1)。</span><span class="sxs-lookup"><span data-stu-id="c1488-763">The index of a format item is less than 0 (zero), or greater than or equal to one (1).</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-764">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-764">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-765">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-765">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-766">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-766">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
        <related type="Article" href="/dotnet/standard/base-types/formatting-types"><span data-ttu-id="c1488-767">设置 .NET 中类型的格式</span><span class="sxs-lookup"><span data-stu-id="c1488-767">Formatting Types in .NET</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/composite-formatting"><span data-ttu-id="c1488-768">复合格式设置</span><span class="sxs-lookup"><span data-stu-id="c1488-768">Composite Formatting</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/how-to-define-and-use-custom-numeric-format-providers"><span data-ttu-id="c1488-769">如何：定义和使用自定义数值格式提供程序</span><span class="sxs-lookup"><span data-stu-id="c1488-769">How to: Define and Use Custom Numeric Format Providers</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings"><span data-ttu-id="c1488-770">标准数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-770">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings"><span data-ttu-id="c1488-771">自定义数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-771">Custom Numeric Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-date-and-time-format-strings"><span data-ttu-id="c1488-772">标准日期和时间格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-772">Standard Date and Time Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-date-and-time-format-strings"><span data-ttu-id="c1488-773">自定义日期和时间格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-773">Custom Date and Time Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-timespan-format-strings"><span data-ttu-id="c1488-774">标准 TimeSpan 格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-774">Standard TimeSpan Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-timespan-format-strings"><span data-ttu-id="c1488-775">自定义的 TimeSpan 格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-775">Custom TimeSpan Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/enumeration-format-strings"><span data-ttu-id="c1488-776">枚举格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-776">Enumeration Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, params object[] args);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, args)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider? provider, string format, params object[]? args);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="c1488-777">一个提供区域性特定的格式设置信息的对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-777">An object that supplies culture-specific formatting information.</span></span></param>
        <param name="format"><span data-ttu-id="c1488-778">复合格式字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-778">A composite format string.</span></span></param>
        <param name="args"><span data-ttu-id="c1488-779">要设置其格式的对象的数组。</span><span class="sxs-lookup"><span data-stu-id="c1488-779">An array of objects to format.</span></span></param>
        <summary><span data-ttu-id="c1488-780">向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-780">Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance.</span></span> <span data-ttu-id="c1488-781">每个格式项都使用指定的格式提供程序由参数数组中相应参数的字符串表示形式替换。</span><span class="sxs-lookup"><span data-stu-id="c1488-781">Each format item is replaced by the string representation of a corresponding argument in a parameter array using a specified format provider.</span></span></summary>
        <returns><span data-ttu-id="c1488-782">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-782">A reference to this instance after the append operation has completed.</span></span> <span data-ttu-id="c1488-783">完成追加操作后，此实例包含执行该操作之前已存在的任何数据，并且有一个 <paramref name="format" /> 的副本作为后缀，其中任何格式规范都由相应对象参数的字符串表示形式替换。</span><span class="sxs-lookup"><span data-stu-id="c1488-783">After the append operation, this instance contains any data that existed before the operation, suffixed by a copy of <paramref name="format" /> where any format specification is replaced by the string representation of the corresponding object argument.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-784">此方法使用 .NET Framework 的 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将对象的值转换为其文本表示形式，并将该表示形式嵌入到当前 <xref:System.Text.StringBuilder> 对象中。</span><span class="sxs-lookup"><span data-stu-id="c1488-784">This method uses the [composite formatting feature](/dotnet/standard/base-types/composite-formatting) of the .NET Framework to convert the value of an object to its text representation and embed that representation in the current <xref:System.Text.StringBuilder> object.</span></span>

 <span data-ttu-id="c1488-785">`format`参数包含与零个或多个索引占位符（称为格式项）混合的零个或多个文本的运行，这些占位符与此方法的参数列表中的对象相对应。</span><span class="sxs-lookup"><span data-stu-id="c1488-785">The `format` parameter consists of zero or more runs of text intermixed with zero or more indexed placeholders, called format items, that correspond to objects in the parameter list of this method.</span></span> <span data-ttu-id="c1488-786">格式设置过程将每个格式项替换为相应对象的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-786">The formatting process replaces each format item with the string representation of the corresponding object.</span></span>

 <span data-ttu-id="c1488-787">格式项的语法如下所示：</span><span class="sxs-lookup"><span data-stu-id="c1488-787">The syntax of a format item is as follows:</span></span>

 <span data-ttu-id="c1488-788">{*index*[，*length*] [：*格式字符串*]}</span><span class="sxs-lookup"><span data-stu-id="c1488-788">{*index*[,*length*][:*formatString*]}</span></span>

 <span data-ttu-id="c1488-789">括号中的元素是可选的。</span><span class="sxs-lookup"><span data-stu-id="c1488-789">Elements in square brackets are optional.</span></span> <span data-ttu-id="c1488-790">下表对每个元素进行了描述。</span><span class="sxs-lookup"><span data-stu-id="c1488-790">The following table describes each element.</span></span>

|<span data-ttu-id="c1488-791">元素</span><span class="sxs-lookup"><span data-stu-id="c1488-791">Element</span></span>|<span data-ttu-id="c1488-792">描述</span><span class="sxs-lookup"><span data-stu-id="c1488-792">Description</span></span>|
|-------------|-----------------|
|<span data-ttu-id="c1488-793">*index*</span><span class="sxs-lookup"><span data-stu-id="c1488-793">*index*</span></span>|<span data-ttu-id="c1488-794">要设置格式的对象的参数列表中的从零开始的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-794">The zero-based position in the parameter list of the object to be formatted.</span></span> <span data-ttu-id="c1488-795">如果由 *index* 指定的对象为 `null` ，则会将格式项替换为 <xref:System.String.Empty?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-795">If the object specified by *index* is `null`, the format item is replaced by <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c1488-796">如果 *索引* 位置中没有参数， <xref:System.FormatException> 则会引发。</span><span class="sxs-lookup"><span data-stu-id="c1488-796">If there is no parameter in the *index* position, a <xref:System.FormatException> is thrown.</span></span>|
|<span data-ttu-id="c1488-797">，*长度*</span><span class="sxs-lookup"><span data-stu-id="c1488-797">,*length*</span></span>|<span data-ttu-id="c1488-798">参数的字符串表示形式中的最小字符数。</span><span class="sxs-lookup"><span data-stu-id="c1488-798">The minimum number of characters in the string representation of the parameter.</span></span> <span data-ttu-id="c1488-799">如果为正，则参数为右对齐; 否则为。如果为负，则为左对齐。</span><span class="sxs-lookup"><span data-stu-id="c1488-799">If positive, the parameter is right-aligned; if negative, it is left-aligned.</span></span>|
|<span data-ttu-id="c1488-800">：*格式字符串*</span><span class="sxs-lookup"><span data-stu-id="c1488-800">:*formatString*</span></span>|<span data-ttu-id="c1488-801">参数支持的标准或自定义格式字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-801">A standard or custom format string that is supported by the parameter.</span></span>|

> [!NOTE]
>  <span data-ttu-id="c1488-802">对于用于日期和时间值的标准和自定义格式字符串，请参阅 [标准日期和时间格式](/dotnet/standard/base-types/standard-date-and-time-format-strings) 字符串和 [自定义日期和时间格式字符串](/dotnet/standard/base-types/custom-date-and-time-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="c1488-802">For the standard and custom format strings used with date and time values, see [Standard Date and Time Format Strings](/dotnet/standard/base-types/standard-date-and-time-format-strings) and [Custom Date and Time Format Strings](/dotnet/standard/base-types/custom-date-and-time-format-strings).</span></span> <span data-ttu-id="c1488-803">对于与数值一起使用的标准和自定义格式字符串，请参阅 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 和 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="c1488-803">For the standard and custom format strings used with numeric values, see [Standard Numeric Format Strings](/dotnet/standard/base-types/standard-numeric-format-strings) and [Custom Numeric Format Strings](/dotnet/standard/base-types/custom-numeric-format-strings).</span></span> <span data-ttu-id="c1488-804">对于用于枚举的标准格式字符串，请参阅 [枚举格式字符串](/dotnet/standard/base-types/enumeration-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="c1488-804">For the standard format strings used with enumerations, see [Enumeration Format Strings](/dotnet/standard/base-types/enumeration-format-strings).</span></span>

 <span data-ttu-id="c1488-805">`provider`参数指定一个 <xref:System.IFormatProvider> 实现，该实现可以为中的对象提供格式设置信息 `args` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-805">The `provider` parameter specifies an <xref:System.IFormatProvider> implementation that can provide formatting information for the objects in `args`.</span></span> <span data-ttu-id="c1488-806">`provider` 可以是以下任意形式：</span><span class="sxs-lookup"><span data-stu-id="c1488-806">`provider` can be any of the following:</span></span>

-   <span data-ttu-id="c1488-807">一个 <xref:System.Globalization.CultureInfo> 对象，提供区域性特定的格式设置信息。</span><span class="sxs-lookup"><span data-stu-id="c1488-807">A <xref:System.Globalization.CultureInfo> object that provides culture-specific formatting information.</span></span>

-   <span data-ttu-id="c1488-808">一个 <xref:System.Globalization.NumberFormatInfo> 对象，该对象为中的数字值提供区域性特定的格式设置信息 `args` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-808">A <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific formatting information for numeric values in `args`.</span></span>

-   <span data-ttu-id="c1488-809">一个 <xref:System.Globalization.DateTimeFormatInfo> 对象，该对象为中的日期和时间值提供区域性特定的格式设置信息 `args` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-809">A <xref:System.Globalization.DateTimeFormatInfo> object that provides culture-specific formatting information for date and time values in `args`.</span></span>

-   <span data-ttu-id="c1488-810">为 <xref:System.IFormatProvider> 中的一个或多个对象提供格式设置信息的自定义实现 `args` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-810">A custom <xref:System.IFormatProvider> implementation that provides formatting information for one or more of the objects in `args`.</span></span> <span data-ttu-id="c1488-811">通常，此类实现还实现 <xref:System.ICustomFormatter> 接口。</span><span class="sxs-lookup"><span data-stu-id="c1488-811">Typically, such an implementation also implements the <xref:System.ICustomFormatter> interface.</span></span> <span data-ttu-id="c1488-812">下一节中的第二个示例演示了 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> 使用自定义实现的方法调用 <xref:System.IFormatProvider> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-812">The second example in the next section illustrates an <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> method call with a custom <xref:System.IFormatProvider> implementation.</span></span>

 <span data-ttu-id="c1488-813">如果 `provider` 参数为 `null` ，则从当前区域性获取格式提供程序信息。</span><span class="sxs-lookup"><span data-stu-id="c1488-813">If the `provider` parameter is `null`, format provider information is obtained from the current culture.</span></span>

 <span data-ttu-id="c1488-814">`args` 表示要设置格式的对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-814">`args` represents the objects to be formatted.</span></span> <span data-ttu-id="c1488-815">中的每个格式项 `format` 都替换为中相应对象的字符串表示形式 `args` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-815">Each format item in `format` is replaced with the string representation of the corresponding object in `args`.</span></span> <span data-ttu-id="c1488-816">如果格式项包括 `formatString` ，并且中的相应对象 `args` 实现 <xref:System.IFormattable> 接口，则 `args[index].ToString(formatString, provider)` 定义格式设置。</span><span class="sxs-lookup"><span data-stu-id="c1488-816">If the format item includes `formatString` and the corresponding object in `args` implements the <xref:System.IFormattable> interface, then `args[index].ToString(formatString, provider)` defines the formatting.</span></span> <span data-ttu-id="c1488-817">否则，会 `args[index].ToString()` 定义格式设置。</span><span class="sxs-lookup"><span data-stu-id="c1488-817">Otherwise, `args[index].ToString()` defines the formatting.</span></span>



## Examples
 <span data-ttu-id="c1488-818">下面的示例演示 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-818">The following example demonstrates the <xref:System.Text.StringBuilder.AppendFormat%2A> method.</span></span>

 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]

 <span data-ttu-id="c1488-819">下面的示例定义了一个 <xref:System.IFormatProvider> 名为的自定义实现 `CustomerFormatter` ，该实现在第四个和第七个数字后设置一个包含连字符的10位客户编号</span><span class="sxs-lookup"><span data-stu-id="c1488-819">The following example defines a custom <xref:System.IFormatProvider> implementation named `CustomerFormatter` that formats a 10-digit customer number with hyphens after the fourth and seventh digits.</span></span> <span data-ttu-id="c1488-820">它被传递给 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> 方法以创建一个字符串，该字符串包含带格式的客户编号和客户名称。</span><span class="sxs-lookup"><span data-stu-id="c1488-820">It is passed to the <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> method to create a string that includes the formatted customer number and customer name.</span></span>

 [!code-csharp[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/customernumberformatter1.cs#1)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/customernumberformatter1.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c1488-821"><paramref name="format" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-821"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="c1488-822"><paramref name="format" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="c1488-822"><paramref name="format" /> is invalid.</span></span>

<span data-ttu-id="c1488-823">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-823">-or-</span></span>

<span data-ttu-id="c1488-824">格式项的索引小于 0（零），或者大于或等于 <paramref name="args" /> 数组的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-824">The index of a format item is less than 0 (zero), or greater than or equal to the length of the <paramref name="args" /> array.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-825">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-825">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-826">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-826">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-827">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-827">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
        <related type="Article" href="/dotnet/standard/base-types/formatting-types"><span data-ttu-id="c1488-828">设置 .NET 中类型的格式</span><span class="sxs-lookup"><span data-stu-id="c1488-828">Formatting Types in .NET</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/composite-formatting"><span data-ttu-id="c1488-829">复合格式设置</span><span class="sxs-lookup"><span data-stu-id="c1488-829">Composite Formatting</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/how-to-define-and-use-custom-numeric-format-providers"><span data-ttu-id="c1488-830">如何：定义和使用自定义数值格式提供程序</span><span class="sxs-lookup"><span data-stu-id="c1488-830">How to: Define and Use Custom Numeric Format Providers</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings"><span data-ttu-id="c1488-831">标准数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-831">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings"><span data-ttu-id="c1488-832">自定义数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-832">Custom Numeric Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-date-and-time-format-strings"><span data-ttu-id="c1488-833">标准日期和时间格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-833">Standard Date and Time Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-date-and-time-format-strings"><span data-ttu-id="c1488-834">自定义日期和时间格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-834">Custom Date and Time Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-timespan-format-strings"><span data-ttu-id="c1488-835">标准 TimeSpan 格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-835">Standard TimeSpan Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-timespan-format-strings"><span data-ttu-id="c1488-836">自定义的 TimeSpan 格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-836">Custom TimeSpan Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/enumeration-format-strings"><span data-ttu-id="c1488-837">枚举格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-837">Enumeration Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object? arg0, object? arg1);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="c1488-838">复合格式字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-838">A composite format string.</span></span></param>
        <param name="arg0"><span data-ttu-id="c1488-839">要设置格式的第一个对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-839">The first object to format.</span></span></param>
        <param name="arg1"><span data-ttu-id="c1488-840">要设置格式的第二个对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-840">The second object to format.</span></span></param>
        <summary><span data-ttu-id="c1488-841">向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-841">Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance.</span></span> <span data-ttu-id="c1488-842">每个格式项都替换为这两个参数中任意一个参数的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-842">Each format item is replaced by the string representation of either of two arguments.</span></span></summary>
        <returns><span data-ttu-id="c1488-843">对追加了 <paramref name="format" /> 的此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-843">A reference to this instance with <paramref name="format" /> appended.</span></span> <span data-ttu-id="c1488-844"><paramref name="format" /> 中的每个格式项都由相应的对象参数的字符串表示形式替换。</span><span class="sxs-lookup"><span data-stu-id="c1488-844">Each format item in <paramref name="format" /> is replaced by the string representation of the corresponding object argument.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-845">此方法使用 .NET Framework 的 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将对象的值转换为其文本表示形式，并将该表示形式嵌入到当前 <xref:System.Text.StringBuilder> 对象中。</span><span class="sxs-lookup"><span data-stu-id="c1488-845">This method uses the [composite formatting feature](/dotnet/standard/base-types/composite-formatting) of the .NET Framework to convert the value of an object to its text representation and embed that representation in the current <xref:System.Text.StringBuilder> object.</span></span>

 <span data-ttu-id="c1488-846">`format`参数包含与零个或多个索引占位符（称为格式项）混合的零个或多个文本的运行 `arg0` ， `arg1` 这两个对象分别与此方法的参数列表中的两个对象相对应。</span><span class="sxs-lookup"><span data-stu-id="c1488-846">The `format` parameter consists of zero or more runs of text intermixed with zero or more indexed placeholders, called format items, that correspond to `arg0` and `arg1`, the two objects in the parameter list of this method.</span></span> <span data-ttu-id="c1488-847">格式设置过程将每个格式项替换为相应对象的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-847">The formatting process replaces each format item with the string representation of the corresponding object.</span></span>

 <span data-ttu-id="c1488-848">格式项的语法如下所示：</span><span class="sxs-lookup"><span data-stu-id="c1488-848">The syntax of a format item is as follows:</span></span>

 <span data-ttu-id="c1488-849">{*index*[，*length*] [：*格式字符串*]}</span><span class="sxs-lookup"><span data-stu-id="c1488-849">{*index*[,*length*][:*formatString*]}</span></span>

 <span data-ttu-id="c1488-850">括号中的元素是可选的。</span><span class="sxs-lookup"><span data-stu-id="c1488-850">Elements in square brackets are optional.</span></span> <span data-ttu-id="c1488-851">下表对每个元素进行了描述。</span><span class="sxs-lookup"><span data-stu-id="c1488-851">The following table describes each element.</span></span>

|<span data-ttu-id="c1488-852">元素</span><span class="sxs-lookup"><span data-stu-id="c1488-852">Element</span></span>|<span data-ttu-id="c1488-853">描述</span><span class="sxs-lookup"><span data-stu-id="c1488-853">Description</span></span>|
|-------------|-----------------|
|<span data-ttu-id="c1488-854">*index*</span><span class="sxs-lookup"><span data-stu-id="c1488-854">*index*</span></span>|<span data-ttu-id="c1488-855">要设置格式的对象的参数列表中的从零开始的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-855">The zero-based position in the parameter list of the object to be formatted.</span></span> <span data-ttu-id="c1488-856">如果由 *index* 指定的对象为 `null` ，则会将格式项替换为 <xref:System.String.Empty?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-856">If the object specified by *index* is `null`, the format item is replaced by <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c1488-857">如果 *索引* 位置中没有参数， <xref:System.FormatException> 则会引发。</span><span class="sxs-lookup"><span data-stu-id="c1488-857">If there is no parameter in the *index* position, a <xref:System.FormatException> is thrown.</span></span>|
|<span data-ttu-id="c1488-858">，*长度*</span><span class="sxs-lookup"><span data-stu-id="c1488-858">,*length*</span></span>|<span data-ttu-id="c1488-859">参数的字符串表示形式中的最小字符数。</span><span class="sxs-lookup"><span data-stu-id="c1488-859">The minimum number of characters in the string representation of the parameter.</span></span> <span data-ttu-id="c1488-860">如果为正，则参数为右对齐; 否则为。如果为负，则为左对齐。</span><span class="sxs-lookup"><span data-stu-id="c1488-860">If positive, the parameter is right-aligned; if negative, it is left-aligned.</span></span>|
|<span data-ttu-id="c1488-861">：*格式字符串*</span><span class="sxs-lookup"><span data-stu-id="c1488-861">:*formatString*</span></span>|<span data-ttu-id="c1488-862">参数支持的标准或自定义格式字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-862">A standard or custom format string that is supported by the parameter.</span></span>|

> [!NOTE]
>  <span data-ttu-id="c1488-863">对于用于日期和时间值的标准和自定义格式字符串，请参阅 [标准日期和时间格式](/dotnet/standard/base-types/standard-date-and-time-format-strings) 字符串和 [自定义日期和时间格式字符串](/dotnet/standard/base-types/custom-date-and-time-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="c1488-863">For the standard and custom format strings used with date and time values, see [Standard Date and Time Format Strings](/dotnet/standard/base-types/standard-date-and-time-format-strings) and [Custom Date and Time Format Strings](/dotnet/standard/base-types/custom-date-and-time-format-strings).</span></span> <span data-ttu-id="c1488-864">对于与数值一起使用的标准和自定义格式字符串，请参阅 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 和 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="c1488-864">For the standard and custom format strings used with numeric values, see [Standard Numeric Format Strings](/dotnet/standard/base-types/standard-numeric-format-strings) and [Custom Numeric Format Strings](/dotnet/standard/base-types/custom-numeric-format-strings).</span></span> <span data-ttu-id="c1488-865">对于用于枚举的标准格式字符串，请参阅 [枚举格式字符串](/dotnet/standard/base-types/enumeration-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="c1488-865">For the standard format strings used with enumerations, see [Enumeration Format Strings](/dotnet/standard/base-types/enumeration-format-strings).</span></span>

 <span data-ttu-id="c1488-866">`arg0` 和 `arg1` 表示要设置格式的对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-866">`arg0` and `arg1` represent the objects to be formatted.</span></span> <span data-ttu-id="c1488-867">中的每个格式项 `format` 都替换为或的字符串表示形式 `arg0` `arg1` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-867">Each format item in `format` is replaced with the string representation of either `arg0` or `arg1`.</span></span> <span data-ttu-id="c1488-868">如果格式项包括， `formatString` 并且相应的对象实现 <xref:System.IFormattable> 接口，则 `arg` *x* `.ToString(formatString, provider)` 定义格式设置，其中*x*是参数的索引。</span><span class="sxs-lookup"><span data-stu-id="c1488-868">If the format item includes `formatString` and the corresponding object implements the <xref:System.IFormattable> interface, then `arg`*x*`.ToString(formatString, provider)` defines the formatting, where *x* is the index of the argument.</span></span> <span data-ttu-id="c1488-869">否则， `arg` *x* `.ToString()` 定义格式设置。</span><span class="sxs-lookup"><span data-stu-id="c1488-869">Otherwise, `arg`*x*`.ToString()` defines the formatting.</span></span>

 <span data-ttu-id="c1488-870">如果分配给的字符串 `format` 为 "感谢你向慈善组织捐赠 {0： # # # #} 个食物</span><span class="sxs-lookup"><span data-stu-id="c1488-870">If the string assigned to `format` is "Thank you for your donation of {0:####} cans of food to our charitable organization."</span></span> <span data-ttu-id="c1488-871">和 `arg0` 是一个值为10的整数，则返回值将为 "感谢你向慈善组织捐赠10罐食物"。</span><span class="sxs-lookup"><span data-stu-id="c1488-871">and `arg0` is an integer with the value 10, the return value will be "Thank you for your donation of 10 cans of food to our charitable organization."</span></span>



## Examples
 <span data-ttu-id="c1488-872">下面的示例演示 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-872">The following example demonstrates the <xref:System.Text.StringBuilder.AppendFormat%2A> method.</span></span>

 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c1488-873"><paramref name="format" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-873"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="c1488-874"><paramref name="format" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="c1488-874"><paramref name="format" /> is invalid.</span></span>

<span data-ttu-id="c1488-875">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-875">-or-</span></span>

<span data-ttu-id="c1488-876">格式项的索引小于 0（零），或者大于等于 2。</span><span class="sxs-lookup"><span data-stu-id="c1488-876">The index of a format item is less than 0 (zero), or greater than or equal to 2.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-877">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-877">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-878">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-878">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-879">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-879">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
        <related type="Article" href="/dotnet/standard/base-types/formatting-types"><span data-ttu-id="c1488-880">设置 .NET 中类型的格式</span><span class="sxs-lookup"><span data-stu-id="c1488-880">Formatting Types in .NET</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/composite-formatting"><span data-ttu-id="c1488-881">复合格式设置</span><span class="sxs-lookup"><span data-stu-id="c1488-881">Composite Formatting</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings"><span data-ttu-id="c1488-882">标准数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-882">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings"><span data-ttu-id="c1488-883">自定义数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-883">Custom Numeric Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-date-and-time-format-strings"><span data-ttu-id="c1488-884">标准日期和时间格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-884">Standard Date and Time Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-date-and-time-format-strings"><span data-ttu-id="c1488-885">自定义日期和时间格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-885">Custom Date and Time Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-timespan-format-strings"><span data-ttu-id="c1488-886">标准 TimeSpan 格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-886">Standard TimeSpan Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-timespan-format-strings"><span data-ttu-id="c1488-887">自定义的 TimeSpan 格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-887">Custom TimeSpan Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/enumeration-format-strings"><span data-ttu-id="c1488-888">枚举格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-888">Enumeration Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder? AppendFormat (IFormatProvider provider, string? format, object arg0, object arg1);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="c1488-889">一个提供区域性特定的格式设置信息的对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-889">An object that supplies culture-specific formatting information.</span></span></param>
        <param name="format"><span data-ttu-id="c1488-890">复合格式字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-890">A composite format string.</span></span></param>
        <param name="arg0"><span data-ttu-id="c1488-891">要设置格式的第一个对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-891">The first object to format.</span></span></param>
        <param name="arg1"><span data-ttu-id="c1488-892">要设置格式的第二个对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-892">The second object to format.</span></span></param>
        <summary><span data-ttu-id="c1488-893">向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-893">Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance.</span></span> <span data-ttu-id="c1488-894">每个格式项都使用指定的格式提供程序替换为两个参数中任一个的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-894">Each format item is replaced by the string representation of either of two arguments using a specified format provider.</span></span></summary>
        <returns><span data-ttu-id="c1488-895">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-895">A reference to this instance after the append operation has completed.</span></span> <span data-ttu-id="c1488-896">完成追加操作后，此实例包含执行该操作之前已存在的任何数据，并且有一个 <paramref name="format" /> 的副本作为后缀，其中任何格式规范都由相应对象参数的字符串表示形式替换。</span><span class="sxs-lookup"><span data-stu-id="c1488-896">After the append operation, this instance contains any data that existed before the operation, suffixed by a copy of <paramref name="format" /> where any format specification is replaced by the string representation of the corresponding object argument.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-897">此方法使用 .NET Framework 的 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将对象的值转换为其文本表示形式，并将该表示形式嵌入到当前 <xref:System.Text.StringBuilder> 对象中。</span><span class="sxs-lookup"><span data-stu-id="c1488-897">This method uses the [composite formatting feature](/dotnet/standard/base-types/composite-formatting) of the .NET Framework to convert the value of an object to its text representation and embed that representation in the current <xref:System.Text.StringBuilder> object.</span></span>

 <span data-ttu-id="c1488-898">`format`参数包含与零个或多个索引占位符（称为格式项）混合的零个或多个文本的运行，这些占位符与此方法的参数列表中的对象相对应。</span><span class="sxs-lookup"><span data-stu-id="c1488-898">The `format` parameter consists of zero or more runs of text intermixed with zero or more indexed placeholders, called format items, that correspond to objects in the parameter list of this method.</span></span> <span data-ttu-id="c1488-899">格式设置过程将每个格式项替换为相应对象的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-899">The formatting process replaces each format item with the string representation of the corresponding object.</span></span>

 <span data-ttu-id="c1488-900">格式项的语法如下所示：</span><span class="sxs-lookup"><span data-stu-id="c1488-900">The syntax of a format item is as follows:</span></span>

 <span data-ttu-id="c1488-901">{*index*[，*length*] [：*格式字符串*]}</span><span class="sxs-lookup"><span data-stu-id="c1488-901">{*index*[,*length*][:*formatString*]}</span></span>

 <span data-ttu-id="c1488-902">括号中的元素是可选的。</span><span class="sxs-lookup"><span data-stu-id="c1488-902">Elements in square brackets are optional.</span></span> <span data-ttu-id="c1488-903">下表对每个元素进行了描述。</span><span class="sxs-lookup"><span data-stu-id="c1488-903">The following table describes each element.</span></span>

|<span data-ttu-id="c1488-904">元素</span><span class="sxs-lookup"><span data-stu-id="c1488-904">Element</span></span>|<span data-ttu-id="c1488-905">描述</span><span class="sxs-lookup"><span data-stu-id="c1488-905">Description</span></span>|
|-------------|-----------------|
|<span data-ttu-id="c1488-906">*index*</span><span class="sxs-lookup"><span data-stu-id="c1488-906">*index*</span></span>|<span data-ttu-id="c1488-907">要设置格式的对象的参数列表中的从零开始的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-907">The zero-based position in the parameter list of the object to be formatted.</span></span> <span data-ttu-id="c1488-908">如果由 *index* 指定的对象为 `null` ，则会将格式项替换为 <xref:System.String.Empty?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-908">If the object specified by *index* is `null`, the format item is replaced by <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c1488-909">如果 *索引* 位置中没有参数， <xref:System.FormatException> 则会引发。</span><span class="sxs-lookup"><span data-stu-id="c1488-909">If there is no parameter in the *index* position, a <xref:System.FormatException> is thrown.</span></span>|
|<span data-ttu-id="c1488-910">，*长度*</span><span class="sxs-lookup"><span data-stu-id="c1488-910">,*length*</span></span>|<span data-ttu-id="c1488-911">参数的字符串表示形式中的最小字符数。</span><span class="sxs-lookup"><span data-stu-id="c1488-911">The minimum number of characters in the string representation of the parameter.</span></span> <span data-ttu-id="c1488-912">如果为正，则参数为右对齐; 否则为。如果为负，则为左对齐。</span><span class="sxs-lookup"><span data-stu-id="c1488-912">If positive, the parameter is right-aligned; if negative, it is left-aligned.</span></span>|
|<span data-ttu-id="c1488-913">：*格式字符串*</span><span class="sxs-lookup"><span data-stu-id="c1488-913">:*formatString*</span></span>|<span data-ttu-id="c1488-914">参数支持的标准或自定义格式字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-914">A standard or custom format string that is supported by the parameter.</span></span>|

> [!NOTE]
>  <span data-ttu-id="c1488-915">对于用于日期和时间值的标准和自定义格式字符串，请参阅 [标准日期和时间格式](/dotnet/standard/base-types/standard-date-and-time-format-strings) 字符串和 [自定义日期和时间格式字符串](/dotnet/standard/base-types/custom-date-and-time-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="c1488-915">For the standard and custom format strings used with date and time values, see [Standard Date and Time Format Strings](/dotnet/standard/base-types/standard-date-and-time-format-strings) and [Custom Date and Time Format Strings](/dotnet/standard/base-types/custom-date-and-time-format-strings).</span></span> <span data-ttu-id="c1488-916">对于与数值一起使用的标准和自定义格式字符串，请参阅 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 和 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="c1488-916">For the standard and custom format strings used with numeric values, see [Standard Numeric Format Strings](/dotnet/standard/base-types/standard-numeric-format-strings) and [Custom Numeric Format Strings](/dotnet/standard/base-types/custom-numeric-format-strings).</span></span> <span data-ttu-id="c1488-917">对于用于枚举的标准格式字符串，请参阅 [枚举格式字符串](/dotnet/standard/base-types/enumeration-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="c1488-917">For the standard format strings used with enumerations, see [Enumeration Format Strings](/dotnet/standard/base-types/enumeration-format-strings).</span></span>

 <span data-ttu-id="c1488-918">`provider`参数指定 <xref:System.IFormatProvider> 可为和提供格式设置信息的实现 `arg0` `arg1` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-918">The `provider` parameter specifies an <xref:System.IFormatProvider> implementation that can provide formatting information for `arg0` and `arg1`.</span></span> <span data-ttu-id="c1488-919">`provider` 可以是以下任意形式：</span><span class="sxs-lookup"><span data-stu-id="c1488-919">`provider` can be any of the following:</span></span>

-   <span data-ttu-id="c1488-920">一个 <xref:System.Globalization.CultureInfo> 对象，提供区域性特定的格式设置信息。</span><span class="sxs-lookup"><span data-stu-id="c1488-920">A <xref:System.Globalization.CultureInfo> object that provides culture-specific formatting information.</span></span>

-   <span data-ttu-id="c1488-921">一个 <xref:System.Globalization.NumberFormatInfo> 对象，它为提供区域性特定的格式设置信息， `arg0` `arg1` 如果它们是数字值，则为。</span><span class="sxs-lookup"><span data-stu-id="c1488-921">A <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific formatting information for `arg0` or `arg1` if they are numeric values.</span></span>

-   <span data-ttu-id="c1488-922">一个 <xref:System.Globalization.DateTimeFormatInfo> 对象，它为提供区域性特定的格式设置信息，或者，为 `arg0` `arg1` 日期和时间值。</span><span class="sxs-lookup"><span data-stu-id="c1488-922">A <xref:System.Globalization.DateTimeFormatInfo> object that provides culture-specific formatting information for `arg0` or `arg1` if they are date and time values.</span></span>

-   <span data-ttu-id="c1488-923">为 <xref:System.IFormatProvider> 和提供格式设置信息的自定义实现 `arg0` `arg1` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-923">A custom <xref:System.IFormatProvider> implementation that provides formatting information for `arg0` and `arg1`.</span></span> <span data-ttu-id="c1488-924">通常，此类实现还实现 <xref:System.ICustomFormatter> 接口。</span><span class="sxs-lookup"><span data-stu-id="c1488-924">Typically, such an implementation also implements the <xref:System.ICustomFormatter> interface.</span></span>

 <span data-ttu-id="c1488-925">如果 `provider` 参数为 `null` ，则从当前区域性获取格式提供程序信息。</span><span class="sxs-lookup"><span data-stu-id="c1488-925">If the `provider` parameter is `null`, format provider information is obtained from the current culture.</span></span>

 <span data-ttu-id="c1488-926">`arg0` 和 `arg1` 表示要设置格式的对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-926">`arg0` and `arg1` represent the objects to be formatted.</span></span> <span data-ttu-id="c1488-927">中的每个格式项 `format` 都替换为具有相应索引的对象的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-927">Each format item in `format` is replaced with the string representation of the object that has the corresponding index.</span></span> <span data-ttu-id="c1488-928">如果格式项包括 `formatString` ，并且相应的参数实现了 <xref:System.IFormattable> 接口，则参数的 `ToString(formatString, provider)` 方法会定义格式设置。</span><span class="sxs-lookup"><span data-stu-id="c1488-928">If the format item includes `formatString` and the corresponding argument implements the <xref:System.IFormattable> interface, then the argument's `ToString(formatString, provider)` method defines the formatting.</span></span> <span data-ttu-id="c1488-929">否则，自变量的 `ToString()` 方法定义格式设置。</span><span class="sxs-lookup"><span data-stu-id="c1488-929">Otherwise, the argument's `ToString()` method defines the formatting.</span></span>



## Examples
 <span data-ttu-id="c1488-930">下面的示例使用 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%29> 方法来显示通用对象中存储的时间和温度数据 <xref:System.Collections.Generic.Dictionary%602> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-930">The following example uses the <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%29> method to display time and temperature data stored in a generic <xref:System.Collections.Generic.Dictionary%602> object.</span></span> <span data-ttu-id="c1488-931">请注意，格式字符串具有三个格式项，但仅有要设置格式的对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-931">Note that the format string has three format items, although there are only to objects to format.</span></span> <span data-ttu-id="c1488-932">这是因为列表中的第一个对象 (日期和时间值) 由两个格式项使用：第一个格式项显示时间，第二个对象显示日期。</span><span class="sxs-lookup"><span data-stu-id="c1488-932">This is because the first object in the list (a date and time value) is used by two format items: The first format item displays the time, and the second displays the date.</span></span>

 [!code-csharp[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat2.cs#3)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat2.vb#3)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c1488-933"><paramref name="format" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-933"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="c1488-934"><paramref name="format" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="c1488-934"><paramref name="format" /> is invalid.</span></span>

<span data-ttu-id="c1488-935">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-935">-or-</span></span>

<span data-ttu-id="c1488-936">格式项的索引小于 0（零）或者大于或等于 2。</span><span class="sxs-lookup"><span data-stu-id="c1488-936">The index of a format item is less than 0 (zero), or greater than or equal to 2 (two).</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-937">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-937">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-938">在 .NET Core 和在 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-938">IIn .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-939">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-939">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
        <related type="Article" href="/dotnet/standard/base-types/formatting-types"><span data-ttu-id="c1488-940">设置 .NET 中类型的格式</span><span class="sxs-lookup"><span data-stu-id="c1488-940">Formatting Types in .NET</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/composite-formatting"><span data-ttu-id="c1488-941">复合格式设置</span><span class="sxs-lookup"><span data-stu-id="c1488-941">Composite Formatting</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/how-to-define-and-use-custom-numeric-format-providers"><span data-ttu-id="c1488-942">如何：定义和使用自定义数值格式提供程序</span><span class="sxs-lookup"><span data-stu-id="c1488-942">How to: Define and Use Custom Numeric Format Providers</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings"><span data-ttu-id="c1488-943">标准数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-943">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings"><span data-ttu-id="c1488-944">自定义数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-944">Custom Numeric Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-date-and-time-format-strings"><span data-ttu-id="c1488-945">标准日期和时间格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-945">Standard Date and Time Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-date-and-time-format-strings"><span data-ttu-id="c1488-946">自定义日期和时间格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-946">Custom Date and Time Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-timespan-format-strings"><span data-ttu-id="c1488-947">标准 TimeSpan 格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-947">Standard TimeSpan Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-timespan-format-strings"><span data-ttu-id="c1488-948">自定义的 TimeSpan 格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-948">Custom TimeSpan Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/enumeration-format-strings"><span data-ttu-id="c1488-949">枚举格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-949">Enumeration Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1, object arg2);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1, arg2)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder? AppendFormat (string? format, object arg0, object arg1, object arg2);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="c1488-950">复合格式字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-950">A composite format string.</span></span></param>
        <param name="arg0"><span data-ttu-id="c1488-951">要设置格式的第一个对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-951">The first object to format.</span></span></param>
        <param name="arg1"><span data-ttu-id="c1488-952">要设置格式的第二个对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-952">The second object to format.</span></span></param>
        <param name="arg2"><span data-ttu-id="c1488-953">要设置格式的第三个对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-953">The third object to format.</span></span></param>
        <summary><span data-ttu-id="c1488-954">向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-954">Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance.</span></span> <span data-ttu-id="c1488-955">每个格式项都替换为这三个参数中任意一个参数的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-955">Each format item is replaced by the string representation of either of three arguments.</span></span></summary>
        <returns><span data-ttu-id="c1488-956">对追加了 <paramref name="format" /> 的此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-956">A reference to this instance with <paramref name="format" /> appended.</span></span> <span data-ttu-id="c1488-957"><paramref name="format" /> 中的每个格式项都由相应的对象参数的字符串表示形式替换。</span><span class="sxs-lookup"><span data-stu-id="c1488-957">Each format item in <paramref name="format" /> is replaced by the string representation of the corresponding object argument.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-958">此方法使用 .NET Framework 的 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将对象的值转换为其文本表示形式，并将该表示形式嵌入到当前 <xref:System.Text.StringBuilder> 对象中。</span><span class="sxs-lookup"><span data-stu-id="c1488-958">This method uses the [composite formatting feature](/dotnet/standard/base-types/composite-formatting) of the .NET Framework to convert the value of an object to its text representation and embed that representation in the current <xref:System.Text.StringBuilder> object.</span></span>

 <span data-ttu-id="c1488-959">参数由零个或多个包含零个或 `format` 多个索引占位符（称为格式项，它们对应于 `arg0` `arg2` ），这种方法的参数列表中的对象组成。</span><span class="sxs-lookup"><span data-stu-id="c1488-959">The `format` parameter consists of zero or more runs of text intermixed with zero or more indexed placeholders, called format items, that correspond to `arg0` through `arg2`, the objects in the parameter list of this method.</span></span> <span data-ttu-id="c1488-960">格式设置过程将每个格式项替换为相应对象的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-960">The formatting process replaces each format item with the string representation of the corresponding object.</span></span>

 <span data-ttu-id="c1488-961">格式项的语法如下所示：</span><span class="sxs-lookup"><span data-stu-id="c1488-961">The syntax of a format item is as follows:</span></span>

 <span data-ttu-id="c1488-962">{*index*[，*length*] [：*格式字符串*]}</span><span class="sxs-lookup"><span data-stu-id="c1488-962">{*index*[,*length*][:*formatString*]}</span></span>

 <span data-ttu-id="c1488-963">括号中的元素是可选的。</span><span class="sxs-lookup"><span data-stu-id="c1488-963">Elements in square brackets are optional.</span></span> <span data-ttu-id="c1488-964">下表对每个元素进行了描述。</span><span class="sxs-lookup"><span data-stu-id="c1488-964">The following table describes each element.</span></span>

|<span data-ttu-id="c1488-965">元素</span><span class="sxs-lookup"><span data-stu-id="c1488-965">Element</span></span>|<span data-ttu-id="c1488-966">描述</span><span class="sxs-lookup"><span data-stu-id="c1488-966">Description</span></span>|
|-------------|-----------------|
|<span data-ttu-id="c1488-967">*index*</span><span class="sxs-lookup"><span data-stu-id="c1488-967">*index*</span></span>|<span data-ttu-id="c1488-968">要设置格式的对象的参数列表中的从零开始的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-968">The zero-based position in the parameter list of the object to be formatted.</span></span> <span data-ttu-id="c1488-969">如果由 *index* 指定的对象为 `null` ，则会将格式项替换为 <xref:System.String.Empty?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-969">If the object specified by *index* is `null`, the format item is replaced by <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c1488-970">如果 *索引* 位置中没有参数， <xref:System.FormatException> 则会引发。</span><span class="sxs-lookup"><span data-stu-id="c1488-970">If there is no parameter in the *index* position, a <xref:System.FormatException> is thrown.</span></span>|
|<span data-ttu-id="c1488-971">，*长度*</span><span class="sxs-lookup"><span data-stu-id="c1488-971">,*length*</span></span>|<span data-ttu-id="c1488-972">参数的字符串表示形式中的最小字符数。</span><span class="sxs-lookup"><span data-stu-id="c1488-972">The minimum number of characters in the string representation of the parameter.</span></span> <span data-ttu-id="c1488-973">如果为正，则参数为右对齐; 否则为。如果为负，则为左对齐。</span><span class="sxs-lookup"><span data-stu-id="c1488-973">If positive, the parameter is right-aligned; if negative, it is left-aligned.</span></span>|
|<span data-ttu-id="c1488-974">：*格式字符串*</span><span class="sxs-lookup"><span data-stu-id="c1488-974">:*formatString*</span></span>|<span data-ttu-id="c1488-975">参数支持的标准或自定义格式字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-975">A standard or custom format string that is supported by the parameter.</span></span>|

> [!NOTE]
>  <span data-ttu-id="c1488-976">对于用于日期和时间值的标准和自定义格式字符串，请参阅 [标准日期和时间格式](/dotnet/standard/base-types/standard-date-and-time-format-strings) 字符串和 [自定义日期和时间格式字符串](/dotnet/standard/base-types/custom-date-and-time-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="c1488-976">For the standard and custom format strings used with date and time values, see [Standard Date and Time Format Strings](/dotnet/standard/base-types/standard-date-and-time-format-strings) and [Custom Date and Time Format Strings](/dotnet/standard/base-types/custom-date-and-time-format-strings).</span></span> <span data-ttu-id="c1488-977">对于与数值一起使用的标准和自定义格式字符串，请参阅 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 和 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="c1488-977">For the standard and custom format strings used with numeric values, see [Standard Numeric Format Strings](/dotnet/standard/base-types/standard-numeric-format-strings) and [Custom Numeric Format Strings](/dotnet/standard/base-types/custom-numeric-format-strings).</span></span> <span data-ttu-id="c1488-978">对于用于枚举的标准格式字符串，请参阅 [枚举格式字符串](/dotnet/standard/base-types/enumeration-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="c1488-978">For the standard format strings used with enumerations, see [Enumeration Format Strings](/dotnet/standard/base-types/enumeration-format-strings).</span></span>

 <span data-ttu-id="c1488-979">`arg0`、 `arg1` 和 `arg2` 表示要设置格式的对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-979">`arg0`, `arg1`, and `arg2` represent the objects to be formatted.</span></span> <span data-ttu-id="c1488-980">中的每个格式项 `format` 都替换为、或的字符串表示形式， `arg0` `arg1` `arg2` 具体取决于格式项的索引。</span><span class="sxs-lookup"><span data-stu-id="c1488-980">Each format item in `format` is replaced with the string representation of either `arg0`, `arg1`, or `arg2`, depending on the index of the format item.</span></span> <span data-ttu-id="c1488-981">如果格式项包括， `formatString` 并且中的相应对象 `args` 实现 <xref:System.IFormattable> 接口，则 `arg` *x* `.ToString(formatString, null)` 定义格式设置，其中*x*是参数的索引。</span><span class="sxs-lookup"><span data-stu-id="c1488-981">If the format item includes `formatString` and the corresponding object in `args` implements the <xref:System.IFormattable> interface, then `arg`*x*`.ToString(formatString, null)` defines the formatting, where *x* is the index of the argument.</span></span> <span data-ttu-id="c1488-982">否则， `arg` *x* `.ToString()` 定义格式设置。</span><span class="sxs-lookup"><span data-stu-id="c1488-982">Otherwise, `arg`*x*`.ToString()` defines the formatting.</span></span>

 <span data-ttu-id="c1488-983">如果分配给的字符串 `format` 为 "感谢你向慈善组织捐赠 {0： # # # #} 个食物</span><span class="sxs-lookup"><span data-stu-id="c1488-983">If the string assigned to `format` is "Thank you for your donation of {0:####} cans of food to our charitable organization."</span></span> <span data-ttu-id="c1488-984">和 `arg0` 是一个值为10的整数，则返回值将为 "感谢你向慈善组织捐赠10罐食物"。</span><span class="sxs-lookup"><span data-stu-id="c1488-984">and `arg0` is an integer with the value 10, the return value will be "Thank you for your donation of 10 cans of food to our charitable organization."</span></span>



## Examples
 <span data-ttu-id="c1488-985">下面的示例演示 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-985">The following example demonstrates the <xref:System.Text.StringBuilder.AppendFormat%2A> method.</span></span>

 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c1488-986"><paramref name="format" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-986"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="c1488-987"><paramref name="format" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="c1488-987"><paramref name="format" /> is invalid.</span></span>

<span data-ttu-id="c1488-988">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-988">-or-</span></span>

<span data-ttu-id="c1488-989">格式项的索引小于 0（零）或者大于或等于 3。</span><span class="sxs-lookup"><span data-stu-id="c1488-989">The index of a format item is less than 0 (zero), or greater than or equal to 3.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-990">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-990">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-991">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-991">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-992">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-992">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
        <related type="Article" href="/dotnet/standard/base-types/formatting-types"><span data-ttu-id="c1488-993">设置 .NET 中类型的格式</span><span class="sxs-lookup"><span data-stu-id="c1488-993">Formatting Types in .NET</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/composite-formatting"><span data-ttu-id="c1488-994">复合格式设置</span><span class="sxs-lookup"><span data-stu-id="c1488-994">Composite Formatting</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings"><span data-ttu-id="c1488-995">标准数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-995">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings"><span data-ttu-id="c1488-996">自定义数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-996">Custom Numeric Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-date-and-time-format-strings"><span data-ttu-id="c1488-997">标准日期和时间格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-997">Standard Date and Time Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-date-and-time-format-strings"><span data-ttu-id="c1488-998">自定义日期和时间格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-998">Custom Date and Time Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-timespan-format-strings"><span data-ttu-id="c1488-999">标准 TimeSpan 格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-999">Standard TimeSpan Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-timespan-format-strings"><span data-ttu-id="c1488-1000">自定义的 TimeSpan 格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-1000">Custom TimeSpan Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/enumeration-format-strings"><span data-ttu-id="c1488-1001">枚举格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-1001">Enumeration Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1, arg2)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder? AppendFormat (IFormatProvider provider, string? format, object arg0, object arg1, object arg2);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="4" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="c1488-1002">一个提供区域性特定的格式设置信息的对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-1002">An object that supplies culture-specific formatting information.</span></span></param>
        <param name="format"><span data-ttu-id="c1488-1003">复合格式字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-1003">A composite format string.</span></span></param>
        <param name="arg0"><span data-ttu-id="c1488-1004">要设置格式的第一个对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-1004">The first object to format.</span></span></param>
        <param name="arg1"><span data-ttu-id="c1488-1005">要设置格式的第二个对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-1005">The second object to format.</span></span></param>
        <param name="arg2"><span data-ttu-id="c1488-1006">要设置格式的第三个对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-1006">The third object to format.</span></span></param>
        <summary><span data-ttu-id="c1488-1007">向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-1007">Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance.</span></span> <span data-ttu-id="c1488-1008">每个格式项都使用指定的格式提供程序替换为三个参数中任一个的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-1008">Each format item is replaced by the string representation of either of three arguments using a specified format provider.</span></span></summary>
        <returns><span data-ttu-id="c1488-1009">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1009">A reference to this instance after the append operation has completed.</span></span> <span data-ttu-id="c1488-1010">完成追加操作后，此实例包含执行该操作之前已存在的任何数据，并且有一个 <paramref name="format" /> 的副本作为后缀，其中任何格式规范都由相应对象参数的字符串表示形式替换。</span><span class="sxs-lookup"><span data-stu-id="c1488-1010">After the append operation, this instance contains any data that existed before the operation, suffixed by a copy of <paramref name="format" /> where any format specification is replaced by the string representation of the corresponding object argument.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1011">此方法使用 .NET Framework 的 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将对象的值转换为其文本表示形式，并将该表示形式嵌入到当前 <xref:System.Text.StringBuilder> 对象中。</span><span class="sxs-lookup"><span data-stu-id="c1488-1011">This method uses the [composite formatting feature](/dotnet/standard/base-types/composite-formatting) of the .NET Framework to convert the value of an object to its text representation and embed that representation in the current <xref:System.Text.StringBuilder> object.</span></span>

 <span data-ttu-id="c1488-1012">`format`参数包含与零个或多个索引占位符（称为格式项）混合的零个或多个文本的运行，这些占位符与此方法的参数列表中的对象相对应。</span><span class="sxs-lookup"><span data-stu-id="c1488-1012">The `format` parameter consists of zero or more runs of text intermixed with zero or more indexed placeholders, called format items, that correspond to objects in the parameter list of this method.</span></span> <span data-ttu-id="c1488-1013">格式设置过程将每个格式项替换为相应对象的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-1013">The formatting process replaces each format item with the string representation of the corresponding object.</span></span>

 <span data-ttu-id="c1488-1014">格式项的语法如下所示：</span><span class="sxs-lookup"><span data-stu-id="c1488-1014">The syntax of a format item is as follows:</span></span>

 <span data-ttu-id="c1488-1015">{*index*[，*length*] [：*格式字符串*]}</span><span class="sxs-lookup"><span data-stu-id="c1488-1015">{*index*[,*length*][:*formatString*]}</span></span>

 <span data-ttu-id="c1488-1016">括号中的元素是可选的。</span><span class="sxs-lookup"><span data-stu-id="c1488-1016">Elements in square brackets are optional.</span></span> <span data-ttu-id="c1488-1017">下表对每个元素进行了描述。</span><span class="sxs-lookup"><span data-stu-id="c1488-1017">The following table describes each element.</span></span>

|<span data-ttu-id="c1488-1018">元素</span><span class="sxs-lookup"><span data-stu-id="c1488-1018">Element</span></span>|<span data-ttu-id="c1488-1019">描述</span><span class="sxs-lookup"><span data-stu-id="c1488-1019">Description</span></span>|
|-------------|-----------------|
|<span data-ttu-id="c1488-1020">*index*</span><span class="sxs-lookup"><span data-stu-id="c1488-1020">*index*</span></span>|<span data-ttu-id="c1488-1021">要设置格式的对象的参数列表中的从零开始的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1021">The zero-based position in the parameter list of the object to be formatted.</span></span> <span data-ttu-id="c1488-1022">如果由 *index* 指定的对象为 `null` ，则会将格式项替换为 <xref:System.String.Empty?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1022">If the object specified by *index* is `null`, the format item is replaced by <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c1488-1023">如果 *索引* 位置中没有参数， <xref:System.FormatException> 则会引发。</span><span class="sxs-lookup"><span data-stu-id="c1488-1023">If there is no parameter in the *index* position, a <xref:System.FormatException> is thrown.</span></span>|
|<span data-ttu-id="c1488-1024">，*长度*</span><span class="sxs-lookup"><span data-stu-id="c1488-1024">,*length*</span></span>|<span data-ttu-id="c1488-1025">参数的字符串表示形式中的最小字符数。</span><span class="sxs-lookup"><span data-stu-id="c1488-1025">The minimum number of characters in the string representation of the parameter.</span></span> <span data-ttu-id="c1488-1026">如果为正，则参数为右对齐; 否则为。如果为负，则为左对齐。</span><span class="sxs-lookup"><span data-stu-id="c1488-1026">If positive, the parameter is right-aligned; if negative, it is left-aligned.</span></span>|
|<span data-ttu-id="c1488-1027">：*格式字符串*</span><span class="sxs-lookup"><span data-stu-id="c1488-1027">:*formatString*</span></span>|<span data-ttu-id="c1488-1028">参数支持的标准或自定义格式字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-1028">A standard or custom format string that is supported by the parameter.</span></span>|

> [!NOTE]
>  <span data-ttu-id="c1488-1029">对于用于日期和时间值的标准和自定义格式字符串，请参阅 [标准日期和时间格式](/dotnet/standard/base-types/standard-date-and-time-format-strings) 字符串和 [自定义日期和时间格式字符串](/dotnet/standard/base-types/custom-date-and-time-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="c1488-1029">For the standard and custom format strings used with date and time values, see [Standard Date and Time Format Strings](/dotnet/standard/base-types/standard-date-and-time-format-strings) and [Custom Date and Time Format Strings](/dotnet/standard/base-types/custom-date-and-time-format-strings).</span></span> <span data-ttu-id="c1488-1030">对于与数值一起使用的标准和自定义格式字符串，请参阅 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 和 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="c1488-1030">For the standard and custom format strings used with numeric values, see [Standard Numeric Format Strings](/dotnet/standard/base-types/standard-numeric-format-strings) and [Custom Numeric Format Strings](/dotnet/standard/base-types/custom-numeric-format-strings).</span></span> <span data-ttu-id="c1488-1031">对于用于枚举的标准格式字符串，请参阅 [枚举格式字符串](/dotnet/standard/base-types/enumeration-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="c1488-1031">For the standard format strings used with enumerations, see [Enumeration Format Strings](/dotnet/standard/base-types/enumeration-format-strings).</span></span>

 <span data-ttu-id="c1488-1032">`provider`参数指定 <xref:System.IFormatProvider> 可为和提供格式设置信息的实现 `arg0` `arg1` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1032">The `provider` parameter specifies an <xref:System.IFormatProvider> implementation that can provide formatting information for `arg0` and `arg1`.</span></span> <span data-ttu-id="c1488-1033">`provider` 可以是以下任意形式：</span><span class="sxs-lookup"><span data-stu-id="c1488-1033">`provider` can be any of the following:</span></span>

-   <span data-ttu-id="c1488-1034">一个 <xref:System.Globalization.CultureInfo> 对象，提供区域性特定的格式设置信息。</span><span class="sxs-lookup"><span data-stu-id="c1488-1034">A <xref:System.Globalization.CultureInfo> object that provides culture-specific formatting information.</span></span>

-   <span data-ttu-id="c1488-1035">一个 <xref:System.Globalization.NumberFormatInfo> 对象，它为提供区域性特定的格式设置信息， `arg0` `arg1` 如果它们是数字值，则为。</span><span class="sxs-lookup"><span data-stu-id="c1488-1035">A <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific formatting information for `arg0` or `arg1` if they are numeric values.</span></span>

-   <span data-ttu-id="c1488-1036">一个 <xref:System.Globalization.DateTimeFormatInfo> 对象，提供、或的区域性特定格式设置信息 `arg0` ， `arg1` `arg2` 如果它们是日期和时间值，则为。</span><span class="sxs-lookup"><span data-stu-id="c1488-1036">A <xref:System.Globalization.DateTimeFormatInfo> object that provides culture-specific formatting information for `arg0`, `arg1`, or `arg2` if they are date and time values.</span></span>

-   <span data-ttu-id="c1488-1037"><xref:System.IFormatProvider>提供、和的格式设置信息的自定义实现 `arg0` `arg1` `arg2` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1037">A custom <xref:System.IFormatProvider> implementation that provides formatting information for `arg0`,  `arg1`, and `arg2`.</span></span> <span data-ttu-id="c1488-1038">通常，此类实现还实现 <xref:System.ICustomFormatter> 接口。</span><span class="sxs-lookup"><span data-stu-id="c1488-1038">Typically, such an implementation also implements the <xref:System.ICustomFormatter> interface.</span></span>

 <span data-ttu-id="c1488-1039">如果 `provider` 参数为 `null` ，则从当前区域性获取格式提供程序信息。</span><span class="sxs-lookup"><span data-stu-id="c1488-1039">If the `provider` parameter is `null`, format provider information is obtained from the current culture.</span></span>

 <span data-ttu-id="c1488-1040">`arg0`、 `arg1` 和 `arg2` 表示要设置格式的对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-1040">`arg0`, `arg1`, and `arg2` represent the objects to be formatted.</span></span> <span data-ttu-id="c1488-1041">中的每个格式项 `format` 都替换为具有相应索引的对象的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="c1488-1041">Each format item in `format` is replaced with the string representation of the object that has the corresponding index.</span></span> <span data-ttu-id="c1488-1042">如果格式项包括 `formatString` ，并且相应的参数实现了 <xref:System.IFormattable> 接口，则参数的 `ToString(formatString, provider)` 方法会定义格式设置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1042">If the format item includes `formatString` and the corresponding argument implements the <xref:System.IFormattable> interface, then the argument's `ToString(formatString, provider)` method defines the formatting.</span></span> <span data-ttu-id="c1488-1043">否则，自变量的 `ToString()` 方法定义格式设置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1043">Otherwise, the argument's `ToString()` method defines the formatting.</span></span>



## Examples
 <span data-ttu-id="c1488-1044">下面的示例使用 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> 方法来说明 `And` 具有整数值的布尔运算的结果。</span><span class="sxs-lookup"><span data-stu-id="c1488-1044">The following example uses the <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> method to illustrate the result of a Boolean `And` operation with integer values.</span></span> <span data-ttu-id="c1488-1045">请注意，格式字符串包含六个格式项，但该方法在其参数列表中只有三个项，因为每个项都以两种不同的方式进行格式化。</span><span class="sxs-lookup"><span data-stu-id="c1488-1045">Note that the format string includes six format items, but the method has only three items in its argument list, because each item is formatted in two different ways.</span></span>

 [!code-csharp[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat3.cs#4)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat3.vb#4)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c1488-1046"><paramref name="format" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1046"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="c1488-1047"><paramref name="format" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="c1488-1047"><paramref name="format" /> is invalid.</span></span>

<span data-ttu-id="c1488-1048">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-1048">-or-</span></span>

<span data-ttu-id="c1488-1049">格式项的索引小于 0（零）或者大于或等于 3。</span><span class="sxs-lookup"><span data-stu-id="c1488-1049">The index of a format item is less than 0 (zero), or greater than or equal to 3 (three).</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1050">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1050">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-1051">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1051">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-1052">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-1052">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
        <related type="Article" href="/dotnet/standard/base-types/formatting-types"><span data-ttu-id="c1488-1053">设置 .NET 中类型的格式</span><span class="sxs-lookup"><span data-stu-id="c1488-1053">Formatting Types in .NET</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/composite-formatting"><span data-ttu-id="c1488-1054">复合格式设置</span><span class="sxs-lookup"><span data-stu-id="c1488-1054">Composite Formatting</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/how-to-define-and-use-custom-numeric-format-providers"><span data-ttu-id="c1488-1055">如何：定义和使用自定义数值格式提供程序</span><span class="sxs-lookup"><span data-stu-id="c1488-1055">How to: Define and Use Custom Numeric Format Providers</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings"><span data-ttu-id="c1488-1056">标准数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-1056">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings"><span data-ttu-id="c1488-1057">自定义数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-1057">Custom Numeric Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-date-and-time-format-strings"><span data-ttu-id="c1488-1058">标准日期和时间格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-1058">Standard Date and Time Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-date-and-time-format-strings"><span data-ttu-id="c1488-1059">自定义日期和时间格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-1059">Custom Date and Time Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/standard-timespan-format-strings"><span data-ttu-id="c1488-1060">标准 TimeSpan 格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-1060">Standard TimeSpan Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-timespan-format-strings"><span data-ttu-id="c1488-1061">自定义的 TimeSpan 格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-1061">Custom TimeSpan Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/enumeration-format-strings"><span data-ttu-id="c1488-1062">枚举格式字符串</span><span class="sxs-lookup"><span data-stu-id="c1488-1062">Enumeration Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params object[]? values);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params object[] values);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="c1488-1063">要用作分隔符的字符。</span><span class="sxs-lookup"><span data-stu-id="c1488-1063">The character to use as a separator.</span></span> <span data-ttu-id="c1488-1064"><paramref name="separator" /> 包括在联接的字符串中（仅当 <paramref name="values" /> 具有多个元素时）。</span><span class="sxs-lookup"><span data-stu-id="c1488-1064"><paramref name="separator" /> is included in the joined strings only if <paramref name="values" /> has more than one element.</span></span></param>
        <param name="values"><span data-ttu-id="c1488-1065">一个数组，包含要连接和附加到字符串生成器的当前实例的字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-1065">An array that contains the strings to concatenate and append to the current instance of the string builder.</span></span></param>
        <summary><span data-ttu-id="c1488-1066">使用各成员之间指定的字符分隔符连接所提供的对象数组中的元素的字符串表示形式，然后将结果附加到字符串生成器的当前实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-1066">Concatenates the string representations of the elements in the provided array of objects, using the specified char separator between each member, then appends the result to the current instance of the string builder.</span></span></summary>
        <returns><span data-ttu-id="c1488-1067">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1067">A reference to this instance after the append operation has completed.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params string[]? values);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params string[] values);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="values" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="c1488-1068">要用作分隔符的字符。</span><span class="sxs-lookup"><span data-stu-id="c1488-1068">The character to use as a separator.</span></span> <span data-ttu-id="c1488-1069"><paramref name="separator" /> 包括在联接的字符串中（仅当 <paramref name="values" /> 具有多个元素时）。</span><span class="sxs-lookup"><span data-stu-id="c1488-1069"><paramref name="separator" /> is included in the joined strings only if <paramref name="values" /> has more than one element.</span></span></param>
        <param name="values"><span data-ttu-id="c1488-1070">一个数组，包含要连接和附加到字符串生成器的当前实例的字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-1070">An array that contains the strings to concatenate and append to the current instance of the string builder.</span></span></param>
        <summary><span data-ttu-id="c1488-1071">使用各字符串之间指定的字符分隔符连接所提供的数组的字符串，然后将结果附加到字符串生成器的当前实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-1071">Concatenates the strings of the provided array, using the specified char separator between each string, then appends the result to the current instance of the string builder.</span></span></summary>
        <returns><span data-ttu-id="c1488-1072">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1072">A reference to this instance after the append operation has completed.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string? separator, params object[]? values);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params object[] values);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="c1488-1073">要用作分隔符的字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-1073">The string to use as a separator.</span></span> <span data-ttu-id="c1488-1074"><paramref name="separator" /> 包括在联接的字符串中（仅当 <paramref name="values" /> 具有多个元素时）。</span><span class="sxs-lookup"><span data-stu-id="c1488-1074"><paramref name="separator" /> is included in the joined strings only if <paramref name="values" /> has more than one element.</span></span></param>
        <param name="values"><span data-ttu-id="c1488-1075">一个数组，包含要连接和附加到字符串生成器的当前实例的字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-1075">An array that contains the strings to concatenate and append to the current instance of the string builder.</span></span></param>
        <summary><span data-ttu-id="c1488-1076">使用各成员之间指定的分隔符连接所提供的对象数组中的元素的字符串表示形式，然后将结果附加到字符串生成器的当前实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-1076">Concatenates the string representations of the elements in the provided array of objects, using the specified separator between each member, then appends the result to the current instance of the string builder.</span></span></summary>
        <returns><span data-ttu-id="c1488-1077">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1077">A reference to this instance after the append operation has completed.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string? separator, params string[]? values);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params string[] values);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="values" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="c1488-1078">要用作分隔符的字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-1078">The string to use as a separator.</span></span> <span data-ttu-id="c1488-1079"><paramref name="separator" /> 包括在联接的字符串中（仅当 <paramref name="values" /> 具有多个元素时）。</span><span class="sxs-lookup"><span data-stu-id="c1488-1079"><paramref name="separator" /> is included in the joined strings only if <paramref name="values" /> has more than one element.</span></span></param>
        <param name="values"><span data-ttu-id="c1488-1080">一个数组，包含要连接和附加到字符串生成器的当前实例的字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-1080">An array that contains the strings to concatenate and append to the current instance of the string builder.</span></span></param>
        <summary><span data-ttu-id="c1488-1081">使用各字符串之间指定的分隔符连接所提供的数组的字符串，然后将结果附加到字符串生成器的当前实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-1081">Concatenates the strings of the provided array, using the specified separator between each string, then appends the result to the current instance of the string builder.</span></span></summary>
        <returns><span data-ttu-id="c1488-1082">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1082">A reference to this instance after the append operation has completed.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As Char, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="c1488-1083"><paramref name="values" /> 成员的类型。</span><span class="sxs-lookup"><span data-stu-id="c1488-1083">The type of the members of <paramref name="values" />.</span></span></typeparam>
        <param name="separator"><span data-ttu-id="c1488-1084">要用作分隔符的字符。</span><span class="sxs-lookup"><span data-stu-id="c1488-1084">The character to use as a separator.</span></span> <span data-ttu-id="c1488-1085"><paramref name="separator" /> 包括在连接和附加的字符串中（仅当 <paramref name="values" /> 具有多个元素时）。</span><span class="sxs-lookup"><span data-stu-id="c1488-1085"><paramref name="separator" /> is included in the concatenated and appended strings only if <paramref name="values" /> has more than one element.</span></span></param>
        <param name="values"><span data-ttu-id="c1488-1086">一个集合，包含要连接和附加到字符串生成器的当前实例的对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-1086">A collection that contains the objects to concatenate and append to the current instance of the string builder.</span></span></param>
        <summary><span data-ttu-id="c1488-1087">使用各成员之间指定的字符分隔符连接和附加集合的成员。</span><span class="sxs-lookup"><span data-stu-id="c1488-1087">Concatenates and appends the members of a collection, using the specified char separator between each member.</span></span></summary>
        <returns><span data-ttu-id="c1488-1088">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1088">A reference to this instance after the append operation has completed.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (string? separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As String, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="c1488-1089"><paramref name="values" /> 成员的类型。</span><span class="sxs-lookup"><span data-stu-id="c1488-1089">The type of the members of <paramref name="values" />.</span></span></typeparam>
        <param name="separator"><span data-ttu-id="c1488-1090">要用作分隔符的字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-1090">The string to use as a separator.</span></span> <span data-ttu-id="c1488-1091"><paramref name="separator" /> 包括在连接和附加的字符串中（仅当 <paramref name="values" /> 具有多个元素时）。</span><span class="sxs-lookup"><span data-stu-id="c1488-1091"><paramref name="separator" /> is included in the concatenated and appended strings only if <paramref name="values" /> has more than one element.</span></span></param>
        <param name="values"><span data-ttu-id="c1488-1092">一个集合，包含要连接和附加到字符串生成器的当前实例的对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-1092">A collection that contains the objects to concatenate and append to the current instance of the string builder.</span></span></param>
        <summary><span data-ttu-id="c1488-1093">使用各成员之间指定的分隔符连接和附加集合的成员。</span><span class="sxs-lookup"><span data-stu-id="c1488-1093">Concatenates and appends the members of a collection, using the specified separator between each member.</span></span></summary>
        <returns><span data-ttu-id="c1488-1094">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1094">A reference to this instance after the append operation has completed.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendLine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c1488-1095">将默认的行终止符（或指定字符串的副本和默认的行终止符）追加到此实例的末尾。</span><span class="sxs-lookup"><span data-stu-id="c1488-1095">Appends the default line terminator, or a copy of a specified string and the default line terminator, to the end of this instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine();" />
      <MemberSignature Language="F#" Value="member this.AppendLine : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c1488-1096">将默认的行终止符追加到当前 <see cref="T:System.Text.StringBuilder" /> 对象的末尾。</span><span class="sxs-lookup"><span data-stu-id="c1488-1096">Appends the default line terminator to the end of the current <see cref="T:System.Text.StringBuilder" /> object.</span></span></summary>
        <returns><span data-ttu-id="c1488-1097">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1097">A reference to this instance after the append operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1098">默认的行终止符是属性的当前值 <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1098">The default line terminator is the current value of the <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> property.</span></span>

 <span data-ttu-id="c1488-1099">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-1099">The capacity of this instance is adjusted as needed.</span></span>



## Examples
 <span data-ttu-id="c1488-1100">下面的示例演示 <xref:System.Text.StringBuilder.AppendLine%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-1100">The following example demonstrates the <xref:System.Text.StringBuilder.AppendLine%2A> method.</span></span>

 [!code-cpp[stringbuilder.appendline#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendline/CPP/al.cpp#1)]
 [!code-csharp[stringbuilder.appendline#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendline/CS/al.cs#1)]
 [!code-vb[stringbuilder.appendline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendline/VB/al.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1101">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1101">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-1102">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1102">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-1103">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-1103">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine (string value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendLine : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine value" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine (string? value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="c1488-1104">要追加的字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-1104">The string to append.</span></span></param>
        <summary><span data-ttu-id="c1488-1105">将后面跟有默认行终止符的指定字符串的副本追加到当前 <see cref="T:System.Text.StringBuilder" /> 对象的末尾。</span><span class="sxs-lookup"><span data-stu-id="c1488-1105">Appends a copy of the specified string followed by the default line terminator to the end of the current <see cref="T:System.Text.StringBuilder" /> object.</span></span></summary>
        <returns><span data-ttu-id="c1488-1106">完成追加操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1106">A reference to this instance after the append operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1107">默认的行终止符是属性的当前值 <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1107">The default line terminator is the current value of the <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> property.</span></span>

 <span data-ttu-id="c1488-1108">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-1108">The capacity of this instance is adjusted as needed.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1109">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1109">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-1110">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1110">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <see cref="T:System.Text.StringBuilder" /> object by calling the <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, both the length and the capacity of the <see cref="T:System.Text.StringBuilder" /> instance can grow beyond the value of its <see cref="P:System.Text.StringBuilder.MaxCapacity" /> property.</span></span> <span data-ttu-id="c1488-1111">当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-1111">This can occur particularly when you call the <see cref="M:System.Text.StringBuilder.Append(System.String)" /> and <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> methods to append small strings.</span></span></para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Text.StringBuilder.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c1488-1112">获取或设置可包含在当前实例所分配的内存中的最大字符数。</span><span class="sxs-lookup"><span data-stu-id="c1488-1112">Gets or sets the maximum number of characters that can be contained in the memory allocated by the current instance.</span></span></summary>
        <value><span data-ttu-id="c1488-1113">可包含在当前实例所分配的内存中的最大字符数。</span><span class="sxs-lookup"><span data-stu-id="c1488-1113">The maximum number of characters that can be contained in the memory allocated by the current instance.</span></span> <span data-ttu-id="c1488-1114">其值可以从 <see cref="P:System.Text.StringBuilder.Length" /> 到 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1114">Its value can range from <see cref="P:System.Text.StringBuilder.Length" /> to <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1115"><xref:System.Text.StringBuilder.Capacity%2A> 不影响当前实例的字符串值。</span><span class="sxs-lookup"><span data-stu-id="c1488-1115"><xref:System.Text.StringBuilder.Capacity%2A> does not affect the string value of the current instance.</span></span> <span data-ttu-id="c1488-1116"><xref:System.Text.StringBuilder.Capacity%2A> 可以减小，只要它不小于 <xref:System.Text.StringBuilder.Length%2A> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1116"><xref:System.Text.StringBuilder.Capacity%2A> can be decreased as long as it is not less than <xref:System.Text.StringBuilder.Length%2A>.</span></span>

 <span data-ttu-id="c1488-1117"><xref:System.Text.StringBuilder>需要时动态分配更多的空间，并 <xref:System.Text.StringBuilder.Capacity%2A> 相应增加。</span><span class="sxs-lookup"><span data-stu-id="c1488-1117">The <xref:System.Text.StringBuilder> dynamically allocates more space when required and increases <xref:System.Text.StringBuilder.Capacity%2A> accordingly.</span></span> <span data-ttu-id="c1488-1118">出于性能原因， <xref:System.Text.StringBuilder> 可能会分配比所需内存更多的内存。</span><span class="sxs-lookup"><span data-stu-id="c1488-1118">For performance reasons, a <xref:System.Text.StringBuilder> might allocate more memory than needed.</span></span> <span data-ttu-id="c1488-1119">分配的内存量是特定于实现的。</span><span class="sxs-lookup"><span data-stu-id="c1488-1119">The amount of memory allocated is implementation-specific.</span></span>



## Examples
 <span data-ttu-id="c1488-1120">下面的示例演示了 <xref:System.Text.StringBuilder.Capacity%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="c1488-1120">The following example demonstrates the <xref:System.Text.StringBuilder.Capacity%2A> property.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1121">为集运算指定的值小于此实例的当前长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1121">The value specified for a set operation is less than the current length of this instance.</span></span>

 <span data-ttu-id="c1488-1122">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-1122">-or-</span></span>

 <span data-ttu-id="c1488-1123">为集运算指定的值大于最大容量。</span><span class="sxs-lookup"><span data-stu-id="c1488-1123">The value specified for a set operation is greater than the maximum capacity.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); void set(int index, char value); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char with get, set" Usage="System.Text.StringBuilder.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="c1488-1124">字符的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1124">The position of the character.</span></span></param>
        <summary><span data-ttu-id="c1488-1125">获取或设置此实例中指定字符位置处的字符。</span><span class="sxs-lookup"><span data-stu-id="c1488-1125">Gets or sets the character at the specified character position in this instance.</span></span></summary>
        <value><span data-ttu-id="c1488-1126"><paramref name="index" /> 位置处的 Unicode 字符。</span><span class="sxs-lookup"><span data-stu-id="c1488-1126">The Unicode character at position <paramref name="index" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1127">`index`参数是中字符的位置 <xref:System.Text.StringBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1127">The `index` parameter is the position of a character within the <xref:System.Text.StringBuilder>.</span></span> <span data-ttu-id="c1488-1128">字符串中的第一个字符位于索引0处。</span><span class="sxs-lookup"><span data-stu-id="c1488-1128">The first character in the string is at index 0.</span></span> <span data-ttu-id="c1488-1129">字符串的长度是它包含的字符数。</span><span class="sxs-lookup"><span data-stu-id="c1488-1129">The length of a string is the number of characters it contains.</span></span> <span data-ttu-id="c1488-1130">实例的最后一个可访问字符位于 <xref:System.Text.StringBuilder> 索引 <xref:System.Text.StringBuilder.Length%2A> -1 处。</span><span class="sxs-lookup"><span data-stu-id="c1488-1130">The last accessible character of a <xref:System.Text.StringBuilder> instance is at index <xref:System.Text.StringBuilder.Length%2A> - 1.</span></span>

 <span data-ttu-id="c1488-1131"><xref:System.Text.StringBuilder.Chars%2A> 是类的默认属性 <xref:System.Text.StringBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1131"><xref:System.Text.StringBuilder.Chars%2A> is the default property of the <xref:System.Text.StringBuilder> class.</span></span> <span data-ttu-id="c1488-1132">在 c # 中，它是一个索引器。</span><span class="sxs-lookup"><span data-stu-id="c1488-1132">In C#, it is an indexer.</span></span> <span data-ttu-id="c1488-1133">这意味着，可以从属性中检索各个字符 <xref:System.Text.StringBuilder.Chars%2A> ，如下面的示例所示，它对字符串中的字母、空格和标点符号的数目进行计数。</span><span class="sxs-lookup"><span data-stu-id="c1488-1133">This means that individual characters can be retrieved from the <xref:System.Text.StringBuilder.Chars%2A> property as shown in the following example, which counts the number of alphabetic, white-space, and punctuation characters in a string.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.chars/cs/chars1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.chars/vb/chars1.vb" id="Snippet1":::
 
### <a name="performance-and-character-based-indexing"></a><span data-ttu-id="c1488-1134">基于性能和字符的索引</span><span class="sxs-lookup"><span data-stu-id="c1488-1134">Performance and character-based indexing</span></span>

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1135">设置字符时，<paramref name="index" /> 在此实例的范围之外。</span><span class="sxs-lookup"><span data-stu-id="c1488-1135"><paramref name="index" /> is outside the bounds of this instance while setting a character.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="c1488-1136">获取字符时，<paramref name="index" /> 在此实例的范围之外。</span><span class="sxs-lookup"><span data-stu-id="c1488-1136"><paramref name="index" /> is outside the bounds of this instance while getting a character.</span></span></exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Function Clear () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c1488-1137">从当前 <see cref="T:System.Text.StringBuilder" /> 实例中移除所有字符。</span><span class="sxs-lookup"><span data-stu-id="c1488-1137">Removes all characters from the current <see cref="T:System.Text.StringBuilder" /> instance.</span></span></summary>
        <returns><span data-ttu-id="c1488-1138">其 <see cref="P:System.Text.StringBuilder.Length" /> 为 0（零）的对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-1138">An object whose <see cref="P:System.Text.StringBuilder.Length" /> is 0 (zero).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="c1488-1139"><xref:System.Text.StringBuilder.Clear%2A> 是一种便捷方法，相当于将当前实例的<xref:System.Text.StringBuilder.Length%2A>属性设置为0（零）。</span><span class="sxs-lookup"><span data-stu-id="c1488-1139"><xref:System.Text.StringBuilder.Clear%2A> is a convenience method that is equivalent to setting the <xref:System.Text.StringBuilder.Length%2A> property of the current instance to 0 (zero).</span></span>

## Examples

<span data-ttu-id="c1488-1140">以下示例使用字符串实例化<xref:System.Text.StringBuilder>对象，调用<xref:System.Text.StringBuilder.Clear%2A>方法，然后将追加一个新的字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-1140">The following example instantiates a <xref:System.Text.StringBuilder> object with a string, calls the <xref:System.Text.StringBuilder.Clear%2A> method, and then appends a new string.</span></span>

:::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.clear/cs/clear1.cs" interactive="try-dotnet" id="Snippet1":::
:::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.clear/vb/clear1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, valuetype System.Span`1&lt;char&gt; destination, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Span{System.Char},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Span(Of Char), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * Span&lt;char&gt; * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="sourceIndex"><span data-ttu-id="c1488-1141">此实例中开始复制字符的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1141">The starting position in this instance where characters will be copied from.</span></span> <span data-ttu-id="c1488-1142">索引是从零开始的。</span><span class="sxs-lookup"><span data-stu-id="c1488-1142">The index is zero-based.</span></span></param>
        <param name="destination"><span data-ttu-id="c1488-1143">将从中复制字符的可写范围。</span><span class="sxs-lookup"><span data-stu-id="c1488-1143">The writable span where characters will be copied.</span></span></param>
        <param name="count"><span data-ttu-id="c1488-1144">要复制的字符数。</span><span class="sxs-lookup"><span data-stu-id="c1488-1144">The number of characters to be copied.</span></span></param>
        <summary><span data-ttu-id="c1488-1145">将此实例的指定段中的字符复制到目标 <see cref="T:System.Char" /> 范围。</span><span class="sxs-lookup"><span data-stu-id="c1488-1145">Copies the characters from a specified segment of this instance to a destination <see cref="T:System.Char" /> span.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1146"><xref:System.Text.StringBuilder.CopyTo%2A>如果需要将对象的连续部分有效地复制 <xref:System.Text.StringBuilder> 到某一范围，此方法旨在用于极少数情况。</span><span class="sxs-lookup"><span data-stu-id="c1488-1146">The <xref:System.Text.StringBuilder.CopyTo%2A> method is intended to be used in the rare situation when you need to efficiently copy successive sections of a <xref:System.Text.StringBuilder> object to an span.</span></span>

 <span data-ttu-id="c1488-1147">例如，你的应用程序可以 <xref:System.Text.StringBuilder> 使用大量字符来填充对象，然后使用方法将 <xref:System.Text.StringBuilder.CopyTo%2A> 对象的小型连续部分复制 <xref:System.Text.StringBuilder> 到部分处理的跨度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1147">For example, your application could populate a <xref:System.Text.StringBuilder> object with a large number of characters then use the <xref:System.Text.StringBuilder.CopyTo%2A> method to copy small, successive pieces of the <xref:System.Text.StringBuilder> object to an span where the pieces are processed.</span></span> <span data-ttu-id="c1488-1148">在处理对象中的所有数据时 <xref:System.Text.StringBuilder> ，对象的大小 <xref:System.Text.StringBuilder> 设置为零，并重复周期。</span><span class="sxs-lookup"><span data-stu-id="c1488-1148">When all the data in the <xref:System.Text.StringBuilder> object is processed, the size of the <xref:System.Text.StringBuilder> object is set to zero and the cycle is repeated.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destination" Type="System.Char[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceIndex"><span data-ttu-id="c1488-1149">此实例中开始复制字符的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1149">The starting position in this instance where characters will be copied from.</span></span> <span data-ttu-id="c1488-1150">索引是从零开始的。</span><span class="sxs-lookup"><span data-stu-id="c1488-1150">The index is zero-based.</span></span></param>
        <param name="destination"><span data-ttu-id="c1488-1151">将从中复制字符的数组。</span><span class="sxs-lookup"><span data-stu-id="c1488-1151">The array where characters will be copied.</span></span></param>
        <param name="destinationIndex"><span data-ttu-id="c1488-1152"><paramref name="destination" /> 中将从其开始复制字符的起始位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1152">The starting position in <paramref name="destination" /> where characters will be copied.</span></span> <span data-ttu-id="c1488-1153">索引是从零开始的。</span><span class="sxs-lookup"><span data-stu-id="c1488-1153">The index is zero-based.</span></span></param>
        <param name="count"><span data-ttu-id="c1488-1154">要复制的字符数。</span><span class="sxs-lookup"><span data-stu-id="c1488-1154">The number of characters to be copied.</span></span></param>
        <summary><span data-ttu-id="c1488-1155">将此实例的指定段中的字符复制到目标 <see cref="T:System.Char" /> 数组的指定段中。</span><span class="sxs-lookup"><span data-stu-id="c1488-1155">Copies the characters from a specified segment of this instance to a specified segment of a destination <see cref="T:System.Char" /> array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1156"><xref:System.Text.StringBuilder.CopyTo%2A>当你需要将对象的连续部分有效地复制到数组时，此方法旨在用于极少数情况 <xref:System.Text.StringBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1156">The <xref:System.Text.StringBuilder.CopyTo%2A> method is intended to be used in the rare situation when you need to efficiently copy successive sections of a <xref:System.Text.StringBuilder> object to an array.</span></span> <span data-ttu-id="c1488-1157">该数组应为固定大小、预分配、可重用并且可能可全局访问。</span><span class="sxs-lookup"><span data-stu-id="c1488-1157">The array should be a fixed size, preallocated, reusable, and possibly globally accessible.</span></span>

 <span data-ttu-id="c1488-1158">例如，你的应用程序可以 <xref:System.Text.StringBuilder> 使用大量字符来填充对象，然后使用方法将 <xref:System.Text.StringBuilder.CopyTo%2A> 对象的小型连续部分复制 <xref:System.Text.StringBuilder> 到处理这些部分的数组。</span><span class="sxs-lookup"><span data-stu-id="c1488-1158">For example, your application could populate a <xref:System.Text.StringBuilder> object with a large number of characters then use the <xref:System.Text.StringBuilder.CopyTo%2A> method to copy small, successive pieces of the <xref:System.Text.StringBuilder> object to an array where the pieces are processed.</span></span> <span data-ttu-id="c1488-1159">在处理对象中的所有数据时 <xref:System.Text.StringBuilder> ，对象的大小 <xref:System.Text.StringBuilder> 设置为零，并重复周期。</span><span class="sxs-lookup"><span data-stu-id="c1488-1159">When all the data in the <xref:System.Text.StringBuilder> object is processed, the size of the <xref:System.Text.StringBuilder> object is set to zero and the cycle is repeated.</span></span>



## Examples
 <span data-ttu-id="c1488-1160">下面的示例演示 <xref:System.Text.StringBuilder.CopyTo%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-1160">The following example demonstrates the <xref:System.Text.StringBuilder.CopyTo%2A> method.</span></span>

 [!code-cpp[stringbuilder.copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.copyto2/CPP/ct2.cpp#1)]
 [!code-csharp[stringbuilder.copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.copyto2/CS/ct2.cs#1)]
 [!code-vb[stringbuilder.copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.copyto2/VB/ct2.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c1488-1161"><paramref name="destination" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1161"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1162"><paramref name="sourceIndex" />、<paramref name="destinationIndex" /> 或 <paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="c1488-1162"><paramref name="sourceIndex" />, <paramref name="destinationIndex" />, or <paramref name="count" />, is less than zero.</span></span>

<span data-ttu-id="c1488-1163">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-1163">-or-</span></span>

 <span data-ttu-id="c1488-1164"><paramref name="sourceIndex" /> 大于此实例的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1164"><paramref name="sourceIndex" /> is greater than the length of this instance.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c1488-1165"><paramref name="sourceIndex" /> + <paramref name="count" /> 大于此实例的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1165"><paramref name="sourceIndex" /> + <paramref name="count" /> is greater than the length of this instance.</span></span>

<span data-ttu-id="c1488-1166">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-1166">-or-</span></span>

 <span data-ttu-id="c1488-1167"><paramref name="destinationIndex" /> + <paramref name="count" /> 大于 <paramref name="destination" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1167"><paramref name="destinationIndex" /> + <paramref name="count" /> is greater than the length of <paramref name="destination" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberSignature Language="F#" Value="member this.EnsureCapacity : int -&gt; int" Usage="stringBuilder.EnsureCapacity capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity"><span data-ttu-id="c1488-1168">要确保的最小容量。</span><span class="sxs-lookup"><span data-stu-id="c1488-1168">The minimum capacity to ensure.</span></span></param>
        <summary><span data-ttu-id="c1488-1169">确保 <see cref="T:System.Text.StringBuilder" /> 的此实例的容量至少是指定值。</span><span class="sxs-lookup"><span data-stu-id="c1488-1169">Ensures that the capacity of this instance of <see cref="T:System.Text.StringBuilder" /> is at least the specified value.</span></span></summary>
        <returns><span data-ttu-id="c1488-1170">此实例的新容量。</span><span class="sxs-lookup"><span data-stu-id="c1488-1170">The new capacity of this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1171">如果当前容量小于 `capacity` 参数，则将此实例的内存重新分配为至少容纳 `capacity` 数量的字符; 否则，不会更改任何内存。</span><span class="sxs-lookup"><span data-stu-id="c1488-1171">If the current capacity is less than the `capacity` parameter, memory for this instance is reallocated to hold at least `capacity` number of characters; otherwise, no memory is changed.</span></span>



## Examples
 <span data-ttu-id="c1488-1172">下面的示例演示 <xref:System.Text.StringBuilder.EnsureCapacity%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-1172">The following example demonstrates the <xref:System.Text.StringBuilder.EnsureCapacity%2A> method.</span></span>

 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1173"><paramref name="capacity" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="c1488-1173"><paramref name="capacity" /> is less than zero.</span></span>

<span data-ttu-id="c1488-1174">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-1174">-or-</span></span>

<span data-ttu-id="c1488-1175">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1175">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (span As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="override this.Equals : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="stringBuilder.Equals span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="c1488-1176">与当前实例进行比较的字符范围。</span><span class="sxs-lookup"><span data-stu-id="c1488-1176">The character span to compare with the current instance.</span></span></param>
        <summary><span data-ttu-id="c1488-1177">返回一个值，该值指示此实例中的字符是否等于指定的只读字符范围中的字符。</span><span class="sxs-lookup"><span data-stu-id="c1488-1177">Returns a value indicating whether the characters in this instance are equal to the characters in a specified read-only character span.</span></span></summary>
        <returns><span data-ttu-id="c1488-1178">如果此实例中的字符与 <paramref name="span" /> 相同，为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1178"><see langword="true" /> if the characters in this instance and <paramref name="span" /> are the same; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="c1488-1179">`Equals`方法执行序号比较，以确定当前实例中的字符是否 `span` 相等。</span><span class="sxs-lookup"><span data-stu-id="c1488-1179">The `Equals` method performs an ordinal comparison to determine whether the characters in the current instance and `span` are equal.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.StringBuilder sb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Text.StringBuilder sb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (sb As StringBuilder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Text::StringBuilder ^ sb);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Text.StringBuilder -&gt; bool" Usage="stringBuilder.Equals sb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sb" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="sb"><span data-ttu-id="c1488-1180">与此实例进行比较的对象，或为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1180">An object to compare with this instance, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="c1488-1181">返回一个值，该值指示此实例是否等于指定对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-1181">Returns a value indicating whether this instance is equal to a specified object.</span></span></summary>
        <returns><span data-ttu-id="c1488-1182">如果此实例和 <paramref name="sb" /> 具有相等的字符串、<see cref="P:System.Text.StringBuilder.Capacity" /> 和 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 值，则为 <see langword="true" />；否则，为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1182"><see langword="true" /> if this instance and <paramref name="sb" /> have equal string, <see cref="P:System.Text.StringBuilder.Capacity" />, and <see cref="P:System.Text.StringBuilder.MaxCapacity" /> values; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="c1488-1183">**.NET Framework 和 .Net Core 2.2 及更早版本：** 当前实例， `sb` 如果它们具有相等的字符串、和值，则相等 <xref:System.Text.StringBuilder.Capacity> <xref:System.Text.StringBuilder.MaxCapacity> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1183">**.NET Framework and .NET Core 2.2 and previous versions:** The current instance and `sb` are equal if they have equal string, <xref:System.Text.StringBuilder.Capacity>, and <xref:System.Text.StringBuilder.MaxCapacity> values.</span></span> <span data-ttu-id="c1488-1184">`Equals`方法使用序号比较来确定字符串是否相等。</span><span class="sxs-lookup"><span data-stu-id="c1488-1184">The `Equals` method uses ordinal comparison to determine whether the strings are equal.</span></span>

<span data-ttu-id="c1488-1185">**.Net Core 3.0 及更高版本：**`sb`如果分配给这两个对象的字符串相同，则当前实例和相等 <xref:System.Text.StringBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1185">**.NET Core 3.0 and later versions:** The current instance and `sb` are equal if the strings assigned to both <xref:System.Text.StringBuilder> objects are the same.</span></span>  <span data-ttu-id="c1488-1186">若要确定相等性， `Equals` 方法使用序号比较。</span><span class="sxs-lookup"><span data-stu-id="c1488-1186">To determine equality, the `Equals` method uses ordinal comparison.</span></span> <span data-ttu-id="c1488-1187">在 <xref:System.Text.StringBuilder.Capacity> <xref:System.Text.StringBuilder.MaxCapacity> 比较中不使用和属性值。</span><span class="sxs-lookup"><span data-stu-id="c1488-1187">The <xref:System.Text.StringBuilder.Capacity> and <xref:System.Text.StringBuilder.MaxCapacity> property values are not used in the comparison.</span></span>

## Examples
 <span data-ttu-id="c1488-1188">下面的代码使用 <xref:System.Text.StringBuilder.Equals%2A> 方法检查两个对象是否 <xref:System.Text.StringBuilder> 相等。</span><span class="sxs-lookup"><span data-stu-id="c1488-1188">The following code uses the <xref:System.Text.StringBuilder.Equals%2A> method to check whether two <xref:System.Text.StringBuilder> objects are equal.</span></span> <span data-ttu-id="c1488-1189">在对每个对象进行少量更改后，将重复调用方法，并将结果显示到控制台。</span><span class="sxs-lookup"><span data-stu-id="c1488-1189">The method is called repeatedly after small changes are made to each object, and the results are displayed to the console.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChunks">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder.ChunkEnumerator GetChunks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.StringBuilder/ChunkEnumerator GetChunks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.GetChunks" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChunks () As StringBuilder.ChunkEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder::ChunkEnumerator GetChunks();" />
      <MemberSignature Language="F#" Value="member this.GetChunks : unit -&gt; System.Text.StringBuilder.ChunkEnumerator" Usage="stringBuilder.GetChunks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder+ChunkEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c1488-1190">返回一个对象，该对象可用于循环访问从此 <see cref="T:System.Text.StringBuilder" /> 实例创建的 <see langword="ReadOnlyMemory&lt;Char&gt;" /> 中表示的字符区块。</span><span class="sxs-lookup"><span data-stu-id="c1488-1190">Returns an object that can be used to iterate through the chunks of characters represented in a <see langword="ReadOnlyMemory&lt;Char&gt;" /> created from this <see cref="T:System.Text.StringBuilder" /> instance.</span></span></summary>
        <returns><span data-ttu-id="c1488-1191"><see langword="ReadOnlyMemory&lt;Char&gt;" /> 中区块的枚举器。</span><span class="sxs-lookup"><span data-stu-id="c1488-1191">An enumerator for the chunks in the <see langword="ReadOnlyMemory&lt;Char&gt;" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="c1488-1192">可以用如下代码来循环访问内存范围内的块：</span><span class="sxs-lookup"><span data-stu-id="c1488-1192">You can iterate the chunks in the memory range with code like the following:</span></span>

```csharp
foreach (ReadOnlyMemory<char> chunk in sb.GetChunks())
    foreach(char ch in chunk.Span)
        { /* operations on ch */ }
```

<span data-ttu-id="c1488-1193">此方法的目的是有效地提取 *常量*的数据 <xref:System.Text.StringBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1193">The purpose of this method is to efficiently extract the data of a *constant* <xref:System.Text.StringBuilder>.</span></span> <span data-ttu-id="c1488-1194">如果在 <xref:System.Text.StringBuilder> 块区枚举不完整时修改了，则结果是不确定的。</span><span class="sxs-lookup"><span data-stu-id="c1488-1194">If the <xref:System.Text.StringBuilder> is modified while the chunk enumeration is incomplete, the result is undefined.</span></span> <span data-ttu-id="c1488-1195"><xref:System.Text.StringBuilder> 也不是线程安全的，因此在并发线程上对其进行操作是非法的。</span><span class="sxs-lookup"><span data-stu-id="c1488-1195"><xref:System.Text.StringBuilder> is also not thread-safe, so operating on it with concurrent threads is illegal.</span></span>

<span data-ttu-id="c1488-1196"><xref:System.ReadOnlyMemory%601>如果修改了，则返回的块不会保持不变 <xref:System.Text.StringBuilder> ，因此，不会将它们缓存供以后使用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1196">The <xref:System.ReadOnlyMemory%601> chunks returned are not guaranteed to remain unchanged if the <xref:System.Text.StringBuilder> is modified, so do not cache them for later use.</span></span>

<span data-ttu-id="c1488-1197">由于在 <xref:System.ReadOnlySpan%601> 前面的 <xref:System.ReadOnlyMemory%601> 示例中，从 (创建一个 <xref:System.ReadOnlyMemory%601.Span?displayProperty=nameWithType>) 开销很大，因此，如果需要在嵌套语句中使用它，请为该范围创建一个本地变量 `for` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1197">Creating a <xref:System.ReadOnlySpan%601> from a <xref:System.ReadOnlyMemory%601> (as the <xref:System.ReadOnlyMemory%601.Span?displayProperty=nameWithType> method does in the previous example) is expensive, so create a local variable for the span if you need to use it in a nested `for` statement.</span></span> <span data-ttu-id="c1488-1198">例如：</span><span class="sxs-lookup"><span data-stu-id="c1488-1198">For example:</span></span>

```csharp
foreach (ReadOnlyMemory<char> chunk in sb.GetChunks())
{
    var span = chunk.Span;
    for(int i = 0; i < span.Length; i++)
    {
        /* operations on span[i] */
    }
}
```

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Insert">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c1488-1199">将指定对象的字符串表示形式插入到此实例中的指定字符位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1199">Inserts the string representation of a specified object into this instance at a specified character position.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, bool value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="c1488-1200">此实例中开始插入的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1200">The position in this instance where insertion begins.</span></span></param>
        <param name="value"><span data-ttu-id="c1488-1201">要插入的值。</span><span class="sxs-lookup"><span data-stu-id="c1488-1201">The value to insert.</span></span></param>
        <summary><span data-ttu-id="c1488-1202">将布尔值的字符串表示形式插入到此实例中的指定字符位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1202">Inserts the string representation of a Boolean value into this instance at the specified character position.</span></span></summary>
        <returns><span data-ttu-id="c1488-1203">完成插入操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1203">A reference to this instance after the insert operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1204"><xref:System.Boolean.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1204"><xref:System.Boolean.ToString%2A?displayProperty=nameWithType> is used to get a string representation of `value`.</span></span> <span data-ttu-id="c1488-1205">将移动现有字符以便为新文本留出空间。</span><span class="sxs-lookup"><span data-stu-id="c1488-1205">Existing characters are shifted to make room for the new text.</span></span> <span data-ttu-id="c1488-1206">根据需要调整容量。</span><span class="sxs-lookup"><span data-stu-id="c1488-1206">The capacity is adjusted as needed.</span></span>



## Examples
 <span data-ttu-id="c1488-1207">下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-1207">The following example demonstrates the <xref:System.Text.StringBuilder.Insert%2A> method.</span></span>

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1208"><paramref name="index" /> 小于零或大于此实例的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1208"><paramref name="index" /> is less than zero or greater than the length of this instance.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c1488-1209">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1209">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-1210">在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 和早期版本中， <see cref="T:System.ArgumentOutOfRangeException" /> 如果插入 <paramref name="value" /> 会导致对象的总长度超过，则调用此方法将引发 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1210">In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] and earlier versions, calls to this method threw an <see cref="T:System.ArgumentOutOfRangeException" /> if inserting <paramref name="value" /> would cause the object's total length to exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span> <span data-ttu-id="c1488-1211">从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ，方法将引发 <see cref="T:System.OutOfMemoryException" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1211">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the method throws an <see cref="T:System.OutOfMemoryException" />.</span></span></para></block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="c1488-1212">此实例中开始插入的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1212">The position in this instance where insertion begins.</span></span></param>
        <param name="value"><span data-ttu-id="c1488-1213">要插入的值。</span><span class="sxs-lookup"><span data-stu-id="c1488-1213">The value to insert.</span></span></param>
        <summary><span data-ttu-id="c1488-1214">将指定的 8 位无符号整数的字符串表示形式插入到此实例中的指定字符位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1214">Inserts the string representation of a specified 8-bit unsigned integer into this instance at the specified character position.</span></span></summary>
        <returns><span data-ttu-id="c1488-1215">完成插入操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1215">A reference to this instance after the insert operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1216"><xref:System.Byte.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1216"><xref:System.Byte.ToString%2A?displayProperty=nameWithType> is used to get a string representation of `value`.</span></span> <span data-ttu-id="c1488-1217">将移动现有字符以便为新文本留出空间。</span><span class="sxs-lookup"><span data-stu-id="c1488-1217">Existing characters are shifted to make room for the new text.</span></span> <span data-ttu-id="c1488-1218">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-1218">The capacity of this instance is adjusted as needed.</span></span>



## Examples
 <span data-ttu-id="c1488-1219">下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-1219">The following example demonstrates the <xref:System.Text.StringBuilder.Insert%2A> method.</span></span>

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1220"><paramref name="index" /> 小于零或大于此实例的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1220"><paramref name="index" /> is less than zero or greater than the length of this instance.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c1488-1221">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1221">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-1222">在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 和早期版本中， <see cref="T:System.ArgumentOutOfRangeException" /> 如果插入 <paramref name="value" /> 会导致对象的总长度超过，则调用此方法将引发 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1222">In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] and earlier versions, calls to this method threw an <see cref="T:System.ArgumentOutOfRangeException" /> if inserting <paramref name="value" /> would cause the object's total length to exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span> <span data-ttu-id="c1488-1223">从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ，方法将引发 <see cref="T:System.OutOfMemoryException" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1223">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the method throws an <see cref="T:System.OutOfMemoryException" />.</span></span></para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, char value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="c1488-1224">此实例中开始插入的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1224">The position in this instance where insertion begins.</span></span></param>
        <param name="value"><span data-ttu-id="c1488-1225">要插入的值。</span><span class="sxs-lookup"><span data-stu-id="c1488-1225">The value to insert.</span></span></param>
        <summary><span data-ttu-id="c1488-1226">将指定的 Unicode 字符的字符串表示形式插入到此实例中的指定位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1226">Inserts the string representation of a specified Unicode character into this instance at the specified character position.</span></span></summary>
        <returns><span data-ttu-id="c1488-1227">完成插入操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1227">A reference to this instance after the insert operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1228"><xref:System.Char.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1228"><xref:System.Char.ToString%2A?displayProperty=nameWithType> is used to get a string representation of `value`.</span></span> <span data-ttu-id="c1488-1229">将移动现有字符以便为新文本留出空间。</span><span class="sxs-lookup"><span data-stu-id="c1488-1229">Existing characters are shifted to make room for the new text.</span></span> <span data-ttu-id="c1488-1230">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-1230">The capacity of this instance is adjusted as needed.</span></span>



## Examples
 <span data-ttu-id="c1488-1231">下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-1231">The following example demonstrates the <xref:System.Text.StringBuilder.Insert%2A> method.</span></span>

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1232"><paramref name="index" /> 小于零或大于此实例的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1232"><paramref name="index" /> is less than zero or greater than the length of this instance.</span></span>

<span data-ttu-id="c1488-1233">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-1233">-or-</span></span>

<span data-ttu-id="c1488-1234">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1234">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[]? value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="c1488-1235">此实例中开始插入的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1235">The position in this instance where insertion begins.</span></span></param>
        <param name="value"><span data-ttu-id="c1488-1236">要插入的字符数组。</span><span class="sxs-lookup"><span data-stu-id="c1488-1236">The character array to insert.</span></span></param>
        <summary><span data-ttu-id="c1488-1237">将指定的 Unicode 字符数组的字符串表示形式插入到此实例中的指定字符位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1237">Inserts the string representation of a specified array of Unicode characters into this instance at the specified character position.</span></span></summary>
        <returns><span data-ttu-id="c1488-1238">完成插入操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1238">A reference to this instance after the insert operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1239">将移动现有字符以便为新文本留出空间。</span><span class="sxs-lookup"><span data-stu-id="c1488-1239">Existing characters are shifted to make room for the new text.</span></span> <span data-ttu-id="c1488-1240">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-1240">The capacity of this instance is adjusted as needed.</span></span>

 <span data-ttu-id="c1488-1241">如果 `value` 为 `null` ，则 <xref:System.Text.StringBuilder> 不会更改。</span><span class="sxs-lookup"><span data-stu-id="c1488-1241">If `value` is `null`, the <xref:System.Text.StringBuilder> is not changed.</span></span>



## Examples
 <span data-ttu-id="c1488-1242">下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-1242">The following example demonstrates the <xref:System.Text.StringBuilder.Insert%2A> method.</span></span>

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1243"><paramref name="index" /> 小于零或大于此实例的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1243"><paramref name="index" /> is less than zero or greater than the length of this instance.</span></span>

<span data-ttu-id="c1488-1244">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-1244">-or-</span></span>

<span data-ttu-id="c1488-1245">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1245">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="c1488-1246">此实例中开始插入的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1246">The position in this instance where insertion begins.</span></span></param>
        <param name="value"><span data-ttu-id="c1488-1247">要插入的值。</span><span class="sxs-lookup"><span data-stu-id="c1488-1247">The value to insert.</span></span></param>
        <summary><span data-ttu-id="c1488-1248">将十进制数的字符串表示形式插入到此实例中的指定字符位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1248">Inserts the string representation of a decimal number into this instance at the specified character position.</span></span></summary>
        <returns><span data-ttu-id="c1488-1249">完成插入操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1249">A reference to this instance after the insert operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1250"><xref:System.Decimal.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1250"><xref:System.Decimal.ToString%2A?displayProperty=nameWithType> is used to get a string representation of `value`.</span></span> <span data-ttu-id="c1488-1251">将移动现有字符以便为新文本留出空间。</span><span class="sxs-lookup"><span data-stu-id="c1488-1251">Existing characters are shifted to make room for the new text.</span></span> <span data-ttu-id="c1488-1252">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-1252">The capacity of this instance is adjusted as needed.</span></span>



## Examples
 <span data-ttu-id="c1488-1253">下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-1253">The following example demonstrates the <xref:System.Text.StringBuilder.Insert%2A> method.</span></span>

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1254"><paramref name="index" /> 小于零或大于此实例的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1254"><paramref name="index" /> is less than zero or greater than the length of this instance.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c1488-1255">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1255">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-1256">在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 和早期版本中， <see cref="T:System.ArgumentOutOfRangeException" /> 如果插入 <paramref name="value" /> 会导致对象的总长度超过，则调用此方法将引发 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1256">In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] and earlier versions, calls to this method threw an <see cref="T:System.ArgumentOutOfRangeException" /> if inserting <paramref name="value" /> would cause the object's total length to exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span> <span data-ttu-id="c1488-1257">从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ，方法将引发 <see cref="T:System.OutOfMemoryException" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1257">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the method throws an <see cref="T:System.OutOfMemoryException" />.</span></span></para></block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, double value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="c1488-1258">此实例中开始插入的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1258">The position in this instance where insertion begins.</span></span></param>
        <param name="value"><span data-ttu-id="c1488-1259">要插入的值。</span><span class="sxs-lookup"><span data-stu-id="c1488-1259">The value to insert.</span></span></param>
        <summary><span data-ttu-id="c1488-1260">将双精度浮点数的字符串表示形式插入到此实例中的指定字符位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1260">Inserts the string representation of a double-precision floating-point number into this instance at the specified character position.</span></span></summary>
        <returns><span data-ttu-id="c1488-1261">完成插入操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1261">A reference to this instance after the insert operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1262"><xref:System.Double.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1262"><xref:System.Double.ToString%2A?displayProperty=nameWithType> is used to get a string representation of `value`.</span></span> <span data-ttu-id="c1488-1263">将移动现有字符以便为新文本留出空间。</span><span class="sxs-lookup"><span data-stu-id="c1488-1263">Existing characters are shifted to make room for the new text.</span></span> <span data-ttu-id="c1488-1264">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-1264">The capacity of this instance is adjusted as needed.</span></span>



## Examples
 <span data-ttu-id="c1488-1265">下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-1265">The following example demonstrates the <xref:System.Text.StringBuilder.Insert%2A> method.</span></span>

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1266"><paramref name="index" /> 小于零或大于此实例的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1266"><paramref name="index" /> is less than zero or greater than the length of this instance.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c1488-1267">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1267">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-1268">在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 和早期版本中， <see cref="T:System.ArgumentOutOfRangeException" /> 如果插入 <paramref name="value" /> 会导致对象的总长度超过，则调用此方法将引发 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1268">In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] and earlier versions, calls to this method threw an <see cref="T:System.ArgumentOutOfRangeException" /> if inserting <paramref name="value" /> would cause the object's total length to exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span> <span data-ttu-id="c1488-1269">从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ，方法将引发 <see cref="T:System.OutOfMemoryException" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1269">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the method throws an <see cref="T:System.OutOfMemoryException" />.</span></span></para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, short value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="c1488-1270">此实例中开始插入的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1270">The position in this instance where insertion begins.</span></span></param>
        <param name="value"><span data-ttu-id="c1488-1271">要插入的值。</span><span class="sxs-lookup"><span data-stu-id="c1488-1271">The value to insert.</span></span></param>
        <summary><span data-ttu-id="c1488-1272">将指定的 16 位带符号整数的字符串表示形式插入到此实例中的指定字符位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1272">Inserts the string representation of a specified 16-bit signed integer into this instance at the specified character position.</span></span></summary>
        <returns><span data-ttu-id="c1488-1273">完成插入操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1273">A reference to this instance after the insert operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1274"><xref:System.Int16.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1274"><xref:System.Int16.ToString%2A?displayProperty=nameWithType> is used to get a string representation of `value`.</span></span> <span data-ttu-id="c1488-1275">将移动现有字符以便为新文本留出空间。</span><span class="sxs-lookup"><span data-stu-id="c1488-1275">Existing characters are shifted to make room for the new text.</span></span> <span data-ttu-id="c1488-1276">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-1276">The capacity of this instance is adjusted as needed.</span></span>



## Examples
 <span data-ttu-id="c1488-1277">下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-1277">The following example demonstrates the <xref:System.Text.StringBuilder.Insert%2A> method.</span></span>

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1278"><paramref name="index" /> 小于零或大于此实例的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1278"><paramref name="index" /> is less than zero or greater than the length of this instance.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c1488-1279">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1279">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-1280">在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 和早期版本中， <see cref="T:System.ArgumentOutOfRangeException" /> 如果插入 <paramref name="value" /> 会导致对象的总长度超过，则调用此方法将引发 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1280">In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] and earlier versions, calls to this method threw an <see cref="T:System.ArgumentOutOfRangeException" /> if inserting <paramref name="value" /> would cause the object's total length to exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span> <span data-ttu-id="c1488-1281">从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ，方法将引发 <see cref="T:System.OutOfMemoryException" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1281">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the method throws an <see cref="T:System.OutOfMemoryException" />.</span></span></para></block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, int value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="c1488-1282">此实例中开始插入的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1282">The position in this instance where insertion begins.</span></span></param>
        <param name="value"><span data-ttu-id="c1488-1283">要插入的值。</span><span class="sxs-lookup"><span data-stu-id="c1488-1283">The value to insert.</span></span></param>
        <summary><span data-ttu-id="c1488-1284">将指定的 32 位带符号整数的字符串表示形式插入到此实例中的指定字符位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1284">Inserts the string representation of a specified 32-bit signed integer into this instance at the specified character position.</span></span></summary>
        <returns><span data-ttu-id="c1488-1285">完成插入操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1285">A reference to this instance after the insert operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1286"><xref:System.Int32.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1286"><xref:System.Int32.ToString%2A?displayProperty=nameWithType> is used to get a string representation of `value`.</span></span> <span data-ttu-id="c1488-1287">将移动现有字符以便为新文本留出空间。</span><span class="sxs-lookup"><span data-stu-id="c1488-1287">Existing characters are shifted to make room for the new text.</span></span> <span data-ttu-id="c1488-1288">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-1288">The capacity of this instance is adjusted as needed.</span></span>



## Examples
 <span data-ttu-id="c1488-1289">下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-1289">The following example demonstrates the <xref:System.Text.StringBuilder.Insert%2A> method.</span></span>

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1290"><paramref name="index" /> 小于零或大于此实例的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1290"><paramref name="index" /> is less than zero or greater than the length of this instance.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c1488-1291">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1291">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-1292">在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 和早期版本中， <see cref="T:System.ArgumentOutOfRangeException" /> 如果插入 <paramref name="value" /> 会导致对象的总长度超过，则调用此方法将引发 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1292">In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] and earlier versions, calls to this method threw an <see cref="T:System.ArgumentOutOfRangeException" /> if inserting <paramref name="value" /> would cause the object's total length to exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span> <span data-ttu-id="c1488-1293">从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ，方法将引发 <see cref="T:System.OutOfMemoryException" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1293">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the method throws an <see cref="T:System.OutOfMemoryException" />.</span></span></para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, long value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="c1488-1294">此实例中开始插入的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1294">The position in this instance where insertion begins.</span></span></param>
        <param name="value"><span data-ttu-id="c1488-1295">要插入的值。</span><span class="sxs-lookup"><span data-stu-id="c1488-1295">The value to insert.</span></span></param>
        <summary><span data-ttu-id="c1488-1296">将 64 位带符号整数的字符串表示形式插入到此实例中的指定字符位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1296">Inserts the string representation of a 64-bit signed integer into this instance at the specified character position.</span></span></summary>
        <returns><span data-ttu-id="c1488-1297">完成插入操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1297">A reference to this instance after the insert operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1298"><xref:System.Int64.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1298"><xref:System.Int64.ToString%2A?displayProperty=nameWithType> is used to get a string representation of `value`.</span></span> <span data-ttu-id="c1488-1299">将移动现有字符以便为新文本留出空间。</span><span class="sxs-lookup"><span data-stu-id="c1488-1299">Existing characters are shifted to make room for the new text.</span></span> <span data-ttu-id="c1488-1300">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-1300">The capacity of this instance is adjusted as needed.</span></span>



## Examples
 <span data-ttu-id="c1488-1301">下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-1301">The following example demonstrates the <xref:System.Text.StringBuilder.Insert%2A> method.</span></span>

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1302"><paramref name="index" /> 小于零或大于此实例的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1302"><paramref name="index" /> is less than zero or greater than the length of this instance.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c1488-1303">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1303">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-1304">在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 和早期版本中， <see cref="T:System.ArgumentOutOfRangeException" /> 如果插入 <paramref name="value" /> 会导致对象的总长度超过，则调用此方法将引发 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1304">In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] and earlier versions, calls to this method threw an <see cref="T:System.ArgumentOutOfRangeException" /> if inserting <paramref name="value" /> would cause the object's total length to exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span> <span data-ttu-id="c1488-1305">从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ，方法将引发 <see cref="T:System.OutOfMemoryException" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1305">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the method throws an <see cref="T:System.OutOfMemoryException" />.</span></span></para></block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, object value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, object? value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="c1488-1306">此实例中开始插入的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1306">The position in this instance where insertion begins.</span></span></param>
        <param name="value"><span data-ttu-id="c1488-1307">要插入的对象，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1307">The object to insert, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="c1488-1308">将对象的字符串表示形式插入到此实例中的指定字符位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1308">Inserts the string representation of an object into this instance at the specified character position.</span></span></summary>
        <returns><span data-ttu-id="c1488-1309">完成插入操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1309">A reference to this instance after the insert operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1310"><xref:System.Object.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1310"><xref:System.Object.ToString%2A?displayProperty=nameWithType> is used to get a string representation of `value`.</span></span> <span data-ttu-id="c1488-1311">将移动现有字符以便为新文本留出空间。</span><span class="sxs-lookup"><span data-stu-id="c1488-1311">Existing characters are shifted to make room for the new text.</span></span> <span data-ttu-id="c1488-1312">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-1312">The capacity of this instance is adjusted as needed.</span></span>

 <span data-ttu-id="c1488-1313">如果 `value` 为 `null` ，则此实例的值将保持不变。</span><span class="sxs-lookup"><span data-stu-id="c1488-1313">If `value` is `null`, the value of this instance is unchanged.</span></span>



## Examples
 <span data-ttu-id="c1488-1314">下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-1314">The following example demonstrates the <xref:System.Text.StringBuilder.Insert%2A> method.</span></span>

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1315"><paramref name="index" /> 小于零或大于此实例的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1315"><paramref name="index" /> is less than zero or greater than the length of this instance.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c1488-1316">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1316">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-1317">在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 和早期版本中， <see cref="T:System.ArgumentOutOfRangeException" /> 如果插入 <paramref name="value" /> 会导致对象的总长度超过，则调用此方法将引发 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1317">In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] and earlier versions, calls to this method threw an <see cref="T:System.ArgumentOutOfRangeException" /> if inserting <paramref name="value" /> would cause the object's total length to exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span> <span data-ttu-id="c1488-1318">从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ，方法将引发 <see cref="T:System.OutOfMemoryException" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1318">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the method throws an <see cref="T:System.OutOfMemoryException" />.</span></span></para></block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder? Insert (int index, ReadOnlySpan&lt;char&gt; value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ReadOnlySpan&lt;char&gt; value);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="c1488-1319">此实例中开始插入的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1319">The position in this instance where insertion begins.</span></span></param>
        <param name="value"><span data-ttu-id="c1488-1320">要插入的字符范围。</span><span class="sxs-lookup"><span data-stu-id="c1488-1320">The character span to insert.</span></span></param>
        <summary><span data-ttu-id="c1488-1321">将字符序列插入到此实例中的指定字符位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1321">Inserts the sequence of characters into this instance at the specified character position.</span></span></summary>
        <returns><span data-ttu-id="c1488-1322">完成插入操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1322">A reference to this instance after the insert operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="c1488-1323">在中，将移动现有字符，以便为中的字符序列 `value` 插入空间。</span><span class="sxs-lookup"><span data-stu-id="c1488-1323">The existing characters are shifted to make room for the character sequence in the `value` to insert it.</span></span> <span data-ttu-id="c1488-1324">根据需要调整容量。</span><span class="sxs-lookup"><span data-stu-id="c1488-1324">The capacity is adjusted as needed.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="c1488-1325">此实例中开始插入的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1325">The position in this instance where insertion begins.</span></span></param>
        <param name="value"><span data-ttu-id="c1488-1326">要插入的值。</span><span class="sxs-lookup"><span data-stu-id="c1488-1326">The value to insert.</span></span></param>
        <summary><span data-ttu-id="c1488-1327">将指定的 8 位带符号整数的字符串表示形式插入到此实例中的指定字符位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1327">Inserts the string representation of a specified 8-bit signed integer into this instance at the specified character position.</span></span></summary>
        <returns><span data-ttu-id="c1488-1328">完成插入操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1328">A reference to this instance after the insert operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1329"><xref:System.SByte.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1329"><xref:System.SByte.ToString%2A?displayProperty=nameWithType> is used to get a string representation of `value`.</span></span> <span data-ttu-id="c1488-1330">将移动现有字符以便为新文本留出空间。</span><span class="sxs-lookup"><span data-stu-id="c1488-1330">Existing characters are shifted to make room for the new text.</span></span> <span data-ttu-id="c1488-1331">根据需要调整容量。</span><span class="sxs-lookup"><span data-stu-id="c1488-1331">The capacity is adjusted as needed.</span></span>



## Examples
 <span data-ttu-id="c1488-1332">下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-1332">The following example demonstrates the <xref:System.Text.StringBuilder.Insert%2A> method.</span></span>

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1333"><paramref name="index" /> 小于零或大于此实例的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1333"><paramref name="index" /> is less than zero or greater than the length of this instance.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c1488-1334">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1334">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-1335">在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 和早期版本中， <see cref="T:System.ArgumentOutOfRangeException" /> 如果插入 <paramref name="value" /> 会导致对象的总长度超过，则调用此方法将引发 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1335">In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] and earlier versions, calls to this method threw an <see cref="T:System.ArgumentOutOfRangeException" /> if inserting <paramref name="value" /> would cause the object's total length to exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span> <span data-ttu-id="c1488-1336">从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ，方法将引发 <see cref="T:System.OutOfMemoryException" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1336">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the method throws an <see cref="T:System.OutOfMemoryException" />.</span></span></para></block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, float value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="c1488-1337">此实例中开始插入的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1337">The position in this instance where insertion begins.</span></span></param>
        <param name="value"><span data-ttu-id="c1488-1338">要插入的值。</span><span class="sxs-lookup"><span data-stu-id="c1488-1338">The value to insert.</span></span></param>
        <summary><span data-ttu-id="c1488-1339">将单精度浮点数的字符串表示形式插入到此实例中的指定字符位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1339">Inserts the string representation of a single-precision floating point number into this instance at the specified character position.</span></span></summary>
        <returns><span data-ttu-id="c1488-1340">完成插入操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1340">A reference to this instance after the insert operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1341"><xref:System.Single.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1341"><xref:System.Single.ToString%2A?displayProperty=nameWithType> is used to get a string representation of `value`.</span></span> <span data-ttu-id="c1488-1342">将移动现有字符以便为新文本留出空间。</span><span class="sxs-lookup"><span data-stu-id="c1488-1342">Existing characters are shifted to make room for the new text.</span></span> <span data-ttu-id="c1488-1343">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-1343">The capacity of this instance is adjusted as needed.</span></span>



## Examples
 <span data-ttu-id="c1488-1344">下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-1344">The following example demonstrates the <xref:System.Text.StringBuilder.Insert%2A> method.</span></span>

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1345"><paramref name="index" /> 小于零或大于此实例的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1345"><paramref name="index" /> is less than zero or greater than the length of this instance.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c1488-1346">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1346">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-1347">在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 和早期版本中， <see cref="T:System.ArgumentOutOfRangeException" /> 如果插入 <paramref name="value" /> 会导致对象的总长度超过，则调用此方法将引发 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1347">In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] and earlier versions, calls to this method threw an <see cref="T:System.ArgumentOutOfRangeException" /> if inserting <paramref name="value" /> would cause the object's total length to exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span> <span data-ttu-id="c1488-1348">从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ，方法将引发 <see cref="T:System.OutOfMemoryException" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1348">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the method throws an <see cref="T:System.OutOfMemoryException" />.</span></span></para></block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string? value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="c1488-1349">此实例中开始插入的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1349">The position in this instance where insertion begins.</span></span></param>
        <param name="value"><span data-ttu-id="c1488-1350">要插入的字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-1350">The string to insert.</span></span></param>
        <summary><span data-ttu-id="c1488-1351">将字符串插入到此实例中的指定字符位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1351">Inserts a string into this instance at the specified character position.</span></span></summary>
        <returns><span data-ttu-id="c1488-1352">完成插入操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1352">A reference to this instance after the insert operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1353">将移动现有字符以便为新文本留出空间。</span><span class="sxs-lookup"><span data-stu-id="c1488-1353">Existing characters are shifted to make room for the new text.</span></span> <span data-ttu-id="c1488-1354">根据需要调整容量。</span><span class="sxs-lookup"><span data-stu-id="c1488-1354">The capacity is adjusted as needed.</span></span>

 <span data-ttu-id="c1488-1355"><xref:System.Text.StringBuilder>如果 `value` 为 `null` ，或者 `value` 不是 `null` 但其长度为零，则不会更改的此实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-1355">This instance of <xref:System.Text.StringBuilder> is not changed if `value` is `null`, or `value` is not `null` but its length is zero.</span></span>



## Examples
 <span data-ttu-id="c1488-1356">下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-1356">The following example demonstrates the <xref:System.Text.StringBuilder.Insert%2A> method.</span></span>

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1357"><paramref name="index" /> 小于零或大于此实例的当前长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1357"><paramref name="index" /> is less than zero or greater than the current length of this instance.</span></span>

<span data-ttu-id="c1488-1358">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-1358">-or-</span></span>

<span data-ttu-id="c1488-1359">此 <see cref="T:System.Text.StringBuilder" /> 对象的当前长度加上 <paramref name="value" /> 的长度超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1359">The current length of this <see cref="T:System.Text.StringBuilder" /> object plus the length of <paramref name="value" /> exceeds <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="c1488-1360">此实例中开始插入的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1360">The position in this instance where insertion begins.</span></span></param>
        <param name="value"><span data-ttu-id="c1488-1361">要插入的值。</span><span class="sxs-lookup"><span data-stu-id="c1488-1361">The value to insert.</span></span></param>
        <summary><span data-ttu-id="c1488-1362">将 16 位无符号整数的字符串表示形式插入到此实例中的指定字符位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1362">Inserts the string representation of a 16-bit unsigned integer into this instance at the specified character position.</span></span></summary>
        <returns><span data-ttu-id="c1488-1363">完成插入操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1363">A reference to this instance after the insert operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1364"><xref:System.UInt16.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1364"><xref:System.UInt16.ToString%2A?displayProperty=nameWithType> is used to get a string representation of `value`.</span></span> <span data-ttu-id="c1488-1365">将移动现有字符以便为新文本留出空间。</span><span class="sxs-lookup"><span data-stu-id="c1488-1365">Existing characters are shifted to make room for the new text.</span></span> <span data-ttu-id="c1488-1366">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-1366">The capacity of this instance is adjusted as needed.</span></span>



## Examples
 <span data-ttu-id="c1488-1367">下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-1367">The following example demonstrates the <xref:System.Text.StringBuilder.Insert%2A> method.</span></span>

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1368"><paramref name="index" /> 小于零或大于此实例的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1368"><paramref name="index" /> is less than zero or greater than the length of this instance.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c1488-1369">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1369">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-1370">在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 和早期版本中， <see cref="T:System.ArgumentOutOfRangeException" /> 如果插入 <paramref name="value" /> 会导致对象的总长度超过，则调用此方法将引发 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1370">In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] and earlier versions, calls to this method threw an <see cref="T:System.ArgumentOutOfRangeException" /> if inserting <paramref name="value" /> would cause the object's total length to exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span> <span data-ttu-id="c1488-1371">从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ，方法将引发 <see cref="T:System.OutOfMemoryException" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1371">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the method throws an <see cref="T:System.OutOfMemoryException" />.</span></span></para></block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="c1488-1372">此实例中开始插入的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1372">The position in this instance where insertion begins.</span></span></param>
        <param name="value"><span data-ttu-id="c1488-1373">要插入的值。</span><span class="sxs-lookup"><span data-stu-id="c1488-1373">The value to insert.</span></span></param>
        <summary><span data-ttu-id="c1488-1374">将 32 位无符号整数的字符串表示形式插入到此实例中的指定字符位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1374">Inserts the string representation of a 32-bit unsigned integer into this instance at the specified character position.</span></span></summary>
        <returns><span data-ttu-id="c1488-1375">完成插入操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1375">A reference to this instance after the insert operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1376"><xref:System.UInt32.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1376"><xref:System.UInt32.ToString%2A?displayProperty=nameWithType> is used to get a string representation of `value`.</span></span> <span data-ttu-id="c1488-1377">将移动现有字符以便为新文本留出空间。</span><span class="sxs-lookup"><span data-stu-id="c1488-1377">Existing characters are shifted to make room for the new text.</span></span> <span data-ttu-id="c1488-1378">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-1378">The capacity of this instance is adjusted as needed.</span></span>



## Examples
 <span data-ttu-id="c1488-1379">下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-1379">The following example demonstrates the <xref:System.Text.StringBuilder.Insert%2A> method.</span></span>

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1380"><paramref name="index" /> 小于零或大于此实例的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1380"><paramref name="index" /> is less than zero or greater than the length of this instance.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c1488-1381">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1381">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-1382">在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 和早期版本中， <see cref="T:System.ArgumentOutOfRangeException" /> 如果插入 <paramref name="value" /> 会导致对象的总长度超过，则调用此方法将引发 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1382">In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] and earlier versions, calls to this method threw an <see cref="T:System.ArgumentOutOfRangeException" /> if inserting <paramref name="value" /> would cause the object's total length to exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span> <span data-ttu-id="c1488-1383">从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ，方法将引发 <see cref="T:System.OutOfMemoryException" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1383">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the method throws an <see cref="T:System.OutOfMemoryException" />.</span></span></para></block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="c1488-1384">此实例中开始插入的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1384">The position in this instance where insertion begins.</span></span></param>
        <param name="value"><span data-ttu-id="c1488-1385">要插入的值。</span><span class="sxs-lookup"><span data-stu-id="c1488-1385">The value to insert.</span></span></param>
        <summary><span data-ttu-id="c1488-1386">将 64 位无符号整数的字符串表示形式插入到此实例中的指定字符位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1386">Inserts the string representation of a 64-bit unsigned integer into this instance at the specified character position.</span></span></summary>
        <returns><span data-ttu-id="c1488-1387">完成插入操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1387">A reference to this instance after the insert operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1388"><xref:System.UInt64.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式 `value` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1388"><xref:System.UInt64.ToString%2A?displayProperty=nameWithType> is used to get a string representation of `value`.</span></span> <span data-ttu-id="c1488-1389">将移动现有字符以便为新文本留出空间。</span><span class="sxs-lookup"><span data-stu-id="c1488-1389">Existing characters are shifted to make room for the new text.</span></span> <span data-ttu-id="c1488-1390">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-1390">The capacity of this instance is adjusted as needed.</span></span>



## Examples
 <span data-ttu-id="c1488-1391">下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-1391">The following example demonstrates the <xref:System.Text.StringBuilder.Insert%2A> method.</span></span>

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1392"><paramref name="index" /> 小于零或大于此实例的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1392"><paramref name="index" /> is less than zero or greater than the length of this instance.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c1488-1393">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1393">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="c1488-1394">在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 和早期版本中， <see cref="T:System.ArgumentOutOfRangeException" /> 如果插入 <paramref name="value" /> 会导致对象的总长度超过，则调用此方法将引发 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1394">In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] and earlier versions, calls to this method threw an <see cref="T:System.ArgumentOutOfRangeException" /> if inserting <paramref name="value" /> would cause the object's total length to exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span> <span data-ttu-id="c1488-1395">从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ，方法将引发 <see cref="T:System.OutOfMemoryException" /> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1395">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the method throws an <see cref="T:System.OutOfMemoryException" />.</span></span></para></block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value, int count);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value, int count);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, count)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string? value, int count);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="c1488-1396">此实例中开始插入的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1396">The position in this instance where insertion begins.</span></span></param>
        <param name="value"><span data-ttu-id="c1488-1397">要插入的字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-1397">The string to insert.</span></span></param>
        <param name="count"><span data-ttu-id="c1488-1398">要插入 <paramref name="value" /> 的次数。</span><span class="sxs-lookup"><span data-stu-id="c1488-1398">The number of times to insert <paramref name="value" />.</span></span></param>
        <summary><span data-ttu-id="c1488-1399">将指定字符串的一个或更多副本插入到此实例中的指定字符位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1399">Inserts one or more copies of a specified string into this instance at the specified character position.</span></span></summary>
        <returns><span data-ttu-id="c1488-1400">完成插入后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1400">A reference to this instance after insertion has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1401">将移动现有字符以便为新文本留出空间。</span><span class="sxs-lookup"><span data-stu-id="c1488-1401">Existing characters are shifted to make room for the new text.</span></span> <span data-ttu-id="c1488-1402">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-1402">The capacity of this instance is adjusted as needed.</span></span>

 <span data-ttu-id="c1488-1403"><xref:System.Text.StringBuilder>如果为，则不会更改此对象，但该对象的 `value` `null` `value` `null` 长度为零，或者 `count` 为零。</span><span class="sxs-lookup"><span data-stu-id="c1488-1403">This <xref:System.Text.StringBuilder> object is not changed if `value` is `null`, `value` is not `null` but its length is zero, or `count` is zero.</span></span>



## Examples
 <span data-ttu-id="c1488-1404">下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-1404">The following example demonstrates the <xref:System.Text.StringBuilder.Insert%2A> method.</span></span>

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1405"><paramref name="index" /> 小于零或大于此实例的当前长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1405"><paramref name="index" /> is less than zero or greater than the current length of this instance.</span></span>

<span data-ttu-id="c1488-1406">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-1406">-or-</span></span>

 <span data-ttu-id="c1488-1407"><paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="c1488-1407"><paramref name="count" /> is less than zero.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c1488-1408">此 <see cref="T:System.Text.StringBuilder" /> 对象的当前长度加上 <paramref name="value" /> 的长度乘以 <paramref name="count" />，超过了 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1408">The current length of this <see cref="T:System.Text.StringBuilder" /> object plus the length of <paramref name="value" /> times <paramref name="count" /> exceeds <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value, int startIndex, int charCount);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, startIndex, charCount)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[]? value, int startIndex, int charCount);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="c1488-1409">此实例中开始插入的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1409">The position in this instance where insertion begins.</span></span></param>
        <param name="value"><span data-ttu-id="c1488-1410">字符数组。</span><span class="sxs-lookup"><span data-stu-id="c1488-1410">A character array.</span></span></param>
        <param name="startIndex"><span data-ttu-id="c1488-1411"><paramref name="value" /> 内的起始索引。</span><span class="sxs-lookup"><span data-stu-id="c1488-1411">The starting index within <paramref name="value" />.</span></span></param>
        <param name="charCount"><span data-ttu-id="c1488-1412">要插入的字符数。</span><span class="sxs-lookup"><span data-stu-id="c1488-1412">The number of characters to insert.</span></span></param>
        <summary><span data-ttu-id="c1488-1413">将指定的 Unicode 字符子数组的字符串表示形式插入到此实例中的指定字符位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1413">Inserts the string representation of a specified subarray of Unicode characters into this instance at the specified character position.</span></span></summary>
        <returns><span data-ttu-id="c1488-1414">完成插入操作后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1414">A reference to this instance after the insert operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1415">将移动现有字符以便为新文本留出空间。</span><span class="sxs-lookup"><span data-stu-id="c1488-1415">Existing characters are shifted to make room for the new text.</span></span> <span data-ttu-id="c1488-1416">此实例的容量会根据需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="c1488-1416">The capacity of this instance is adjusted as needed.</span></span>



## Examples
 <span data-ttu-id="c1488-1417">下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-1417">The following example demonstrates the <xref:System.Text.StringBuilder.Insert%2A> method.</span></span>

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c1488-1418"><paramref name="value" /> 为 <see langword="null" />，且 <paramref name="startIndex" /> 和 <paramref name="charCount" /> 不为零。</span><span class="sxs-lookup"><span data-stu-id="c1488-1418"><paramref name="value" /> is <see langword="null" />, and <paramref name="startIndex" /> and <paramref name="charCount" /> are not zero.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1419"><paramref name="index" />、<paramref name="startIndex" /> 或 <paramref name="charCount" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="c1488-1419"><paramref name="index" />, <paramref name="startIndex" />, or <paramref name="charCount" /> is less than zero.</span></span>

<span data-ttu-id="c1488-1420">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-1420">-or-</span></span>

 <span data-ttu-id="c1488-1421"><paramref name="index" /> 大于此实例的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1421"><paramref name="index" /> is greater than the length of this instance.</span></span>

<span data-ttu-id="c1488-1422">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-1422">-or-</span></span>

 <span data-ttu-id="c1488-1423"><paramref name="startIndex" /> 加 <paramref name="charCount" /> 不是 <paramref name="value" /> 中的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1423"><paramref name="startIndex" /> plus <paramref name="charCount" /> is not a position within <paramref name="value" />.</span></span>

<span data-ttu-id="c1488-1424">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-1424">-or-</span></span>

<span data-ttu-id="c1488-1425">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1425">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Length" />
      <MemberSignature Language="VB.NET" Value="Public Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Length : int with get, set" Usage="System.Text.StringBuilder.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c1488-1426">获取或设置当前 <see cref="T:System.Text.StringBuilder" /> 对象的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1426">Gets or sets the length of the current <see cref="T:System.Text.StringBuilder" /> object.</span></span></summary>
        <value><span data-ttu-id="c1488-1427">此实例的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1427">The length of this instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1428">对象的长度 <xref:System.Text.StringBuilder> 由其对象数定义 <xref:System.Char> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1428">The length of a <xref:System.Text.StringBuilder> object is defined by its number of <xref:System.Char> objects.</span></span>

 <span data-ttu-id="c1488-1429">与 <xref:System.String.Length%2A?displayProperty=nameWithType> 属性一样， <xref:System.Text.StringBuilder.Length%2A> 属性指示当前字符串对象的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1429">Like the <xref:System.String.Length%2A?displayProperty=nameWithType> property, the <xref:System.Text.StringBuilder.Length%2A> property indicates the length of the current string object.</span></span> <span data-ttu-id="c1488-1430">与 <xref:System.String.Length%2A?displayProperty=nameWithType> 属性不同，属性是只读的，它 <xref:System.Text.StringBuilder.Length%2A> 允许您修改存储在对象中的字符串的长度 <xref:System.Text.StringBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1430">Unlike the <xref:System.String.Length%2A?displayProperty=nameWithType> property, which is read-only, the <xref:System.Text.StringBuilder.Length%2A> property allows you to modify the length of the string stored to the <xref:System.Text.StringBuilder> object.</span></span>

 <span data-ttu-id="c1488-1431">如果指定的长度小于当前长度，则当前 <xref:System.Text.StringBuilder> 对象将被截断为指定长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1431">If the specified length is less than the current length, the current <xref:System.Text.StringBuilder> object is truncated to the specified length.</span></span> <span data-ttu-id="c1488-1432">如果指定的长度大于当前长度，则当前对象的字符串值的结尾 <xref:System.Text.StringBuilder> 将用 UNICODE 空字符 (U + 0000) 填充。</span><span class="sxs-lookup"><span data-stu-id="c1488-1432">If the specified length is greater than the current length, the end of the string value of the current <xref:System.Text.StringBuilder> object is padded with the Unicode NULL character (U+0000).</span></span>

 <span data-ttu-id="c1488-1433">如果指定的长度大于当前容量，则 <xref:System.Text.StringBuilder.Capacity%2A> 会增加，使其大于或等于指定的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1433">If the specified length is greater than the current capacity, <xref:System.Text.StringBuilder.Capacity%2A> increases so that it is greater than or equal to the specified length.</span></span>



## Examples
 <span data-ttu-id="c1488-1434">下面的示例演示了 <xref:System.Text.StringBuilder.Length%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="c1488-1434">The following example demonstrates the <xref:System.Text.StringBuilder.Length%2A> property.</span></span>

 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1435">为集运算指定的值小于零或大于 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1435">The value specified for a set operation is less than zero or greater than <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MaxCapacity">
      <MemberSignature Language="C#" Value="public int MaxCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.MaxCapacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaxCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxCapacity { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxCapacity : int" Usage="System.Text.StringBuilder.MaxCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c1488-1436">获取此实例的最大容量。</span><span class="sxs-lookup"><span data-stu-id="c1488-1436">Gets the maximum capacity of this instance.</span></span></summary>
        <value><span data-ttu-id="c1488-1437">此实例可容纳的最大字符数。</span><span class="sxs-lookup"><span data-stu-id="c1488-1437">The maximum number of characters this instance can hold.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1438">此实现的最大容量为 <xref:System.Int32.MaxValue?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1438">The maximum capacity for this implementation is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c1488-1439">不过，此值是特定于实现的，并且在其他或更高的实现中可能不同。</span><span class="sxs-lookup"><span data-stu-id="c1488-1439">However, this value is implementation-specific and might be different in other or later implementations.</span></span> <span data-ttu-id="c1488-1440">可以 <xref:System.Text.StringBuilder> 通过调用构造函数来显式设置对象的最大容量 <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1440">You can explicitly set the maximum capacity of a <xref:System.Text.StringBuilder> object by calling the <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> constructor.</span></span>

<span data-ttu-id="c1488-1441">在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <xref:System.Text.StringBuilder> 通过调用构造函数实例化对象时， <xref:System.Text.StringBuilder.%23ctor(System.Int32,System.Int32)> 实例的长度和容量 <xref:System.Text.StringBuilder> 可能会超出其属性的值 <xref:System.Text.StringBuilder.MaxCapacity> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1441">In .NET Core and in the .NET Framework 4.0 and later versions, when you instantiate the <xref:System.Text.StringBuilder> object by calling the <xref:System.Text.StringBuilder.%23ctor(System.Int32,System.Int32)> constructor, both the length and the capacity of the <xref:System.Text.StringBuilder> instance can grow beyond the value of its <xref:System.Text.StringBuilder.MaxCapacity> property.</span></span> <span data-ttu-id="c1488-1442">当调用 <xref:System.Text.StringBuilder.Append(System.String)> 和 <xref:System.Text.StringBuilder.AppendFormat(System.String,System.Object)> 方法追加小字符串时，尤其如此。</span><span class="sxs-lookup"><span data-stu-id="c1488-1442">This can occur particularly when you call the <xref:System.Text.StringBuilder.Append(System.String)> and <xref:System.Text.StringBuilder.AppendFormat(System.String,System.Object)> methods to append small strings.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Remove (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Remove(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, length As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Remove(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Remove (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="c1488-1443">此实例中开始移除操作的从零开始的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1443">The zero-based position in this instance where removal begins.</span></span></param>
        <param name="length"><span data-ttu-id="c1488-1444">要删除的字符数。</span><span class="sxs-lookup"><span data-stu-id="c1488-1444">The number of characters to remove.</span></span></param>
        <summary><span data-ttu-id="c1488-1445">将指定范围的字符从此实例中移除。</span><span class="sxs-lookup"><span data-stu-id="c1488-1445">Removes the specified range of characters from this instance.</span></span></summary>
        <returns><span data-ttu-id="c1488-1446">切除操作完成后对此实例的引用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1446">A reference to this instance after the excise operation has completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1447">当前方法从当前实例中删除指定范围内的字符。</span><span class="sxs-lookup"><span data-stu-id="c1488-1447">The current method removes the specified range of characters from the current instance.</span></span> <span data-ttu-id="c1488-1448">将 () 的字符 `startIndex`  +  `length` 移动到 `startIndex` ，并缩短当前实例的字符串值 `length` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1448">The characters at (`startIndex` + `length`) are moved to `startIndex`, and the string value of the current instance is shortened by `length`.</span></span> <span data-ttu-id="c1488-1449">当前实例的容量不受影响。</span><span class="sxs-lookup"><span data-stu-id="c1488-1449">The capacity of the current instance is unaffected.</span></span>

> [!NOTE]
>  <span data-ttu-id="c1488-1450"><xref:System.Text.StringBuilder.Remove%2A>方法修改当前实例的值 <xref:System.Text.StringBuilder> 并返回该实例。</span><span class="sxs-lookup"><span data-stu-id="c1488-1450">The <xref:System.Text.StringBuilder.Remove%2A> method modifies the value of the current <xref:System.Text.StringBuilder> instance and returns that instance.</span></span> <span data-ttu-id="c1488-1451">它不创建并返回新的 <xref:System.Text.StringBuilder> 对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-1451">It does not create and return a new <xref:System.Text.StringBuilder> object.</span></span>



## Examples
 <span data-ttu-id="c1488-1452">下面的示例演示 <xref:System.Text.StringBuilder.Remove%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-1452">The following example demonstrates the <xref:System.Text.StringBuilder.Remove%2A> method.</span></span>

 [!code-cpp[stringbuilder.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.remove/CPP/remove.cpp#1)]
 [!code-csharp[stringbuilder.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.remove/CS/remove.cs#1)]
 [!code-vb[stringbuilder.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.remove/VB/remove.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1453">如果 <paramref name="startIndex" /> 或 <paramref name="length" /> 小于零，或者 <paramref name="startIndex" /> + <paramref name="length" /> 大于此实例的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1453">If <paramref name="startIndex" /> or <paramref name="length" /> is less than zero, or <paramref name="startIndex" /> + <paramref name="length" /> is greater than the length of this instance.</span></span></exception>
        <altmember cref="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c1488-1454">将此实例中出现的所有指定字符或字符串替换为其他的指定字符或字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-1454">Replaces all occurrences of a specified character or string in this instance with another specified character or string.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar"><span data-ttu-id="c1488-1455">要替换的字符。</span><span class="sxs-lookup"><span data-stu-id="c1488-1455">The character to replace.</span></span></param>
        <param name="newChar"><span data-ttu-id="c1488-1456">替换 <paramref name="oldChar" /> 的字符。</span><span class="sxs-lookup"><span data-stu-id="c1488-1456">The character that replaces <paramref name="oldChar" />.</span></span></param>
        <summary><span data-ttu-id="c1488-1457">将此实例中出现的所有指定字符替换为其他指定字符。</span><span class="sxs-lookup"><span data-stu-id="c1488-1457">Replaces all occurrences of a specified character in this instance with another specified character.</span></span></summary>
        <returns><span data-ttu-id="c1488-1458">对此实例的引用，其中 <paramref name="oldChar" /> 被 <paramref name="newChar" /> 替换。</span><span class="sxs-lookup"><span data-stu-id="c1488-1458">A reference to this instance with <paramref name="oldChar" /> replaced by <paramref name="newChar" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1459">此方法执行序号、区分大小写的比较，以标识 `oldChar` 当前实例中的匹配项。</span><span class="sxs-lookup"><span data-stu-id="c1488-1459">This method performs an ordinal, case-sensitive comparison to identify occurrences of `oldChar` in the current instance.</span></span> <span data-ttu-id="c1488-1460">替换后，当前实例的大小 <xref:System.Text.StringBuilder> 将保持不变。</span><span class="sxs-lookup"><span data-stu-id="c1488-1460">The size of the current <xref:System.Text.StringBuilder> instance is unchanged after the replacement.</span></span>



## Examples
 <span data-ttu-id="c1488-1461">下面的示例演示 <xref:System.Text.StringBuilder.Replace%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-1461">The following example demonstrates the <xref:System.Text.StringBuilder.Replace%2A> method.</span></span>

 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string? newValue);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue"><span data-ttu-id="c1488-1462">要替换的字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-1462">The string to replace.</span></span></param>
        <param name="newValue"><span data-ttu-id="c1488-1463">替换 <paramref name="oldValue" /> 的字符串或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1463">The string that replaces <paramref name="oldValue" />, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="c1488-1464">将此实例中出现的所有指定字符串的替换为其他指定字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-1464">Replaces all occurrences of a specified string in this instance with another specified string.</span></span></summary>
        <returns><span data-ttu-id="c1488-1465">对此实例的引用，其中 <paramref name="oldValue" /> 的所有实例被 <paramref name="newValue" /> 替换。</span><span class="sxs-lookup"><span data-stu-id="c1488-1465">A reference to this instance with all instances of <paramref name="oldValue" /> replaced by <paramref name="newValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1466">此方法执行序号、区分大小写的比较，以标识 `oldValue` 当前实例中的匹配项。</span><span class="sxs-lookup"><span data-stu-id="c1488-1466">This method performs an ordinal, case-sensitive comparison to identify occurrences of `oldValue` in the current instance.</span></span> <span data-ttu-id="c1488-1467">如果 `newValue` 为 `null` 或 <xref:System.String.Empty?displayProperty=nameWithType> ，则删除的所有匹配项 `oldValue` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1467">If `newValue` is `null` or <xref:System.String.Empty?displayProperty=nameWithType>, all occurrences of `oldValue` are removed.</span></span>



## Examples
 <span data-ttu-id="c1488-1468">下面的示例演示 <xref:System.Text.StringBuilder.Replace%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-1468">The following example demonstrates the <xref:System.Text.StringBuilder.Replace%2A> method.</span></span>

 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c1488-1469"><paramref name="oldValue" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1469"><paramref name="oldValue" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c1488-1470"><paramref name="oldValue" /> 的长度为零。</span><span class="sxs-lookup"><span data-stu-id="c1488-1470">The length of <paramref name="oldValue" /> is zero.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1471">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1471">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldChar"><span data-ttu-id="c1488-1472">要替换的字符。</span><span class="sxs-lookup"><span data-stu-id="c1488-1472">The character to replace.</span></span></param>
        <param name="newChar"><span data-ttu-id="c1488-1473">替换 <paramref name="oldChar" /> 的字符。</span><span class="sxs-lookup"><span data-stu-id="c1488-1473">The character that replaces <paramref name="oldChar" />.</span></span></param>
        <param name="startIndex"><span data-ttu-id="c1488-1474">此实例中子字符串开始的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1474">The position in this instance where the substring begins.</span></span></param>
        <param name="count"><span data-ttu-id="c1488-1475">子字符串的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1475">The length of the substring.</span></span></param>
        <summary><span data-ttu-id="c1488-1476">将此实例的子字符串中出现的所有指定字符替换为其他指定字符。</span><span class="sxs-lookup"><span data-stu-id="c1488-1476">Replaces, within a substring of this instance, all occurrences of a specified character with another specified character.</span></span></summary>
        <returns><span data-ttu-id="c1488-1477">对此实例的引用，其中从 <paramref name="startIndex" /> 到 <paramref name="startIndex" /> + <paramref name="count" /> -1 范围内的 <paramref name="oldChar" /> 被 <paramref name="newChar" /> 替换。</span><span class="sxs-lookup"><span data-stu-id="c1488-1477">A reference to this instance with <paramref name="oldChar" /> replaced by <paramref name="newChar" /> in the range from <paramref name="startIndex" /> to <paramref name="startIndex" /> + <paramref name="count" /> -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1478">此方法执行序号、区分大小写的比较，以标识 `oldChar` 当前实例中的匹配项。</span><span class="sxs-lookup"><span data-stu-id="c1488-1478">This method performs an ordinal, case-sensitive comparison to identify occurrences of `oldChar` in the current instance.</span></span> <span data-ttu-id="c1488-1479">替换后，当前对象的大小 <xref:System.Text.StringBuilder> 不变。</span><span class="sxs-lookup"><span data-stu-id="c1488-1479">The size of the current <xref:System.Text.StringBuilder> object is unchanged after the replacement.</span></span>



## Examples
 <span data-ttu-id="c1488-1480">下面的示例演示 <xref:System.Text.StringBuilder.Replace%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-1480">The following example demonstrates the <xref:System.Text.StringBuilder.Replace%2A> method.</span></span>

 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1481"><paramref name="startIndex" /> + <paramref name="count" /> 大于此实例的值的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1481"><paramref name="startIndex" /> + <paramref name="count" /> is greater than the length of the value of this instance.</span></span>

<span data-ttu-id="c1488-1482">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-1482">-or-</span></span>

 <span data-ttu-id="c1488-1483"><paramref name="startIndex" /> 或 <paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="c1488-1483"><paramref name="startIndex" /> or <paramref name="count" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue, int startIndex, int count);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue, startIndex, count)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string? newValue, int startIndex, int count);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldValue"><span data-ttu-id="c1488-1484">要替换的字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-1484">The string to replace.</span></span></param>
        <param name="newValue"><span data-ttu-id="c1488-1485">替换 <paramref name="oldValue" /> 的字符串或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1485">The string that replaces <paramref name="oldValue" />, or <see langword="null" />.</span></span></param>
        <param name="startIndex"><span data-ttu-id="c1488-1486">此实例中子字符串开始的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1486">The position in this instance where the substring begins.</span></span></param>
        <param name="count"><span data-ttu-id="c1488-1487">子字符串的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1487">The length of the substring.</span></span></param>
        <summary><span data-ttu-id="c1488-1488">将此实例的子字符串中出现的所有指定字符串替换为其他指定字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-1488">Replaces, within a substring of this instance, all occurrences of a specified string with another specified string.</span></span></summary>
        <returns><span data-ttu-id="c1488-1489">对此实例的引用，其中从 <paramref name="startIndex" /> 到 <paramref name="startIndex" /> + <paramref name="count" /> - 1 的范围内 <paramref name="oldValue" /> 的所有实例被 <paramref name="newValue" /> 替换。</span><span class="sxs-lookup"><span data-stu-id="c1488-1489">A reference to this instance with all instances of <paramref name="oldValue" /> replaced by <paramref name="newValue" /> in the range from <paramref name="startIndex" /> to <paramref name="startIndex" /> + <paramref name="count" /> - 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1490">此方法执行序号、区分大小写的比较，以标识 `oldValue` 指定子字符串中的匹配项。</span><span class="sxs-lookup"><span data-stu-id="c1488-1490">This method performs an ordinal, case-sensitive comparison to identify occurrences of `oldValue` in the specified substring.</span></span> <span data-ttu-id="c1488-1491">如果 `newValue` 为 `null` 或 <xref:System.String.Empty?displayProperty=nameWithType> ，则删除的所有匹配项 `oldValue` 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1491">If `newValue` is `null` or <xref:System.String.Empty?displayProperty=nameWithType>, all occurrences of `oldValue` are removed.</span></span>



## Examples
 <span data-ttu-id="c1488-1492">下面的示例演示 <xref:System.Text.StringBuilder.Replace%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-1492">The following example demonstrates the <xref:System.Text.StringBuilder.Replace%2A> method.</span></span>

 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c1488-1493"><paramref name="oldValue" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1493"><paramref name="oldValue" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c1488-1494"><paramref name="oldValue" /> 的长度为零。</span><span class="sxs-lookup"><span data-stu-id="c1488-1494">The length of <paramref name="oldValue" /> is zero.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1495"><paramref name="startIndex" /> 或 <paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="c1488-1495"><paramref name="startIndex" /> or <paramref name="count" /> is less than zero.</span></span>

<span data-ttu-id="c1488-1496">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-1496">-or-</span></span>

 <span data-ttu-id="c1488-1497"><paramref name="startIndex" /> 加 <paramref name="count" /> 指示一个不在此实例内的字符位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1497"><paramref name="startIndex" /> plus <paramref name="count" /> indicates a character position not within this instance.</span></span>

<span data-ttu-id="c1488-1498">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-1498">-or-</span></span>

<span data-ttu-id="c1488-1499">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1499">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</span></span></exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.Serialization.ISerializable.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.System.Runtime.Serialization.ISerializable.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="stringBuilder.System.Runtime.Serialization.ISerializable.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="c1488-1500">要用序列化信息填充的对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-1500">The object to populate with serialization information.</span></span></param>
        <param name="context"><span data-ttu-id="c1488-1501">存储和检索序列化数据的位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1501">The place to store and retrieve serialized data.</span></span> <span data-ttu-id="c1488-1502">保留供将来使用。</span><span class="sxs-lookup"><span data-stu-id="c1488-1502">Reserved for future use.</span></span></param>
        <summary><span data-ttu-id="c1488-1503">使用所需的数据填充 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象来反序列化当前 <see cref="T:System.Text.StringBuilder" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="c1488-1503">Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object with the data necessary to deserialize the current <see cref="T:System.Text.StringBuilder" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1504">此 `context` 参数保留以供将来使用，并且不参与此操作。</span><span class="sxs-lookup"><span data-stu-id="c1488-1504">The `context` parameter is reserved for future use and does not participate in this operation.</span></span>

 <span data-ttu-id="c1488-1505">有关更多信息，请参见 <xref:System.Runtime.Serialization.SerializationInfo.AddValue%28System.String%2CSystem.Object%2CSystem.Type%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-1505">For more information, see the <xref:System.Runtime.Serialization.SerializationInfo.AddValue%28System.String%2CSystem.Object%2CSystem.Type%29?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c1488-1506"><paramref name="info" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1506"><paramref name="info" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c1488-1507">将 <see cref="T:System.Text.StringBuilder" /> 的值转换为 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1507">Converts the value of a <see cref="T:System.Text.StringBuilder" /> to a <see cref="T:System.String" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="stringBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c1488-1508">将此实例的值转换为 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1508">Converts the value of this instance to a <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="c1488-1509">其值与此实例相同的字符串。</span><span class="sxs-lookup"><span data-stu-id="c1488-1509">A string whose value is the same as this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1510">必须 <xref:System.Text.StringBuilder.ToString%2A> 先调用方法将 <xref:System.Text.StringBuilder> 对象转换为对象，然后才能将 <xref:System.String> 对象表示的字符串传递给 <xref:System.Text.StringBuilder> 具有 <xref:System.String> 参数或在用户界面中显示它的方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-1510">You must call the <xref:System.Text.StringBuilder.ToString%2A> method to convert the <xref:System.Text.StringBuilder> object to a <xref:System.String> object before you can pass the string represented by the <xref:System.Text.StringBuilder> object to a method that has a <xref:System.String> parameter or display it in the user interface.</span></span>



## Examples
 <span data-ttu-id="c1488-1511">下面的示例演示如何调用 <xref:System.Text.StringBuilder.ToString%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-1511">The following example demonstrates calling the <xref:System.Text.StringBuilder.ToString%2A> method.</span></span> <span data-ttu-id="c1488-1512">此示例是为类提供的更大示例的一部分 <xref:System.Text.StringBuilder> 。</span><span class="sxs-lookup"><span data-stu-id="c1488-1512">This example is part of a larger example provided for the <xref:System.Text.StringBuilder> class.</span></span>

 [!code-cpp[StringBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#5)]
 [!code-csharp[StringBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#5)]
 [!code-vb[StringBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#5)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : int * int -&gt; string" Usage="stringBuilder.ToString (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="c1488-1513">此实例内子字符串的起始位置。</span><span class="sxs-lookup"><span data-stu-id="c1488-1513">The starting position of the substring in this instance.</span></span></param>
        <param name="length"><span data-ttu-id="c1488-1514">子字符串的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1514">The length of the substring.</span></span></param>
        <summary><span data-ttu-id="c1488-1515">将此实例中子字符串的值转换为 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="c1488-1515">Converts the value of a substring of this instance to a <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="c1488-1516">一个字符串，其值与此实例的指定子字符串相同。</span><span class="sxs-lookup"><span data-stu-id="c1488-1516">A string whose value is the same as the specified substring of this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c1488-1517">必须 <xref:System.Text.StringBuilder.ToString%2A> 先调用方法将 <xref:System.Text.StringBuilder> 对象转换为对象，然后才能将 <xref:System.String> 对象表示的字符串传递给 <xref:System.Text.StringBuilder> 具有 <xref:System.String> 参数或在用户界面中显示它的方法。</span><span class="sxs-lookup"><span data-stu-id="c1488-1517">You must call the <xref:System.Text.StringBuilder.ToString%2A> method to convert the <xref:System.Text.StringBuilder> object to a <xref:System.String> object before you can pass the string represented by the <xref:System.Text.StringBuilder> object to a method that has a <xref:System.String> parameter or display it in the user interface.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c1488-1518"><paramref name="startIndex" /> 或 <paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="c1488-1518"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span>

<span data-ttu-id="c1488-1519">- 或 -</span><span class="sxs-lookup"><span data-stu-id="c1488-1519">-or-</span></span>

<span data-ttu-id="c1488-1520"><paramref name="startIndex" /> 和 <paramref name="length" /> 之和大于当前实例的长度。</span><span class="sxs-lookup"><span data-stu-id="c1488-1520">The sum of <paramref name="startIndex" /> and <paramref name="length" /> is greater than the length of the current instance.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
