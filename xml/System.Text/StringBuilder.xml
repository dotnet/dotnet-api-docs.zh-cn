<Type Name="StringBuilder" FullName="System.Text.StringBuilder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6dc30a1b5b1aa5831ba5e0f1f2a1634ffcd38470" /><Meta Name="ms.sourcegitcommit" Value="9a0316374d19cc78674994106d073aa5ef1bd5f3" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="11/10/2020" /><Meta Name="ms.locfileid" Value="94460564" /></Metadata><TypeSignature Language="C#" Value="public sealed class StringBuilder" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit StringBuilder extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="DocId" Value="T:System.Text.StringBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StringBuilder" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C++ CLI" Value="public ref class StringBuilder sealed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="F#" Value="type StringBuilder = class" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C#" Value="public sealed class StringBuilder : System.Runtime.Serialization.ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StringBuilder&#xA;Implements ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class StringBuilder sealed : System::Runtime::Serialization::ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type StringBuilder = class&#xA;    interface ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit StringBuilder extends System.Object" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示可变字符字符串。 此类不能被继承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 此类表示一个类似字符串的对象，其值为可变字符序列。

 本部分内容：

-   [String 和 StringBuilder 类型](#StringAndSB)

-   [StringBuilder 的工作方式](#HowWorks)

-   [内存分配](#Memory)

-   [实例化 StringBuilder 对象](#Instantiating)

-   [调用 StringBuilder 方法](#Calling)

-   [执行 StringBuilder 操作](#Operations)

    -   [迭代 StringBuilder 字符](#Iterating)

    -   [向 StringBuilder 对象添加文本](#Adding)

    -   [从 StringBuilder 对象中删除文本](#Deleting)

    -   [修改 StringBuilder 对象中的文本](#Modifying)

-   [在 StringBuilder 对象中搜索文本](#Searching)

-   [将 StringBuilder 对象转换为字符串](#Converting)

<a name="StringAndSB"></a>
## <a name="the-string-and-stringbuilder-types"></a>String 和 StringBuilder 类型
 尽管 <xref:System.Text.StringBuilder> 和 <xref:System.String> 都表示字符序列，但它们的实现方式不同。 <xref:System.String> 是不可变类型。 也就是说，出现的用于修改对象的每个操作 <xref:System.String> 实际上都会创建一个新的字符串。

 例如， <xref:System.String.Concat%2A?displayProperty=nameWithType> 以下 c # 示例中的方法调用将显示为更改名为的字符串变量的值 `value` 。 事实上，该 <xref:System.String.Concat%2A> 方法将返回一个 `value` 对象，该对象具有与 `value` 传递给该方法的对象不同的值和地址。 请注意，必须使用编译器选项编译该示例 `/unsafe` 。

 [!code-csharp[System.Text.StringBuilder.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/immutability2.cs#1)]

 对于执行大量字符串操作的例程 (例如在循环中多次修改字符串的应用程序) ，重复修改字符串可能会显著降低性能。 替代方法是使用 <xref:System.Text.StringBuilder> ，它是一个可变字符串类。 可变性是指在创建类的实例后，可以通过追加、移除、替换或插入字符来修改它。 <xref:System.Text.StringBuilder>对象维护缓冲区以容纳对字符串的扩展。 如果空间可用，则会将新数据追加到缓冲区;否则，将分配一个新的更大的缓冲区，将原始缓冲区中的数据复制到新缓冲区，然后将新数据追加到新缓冲区。

> [!IMPORTANT]
>  尽管 <xref:System.Text.StringBuilder> 类通常比类提供更好的性能 <xref:System.String> ，但你不应在 <xref:System.String> <xref:System.Text.StringBuilder> 每次需要操作字符串时自动将替换为。 性能取决于字符串的大小、要为新字符串分配的内存量、正在执行应用程序的系统以及操作的类型。 应该准备好测试应用程序，以确定实际是否 <xref:System.Text.StringBuilder> 提供显著的性能改进。

 请考虑 <xref:System.String> 在以下情况下使用类：

-   当你的应用将对字符串进行的更改数量很小时。 在这些情况下， <xref:System.Text.StringBuilder> 可能会提供可忽略或不会提高性能的性能 <xref:System.String> 。

-   当你执行固定数量的串联操作时，尤其是字符串文本。 在这种情况下，编译器可能会将串联操作合并为单个操作。

-   在生成字符串时，必须执行大量的搜索操作。 <xref:System.Text.StringBuilder>类缺少搜索方法，如 `IndexOf` 或 `StartsWith` 。 <xref:System.Text.StringBuilder>对于这些操作，必须将对象转换为 <xref:System.String> ，这可能会使使用不会带来性能优势 <xref:System.Text.StringBuilder> 。 有关详细信息，请参阅在 [StringBuilder 对象中搜索文本](#Searching) 部分。

 请考虑 <xref:System.Text.StringBuilder> 在以下情况下使用类：

-   如果希望应用在设计时对字符串进行未知数量的更改 (例如，当你使用循环来连接包含用户输入) 的随机数量的字符串时。

-   希望应用对字符串进行大量更改时。

<a name="HowWorks"></a>
## <a name="how-stringbuilder-works"></a>StringBuilder 的工作方式
 <xref:System.Text.StringBuilder.Length%2A?displayProperty=nameWithType>属性指示对象当前包含的字符数 <xref:System.Text.StringBuilder> 。 如果向对象添加字符 <xref:System.Text.StringBuilder> ，则其长度将增加，直到它等于属性的大小 <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> ，该大小定义对象可以包含的字符数。 如果添加的字符数导致对象的长度 <xref:System.Text.StringBuilder> 超过其当前容量，则分配新内存，属性的值 <xref:System.Text.StringBuilder.Capacity%2A> 翻倍，新字符将添加到 <xref:System.Text.StringBuilder> 对象中，并 <xref:System.Text.StringBuilder.Length%2A> 调整其属性。 对象的额外内存 <xref:System.Text.StringBuilder> 会动态分配，直到达到属性定义的值 <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType> 。 达到最大容量时，不能为该对象分配更多的内存 <xref:System.Text.StringBuilder> ，尝试添加字符或将其扩展到超出其最大容量后，会引发 <xref:System.ArgumentOutOfRangeException> 或 <xref:System.OutOfMemoryException> 例外。

 下面的示例演示了 <xref:System.Text.StringBuilder> 对象如何分配新内存并动态增加其容量，因为分配给对象的字符串会展开。 该代码 <xref:System.Text.StringBuilder> 通过调用默认 (无参数) 构造函数来创建对象。 此对象的默认容量为16个字符，其最大容量超过2000000000个字符。 追加字符串 "This is a 句子"。 导致新的内存分配，因为字符串长度 (19 个字符) 超过对象的默认容量 <xref:System.Text.StringBuilder> 。 对象的容量长度为32个字符，添加新字符串，并且对象的长度现在等于19个字符。 然后，该代码将追加字符串 "This is 其他句子"。 对象的值 <xref:System.Text.StringBuilder> 11 次。 每当追加操作导致对象的长度 <xref:System.Text.StringBuilder> 超过其容量时，其现有容量就会加倍， <xref:System.Text.StringBuilder.Append%2A> 操作成功。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/default1.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/default1.vb" id="Snippet3":::

<a name="Memory"></a>
## <a name="memory-allocation"></a>内存分配
 对象的默认容量 <xref:System.Text.StringBuilder> 是16个字符，默认的最大容量为 <xref:System.Int32.MaxValue?displayProperty=nameWithType> 。 如果调用 <xref:System.Text.StringBuilder.%23ctor> 和构造函数，则使用这些默认值 <xref:System.Text.StringBuilder.%23ctor%28System.String%29> 。

 可以通过以下方式显式定义对象的初始容量 <xref:System.Text.StringBuilder> ：

-   通过在 <xref:System.Text.StringBuilder> 创建对象时调用包含参数的任何构造函数 `capacity` 。

-   通过将新值显式分配给 <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> 属性来展开现有 <xref:System.Text.StringBuilder> 对象。 请注意，如果新容量小于现有容量或大于 <xref:System.Text.StringBuilder> 对象的最大容量，则属性引发异常。

-   通过 <xref:System.Text.StringBuilder.EnsureCapacity%2A?displayProperty=nameWithType> 使用新容量调用方法。 新容量不得大于 <xref:System.Text.StringBuilder> 对象的最大容量。 但是，与对属性的赋值不同 <xref:System.Text.StringBuilder.Capacity%2A> ， <xref:System.Text.StringBuilder.EnsureCapacity%2A> 如果所需的新容量小于现有容量，则不会引发异常; 在这种情况下，方法调用不起作用。

 如果分配给 <xref:System.Text.StringBuilder> 构造函数调用中的对象的字符串长度超过默认容量或指定的容量，则将 <xref:System.Text.StringBuilder.Capacity%2A> 属性设置为与参数一起指定的字符串长度 `value` 。

 可以 <xref:System.Text.StringBuilder> 通过调用构造函数来显式定义对象的最大容量 <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> 。 不能通过为属性分配新值来更改最大容量 <xref:System.Text.StringBuilder.MaxCapacity%2A> ，因为它是只读的。

 如上一节所示，只要现有容量不足，就会分配额外的内存，并且对象的容量将与 <xref:System.Text.StringBuilder> 属性定义的值加倍 <xref:System.Text.StringBuilder.MaxCapacity%2A> 。

 通常，默认容量和最大容量适用于大多数应用。 可以考虑在以下条件下设置这些值：

-   如果对象的最终大小 <xref:System.Text.StringBuilder> 可能会变得非常大，通常会超出几兆字节。 在这种情况下，将初始属性设置为明显较高的值可能会提高性能， <xref:System.Text.StringBuilder.Capacity%2A> 从而无需过多的内存重新分配。

-   如果你的应用在内存有限的系统上运行。 在这种情况下，您可能需要考虑将 <xref:System.Text.StringBuilder.MaxCapacity%2A> 属性设置为小于 <xref:System.Int32.MaxValue?displayProperty=nameWithType> 您的应用程序处理可能导致它在内存约束的环境中执行的大型字符串。

<a name="Instantiating"></a>
## <a name="instantiating-a-stringbuilder-object"></a>实例化 StringBuilder 对象
 可以 <xref:System.Text.StringBuilder> 通过调用下表中列出的六个重载类构造函数之一来实例化对象。 三个构造函数实例化一个 <xref:System.Text.StringBuilder> 对象，该对象的值为空字符串，但 <xref:System.Text.StringBuilder.Capacity%2A> 以不同的方式设置其和 <xref:System.Text.StringBuilder.MaxCapacity%2A> 值。 其余三个构造函数定义一个 <xref:System.Text.StringBuilder> 对象，该对象具有特定的字符串值和容量。 这三个构造函数中的两个使用默认的最大容量 <xref:System.Int32.MaxValue?displayProperty=nameWithType> ，而第三个构造函数可设置最大容量。

|构造函数|字符串值|容量|最大容量|
|-----------------|------------------|--------------|----------------------|
|<xref:System.Text.StringBuilder.%23ctor>|<xref:System.String.Empty?displayProperty=nameWithType>|16|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|由参数定义 `capacity`|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|由参数定义 `capacity`|由参数定义 `maxCapacity`|
|<xref:System.Text.StringBuilder.%23ctor%28System.String%29>|由参数定义 `value`|16或 `value` 。 <xref:System.String.Length%2A>，以较大者为准|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%29>|由参数定义 `value`|由 `capacity` 参数或定义 `value` 。 <xref:System.String.Length%2A>，以较大者为准。|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>|由 `value` 定义。 <xref:System.String.Substring%2A>(`startIndex`, `length`)|由 `capacity` 参数或定义 `value` 。 <xref:System.String.Length%2A>，以较大者为准。|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|

 下面的示例使用三个构造函数重载来实例化 <xref:System.Text.StringBuilder> 对象。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/instantiate1.cs" interactive="try-dotnet" id="Snippet6":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/instantiate1.vb" id="Snippet6":::

<a name="Calling"></a>
## <a name="calling-stringbuilder-methods"></a>调用 StringBuilder 方法
 修改实例中的字符串的大多数方法都将 <xref:System.Text.StringBuilder> 返回对同一实例的引用。 这使您可以通过 <xref:System.Text.StringBuilder> 两种方式调用方法：

-   可以进行单个方法调用并忽略返回值，如下例所示。

     :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call1.cs" interactive="try-dotnet" id="Snippet4":::
     :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call1.vb" id="Snippet4":::

-   可以在单个语句中执行一系列方法调用。 如果要编写一条链接连续操作的语句，这会很方便。 下面的示例将上一示例中的三个方法调用合并为单个代码行。

     :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call2.cs" interactive="try-dotnet" id="Snippet5":::
     :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call2.vb" id="Snippet5":::

<a name="Operations"></a>
## <a name="performing-stringbuilder-operations"></a>执行 StringBuilder 操作
 您可以使用类的方法 <xref:System.Text.StringBuilder> 来循环访问、添加、删除或修改对象中的字符 <xref:System.Text.StringBuilder> 。

<a name="Iterating"></a>
### <a name="iterating-stringbuilder-characters"></a>迭代 StringBuilder 字符
 可以 <xref:System.Text.StringBuilder> 通过使用属性访问对象中的字符 <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> 。 在 c # 中， <xref:System.Text.StringBuilder.Chars%2A> 是索引器; 在 Visual Basic 中，它是类的默认属性 <xref:System.Text.StringBuilder> 。 这使您可以仅使用索引来设置或检索单个字符，而无需显式引用 <xref:System.Text.StringBuilder.Chars%2A> 属性。 对象中的字符从 <xref:System.Text.StringBuilder> 索引0开始 (零) 并继续到索引 <xref:System.Text.StringBuilder.Length%2A> -1。

 下面的示例阐释了 <xref:System.Text.StringBuilder.Chars%2A> 属性。 它将10个随机数追加到 <xref:System.Text.StringBuilder> 对象，然后循环访问每个字符。 如果该字符的 Unicode 类别为 <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType> ，则将该数字减小 1 (或者将其值为 0) 将其更改为9。 此示例在 <xref:System.Text.StringBuilder> 更改各个字符的值之前和之后都显示对象的内容。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/chars1.cs" interactive="try-dotnet" id="Snippet7":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/chars1.vb" id="Snippet7":::

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]

<a name="Adding"></a>
### <a name="adding-text-to-a-stringbuilder-object"></a>向 StringBuilder 对象添加文本
 此 <xref:System.Text.StringBuilder> 类包括以下方法来扩展对象的内容 <xref:System.Text.StringBuilder> ：

-   <xref:System.Text.StringBuilder.Append%2A>方法追加字符串、子字符串、字符数组、字符数组的一部分、多次重复的单个字符或基元数据类型到对象的字符串表示形式 <xref:System.Text.StringBuilder> 。

-   <xref:System.Text.StringBuilder.AppendLine%2A>方法将行终止符或字符串及行结束符一起追加到 <xref:System.Text.StringBuilder> 对象。

-   <xref:System.Text.StringBuilder.AppendFormat%2A>方法将[复合格式字符串](/dotnet/standard/base-types/composite-formatting)追加到 <xref:System.Text.StringBuilder> 对象。 结果字符串中包含的对象的字符串表示形式可以反映当前系统区域性或指定区域性的格式设置约定。

-   <xref:System.Text.StringBuilder.Insert%2A>方法在对象中的指定位置插入字符串、子串、字符串的多个重复项、字符数组、部分字符数组或基元数据类型的字符串表示形式 <xref:System.Text.StringBuilder> 。 位置由从零开始的索引定义。

 下面的示例使用 <xref:System.Text.StringBuilder.Append%2A> 、 <xref:System.Text.StringBuilder.AppendLine%2A> 、 <xref:System.Text.StringBuilder.AppendFormat%2A> 和 <xref:System.Text.StringBuilder.Insert%2A> 方法展开对象的文本 <xref:System.Text.StringBuilder> 。

  :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/expand1.cs" interactive="try-dotnet" id="Snippet9":::
  :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/expand1.vb" id="Snippet9":::

<a name="Deleting"></a>
### <a name="deleting-text-from-a-stringbuilder-object"></a>从 StringBuilder 对象中删除文本
 <xref:System.Text.StringBuilder>类包括可以减少的当前大小的方法<xref:System.Text.StringBuilder>实例。 <xref:System.Text.StringBuilder.Clear%2A>方法中删除所有字符，并设置<xref:System.Text.StringBuilder.Length%2A>属性设置为零。 <xref:System.Text.StringBuilder.Remove%2A>方法中删除指定的数量的特定索引位置开始的字符。 此外，从末尾删除字符<xref:System.Text.StringBuilder>对象通过设置其<xref:System.Text.StringBuilder.Length%2A>属性的值小于当前实例的长度。

 下面的示例从对象中删除一些文本 <xref:System.Text.StringBuilder> 、显示其生成的容量、最大容量和 length 属性值，然后调用 <xref:System.Text.StringBuilder.Clear%2A> 方法从对象中删除所有字符 <xref:System.Text.StringBuilder> 。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/delete1.cs" interactive="try-dotnet" id="Snippet10":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/delete1.vb" id="Snippet10":::

<a name="Modifying"></a>
### <a name="modifying-the-text-in-a-stringbuilder-object"></a>修改 StringBuilder 对象中的文本
 <xref:System.Text.StringBuilder.Replace%2A?displayProperty=nameWithType>方法将替换整个 <xref:System.Text.StringBuilder> 对象或特定字符范围内出现的所有字符或字符串。 下面的示例使用 <xref:System.Text.StringBuilder.Replace%2A> 方法在对象中用问号 (？ ) 来替换所有惊叹号 (！ ) <xref:System.Text.StringBuilder> 。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/replace1.cs" interactive="try-dotnet" id="Snippet11":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/replace1.vb" id="Snippet11":::

<a name="Searching"></a>
## <a name="searching-the-text-in-a-stringbuilder-object"></a>在 StringBuilder 对象中搜索文本
 <xref:System.Text.StringBuilder>类不包括与 <xref:System.String.Contains%2A?displayProperty=nameWithType> 类提供的、和方法类似的方法 <xref:System.String.IndexOf%2A?displayProperty=nameWithType> <xref:System.String.StartsWith%2A?displayProperty=nameWithType> <xref:System.String> ，这允许您在对象中搜索特定字符或子字符串。 若要确定子字符串的存在或起始字符位置，需要 <xref:System.String> 使用字符串搜索方法或正则表达式方法搜索某个值。 可通过四种方式实现此类搜索，如下表所示。

|方法|优点|缺点|
|---------------|----------|----------|
|搜索字符串值，然后将其添加到 <xref:System.Text.StringBuilder> 对象。|适用于确定子字符串是否存在。|子字符串的索引位置非常重要时，不能使用。|
|调用 <xref:System.Text.StringBuilder.ToString%2A> 并搜索返回的 <xref:System.String> 对象。|如果将所有文本分配到 <xref:System.Text.StringBuilder> 对象，然后开始对其进行修改，则可轻松使用。|<xref:System.Text.StringBuilder.ToString%2A>如果您必须在将所有文本添加到对象之前进行修改，则重复调用会很繁琐 <xref:System.Text.StringBuilder> 。<br /><br /> 如果要进行更改，则必须记得从对象的文本末尾进行操作 <xref:System.Text.StringBuilder> 。|
|使用 <xref:System.Text.StringBuilder.Chars%2A> 属性按顺序搜索字符范围。|如果您担心单个字符或小型子字符串，此方法非常有用。|如果搜索的字符数很大或者搜索逻辑很复杂，则这种情况很繁琐。<br /><br />通过重复方法调用，导致非常大的对象性能非常差。  |
|将 <xref:System.Text.StringBuilder> 对象转换为 <xref:System.String> 对象，并对对象执行修改 <xref:System.String> 。|如果修改次数较小，则此方法很有用。|如果修改的数量较大，则会使类的性能优势抵消 <xref:System.Text.StringBuilder> 。|

 让我们更详细地研究一下这些方法。

-   如果搜索的目标是确定特定的子字符串是否存在 (也就是说，如果不感兴趣) 子字符串的位置，则可以在将字符串存储到对象之前对其进行搜索 <xref:System.Text.StringBuilder> 。 下面的示例提供了一个可能的实现。 它定义一个 `StringBuilderFinder` 类，该类的构造函数传递对对象的引用 <xref:System.Text.StringBuilder> 以及要在字符串中查找的子字符串。 在这种情况下，该示例将尝试确定是否已记录温度为华氏温度或摄氏温度，并将相应的引导文本添加到对象的开头 <xref:System.Text.StringBuilder> 。 随机数生成器用于选择以摄氏或华氏度为单位包含数据的数组。

     :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern1.cs" interactive="try-dotnet" id="Snippet12":::
     :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern1.vb" id="Snippet12":::

-   调用 <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> 方法将 <xref:System.Text.StringBuilder> 对象转换为 <xref:System.String> 对象。 您可以使用或等方法搜索字符串 <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> <xref:System.String.StartsWith%2A?displayProperty=nameWithType> ，也可以使用正则表达式和 <xref:System.Text.RegularExpressions.Regex> 类搜索模式。 由于 <xref:System.Text.StringBuilder> 和 <xref:System.String> 对象使用 utf-16 编码存储字符，因此字符、子字符串和正则表达式匹配项的索引位置在这两个对象中是相同的。 这使您可以使用 <xref:System.Text.StringBuilder> 方法在对象中找到该文本的同一位置进行更改 <xref:System.String> 。

    > [!NOTE]
    >  如果采用这种方法，应从对象的末尾开始工作， <xref:System.Text.StringBuilder> 这样就不必反复将 <xref:System.Text.StringBuilder> 对象转换为字符串。

     下面的示例阐释了这种方法。 它在对象中存储每个英文字母的四个匹配项 <xref:System.Text.StringBuilder> 。 然后，它将文本转换为 <xref:System.String> 对象，并使用正则表达式标识每个四字符序列的起始位置。 最后，在除第一个序列外的每个四字符序列之前添加下划线，并将序列的第一个字符转换为大写。

     :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern2.cs" interactive="try-dotnet" id="Snippet13":::
     :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern2.vb" id="Snippet13":::

-   使用 <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> 属性可按顺序在对象中搜索一定范围内的字符 <xref:System.Text.StringBuilder> 。 如果要搜索的字符数很大或者搜索逻辑特别复杂，则这种方法可能不可行。 对于非常大的分块对象的基于字符索引的访问的性能影响 <xref:System.Text.StringBuilder> ，请参阅属性的文档 <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> 。

     下面的示例与上一个示例的功能相同，但实现方式不同。 它使用 <xref:System.Text.StringBuilder.Chars%2A> 属性来检测某个字符值已更改的时间，在该位置插入一个下划线，并将新序列中的第一个字符转换为大写。

     :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern3.cs" interactive="try-dotnet" id="Snippet14":::
     :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern3.vb" id="Snippet14":::

-   将所有未修改的文本存储在 <xref:System.Text.StringBuilder> 对象中，调用 <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> 方法将对象转换 <xref:System.Text.StringBuilder> 为 <xref:System.String> 对象，然后对对象执行修改 <xref:System.String> 。 如果只有少量的修改，可以使用此方法;否则，使用不可变字符串的成本可能会抵消使用对象的性能优势 <xref:System.Text.StringBuilder> 。

     下面的示例在功能上与前面两个示例相同，但实现方式不同。 它将创建一个 <xref:System.Text.StringBuilder> 对象，将其转换为 <xref:System.String> 对象，然后使用正则表达式对该字符串执行所有剩余的修改。 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType>方法使用 lambda 表达式对每个匹配项执行替换。

     :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern4.cs" interactive="try-dotnet" id="Snippet15":::
     :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern4.vb" id="Snippet15":::

<a name="Converting"></a>
## <a name="converting-the-stringbuilder-object-to-a-string"></a>将 StringBuilder 对象转换为字符串
 必须先将 <xref:System.Text.StringBuilder> 对象转换为 <xref:System.String> 对象，然后才能将 <xref:System.Text.StringBuilder> 对象表示的字符串传递给包含 <xref:System.String> 参数的方法，或在用户界面中显示它。 可以通过调用方法来执行此转换 <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> 。 有关说明，请参阅前面的示例，该示例调用 <xref:System.Text.StringBuilder.ToString%2A> 方法将对象转换 <xref:System.Text.StringBuilder> 为字符串，以便可以将其传递给正则表达式方法。



## Examples
 下面的示例演示如何调用类定义的多个方法 <xref:System.Text.StringBuilder> 。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb" id="Snippet1":::

 ]]></format>
    </remarks>
    <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此实例的字符串值设置为 <xref:System.String.Empty?displayProperty=nameWithType> ，容量设置为特定于实现的默认容量。



## Examples
 下面的示例演示如何调用 <xref:System.Text.StringBuilder.%23ctor%2A> 不带参数的构造函数。

 [!code-cpp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#1)]
 [!code-csharp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#1)]
 [!code-vb[System.Text.StringBuilder.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">此实例的建议起始大小。</param>
        <summary>使用指定的容量初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `capacity`参数定义可存储在当前实例所分配的内存中的最大字符数。 它的值被分配给 <xref:System.Text.StringBuilder.Capacity%2A> 属性。 如果要存储在当前实例中的字符数超出此 `capacity` 值，则对象将 <xref:System.Text.StringBuilder> 分配额外的内存来存储它们。

 此实例的字符串值设置为 <xref:System.String.Empty?displayProperty=nameWithType> 。 如果 `capacity` 为零，则使用特定于实现的默认容量。



## Examples
 下面的示例演示如何 <xref:System.Text.StringBuilder.%23ctor%2A> 使用指定的容量调用构造函数。

 [!code-cpp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#3)]
 [!code-csharp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#3)]
 [!code-vb[System.Text.StringBuilder.Constructors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#3)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> 小于零。</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">用于初始化实例值的字符串。 如果 <paramref name="value" /> 为 <see langword="null" />，则新的 <see cref="T:System.Text.StringBuilder" /> 将包含空字符串（即包含 <see cref="F:System.String.Empty" />）。</param>
        <summary>使用指定的字符串初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果 `value` 为 `null`，则新的 <xref:System.Text.StringBuilder> 将包含空字符串（即包含 <xref:System.String.Empty>）。



## Examples
 下面的示例演示如何调用 <xref:System.Text.StringBuilder.%23ctor%2A> 具有指定字符串的构造函数。

 [!code-cpp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#4)]
 [!code-csharp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#4)]
 [!code-vb[System.Text.StringBuilder.Constructors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#4)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity, int maxCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, int32 maxCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, maxCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity, int maxCapacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (capacity, maxCapacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="maxCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity"><see cref="T:System.Text.StringBuilder" /> 的建议起始大小。</param>
        <param name="maxCapacity">当前字符串可包含的最大字符数。</param>
        <summary>初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例，该类起始于指定容量并且可增长到指定的最大容量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `capacity`参数定义可存储在当前实例所分配的内存中的最大字符数。 它的值被分配给 <xref:System.Text.StringBuilder.Capacity%2A> 属性。 如果要存储在当前实例中的字符数超出此 `capacity` 值，则对象将 <xref:System.Text.StringBuilder> 分配额外的内存来存储它们。

 如果 `capacity` 为零，则使用特定于实现的默认容量。

 `maxCapacity`属性定义当前实例可以容纳的最大字符数。 它的值被分配给 <xref:System.Text.StringBuilder.MaxCapacity%2A> 属性。 如果要在当前实例中存储的字符数超过此 `maxCapacity` 值，则对象不 <xref:System.Text.StringBuilder> 会分配额外的内存，而是引发异常。



## Examples
 下面的示例演示如何 <xref:System.Text.StringBuilder.%23ctor%2A> 使用指定的容量和最大容量调用构造函数。

 [!code-cpp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#5)]
 [!code-csharp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#5)]
 [!code-vb[System.Text.StringBuilder.Constructors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#5)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxCapacity" /> 小于一，<paramref name="capacity" /> 小于零，或 <paramref name="capacity" /> 大于 <paramref name="maxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
        <altmember cref="P:System.Text.StringBuilder.MaxCapacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">用于初始化实例值的字符串。 如果 <paramref name="value" /> 为 <see langword="null" />，则新的 <see cref="T:System.Text.StringBuilder" /> 将包含空字符串（即包含 <see cref="F:System.String.Empty" />）。</param>
        <param name="capacity"><see cref="T:System.Text.StringBuilder" /> 的建议起始大小。</param>
        <summary>使用指定的字符串和容量初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `capacity`参数定义可存储在当前实例所分配的内存中的最大字符数。 它的值被分配给 <xref:System.Text.StringBuilder.Capacity%2A> 属性。 如果要存储在当前实例中的字符数超出此 `capacity` 值，则对象将 <xref:System.Text.StringBuilder> 分配额外的内存来存储它们。

 如果 `capacity` 为零，则使用特定于实现的默认容量。



## Examples
 下面的示例演示如何 <xref:System.Text.StringBuilder.%23ctor%2A> 使用初始字符串和指定的容量调用构造函数。

 [!code-cpp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#7)]
 [!code-csharp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#7)]
 [!code-vb[System.Text.StringBuilder.Constructors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#7)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> 小于零。</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 startIndex, int32 length, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, startIndex As Integer, length As Integer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int * int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, startIndex, length, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">字符串包含用于初始化此实例值的子字符串。 如果 <paramref name="value" /> 为 <see langword="null" />，则新的 <see cref="T:System.Text.StringBuilder" /> 将包含空字符串（即包含 <see cref="F:System.String.Empty" />）。</param>
        <param name="startIndex"><paramref name="value" /> 中子字符串开始的位置。</param>
        <param name="length">子字符串中的字符数。</param>
        <param name="capacity"><see cref="T:System.Text.StringBuilder" /> 的建议起始大小。</param>
        <summary>从指定的子字符串和容量初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `capacity`参数定义可存储在当前实例所分配的内存中的最大字符数。 它的值被分配给 <xref:System.Text.StringBuilder.Capacity%2A> 属性。 如果要存储在当前实例中的字符数超出此 `capacity` 值，则对象将 <xref:System.Text.StringBuilder> 分配额外的内存来存储它们。

 如果 `capacity` 为零，则使用特定于实现的默认容量。



## Examples
 下面的示例演示如何调用 <xref:System.Text.StringBuilder.%23ctor%2A> 具有指定字符串的构造函数。

 [!code-cpp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#6)]
 [!code-csharp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#6)]
 [!code-vb[System.Text.StringBuilder.Constructors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#6)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> 小于零。

- 或 -

 <paramref name="startIndex" /> 加 <paramref name="length" /> 不是 <paramref name="value" /> 中的位置。</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向此实例追加指定对象的字符串表示形式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(bool value);" />
      <MemberSignature Language="F#" Value="member this.Append : bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">要追加的布尔值。</param>
        <summary>向此实例追加指定的布尔值的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.Boolean%29>方法修改此类的现有实例，而不返回新的类实例。 因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb" id="Snippet2"::: 

 <xref:System.Text.StringBuilder.Append%28System.Boolean%29>方法调用 <xref:System.Boolean.ToString?displayProperty=nameWithType> 方法来获取的字符串表示形式 `value` 。 此实例的容量会根据需要进行调整。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Append : byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 8 位无符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.Byte%29>方法修改此类的现有实例，而不返回新的类实例。 因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs" interactive="try-dotnet-method" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb" id="Snippet3":::

 <xref:System.Text.StringBuilder.Append%28System.Byte%29>方法调用 <xref:System.Byte.ToString%28System.IFormatProvider%29> 方法为当前区域性获取的字符串表示形式 `value` 。 若要控制的格式 `value` ，请调用 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。

 此实例的容量会根据需要进行调整。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value);" />
      <MemberSignature Language="F#" Value="member this.Append : char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">要追加的 UTF 16 编码的代码单元。</param>
        <summary>将指定的 <see cref="T:System.Char" /> 对象的字符串表示形式追加到此实例。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.Char%29>方法修改此类的现有实例，而不返回新的类实例。 因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs" interactive="try-dotnet-method" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb" id="Snippet4":::

 此实例的容量会根据需要进行调整。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[]? value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">要追加的字符数组。</param>
        <summary>向此实例追加指定数组中的 Unicode 字符的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法将指定数组中的所有字符追加到当前实例，其顺序与它们在中出现的顺序相同 `value` 。 如果 `value` 为 `null` ，则不进行任何更改。

 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%29>方法修改此类的现有实例，而不返回新的类实例。 因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs" interactive="try-dotnet-method" id="Snippet6":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb" id="Snippet6"::: 

 此实例的容量会根据需要进行调整。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Append : decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的十进制数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.Decimal%29>方法修改此类的现有实例，而不返回新的类实例。 因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs" interactive="try-dotnet-method" id="Snippet8":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb" id="Snippet8":::

 <xref:System.Text.StringBuilder.Append%28System.Decimal%29>方法调用 <xref:System.Decimal.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 方法为当前区域性获取的字符串表示形式 `value` 。 若要控制的格式 `value` ，请调用 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。

 此实例的容量会根据需要进行调整。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(double value);" />
      <MemberSignature Language="F#" Value="member this.Append : double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的双精度浮点数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.Double%29>方法修改此类的现有实例，而不返回新的类实例。 因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs" interactive="try-dotnet-method" id="Snippet9":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb" id="Snippet9":::

 <xref:System.Text.StringBuilder.Append%28System.Double%29>方法调用 <xref:System.Double.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 方法为当前区域性获取的字符串表示形式 `value` 。 若要控制的格式 `value` ，请调用 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。

 此实例的容量会根据需要进行调整。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(short value);" />
      <MemberSignature Language="F#" Value="member this.Append : int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 16 位有符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.Int16%29>方法修改此类的现有实例，而不返回新的类实例。 因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs" interactive="try-dotnet-method" id="Snippet10":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb" id="Snippet10":::

 <xref:System.Text.StringBuilder.Append%28System.Int16%29>方法调用 <xref:System.Int16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 方法为当前区域性获取的字符串表示形式 `value` 。 若要控制的格式 `value` ，请调用 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。

 此实例的容量会根据需要进行调整。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(int value);" />
      <MemberSignature Language="F#" Value="member this.Append : int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 32 位有符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.Int32%29>方法修改此类的现有实例，而不返回新的类实例。 因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs" interactive="try-dotnet-method" id="Snippet11":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb" id="Snippet11"::: 

 <xref:System.Text.StringBuilder.Append%28System.Int32%29>方法调用 <xref:System.Int32.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 方法为当前区域性获取的字符串表示形式 `value` 。 若要控制的格式 `value` ，请调用 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。

 此实例的容量会根据需要进行调整。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(long value);" />
      <MemberSignature Language="F#" Value="member this.Append : int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 64 位有符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.Int64%29>方法修改此类的现有实例，而不返回新的类实例。 因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs" interactive="try-dotnet-method" id="Snippet12":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb" id="Snippet12":::

 <xref:System.Text.StringBuilder.Append%28System.Int64%29>方法调用 <xref:System.Int64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 以获取当前区域性的的字符串表示形式 `value` 。 若要控制的格式 `value` ，请调用 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。

 此实例的容量会根据需要进行调整。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (object value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (object? value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要追加的对象。</param>
        <summary>向此实例追加指定对象的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.Object%29>方法修改此类的现有实例，而不返回新的类实例。 因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。 它定义了一个 `Dog` 类，创建一个 `Dog` 对象，并对方法进行了三次调用， <xref:System.Text.StringBuilder.Append%2A> 以创建一个包含狗名称和同类的字符串。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append4.cs" interactive="try-dotnet" id="Snippet18":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append4.vb" id="Snippet18":::

 <xref:System.Text.StringBuilder.Append%28System.Object%29>方法调用 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法来获取的字符串表示形式 `value` 。 如果 `value` 为 `null` ，则不会对对象进行任何更改 <xref:System.Text.StringBuilder> 。

 此实例的容量会根据需要进行调整。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder? Append (ReadOnlyMemory&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlyMemory`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlyMemory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlyMemory(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlyMemory&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlyMemory&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlyMemory&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">要追加的只读字符内存区域。</param>
        <summary>向此实例追加指定的只读字符内存区域的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder? Append (ReadOnlySpan&lt;char&gt; value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlySpan&lt;char&gt; value);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">要追加的只读字符范围。</param>
        <summary>向此实例追加指定的只读字符范围的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Append : sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 8 位有符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.SByte%29>方法修改此类的现有实例，而不返回新的类实例。 因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs" interactive="try-dotnet-method" id="Snippet13":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb" id="Snippet13"::: 

 <xref:System.Text.StringBuilder.Append%28System.SByte%29>方法调用 <xref:System.SByte.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 方法为当前区域性获取的字符串表示形式 `value` 。 若要控制的格式 `value` ，请调用 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。

 此实例的容量会根据需要进行调整。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(float value);" />
      <MemberSignature Language="F#" Value="member this.Append : single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的单精度浮点数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.Single%29>方法修改此类的现有实例，而不返回新的类实例。 因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。

 [!code-csharp[System.Text.StringBuilder.Append#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#14)]
 [!code-vb[System.Text.StringBuilder.Append#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#14)]

 <xref:System.Text.StringBuilder.Append%28System.Single%29>方法调用 <xref:System.Single.ToString%2A?displayProperty=nameWithType> 方法为当前区域性获取的字符串表示形式 `value` 。 若要控制的格式 `value` ，请调用 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。

 此实例的容量会根据需要进行调整。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string? value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要追加的字符串。</param>
        <summary>向此实例追加指定字符串的副本。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.String%29>方法修改此类的现有实例，而不返回新的类实例。 因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb" id="Snippet2"::: 

 如果 `value` 为 `null` ，则不进行任何更改。

 此实例的容量会根据需要进行调整。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder? value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">要追加的字符串生成器。</param>
        <summary>向此实例追加指定的字符串生成器的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 16 位无符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.UInt16%29>方法修改此类的现有实例，而不返回新的类实例。 因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs" interactive="try-dotnet-method" id="Snippet15":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb" id="Snippet15":::

 <xref:System.Text.StringBuilder.Append%28System.UInt16%29>方法调用 <xref:System.UInt16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 方法来获取的字符串表示形式 `value` 。 若要控制的格式 `value` ，请调用 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。

 此实例的容量会根据需要进行调整。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 32 位无符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.UInt32%29>方法修改此类的现有实例，而不返回新的类实例。 因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs" interactive="try-dotnet-method" id="Snippet16":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb" id="Snippet16":::

 <xref:System.Text.StringBuilder.Append%28System.UInt32%29>调用 <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> 方法为当前区域性获取的字符串表示形式 `value` 。 若要控制的格式 `value` ，请调用 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。

 此实例的容量会根据需要进行调整。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 64 位无符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.UInt64%29>方法修改此类的现有实例，而不返回新的类实例。 因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs" interactive="try-dotnet-method" id="Snippet17":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb" id="Snippet17":::

 <xref:System.Text.StringBuilder.Append%28System.UInt64%29>方法调用 <xref:System.UInt64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 方法为当前区域性获取的字符串表示形式 `value` 。 若要控制的格式 `value` ，请调用 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。

 此实例的容量会根据需要进行调整。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value, int repeatCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value, int32 repeatCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char, repeatCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value, int repeatCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, repeatCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="repeatCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要追加的字符。</param>
        <param name="repeatCount">要追加 <paramref name="value" /> 的次数。</param>
        <summary>向此实例追加 Unicode 字符的字符串表示形式指定数目的副本。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.Char%2CSystem.Int32%29>方法修改此类的现有实例，而不返回新的类实例。 因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。

 [!code-csharp[System.Text.StringBuilder.Append#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#5)]
 [!code-vb[System.Text.StringBuilder.Append#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#5)]

 此实例的容量会根据需要进行调整。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="repeatCount" /> 小于零。

- 或 -

增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <exception cref="T:System.OutOfMemoryException">内存不足。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char* value, int valueCount);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char* value, int32 valueCount) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char*,System.Int32)" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char* value, int valueCount);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.Append : nativeptr&lt;char&gt; * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, valueCount)" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder? Append (char* value, int valueCount);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">指向字符数组的指针。</param>
        <param name="valueCount">数组中的字符数。</param>
        <summary>将从指定地址开始的 Unicode 字符数组追加到此实例。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法 `valueCount` 将从 address 开始的字符追加 `value` 到当前实例。

 <xref:System.Text.StringBuilder.Append%28System.Char%2A%2CSystem.Int32%29>方法修改此类的现有实例，而不返回新的类实例。 因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象。

 此实例的容量会根据需要进行调整。

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="valueCount" /> 小于零。

- 或 -

增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="value" /> 为 null 指针。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value, int startIndex, int charCount);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, charCount)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[]? value, int startIndex, int charCount);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">字符数组。</param>
        <param name="startIndex"><paramref name="value" /> 中的起始位置。</param>
        <param name="charCount">要追加的字符数。</param>
        <summary>向此实例追加指定的 Unicode 字符子数组的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法将指定范围的字符追加 `value` 到当前实例中。 如果 `value` 为 `null` 和 `startIndex` 且 `count` 均为零，则不进行任何更改。

 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>方法修改此类的现有实例，而不返回新的类实例。 因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs" interactive="try-dotnet-method" id="Snippet7":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb" id="Snippet7":::

 此实例的容量会根据需要进行调整。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />，且 <paramref name="startIndex" /> 和 <paramref name="charCount" /> 不为零。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> 小于零。

- 或 -

 <paramref name="startIndex" /> 小于零。

- 或 -

 <paramref name="startIndex" /> + <paramref name="charCount" /> 大于 <paramref name="value" /> 的长度。

- 或 -

增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value, int startIndex, int count);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string? value, int startIndex, int count);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">包含要追加的子字符串的字符串。</param>
        <param name="startIndex"><paramref name="value" /> 中子字符串开始的位置。</param>
        <param name="count">要追加的 <paramref name="value" /> 中的字符数。</param>
        <summary>向此实例追加指定子字符串的副本。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法将指定范围的字符追加 `value` 到当前实例中。 如果 `value` 为 `null` 和 `startIndex` 且 `count` 均为零，则不进行任何更改。

 <xref:System.Text.StringBuilder.Append%28System.String%2CSystem.Int32%2CSystem.Int32%29>方法修改此类的现有实例，而不返回新的类实例。 因此，你可以对现有引用调用方法或属性，并且不必将返回值分配给 <xref:System.Text.StringBuilder> 对象，如下面的示例所示。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs" interactive="try-dotnet-method" id="Snippet19":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb" id="Snippet19"::: 

 此实例的容量会根据需要进行调整。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />，且 <paramref name="startIndex" /> 和 <paramref name="count" /> 不为零。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 小于零。

- 或 -

 <paramref name="startIndex" /> 小于零。

- 或 -

 <paramref name="startIndex" /> + <paramref name="count" /> 大于 <paramref name="value" /> 的长度。

- 或 -

增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder? value, int startIndex, int count);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value, int startIndex, int count);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">包含要追加的子字符串的字符串生成器。</param>
        <param name="startIndex"><paramref name="value" /> 中子字符串开始的位置。</param>
        <param name="count">要追加的 <paramref name="value" /> 中的字符数。</param>
        <summary>向此实例追加指定字符串生成器中的子字符串副本。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendFormat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都由相应的对象自变量的字符串表示形式替换。</summary>
        <related type="Article" href="/dotnet/standard/base-types/composite-formatting">复合格式设置</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">标准数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">自定义数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-date-and-time-format-strings">标准日期和时间格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-date-and-time-format-strings">自定义日期和时间格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-timespan-format-strings">标准 TimeSpan 格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-timespan-format-strings">自定义的 TimeSpan 格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/enumeration-format-strings">枚举格式字符串</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object? arg0);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">复合格式字符串。</param>
        <param name="arg0">要设置其格式的对象。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都替换为一个自变量的字符串表示形式。</summary>
        <returns>对追加了 <paramref name="format" /> 的此实例的引用。 <paramref name="format" /> 中的每个格式项都替换为 <paramref name="arg0" /> 的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法使用 .NET Framework 的 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将对象的值转换为其文本表示形式，并将该表示形式嵌入到当前 <xref:System.Text.StringBuilder> 对象中。

 `format`参数包含与零个或多个索引占位符（称为格式项）混合的零个或多个文本的运行。 格式项的索引必须为0，以对应于 `arg0` 此方法的参数列表中的单个对象。 格式设置过程将每个格式项替换为的字符串表示形式 `arg0` 。

 格式项的语法如下所示：

 {*index*[，*length*] [：*格式字符串*]}

 括号中的元素是可选的。 下表对每个元素进行了描述。

|元素|描述|
|-------------|-----------------|
|*index*|要设置格式的对象的参数列表中的从零开始的位置。 如果由 *index* 指定的对象为 `null` ，则会将格式项替换为 <xref:System.String.Empty?displayProperty=nameWithType> 。 如果 *索引* 位置中没有参数， <xref:System.FormatException> 则会引发。|
|，*长度*|参数的字符串表示形式中的最小字符数。 如果为正，则参数为右对齐; 否则为。如果为负，则为左对齐。|
|：*格式字符串*|参数支持的标准或自定义格式字符串。|

> [!NOTE]
>  对于用于日期和时间值的标准和自定义格式字符串，请参阅 [标准日期和时间格式](/dotnet/standard/base-types/standard-date-and-time-format-strings) 字符串和 [自定义日期和时间格式字符串](/dotnet/standard/base-types/custom-date-and-time-format-strings)。 对于与数值一起使用的标准和自定义格式字符串，请参阅 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 和 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。 对于用于枚举的标准格式字符串，请参阅 [枚举格式字符串](/dotnet/standard/base-types/enumeration-format-strings)。

 `arg0` 表示要设置格式的对象。 中的每个格式项 `format` 都替换为的字符串表示形式 `arg0` 。 如果格式项包含 `formatString` 并 `arg0` 实现 <xref:System.IFormattable> 接口，则 `arg0.ToString(formatString, null)` 定义格式设置。 否则，会 `arg0.ToString()` 定义格式设置。

 如果分配给的字符串 `format` 为 "感谢你向慈善组织捐赠 {0： # # # #} 个食物 和 `arg0` 是一个值为10的整数，则返回值将为 "感谢你向慈善组织捐赠10罐食物"。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 无效。

- 或 -

格式项的索引小于 0（零），或者大于或等于 1。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">设置 .NET 中类型的格式</related>
        <related type="Article" href="/dotnet/standard/base-types/composite-formatting">复合格式设置</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">标准数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">自定义数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-date-and-time-format-strings">标准日期和时间格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-date-and-time-format-strings">自定义日期和时间格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-timespan-format-strings">标准 TimeSpan 格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-timespan-format-strings">自定义的 TimeSpan 格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/enumeration-format-strings">枚举格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, params object[] args);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, args)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, params object[]? args);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">复合格式字符串。</param>
        <param name="args">要设置其格式的对象的数组。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都由参数数组中相应参数的字符串表示形式替换。</summary>
        <returns>对追加了 <paramref name="format" /> 的此实例的引用。 <paramref name="format" /> 中的每个格式项都由相应的对象参数的字符串表示形式替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法使用 .NET Framework 的 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将对象的值转换为其文本表示形式，并将该表示形式嵌入到当前 <xref:System.Text.StringBuilder> 对象中。

 `format`参数包含与零个或多个索引占位符（称为格式项）混合的零个或多个文本的运行，这些占位符与此方法的参数列表中的对象相对应。 格式设置过程将每个格式项替换为相应对象的字符串表示形式。

 格式项的语法如下所示：

 {*index*[，*length*] [：*格式字符串*]}

 括号中的元素是可选的。 下表对每个元素进行了描述。

|元素|描述|
|-------------|-----------------|
|*index*|要设置格式的对象的参数列表中的从零开始的位置。 如果由 *index* 指定的对象为 `null` ，则会将格式项替换为 <xref:System.String.Empty?displayProperty=nameWithType> 。 如果 *索引* 位置中没有参数， <xref:System.FormatException> 则会引发。|
|，*长度*|参数的字符串表示形式中的最小字符数。 如果为正，则参数为右对齐; 否则为。如果为负，则为左对齐。|
|：*格式字符串*|参数支持的标准或自定义格式字符串。|

> [!NOTE]
>  对于用于日期和时间值的标准和自定义格式字符串，请参阅 [标准日期和时间格式](/dotnet/standard/base-types/standard-date-and-time-format-strings) 字符串和 [自定义日期和时间格式字符串](/dotnet/standard/base-types/custom-date-and-time-format-strings)。 对于与数值一起使用的标准和自定义格式字符串，请参阅 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 和 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。 对于用于枚举的标准格式字符串，请参阅 [枚举格式字符串](/dotnet/standard/base-types/enumeration-format-strings)。

 `args` 表示要设置格式的对象。 中的每个格式项 `format` 都替换为中相应对象的字符串表示形式 `args` 。 如果格式项包括 `formatString` ，并且中的相应对象 `args` 实现 <xref:System.IFormattable> 接口，则 `args[index].ToString(formatString, provider)` 定义格式设置。 否则，会 `args[index].ToString()` 定义格式设置。

 如果分配给的字符串 `format` 为 "感谢你向慈善组织捐赠 {0： # # # #} 个食物 和 `arg0` 是一个值为10的整数，则返回值将为 "感谢你向慈善组织捐赠10罐食物"。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 或 <paramref name="args" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 无效。

- 或 -

格式项的索引小于 0（零），或者大于或等于 <paramref name="args" /> 数组的长度。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">设置 .NET 中类型的格式</related>
        <related type="Article" href="/dotnet/standard/base-types/composite-formatting">复合格式设置</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">标准数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">自定义数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-date-and-time-format-strings">标准日期和时间格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-date-and-time-format-strings">自定义日期和时间格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-timespan-format-strings">标准 TimeSpan 格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-timespan-format-strings">自定义的 TimeSpan 格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/enumeration-format-strings">枚举格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider? provider, string format, object? arg0);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <param name="format">复合格式字符串。</param>
        <param name="arg0">要设置格式的对象。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都使用指定的格式提供程序替换为单个参数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。 完成追加操作后，此实例包含执行该操作之前已存在的任何数据，并且有一个 <paramref name="format" /> 的副本作为后缀，其中任何格式规范都由 <paramref name="arg0" /> 的字符串表示形式替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法使用 .NET Framework 的  [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将的值转换 `arg0` 为其文本表示形式，并将该表示形式嵌入到当前 <xref:System.Text.StringBuilder> 对象中。

 `format`参数包含与零个或多个索引占位符（称为格式项）混合的零个或多个文本的运行。 每个格式项的索引必须为零 (0) ，因为此方法包含一个带有单个参数的参数列表。 格式设置过程将每个格式项替换为的字符串表示形式 `arg0` 。

 格式项的语法如下所示：

 {*index*[，*length*] [：*格式字符串*]}

 括号中的元素是可选的。 下表对每个元素进行了描述。

|元素|描述|
|-------------|-----------------|
|*index*|要设置格式的对象的参数列表中的从零开始的位置。 如果由 *index* 指定的对象为 `null` ，则会将格式项替换为 <xref:System.String.Empty?displayProperty=nameWithType> 。 在这种情况下，因为 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> 方法在参数列表中有一个参数，所以 *index* 的值必须始终为0。 如果不是，则 <xref:System.FormatException> 会引发。|
|，*长度*|参数的字符串表示形式中的最小字符数。 如果为正，则参数为右对齐; 否则为。如果为负，则为左对齐。|
|：*格式字符串*|参数支持的标准或自定义格式字符串。|

> [!NOTE]
>  对于用于日期和时间值的标准和自定义格式字符串，请参阅 [标准日期和时间格式](/dotnet/standard/base-types/standard-date-and-time-format-strings) 字符串和 [自定义日期和时间格式字符串](/dotnet/standard/base-types/custom-date-and-time-format-strings)。 对于与数值一起使用的标准和自定义格式字符串，请参阅 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 和 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。 对于用于枚举的标准格式字符串，请参阅 [枚举格式字符串](/dotnet/standard/base-types/enumeration-format-strings)。

 `provider`参数指定一个 <xref:System.IFormatProvider> 实现，该实现可以为中的对象提供格式设置信息 `args` 。 `provider` 可以是以下任意形式：

-   一个 <xref:System.Globalization.CultureInfo> 对象，提供区域性特定的格式设置信息。

-   一个 <xref:System.Globalization.NumberFormatInfo> 对象，它提供有关的区域性特定格式设置信息 `arg0` 。

-   一个 <xref:System.Globalization.DateTimeFormatInfo> 对象，它提供有关的区域性特定格式设置信息 `arg0` 。

-   <xref:System.IFormatProvider>为提供格式设置信息的自定义 `arg0` 实现。 通常，此类实现还实现 <xref:System.ICustomFormatter> 接口。

 如果 `provider` 参数为 `null` ，则从当前区域性获取格式设置信息。

 `arg0` 表示要设置格式的对象。 中的每个格式项 `format` 都替换为的字符串表示形式 `arg0` 。 如果格式项包含 `formatString` 并 `arg0` 实现 <xref:System.IFormattable> 接口，则 `arg0.ToString(formatString, provider)` 定义格式设置。 否则，会 `arg0.ToString()` 定义格式设置。



## Examples
 下面包括对方法的两次调用 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> 。 两者都使用 English-Great 英国 (en-GB) 区域性的格式约定。 第一个在 <xref:System.Decimal> 结果字符串中插入货币值的字符串表示形式。 第二个将 <xref:System.DateTime> 值插入到结果字符串中的两个位置，第一个是只包含短日期字符串，第二个在短时间字符串中。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat1.cs" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat1.vb" id="Snippet2":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 无效。

- 或 -

格式项的索引小于 0（零），或者大于等于一 (1)。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">设置 .NET 中类型的格式</related>
        <related type="Article" href="/dotnet/standard/base-types/composite-formatting">复合格式设置</related>
        <related type="Article" href="/dotnet/standard/base-types/how-to-define-and-use-custom-numeric-format-providers">如何：定义和使用自定义数值格式提供程序</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">标准数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">自定义数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-date-and-time-format-strings">标准日期和时间格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-date-and-time-format-strings">自定义日期和时间格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-timespan-format-strings">标准 TimeSpan 格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-timespan-format-strings">自定义的 TimeSpan 格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/enumeration-format-strings">枚举格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, params object[] args);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, args)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider? provider, string format, params object[]? args);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <param name="format">复合格式字符串。</param>
        <param name="args">要设置其格式的对象的数组。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都使用指定的格式提供程序由参数数组中相应参数的字符串表示形式替换。</summary>
        <returns>完成追加操作后对此实例的引用。 完成追加操作后，此实例包含执行该操作之前已存在的任何数据，并且有一个 <paramref name="format" /> 的副本作为后缀，其中任何格式规范都由相应对象参数的字符串表示形式替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法使用 .NET Framework 的 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将对象的值转换为其文本表示形式，并将该表示形式嵌入到当前 <xref:System.Text.StringBuilder> 对象中。

 `format`参数包含与零个或多个索引占位符（称为格式项）混合的零个或多个文本的运行，这些占位符与此方法的参数列表中的对象相对应。 格式设置过程将每个格式项替换为相应对象的字符串表示形式。

 格式项的语法如下所示：

 {*index*[，*length*] [：*格式字符串*]}

 括号中的元素是可选的。 下表对每个元素进行了描述。

|元素|描述|
|-------------|-----------------|
|*index*|要设置格式的对象的参数列表中的从零开始的位置。 如果由 *index* 指定的对象为 `null` ，则会将格式项替换为 <xref:System.String.Empty?displayProperty=nameWithType> 。 如果 *索引* 位置中没有参数， <xref:System.FormatException> 则会引发。|
|，*长度*|参数的字符串表示形式中的最小字符数。 如果为正，则参数为右对齐; 否则为。如果为负，则为左对齐。|
|：*格式字符串*|参数支持的标准或自定义格式字符串。|

> [!NOTE]
>  对于用于日期和时间值的标准和自定义格式字符串，请参阅 [标准日期和时间格式](/dotnet/standard/base-types/standard-date-and-time-format-strings) 字符串和 [自定义日期和时间格式字符串](/dotnet/standard/base-types/custom-date-and-time-format-strings)。 对于与数值一起使用的标准和自定义格式字符串，请参阅 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 和 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。 对于用于枚举的标准格式字符串，请参阅 [枚举格式字符串](/dotnet/standard/base-types/enumeration-format-strings)。

 `provider`参数指定一个 <xref:System.IFormatProvider> 实现，该实现可以为中的对象提供格式设置信息 `args` 。 `provider` 可以是以下任意形式：

-   一个 <xref:System.Globalization.CultureInfo> 对象，提供区域性特定的格式设置信息。

-   一个 <xref:System.Globalization.NumberFormatInfo> 对象，该对象为中的数字值提供区域性特定的格式设置信息 `args` 。

-   一个 <xref:System.Globalization.DateTimeFormatInfo> 对象，该对象为中的日期和时间值提供区域性特定的格式设置信息 `args` 。

-   为 <xref:System.IFormatProvider> 中的一个或多个对象提供格式设置信息的自定义实现 `args` 。 通常，此类实现还实现 <xref:System.ICustomFormatter> 接口。 下一节中的第二个示例演示了 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> 使用自定义实现的方法调用 <xref:System.IFormatProvider> 。

 如果 `provider` 参数为 `null` ，则从当前区域性获取格式提供程序信息。

 `args` 表示要设置格式的对象。 中的每个格式项 `format` 都替换为中相应对象的字符串表示形式 `args` 。 如果格式项包括 `formatString` ，并且中的相应对象 `args` 实现 <xref:System.IFormattable> 接口，则 `args[index].ToString(formatString, provider)` 定义格式设置。 否则，会 `args[index].ToString()` 定义格式设置。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb" id="Snippet1":::

 下面的示例定义了一个 <xref:System.IFormatProvider> 名为的自定义实现 `CustomerFormatter` ，该实现在第四个和第七个数字后设置一个包含连字符的10位客户编号 它被传递给 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> 方法以创建一个字符串，该字符串包含带格式的客户编号和客户名称。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/customernumberformatter1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/customernumberformatter1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 无效。

- 或 -

格式项的索引小于 0（零），或者大于或等于 <paramref name="args" /> 数组的长度。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">设置 .NET 中类型的格式</related>
        <related type="Article" href="/dotnet/standard/base-types/composite-formatting">复合格式设置</related>
        <related type="Article" href="/dotnet/standard/base-types/how-to-define-and-use-custom-numeric-format-providers">如何：定义和使用自定义数值格式提供程序</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">标准数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">自定义数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-date-and-time-format-strings">标准日期和时间格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-date-and-time-format-strings">自定义日期和时间格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-timespan-format-strings">标准 TimeSpan 格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-timespan-format-strings">自定义的 TimeSpan 格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/enumeration-format-strings">枚举格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object? arg0, object? arg1);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">复合格式字符串。</param>
        <param name="arg0">要设置格式的第一个对象。</param>
        <param name="arg1">要设置格式的第二个对象。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都替换为这两个参数中任意一个参数的字符串表示形式。</summary>
        <returns>对追加了 <paramref name="format" /> 的此实例的引用。 <paramref name="format" /> 中的每个格式项都由相应的对象参数的字符串表示形式替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法使用 .NET Framework 的 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将对象的值转换为其文本表示形式，并将该表示形式嵌入到当前 <xref:System.Text.StringBuilder> 对象中。

 `format`参数包含与零个或多个索引占位符（称为格式项）混合的零个或多个文本的运行 `arg0` ， `arg1` 这两个对象分别与此方法的参数列表中的两个对象相对应。 格式设置过程将每个格式项替换为相应对象的字符串表示形式。

 格式项的语法如下所示：

 {*index*[，*length*] [：*格式字符串*]}

 括号中的元素是可选的。 下表对每个元素进行了描述。

|元素|描述|
|-------------|-----------------|
|*index*|要设置格式的对象的参数列表中的从零开始的位置。 如果由 *index* 指定的对象为 `null` ，则会将格式项替换为 <xref:System.String.Empty?displayProperty=nameWithType> 。 如果 *索引* 位置中没有参数， <xref:System.FormatException> 则会引发。|
|，*长度*|参数的字符串表示形式中的最小字符数。 如果为正，则参数为右对齐; 否则为。如果为负，则为左对齐。|
|：*格式字符串*|参数支持的标准或自定义格式字符串。|

> [!NOTE]
>  对于用于日期和时间值的标准和自定义格式字符串，请参阅 [标准日期和时间格式](/dotnet/standard/base-types/standard-date-and-time-format-strings) 字符串和 [自定义日期和时间格式字符串](/dotnet/standard/base-types/custom-date-and-time-format-strings)。 对于与数值一起使用的标准和自定义格式字符串，请参阅 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 和 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。 对于用于枚举的标准格式字符串，请参阅 [枚举格式字符串](/dotnet/standard/base-types/enumeration-format-strings)。

 `arg0` 和 `arg1` 表示要设置格式的对象。 中的每个格式项 `format` 都替换为或的字符串表示形式 `arg0` `arg1` 。 如果格式项包括， `formatString` 并且相应的对象实现 <xref:System.IFormattable> 接口，则 `arg` *x* `.ToString(formatString, provider)` 定义格式设置，其中 *x* 是参数的索引。 否则， `arg` *x* `.ToString()` 定义格式设置。

 如果分配给的字符串 `format` 为 "感谢你向慈善组织捐赠 {0： # # # #} 个食物 和 `arg0` 是一个值为10的整数，则返回值将为 "感谢你向慈善组织捐赠10罐食物"。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 无效。

- 或 -

格式项的索引小于 0（零），或者大于等于 2。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">设置 .NET 中类型的格式</related>
        <related type="Article" href="/dotnet/standard/base-types/composite-formatting">复合格式设置</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">标准数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">自定义数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-date-and-time-format-strings">标准日期和时间格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-date-and-time-format-strings">自定义日期和时间格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-timespan-format-strings">标准 TimeSpan 格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-timespan-format-strings">自定义的 TimeSpan 格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/enumeration-format-strings">枚举格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder? AppendFormat (IFormatProvider provider, string? format, object arg0, object arg1);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <param name="format">复合格式字符串。</param>
        <param name="arg0">要设置格式的第一个对象。</param>
        <param name="arg1">要设置格式的第二个对象。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都使用指定的格式提供程序替换为两个参数中任一个的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。 完成追加操作后，此实例包含执行该操作之前已存在的任何数据，并且有一个 <paramref name="format" /> 的副本作为后缀，其中任何格式规范都由相应对象参数的字符串表示形式替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法使用 .NET Framework 的 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将对象的值转换为其文本表示形式，并将该表示形式嵌入到当前 <xref:System.Text.StringBuilder> 对象中。

 `format`参数包含与零个或多个索引占位符（称为格式项）混合的零个或多个文本的运行，这些占位符与此方法的参数列表中的对象相对应。 格式设置过程将每个格式项替换为相应对象的字符串表示形式。

 格式项的语法如下所示：

 {*index*[，*length*] [：*格式字符串*]}

 括号中的元素是可选的。 下表对每个元素进行了描述。

|元素|描述|
|-------------|-----------------|
|*index*|要设置格式的对象的参数列表中的从零开始的位置。 如果由 *index* 指定的对象为 `null` ，则会将格式项替换为 <xref:System.String.Empty?displayProperty=nameWithType> 。 如果 *索引* 位置中没有参数， <xref:System.FormatException> 则会引发。|
|，*长度*|参数的字符串表示形式中的最小字符数。 如果为正，则参数为右对齐; 否则为。如果为负，则为左对齐。|
|：*格式字符串*|参数支持的标准或自定义格式字符串。|

> [!NOTE]
>  对于用于日期和时间值的标准和自定义格式字符串，请参阅 [标准日期和时间格式](/dotnet/standard/base-types/standard-date-and-time-format-strings) 字符串和 [自定义日期和时间格式字符串](/dotnet/standard/base-types/custom-date-and-time-format-strings)。 对于与数值一起使用的标准和自定义格式字符串，请参阅 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 和 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。 对于用于枚举的标准格式字符串，请参阅 [枚举格式字符串](/dotnet/standard/base-types/enumeration-format-strings)。

 `provider`参数指定 <xref:System.IFormatProvider> 可为和提供格式设置信息的实现 `arg0` `arg1` 。 `provider` 可以是以下任意形式：

-   一个 <xref:System.Globalization.CultureInfo> 对象，提供区域性特定的格式设置信息。

-   一个 <xref:System.Globalization.NumberFormatInfo> 对象，它为提供区域性特定的格式设置信息， `arg0` `arg1` 如果它们是数字值，则为。

-   一个 <xref:System.Globalization.DateTimeFormatInfo> 对象，它为提供区域性特定的格式设置信息，或者，为 `arg0` `arg1` 日期和时间值。

-   为 <xref:System.IFormatProvider> 和提供格式设置信息的自定义实现 `arg0` `arg1` 。 通常，此类实现还实现 <xref:System.ICustomFormatter> 接口。

 如果 `provider` 参数为 `null` ，则从当前区域性获取格式提供程序信息。

 `arg0` 和 `arg1` 表示要设置格式的对象。 中的每个格式项 `format` 都替换为具有相应索引的对象的字符串表示形式。 如果格式项包括 `formatString` ，并且相应的参数实现了 <xref:System.IFormattable> 接口，则参数的 `ToString(formatString, provider)` 方法会定义格式设置。 否则，自变量的 `ToString()` 方法定义格式设置。



## Examples
 下面的示例使用 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%29> 方法来显示通用对象中存储的时间和温度数据 <xref:System.Collections.Generic.Dictionary%602> 。 请注意，格式字符串具有三个格式项，但仅有要设置格式的对象。 这是因为列表中的第一个对象 (日期和时间值) 由两个格式项使用：第一个格式项显示时间，第二个对象显示日期。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat2.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat2.vb" id="Snippet3":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 无效。

- 或 -

格式项的索引小于 0（零）或者大于或等于 2。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和在 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">设置 .NET 中类型的格式</related>
        <related type="Article" href="/dotnet/standard/base-types/composite-formatting">复合格式设置</related>
        <related type="Article" href="/dotnet/standard/base-types/how-to-define-and-use-custom-numeric-format-providers">如何：定义和使用自定义数值格式提供程序</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">标准数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">自定义数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-date-and-time-format-strings">标准日期和时间格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-date-and-time-format-strings">自定义日期和时间格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-timespan-format-strings">标准 TimeSpan 格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-timespan-format-strings">自定义的 TimeSpan 格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/enumeration-format-strings">枚举格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1, object arg2);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1, arg2)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder? AppendFormat (string? format, object arg0, object arg1, object arg2);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">复合格式字符串。</param>
        <param name="arg0">要设置格式的第一个对象。</param>
        <param name="arg1">要设置格式的第二个对象。</param>
        <param name="arg2">要设置格式的第三个对象。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都替换为这三个参数中任意一个参数的字符串表示形式。</summary>
        <returns>对追加了 <paramref name="format" /> 的此实例的引用。 <paramref name="format" /> 中的每个格式项都由相应的对象参数的字符串表示形式替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法使用 .NET Framework 的 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将对象的值转换为其文本表示形式，并将该表示形式嵌入到当前 <xref:System.Text.StringBuilder> 对象中。

 参数由零个或多个包含零个或 `format` 多个索引占位符（称为格式项，它们对应于 `arg0` `arg2` ），这种方法的参数列表中的对象组成。 格式设置过程将每个格式项替换为相应对象的字符串表示形式。

 格式项的语法如下所示：

 {*index*[，*length*] [：*格式字符串*]}

 括号中的元素是可选的。 下表对每个元素进行了描述。

|元素|描述|
|-------------|-----------------|
|*index*|要设置格式的对象的参数列表中的从零开始的位置。 如果由 *index* 指定的对象为 `null` ，则会将格式项替换为 <xref:System.String.Empty?displayProperty=nameWithType> 。 如果 *索引* 位置中没有参数， <xref:System.FormatException> 则会引发。|
|，*长度*|参数的字符串表示形式中的最小字符数。 如果为正，则参数为右对齐; 否则为。如果为负，则为左对齐。|
|：*格式字符串*|参数支持的标准或自定义格式字符串。|

> [!NOTE]
>  对于用于日期和时间值的标准和自定义格式字符串，请参阅 [标准日期和时间格式](/dotnet/standard/base-types/standard-date-and-time-format-strings) 字符串和 [自定义日期和时间格式字符串](/dotnet/standard/base-types/custom-date-and-time-format-strings)。 对于与数值一起使用的标准和自定义格式字符串，请参阅 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 和 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。 对于用于枚举的标准格式字符串，请参阅 [枚举格式字符串](/dotnet/standard/base-types/enumeration-format-strings)。

 `arg0`、 `arg1` 和 `arg2` 表示要设置格式的对象。 中的每个格式项 `format` 都替换为、或的字符串表示形式， `arg0` `arg1` `arg2` 具体取决于格式项的索引。 如果格式项包括， `formatString` 并且中的相应对象 `args` 实现 <xref:System.IFormattable> 接口，则 `arg` *x* `.ToString(formatString, null)` 定义格式设置，其中 *x* 是参数的索引。 否则， `arg` *x* `.ToString()` 定义格式设置。

 如果分配给的字符串 `format` 为 "感谢你向慈善组织捐赠 {0： # # # #} 个食物 和 `arg0` 是一个值为10的整数，则返回值将为 "感谢你向慈善组织捐赠10罐食物"。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.AppendFormat%2A> 方法。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 无效。

- 或 -

格式项的索引小于 0（零）或者大于或等于 3。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">设置 .NET 中类型的格式</related>
        <related type="Article" href="/dotnet/standard/base-types/composite-formatting">复合格式设置</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">标准数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">自定义数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-date-and-time-format-strings">标准日期和时间格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-date-and-time-format-strings">自定义日期和时间格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-timespan-format-strings">标准 TimeSpan 格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-timespan-format-strings">自定义的 TimeSpan 格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/enumeration-format-strings">枚举格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1, arg2)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder? AppendFormat (IFormatProvider provider, string? format, object arg0, object arg1, object arg2);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="4" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <param name="format">复合格式字符串。</param>
        <param name="arg0">要设置格式的第一个对象。</param>
        <param name="arg1">要设置格式的第二个对象。</param>
        <param name="arg2">要设置格式的第三个对象。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都使用指定的格式提供程序替换为三个参数中任一个的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。 完成追加操作后，此实例包含执行该操作之前已存在的任何数据，并且有一个 <paramref name="format" /> 的副本作为后缀，其中任何格式规范都由相应对象参数的字符串表示形式替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法使用 .NET Framework 的 [复合格式设置功能](/dotnet/standard/base-types/composite-formatting) 将对象的值转换为其文本表示形式，并将该表示形式嵌入到当前 <xref:System.Text.StringBuilder> 对象中。

 `format`参数包含与零个或多个索引占位符（称为格式项）混合的零个或多个文本的运行，这些占位符与此方法的参数列表中的对象相对应。 格式设置过程将每个格式项替换为相应对象的字符串表示形式。

 格式项的语法如下所示：

 {*index*[，*length*] [：*格式字符串*]}

 括号中的元素是可选的。 下表对每个元素进行了描述。

|元素|描述|
|-------------|-----------------|
|*index*|要设置格式的对象的参数列表中的从零开始的位置。 如果由 *index* 指定的对象为 `null` ，则会将格式项替换为 <xref:System.String.Empty?displayProperty=nameWithType> 。 如果 *索引* 位置中没有参数， <xref:System.FormatException> 则会引发。|
|，*长度*|参数的字符串表示形式中的最小字符数。 如果为正，则参数为右对齐; 否则为。如果为负，则为左对齐。|
|：*格式字符串*|参数支持的标准或自定义格式字符串。|

> [!NOTE]
>  对于用于日期和时间值的标准和自定义格式字符串，请参阅 [标准日期和时间格式](/dotnet/standard/base-types/standard-date-and-time-format-strings) 字符串和 [自定义日期和时间格式字符串](/dotnet/standard/base-types/custom-date-and-time-format-strings)。 对于与数值一起使用的标准和自定义格式字符串，请参阅 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 和 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。 对于用于枚举的标准格式字符串，请参阅 [枚举格式字符串](/dotnet/standard/base-types/enumeration-format-strings)。

 `provider`参数指定 <xref:System.IFormatProvider> 可为和提供格式设置信息的实现 `arg0` `arg1` 。 `provider` 可以是以下任意形式：

-   一个 <xref:System.Globalization.CultureInfo> 对象，提供区域性特定的格式设置信息。

-   一个 <xref:System.Globalization.NumberFormatInfo> 对象，它为提供区域性特定的格式设置信息， `arg0` `arg1` 如果它们是数字值，则为。

-   一个 <xref:System.Globalization.DateTimeFormatInfo> 对象，提供、或的区域性特定格式设置信息 `arg0` ， `arg1` `arg2` 如果它们是日期和时间值，则为。

-   <xref:System.IFormatProvider>提供、和的格式设置信息的自定义实现 `arg0` `arg1` `arg2` 。 通常，此类实现还实现 <xref:System.ICustomFormatter> 接口。

 如果 `provider` 参数为 `null` ，则从当前区域性获取格式提供程序信息。

 `arg0`、 `arg1` 和 `arg2` 表示要设置格式的对象。 中的每个格式项 `format` 都替换为具有相应索引的对象的字符串表示形式。 如果格式项包括 `formatString` ，并且相应的参数实现了 <xref:System.IFormattable> 接口，则参数的 `ToString(formatString, provider)` 方法会定义格式设置。 否则，自变量的 `ToString()` 方法定义格式设置。



## Examples
 下面的示例使用 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> 方法来说明 `And` 具有整数值的布尔运算的结果。 请注意，格式字符串包含六个格式项，但该方法在其参数列表中只有三个项，因为每个项都以两种不同的方式进行格式化。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat3.cs" interactive="try-dotnet" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat3.vb" id="Snippet4":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 无效。

- 或 -

格式项的索引小于 0（零）或者大于或等于 3。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">设置 .NET 中类型的格式</related>
        <related type="Article" href="/dotnet/standard/base-types/composite-formatting">复合格式设置</related>
        <related type="Article" href="/dotnet/standard/base-types/how-to-define-and-use-custom-numeric-format-providers">如何：定义和使用自定义数值格式提供程序</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">标准数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">自定义数字格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-date-and-time-format-strings">标准日期和时间格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-date-and-time-format-strings">自定义日期和时间格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-timespan-format-strings">标准 TimeSpan 格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-timespan-format-strings">自定义的 TimeSpan 格式字符串</related>
        <related type="Article" href="/dotnet/standard/base-types/enumeration-format-strings">枚举格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params object[]? values);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params object[] values);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">要用作分隔符的字符。 <paramref name="separator" /> 包括在联接的字符串中（仅当 <paramref name="values" /> 具有多个元素时）。</param>
        <param name="values">一个数组，包含要连接和附加到字符串生成器的当前实例的字符串。</param>
        <summary>使用各成员之间指定的字符分隔符连接所提供的对象数组中的元素的字符串表示形式，然后将结果附加到字符串生成器的当前实例。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params string[]? values);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params string[] values);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="values" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">要用作分隔符的字符。 <paramref name="separator" /> 包括在联接的字符串中（仅当 <paramref name="values" /> 具有多个元素时）。</param>
        <param name="values">一个数组，包含要连接和附加到字符串生成器的当前实例的字符串。</param>
        <summary>使用各字符串之间指定的字符分隔符连接所提供的数组的字符串，然后将结果附加到字符串生成器的当前实例。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string? separator, params object[]? values);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params object[] values);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">要用作分隔符的字符串。 <paramref name="separator" /> 包括在联接的字符串中（仅当 <paramref name="values" /> 具有多个元素时）。</param>
        <param name="values">一个数组，包含要连接和附加到字符串生成器的当前实例的字符串。</param>
        <summary>使用各成员之间指定的分隔符连接所提供的对象数组中的元素的字符串表示形式，然后将结果附加到字符串生成器的当前实例。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string? separator, params string[]? values);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params string[] values);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="values" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">要用作分隔符的字符串。 <paramref name="separator" /> 包括在联接的字符串中（仅当 <paramref name="values" /> 具有多个元素时）。</param>
        <param name="values">一个数组，包含要连接和附加到字符串生成器的当前实例的字符串。</param>
        <summary>使用各字符串之间指定的分隔符连接所提供的数组的字符串，然后将结果附加到字符串生成器的当前实例。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As Char, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><paramref name="values" /> 成员的类型。</typeparam>
        <param name="separator">要用作分隔符的字符。 <paramref name="separator" /> 包括在连接和附加的字符串中（仅当 <paramref name="values" /> 具有多个元素时）。</param>
        <param name="values">一个集合，包含要连接和附加到字符串生成器的当前实例的对象。</param>
        <summary>使用各成员之间指定的字符分隔符连接和附加集合的成员。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (string? separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As String, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><paramref name="values" /> 成员的类型。</typeparam>
        <param name="separator">要用作分隔符的字符串。 <paramref name="separator" /> 包括在连接和附加的字符串中（仅当 <paramref name="values" /> 具有多个元素时）。</param>
        <param name="values">一个集合，包含要连接和附加到字符串生成器的当前实例的对象。</param>
        <summary>使用各成员之间指定的分隔符连接和附加集合的成员。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendLine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将默认的行终止符（或指定字符串的副本和默认的行终止符）追加到此实例的末尾。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine();" />
      <MemberSignature Language="F#" Value="member this.AppendLine : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将默认的行终止符追加到当前 <see cref="T:System.Text.StringBuilder" /> 对象的末尾。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 默认的行终止符是属性的当前值 <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> 。

 此实例的容量会根据需要进行调整。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.AppendLine%2A> 方法。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendline/CPP/al.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendline/CS/al.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendline/VB/al.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine (string value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendLine : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine value" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine (string? value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要追加的字符串。</param>
        <summary>将后面跟有默认行终止符的指定字符串的副本追加到当前 <see cref="T:System.Text.StringBuilder" /> 对象的末尾。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 默认的行终止符是属性的当前值 <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> 。

 此实例的容量会根据需要进行调整。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <see cref="T:System.Text.StringBuilder" /> 通过调用构造函数实例化对象时， <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 实例的长度和容量 <see cref="T:System.Text.StringBuilder" /> 可能会超出其属性的值 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 当调用 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 和 <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 方法追加小字符串时，尤其如此。</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Text.StringBuilder.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置可包含在当前实例所分配的内存中的最大字符数。</summary>
        <value>可包含在当前实例所分配的内存中的最大字符数。 其值可以从 <see cref="P:System.Text.StringBuilder.Length" /> 到 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Capacity%2A> 不影响当前实例的字符串值。 <xref:System.Text.StringBuilder.Capacity%2A> 可以减小，只要它不小于 <xref:System.Text.StringBuilder.Length%2A> 。

 <xref:System.Text.StringBuilder>需要时动态分配更多的空间，并 <xref:System.Text.StringBuilder.Capacity%2A> 相应增加。 出于性能原因， <xref:System.Text.StringBuilder> 可能会分配比所需内存更多的内存。 分配的内存量是特定于实现的。



## Examples
 下面的示例演示了 <xref:System.Text.StringBuilder.Capacity%2A> 属性。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">为集运算指定的值小于此实例的当前长度。

 - 或 -

 为集运算指定的值大于最大容量。</exception>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); void set(int index, char value); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char with get, set" Usage="System.Text.StringBuilder.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">字符的位置。</param>
        <summary>获取或设置此实例中指定字符位置处的字符。</summary>
        <value><paramref name="index" /> 位置处的 Unicode 字符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `index`参数是中字符的位置 <xref:System.Text.StringBuilder> 。 字符串中的第一个字符位于索引0处。 字符串的长度是它包含的字符数。 实例的最后一个可访问字符位于 <xref:System.Text.StringBuilder> 索引 <xref:System.Text.StringBuilder.Length%2A> -1 处。

 <xref:System.Text.StringBuilder.Chars%2A> 是类的默认属性 <xref:System.Text.StringBuilder> 。 在 c # 中，它是一个索引器。 这意味着，可以从属性中检索各个字符 <xref:System.Text.StringBuilder.Chars%2A> ，如下面的示例所示，它对字符串中的字母、空格和标点符号的数目进行计数。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.chars/cs/chars1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.chars/vb/chars1.vb" id="Snippet1":::
 
### <a name="performance-and-character-based-indexing"></a>基于性能和字符的索引

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">设置字符时，<paramref name="index" /> 在此实例的范围之外。</exception>
        <exception cref="T:System.IndexOutOfRangeException">获取字符时，<paramref name="index" /> 在此实例的范围之外。</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Function Clear () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从当前 <see cref="T:System.Text.StringBuilder" /> 实例中移除所有字符。</summary>
        <returns>其 <see cref="P:System.Text.StringBuilder.Length" /> 为 0（零）的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<xref:System.Text.StringBuilder.Clear%2A> 是一种便捷方法，相当于将当前实例的<xref:System.Text.StringBuilder.Length%2A>属性设置为0（零）。

## Examples

以下示例使用字符串实例化<xref:System.Text.StringBuilder>对象，调用<xref:System.Text.StringBuilder.Clear%2A>方法，然后将追加一个新的字符串。

:::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.clear/cs/clear1.cs" interactive="try-dotnet" id="Snippet1":::
:::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.clear/vb/clear1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, valuetype System.Span`1&lt;char&gt; destination, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Span{System.Char},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Span(Of Char), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * Span&lt;char&gt; * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">此实例中开始复制字符的位置。 索引是从零开始的。</param>
        <param name="destination">将从中复制字符的可写范围。</param>
        <param name="count">要复制的字符数。</param>
        <summary>将此实例的指定段中的字符复制到目标 <see cref="T:System.Char" /> 范围。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.CopyTo%2A>如果需要将对象的连续部分有效地复制 <xref:System.Text.StringBuilder> 到某一范围，此方法旨在用于极少数情况。

 例如，你的应用程序可以 <xref:System.Text.StringBuilder> 使用大量字符来填充对象，然后使用方法将 <xref:System.Text.StringBuilder.CopyTo%2A> 对象的小型连续部分复制 <xref:System.Text.StringBuilder> 到部分处理的跨度。 在处理对象中的所有数据时 <xref:System.Text.StringBuilder> ，对象的大小 <xref:System.Text.StringBuilder> 设置为零，并重复周期。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destination" Type="System.Char[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">此实例中开始复制字符的位置。 索引是从零开始的。</param>
        <param name="destination">将从中复制字符的数组。</param>
        <param name="destinationIndex"><paramref name="destination" /> 中将从其开始复制字符的起始位置。 索引是从零开始的。</param>
        <param name="count">要复制的字符数。</param>
        <summary>将此实例的指定段中的字符复制到目标 <see cref="T:System.Char" /> 数组的指定段中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.CopyTo%2A>当你需要将对象的连续部分有效地复制到数组时，此方法旨在用于极少数情况 <xref:System.Text.StringBuilder> 。 该数组应为固定大小、预分配、可重用并且可能可全局访问。

 例如，你的应用程序可以 <xref:System.Text.StringBuilder> 使用大量字符来填充对象，然后使用方法将 <xref:System.Text.StringBuilder.CopyTo%2A> 对象的小型连续部分复制 <xref:System.Text.StringBuilder> 到处理这些部分的数组。 在处理对象中的所有数据时 <xref:System.Text.StringBuilder> ，对象的大小 <xref:System.Text.StringBuilder> 设置为零，并重复周期。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.CopyTo%2A> 方法。

 [!code-cpp[stringbuilder.copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.copyto2/CPP/ct2.cpp#1)]
 [!code-csharp[stringbuilder.copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.copyto2/CS/ct2.cs#1)]
 [!code-vb[stringbuilder.copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.copyto2/VB/ct2.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" />、<paramref name="destinationIndex" /> 或 <paramref name="count" /> 小于零。

- 或 -

 <paramref name="sourceIndex" /> 大于此实例的长度。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceIndex" /> + <paramref name="count" /> 大于此实例的长度。

- 或 -

 <paramref name="destinationIndex" /> + <paramref name="count" /> 大于 <paramref name="destination" /> 的长度。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberSignature Language="F#" Value="member this.EnsureCapacity : int -&gt; int" Usage="stringBuilder.EnsureCapacity capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">要确保的最小容量。</param>
        <summary>确保 <see cref="T:System.Text.StringBuilder" /> 的此实例的容量至少是指定值。</summary>
        <returns>此实例的新容量。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果当前容量小于 `capacity` 参数，则将此实例的内存重新分配为至少容纳 `capacity` 数量的字符; 否则，不会更改任何内存。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.EnsureCapacity%2A> 方法。

 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> 小于零。

- 或 -

增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (span As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="override this.Equals : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="stringBuilder.Equals span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="span">与当前实例进行比较的字符范围。</param>
        <summary>返回一个值，该值指示此实例中的字符是否等于指定的只读字符范围中的字符。</summary>
        <returns>如果此实例中的字符与 <paramref name="span" /> 相同，为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

`Equals`方法执行序号比较，以确定当前实例中的字符是否 `span` 相等。

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.StringBuilder sb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Text.StringBuilder sb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (sb As StringBuilder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Text::StringBuilder ^ sb);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Text.StringBuilder -&gt; bool" Usage="stringBuilder.Equals sb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sb" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="sb">与此实例进行比较的对象，或为 <see langword="null" />。</param>
        <summary>返回一个值，该值指示此实例是否等于指定的对象。</summary>
        <returns>如果此实例和 <paramref name="sb" /> 具有相等的字符串、<see cref="P:System.Text.StringBuilder.Capacity" /> 和 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 值，则为 <see langword="true" />；否则，为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

**.NET Framework 和 .Net Core 2.2 及更早版本：** 当前实例， `sb` 如果它们具有相等的字符串、和值，则相等 <xref:System.Text.StringBuilder.Capacity> <xref:System.Text.StringBuilder.MaxCapacity> 。 `Equals`方法使用序号比较来确定字符串是否相等。

**.Net Core 3.0 及更高版本：**`sb`如果分配给这两个对象的字符串相同，则当前实例和相等 <xref:System.Text.StringBuilder> 。  若要确定相等性， `Equals` 方法使用序号比较。 在 <xref:System.Text.StringBuilder.Capacity> <xref:System.Text.StringBuilder.MaxCapacity> 比较中不使用和属性值。

## Examples
 下面的代码使用 <xref:System.Text.StringBuilder.Equals%2A> 方法检查两个对象是否 <xref:System.Text.StringBuilder> 相等。 在对每个对象进行少量更改后，将重复调用方法，并将结果显示到控制台。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChunks">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder.ChunkEnumerator GetChunks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.StringBuilder/ChunkEnumerator GetChunks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.GetChunks" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChunks () As StringBuilder.ChunkEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder::ChunkEnumerator GetChunks();" />
      <MemberSignature Language="F#" Value="member this.GetChunks : unit -&gt; System.Text.StringBuilder.ChunkEnumerator" Usage="stringBuilder.GetChunks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder+ChunkEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个对象，该对象可用于循环访问从此 <see cref="T:System.Text.StringBuilder" /> 实例创建的 <see langword="ReadOnlyMemory&lt;Char&gt;" /> 中表示的字符区块。</summary>
        <returns><see langword="ReadOnlyMemory&lt;Char&gt;" /> 中区块的枚举器。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

可以用如下代码来循环访问内存范围内的块：

```csharp
foreach (ReadOnlyMemory<char> chunk in sb.GetChunks())
    foreach(char ch in chunk.Span)
        { /* operations on ch */ }
```

此方法的目的是有效地提取 *常量* 的数据 <xref:System.Text.StringBuilder> 。 如果在 <xref:System.Text.StringBuilder> 块区枚举不完整时修改了，则结果是不确定的。 <xref:System.Text.StringBuilder> 也不是线程安全的，因此在并发线程上对其进行操作是非法的。

<xref:System.ReadOnlyMemory%601>如果修改了，则返回的块不会保持不变 <xref:System.Text.StringBuilder> ，因此，不会将它们缓存供以后使用。

由于在 <xref:System.ReadOnlySpan%601> 前面的 <xref:System.ReadOnlyMemory%601> 示例中，从 (创建一个 <xref:System.ReadOnlyMemory%601.Span?displayProperty=nameWithType>) 开销很大，因此，如果需要在嵌套语句中使用它，请为该范围创建一个本地变量 `for` 。 例如：

```csharp
foreach (ReadOnlyMemory<char> chunk in sb.GetChunks())
{
    var span = chunk.Span;
    for(int i = 0; i < span.Length; i++)
    {
        /* operations on span[i] */
    }
}
```

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Insert">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将指定对象的字符串表示形式插入到此实例中的指定字符位置。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, bool value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将布尔值的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Boolean.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式 `value` 。 将移动现有字符以便为新文本留出空间。 根据需要调整容量。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 和早期版本中， <see cref="T:System.ArgumentOutOfRangeException" /> 如果插入 <paramref name="value" /> 会导致对象的总长度超过，则调用此方法将引发 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ，方法将引发 <see cref="T:System.OutOfMemoryException" /> 。</para></block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将指定的 8 位无符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Byte.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式 `value` 。 将移动现有字符以便为新文本留出空间。 此实例的容量会根据需要进行调整。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 和早期版本中， <see cref="T:System.ArgumentOutOfRangeException" /> 如果插入 <paramref name="value" /> 会导致对象的总长度超过，则调用此方法将引发 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ，方法将引发 <see cref="T:System.OutOfMemoryException" /> 。</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, char value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将指定的 Unicode 字符的字符串表示形式插入到此实例中的指定位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Char.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式 `value` 。 将移动现有字符以便为新文本留出空间。 此实例的容量会根据需要进行调整。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的长度。

- 或 -

增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[]? value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的字符数组。</param>
        <summary>将指定的 Unicode 字符数组的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 将移动现有字符以便为新文本留出空间。 此实例的容量会根据需要进行调整。

 如果 `value` 为 `null` ，则 <xref:System.Text.StringBuilder> 不会更改。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的长度。

- 或 -

增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将十进制数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Decimal.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式 `value` 。 将移动现有字符以便为新文本留出空间。 此实例的容量会根据需要进行调整。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 和早期版本中， <see cref="T:System.ArgumentOutOfRangeException" /> 如果插入 <paramref name="value" /> 会导致对象的总长度超过，则调用此方法将引发 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ，方法将引发 <see cref="T:System.OutOfMemoryException" /> 。</para></block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, double value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将双精度浮点数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Double.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式 `value` 。 将移动现有字符以便为新文本留出空间。 此实例的容量会根据需要进行调整。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 和早期版本中， <see cref="T:System.ArgumentOutOfRangeException" /> 如果插入 <paramref name="value" /> 会导致对象的总长度超过，则调用此方法将引发 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ，方法将引发 <see cref="T:System.OutOfMemoryException" /> 。</para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, short value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将指定的 16 位带符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Int16.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式 `value` 。 将移动现有字符以便为新文本留出空间。 此实例的容量会根据需要进行调整。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 和早期版本中， <see cref="T:System.ArgumentOutOfRangeException" /> 如果插入 <paramref name="value" /> 会导致对象的总长度超过，则调用此方法将引发 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ，方法将引发 <see cref="T:System.OutOfMemoryException" /> 。</para></block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, int value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将指定的 32 位带符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Int32.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式 `value` 。 将移动现有字符以便为新文本留出空间。 此实例的容量会根据需要进行调整。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 和早期版本中， <see cref="T:System.ArgumentOutOfRangeException" /> 如果插入 <paramref name="value" /> 会导致对象的总长度超过，则调用此方法将引发 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ，方法将引发 <see cref="T:System.OutOfMemoryException" /> 。</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, long value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将 64 位带符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Int64.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式 `value` 。 将移动现有字符以便为新文本留出空间。 此实例的容量会根据需要进行调整。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 和早期版本中， <see cref="T:System.ArgumentOutOfRangeException" /> 如果插入 <paramref name="value" /> 会导致对象的总长度超过，则调用此方法将引发 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ，方法将引发 <see cref="T:System.OutOfMemoryException" /> 。</para></block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, object value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, object? value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的对象，或 <see langword="null" />。</param>
        <summary>将对象的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式 `value` 。 将移动现有字符以便为新文本留出空间。 此实例的容量会根据需要进行调整。

 如果 `value` 为 `null` ，则此实例的值将保持不变。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 和早期版本中， <see cref="T:System.ArgumentOutOfRangeException" /> 如果插入 <paramref name="value" /> 会导致对象的总长度超过，则调用此方法将引发 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ，方法将引发 <see cref="T:System.OutOfMemoryException" /> 。</para></block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder? Insert (int index, ReadOnlySpan&lt;char&gt; value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ReadOnlySpan&lt;char&gt; value);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的字符范围。</param>
        <summary>将字符序列插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

在中，将移动现有字符，以便为中的字符序列 `value` 插入空间。 根据需要调整容量。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将指定的 8 位带符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.SByte.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式 `value` 。 将移动现有字符以便为新文本留出空间。 根据需要调整容量。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 和早期版本中， <see cref="T:System.ArgumentOutOfRangeException" /> 如果插入 <paramref name="value" /> 会导致对象的总长度超过，则调用此方法将引发 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ，方法将引发 <see cref="T:System.OutOfMemoryException" /> 。</para></block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, float value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将单精度浮点数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Single.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式 `value` 。 将移动现有字符以便为新文本留出空间。 此实例的容量会根据需要进行调整。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 和早期版本中， <see cref="T:System.ArgumentOutOfRangeException" /> 如果插入 <paramref name="value" /> 会导致对象的总长度超过，则调用此方法将引发 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ，方法将引发 <see cref="T:System.OutOfMemoryException" /> 。</para></block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string? value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的字符串。</param>
        <summary>将字符串插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 将移动现有字符以便为新文本留出空间。 根据需要调整容量。

 <xref:System.Text.StringBuilder>如果 `value` 为 `null` ，或者 `value` 不是 `null` 但其长度为零，则不会更改的此实例。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的当前长度。

- 或 -

此 <see cref="T:System.Text.StringBuilder" /> 对象的当前长度加上 <paramref name="value" /> 的长度超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将 16 位无符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.UInt16.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式 `value` 。 将移动现有字符以便为新文本留出空间。 此实例的容量会根据需要进行调整。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 和早期版本中， <see cref="T:System.ArgumentOutOfRangeException" /> 如果插入 <paramref name="value" /> 会导致对象的总长度超过，则调用此方法将引发 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ，方法将引发 <see cref="T:System.OutOfMemoryException" /> 。</para></block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将 32 位无符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式 `value` 。 将移动现有字符以便为新文本留出空间。 此实例的容量会根据需要进行调整。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 和早期版本中， <see cref="T:System.ArgumentOutOfRangeException" /> 如果插入 <paramref name="value" /> 会导致对象的总长度超过，则调用此方法将引发 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ，方法将引发 <see cref="T:System.OutOfMemoryException" /> 。</para></block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将 64 位无符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式 `value` 。 将移动现有字符以便为新文本留出空间。 此实例的容量会根据需要进行调整。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 和早期版本中， <see cref="T:System.ArgumentOutOfRangeException" /> 如果插入 <paramref name="value" /> 会导致对象的总长度超过，则调用此方法将引发 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 。 从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ，方法将引发 <see cref="T:System.OutOfMemoryException" /> 。</para></block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value, int count);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value, int count);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, count)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string? value, int count);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的字符串。</param>
        <param name="count">要插入 <paramref name="value" /> 的次数。</param>
        <summary>将指定字符串的一个或更多副本插入到此实例中的指定字符位置。</summary>
        <returns>完成插入后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 将移动现有字符以便为新文本留出空间。 此实例的容量会根据需要进行调整。

 <xref:System.Text.StringBuilder>如果为，则不会更改此对象，但该对象的 `value` `null` `value` `null` 长度为零，或者 `count` 为零。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的当前长度。

- 或 -

 <paramref name="count" /> 小于零。</exception>
        <exception cref="T:System.OutOfMemoryException">此 <see cref="T:System.Text.StringBuilder" /> 对象的当前长度加上 <paramref name="value" /> 的长度乘以 <paramref name="count" />，超过了 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value, int startIndex, int charCount);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, startIndex, charCount)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[]? value, int startIndex, int charCount);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">字符数组。</param>
        <param name="startIndex"><paramref name="value" /> 内的起始索引。</param>
        <param name="charCount">要插入的字符数。</param>
        <summary>将指定的 Unicode 字符子数组的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 将移动现有字符以便为新文本留出空间。 此实例的容量会根据需要进行调整。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.Insert%2A> 方法。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />，且 <paramref name="startIndex" /> 和 <paramref name="charCount" /> 不为零。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />、<paramref name="startIndex" /> 或 <paramref name="charCount" /> 小于零。

- 或 -

 <paramref name="index" /> 大于此实例的长度。

- 或 -

 <paramref name="startIndex" /> 加 <paramref name="charCount" /> 不是 <paramref name="value" /> 中的位置。

- 或 -

增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Length" />
      <MemberSignature Language="VB.NET" Value="Public Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Length : int with get, set" Usage="System.Text.StringBuilder.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前 <see cref="T:System.Text.StringBuilder" /> 对象的长度。</summary>
        <value>此实例的长度。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 对象的长度 <xref:System.Text.StringBuilder> 由其对象数定义 <xref:System.Char> 。

 与 <xref:System.String.Length%2A?displayProperty=nameWithType> 属性一样， <xref:System.Text.StringBuilder.Length%2A> 属性指示当前字符串对象的长度。 与 <xref:System.String.Length%2A?displayProperty=nameWithType> 属性不同，属性是只读的，它 <xref:System.Text.StringBuilder.Length%2A> 允许您修改存储在对象中的字符串的长度 <xref:System.Text.StringBuilder> 。

 如果指定的长度小于当前长度，则当前 <xref:System.Text.StringBuilder> 对象将被截断为指定长度。 如果指定的长度大于当前长度，则当前对象的字符串值的结尾 <xref:System.Text.StringBuilder> 将用 UNICODE 空字符 (U + 0000) 填充。

 如果指定的长度大于当前容量，则 <xref:System.Text.StringBuilder.Capacity%2A> 会增加，使其大于或等于指定的长度。



## Examples
 下面的示例演示了 <xref:System.Text.StringBuilder.Length%2A> 属性。

 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">为集运算指定的值小于零或大于 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxCapacity">
      <MemberSignature Language="C#" Value="public int MaxCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.MaxCapacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaxCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxCapacity { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxCapacity : int" Usage="System.Text.StringBuilder.MaxCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例的最大容量。</summary>
        <value>此实例可容纳的最大字符数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此实现的最大容量为 <xref:System.Int32.MaxValue?displayProperty=nameWithType> 。 不过，此值是特定于实现的，并且在其他或更高的实现中可能不同。 可以 <xref:System.Text.StringBuilder> 通过调用构造函数来显式设置对象的最大容量 <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> 。

在 .NET Core 和 .NET Framework 4.0 及更高版本中，当你 <xref:System.Text.StringBuilder> 通过调用构造函数实例化对象时， <xref:System.Text.StringBuilder.%23ctor(System.Int32,System.Int32)> 实例的长度和容量 <xref:System.Text.StringBuilder> 可能会超出其属性的值 <xref:System.Text.StringBuilder.MaxCapacity> 。 当调用 <xref:System.Text.StringBuilder.Append(System.String)> 和 <xref:System.Text.StringBuilder.AppendFormat(System.String,System.Object)> 方法追加小字符串时，尤其如此。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Remove (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Remove(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, length As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Remove(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Remove (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">此实例中开始移除操作的从零开始的位置。</param>
        <param name="length">要删除的字符数。</param>
        <summary>将指定范围的字符从此实例中移除。</summary>
        <returns>切除操作完成后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 当前方法从当前实例中删除指定范围内的字符。 将 () 的字符 `startIndex`  +  `length` 移动到 `startIndex` ，并缩短当前实例的字符串值 `length` 。 当前实例的容量不受影响。

> [!NOTE]
>  <xref:System.Text.StringBuilder.Remove%2A>方法修改当前实例的值 <xref:System.Text.StringBuilder> 并返回该实例。 它不创建并返回新的 <xref:System.Text.StringBuilder> 对象。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.Remove%2A> 方法。

 [!code-cpp[stringbuilder.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.remove/CPP/remove.cpp#1)]
 [!code-csharp[stringbuilder.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.remove/CS/remove.cs#1)]
 [!code-vb[stringbuilder.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.remove/VB/remove.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">如果 <paramref name="startIndex" /> 或 <paramref name="length" /> 小于零，或者 <paramref name="startIndex" /> + <paramref name="length" /> 大于此实例的长度。</exception>
        <altmember cref="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将此实例中出现的所有指定字符或字符串替换为其他的指定字符或字符串。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">要替换的字符。</param>
        <param name="newChar">替换 <paramref name="oldChar" /> 的字符。</param>
        <summary>将此实例中出现的所有指定字符替换为其他指定字符。</summary>
        <returns>对此实例的引用，其中 <paramref name="oldChar" /> 被 <paramref name="newChar" /> 替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法执行序号、区分大小写的比较，以标识 `oldChar` 当前实例中的匹配项。 替换后，当前实例的大小 <xref:System.Text.StringBuilder> 将保持不变。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.Replace%2A> 方法。

 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string? newValue);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">要替换的字符串。</param>
        <param name="newValue">替换 <paramref name="oldValue" /> 的字符串或 <see langword="null" />。</param>
        <summary>将此实例中出现的所有指定字符串的替换为其他指定字符串。</summary>
        <returns>对此实例的引用，其中 <paramref name="oldValue" /> 的所有实例被 <paramref name="newValue" /> 替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法执行序号、区分大小写的比较，以标识 `oldValue` 当前实例中的匹配项。 如果 `newValue` 为 `null` 或 <xref:System.String.Empty?displayProperty=nameWithType> ，则删除的所有匹配项 `oldValue` 。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.Replace%2A> 方法。

 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="oldValue" /> 的长度为零。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldChar">要替换的字符。</param>
        <param name="newChar">替换 <paramref name="oldChar" /> 的字符。</param>
        <param name="startIndex">此实例中子字符串开始的位置。</param>
        <param name="count">子字符串的长度。</param>
        <summary>将此实例的子字符串中出现的所有指定字符替换为其他指定字符。</summary>
        <returns>对此实例的引用，其中从 <paramref name="startIndex" /> 到 <paramref name="startIndex" /> + <paramref name="count" /> -1 范围内的 <paramref name="oldChar" /> 被 <paramref name="newChar" /> 替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法执行序号、区分大小写的比较，以标识 `oldChar` 当前实例中的匹配项。 替换后，当前对象的大小 <xref:System.Text.StringBuilder> 不变。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.Replace%2A> 方法。

 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> + <paramref name="count" /> 大于此实例的值的长度。

- 或 -

 <paramref name="startIndex" /> 或 <paramref name="count" /> 小于零。</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue, int startIndex, int count);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue, startIndex, count)" />
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string? newValue, int startIndex, int count);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldValue">要替换的字符串。</param>
        <param name="newValue">替换 <paramref name="oldValue" /> 的字符串或 <see langword="null" />。</param>
        <param name="startIndex">此实例中子字符串开始的位置。</param>
        <param name="count">子字符串的长度。</param>
        <summary>将此实例的子字符串中出现的所有指定字符串替换为其他指定字符串。</summary>
        <returns>对此实例的引用，其中从 <paramref name="startIndex" /> 到 <paramref name="startIndex" /> + <paramref name="count" /> - 1 的范围内 <paramref name="oldValue" /> 的所有实例被 <paramref name="newValue" /> 替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法执行序号、区分大小写的比较，以标识 `oldValue` 指定子字符串中的匹配项。 如果 `newValue` 为 `null` 或 <xref:System.String.Empty?displayProperty=nameWithType> ，则删除的所有匹配项 `oldValue` 。



## Examples
 下面的示例演示 <xref:System.Text.StringBuilder.Replace%2A> 方法。

 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="oldValue" /> 的长度为零。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 或 <paramref name="count" /> 小于零。

- 或 -

 <paramref name="startIndex" /> 加 <paramref name="count" /> 指示一个不在此实例内的字符位置。

- 或 -

增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.Serialization.ISerializable.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.System.Runtime.Serialization.ISerializable.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="stringBuilder.System.Runtime.Serialization.ISerializable.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="info">要用序列化信息填充的对象。</param>
        <param name="context">存储和检索序列化数据的位置。 留待将来使用。</param>
        <summary>使用所需的数据填充 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象来反序列化当前 <see cref="T:System.Text.StringBuilder" /> 对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此 `context` 参数保留以供将来使用，并且不参与此操作。

 有关更多信息，请参见 <xref:System.Runtime.Serialization.SerializationInfo.AddValue%28System.String%2CSystem.Object%2CSystem.Type%29?displayProperty=nameWithType> 方法。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将 <see cref="T:System.Text.StringBuilder" /> 的值转换为 <see cref="T:System.String" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="stringBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将此实例的值转换为 <see cref="T:System.String" />。</summary>
        <returns>其值与此实例相同的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 必须 <xref:System.Text.StringBuilder.ToString%2A> 先调用方法将 <xref:System.Text.StringBuilder> 对象转换为对象，然后才能将 <xref:System.String> 对象表示的字符串传递给 <xref:System.Text.StringBuilder> 具有 <xref:System.String> 参数或在用户界面中显示它的方法。



## Examples
 下面的示例演示如何调用 <xref:System.Text.StringBuilder.ToString%2A> 方法。 此示例是为类提供的更大示例的一部分 <xref:System.Text.StringBuilder> 。

 [!code-cpp[StringBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#5)]
 [!code-csharp[StringBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#5)]
 [!code-vb[StringBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#5)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : int * int -&gt; string" Usage="stringBuilder.ToString (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">此实例内子字符串的起始位置。</param>
        <param name="length">子字符串的长度。</param>
        <summary>将此实例中子字符串的值转换为 <see cref="T:System.String" />。</summary>
        <returns>一个字符串，其值与此实例的指定子字符串相同。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 必须 <xref:System.Text.StringBuilder.ToString%2A> 先调用方法将 <xref:System.Text.StringBuilder> 对象转换为对象，然后才能将 <xref:System.String> 对象表示的字符串传递给 <xref:System.Text.StringBuilder> 具有 <xref:System.String> 参数或在用户界面中显示它的方法。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 或 <paramref name="length" /> 小于零。

- 或 -

<paramref name="startIndex" /> 和 <paramref name="length" /> 之和大于当前实例的长度。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
