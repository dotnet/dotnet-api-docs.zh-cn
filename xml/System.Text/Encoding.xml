<Type Name="Encoding" FullName="System.Text.Encoding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8806cc09a0179a6f57330063bea96ac1882d4dfc" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83978981" /></Metadata><TypeSignature Language="C#" Value="public abstract class Encoding" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Encoding extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoding" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoding abstract" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
  <TypeSignature Language="F#" Value="type Encoding = class" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
  <TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Encoding extends System.Object implements class System.ICloneable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoding&#xA;Implements ICloneable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoding abstract : ICloneable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Encoding = class&#xA;    interface ICloneable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Text.Encoding" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Text.Encoding" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Text.Encoding" FromVersion="4.1.0.0" To="System.Runtime" ToVersion="4.2.0.0" FrameworkAlternate="netcore-2.0" />
    <TypeForwarding From="System.Text.Encoding" FromVersion="4.1.1.0" To="System.Runtime" ToVersion="4.2.1.0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
    <TypeForwarding From="System.Text.Encoding" FromVersion="4.1.2.0" To="System.Runtime" ToVersion="4.2.2.0" FrameworkAlternate="netcore-3.1" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="1dab1-101">表示字符编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-101">Represents a character encoding.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-102">编码是将一组 Unicode 字符转换为一个字节序列的过程。</span><span class="sxs-lookup"><span data-stu-id="1dab1-102">Encoding is the process of transforming a set of Unicode characters into a sequence of bytes.</span></span> <span data-ttu-id="1dab1-103">相反，解码是将编码字节序列转换为一组 Unicode 字符的过程。</span><span class="sxs-lookup"><span data-stu-id="1dab1-103">In contrast, decoding is the process of transforming a sequence of encoded bytes into a set of Unicode characters.</span></span> <span data-ttu-id="1dab1-104">有关 Unicode 转换格式（UTFs）和 <xref:System.Text.Encoding>支持的其他编码的信息，请参阅[.net 中的字符编码](/dotnet/standard/base-types/character-encoding)。</span><span class="sxs-lookup"><span data-stu-id="1dab1-104">For information about the Unicode Transformation Formats (UTFs) and other encodings supported by <xref:System.Text.Encoding>, see [Character Encoding in .NET](/dotnet/standard/base-types/character-encoding).</span></span>

 <span data-ttu-id="1dab1-105">请注意，<xref:System.Text.Encoding> 适用于 Unicode 字符，而不是任意二进制数据（如字节数组）。</span><span class="sxs-lookup"><span data-stu-id="1dab1-105">Note that <xref:System.Text.Encoding> is intended to operate on Unicode characters instead of arbitrary binary data, such as byte arrays.</span></span> <span data-ttu-id="1dab1-106">如果必须将任意二进制数据编码为文本，则应使用诸如 uuencode 这样的协议，该协议由 <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>等方法实现。</span><span class="sxs-lookup"><span data-stu-id="1dab1-106">If you must encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="1dab1-107">.NET 提供了 <xref:System.Text.Encoding> 类的以下实现，以支持当前的 Unicode 编码和其他编码：</span><span class="sxs-lookup"><span data-stu-id="1dab1-107">.NET provides the following implementations of the <xref:System.Text.Encoding> class to support current Unicode encodings and other encodings:</span></span>

-   <span data-ttu-id="1dab1-108"><xref:System.Text.ASCIIEncoding> 将 Unicode 字符编码为单个7位 ASCII 字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-108"><xref:System.Text.ASCIIEncoding> encodes Unicode characters as single 7-bit ASCII characters.</span></span> <span data-ttu-id="1dab1-109">此编码仅支持 U + 0000 到 U + 007F 之间的字符值。</span><span class="sxs-lookup"><span data-stu-id="1dab1-109">This encoding only supports character values between U+0000 and U+007F.</span></span> <span data-ttu-id="1dab1-110">代码页20127。</span><span class="sxs-lookup"><span data-stu-id="1dab1-110">Code page 20127.</span></span> <span data-ttu-id="1dab1-111">还可通过 <xref:System.Text.Encoding.ASCII%2A> 属性获取。</span><span class="sxs-lookup"><span data-stu-id="1dab1-111">Also available through the <xref:System.Text.Encoding.ASCII%2A> property.</span></span>

-   <span data-ttu-id="1dab1-112"><xref:System.Text.UTF7Encoding> 使用 UTF-7 编码对 Unicode 字符进行编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-112"><xref:System.Text.UTF7Encoding> encodes Unicode characters using the UTF-7 encoding.</span></span> <span data-ttu-id="1dab1-113">此编码支持所有 Unicode 字符值。</span><span class="sxs-lookup"><span data-stu-id="1dab1-113">This encoding supports all Unicode character values.</span></span> <span data-ttu-id="1dab1-114">代码页65000。</span><span class="sxs-lookup"><span data-stu-id="1dab1-114">Code page 65000.</span></span> <span data-ttu-id="1dab1-115">还可通过 <xref:System.Text.Encoding.UTF7%2A> 属性获取。</span><span class="sxs-lookup"><span data-stu-id="1dab1-115">Also available through the <xref:System.Text.Encoding.UTF7%2A> property.</span></span>

-   <span data-ttu-id="1dab1-116"><xref:System.Text.UTF8Encoding> 使用 UTF-8 编码对 Unicode 字符进行编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-116"><xref:System.Text.UTF8Encoding> encodes Unicode characters using the UTF-8 encoding.</span></span> <span data-ttu-id="1dab1-117">此编码支持所有 Unicode 字符值。</span><span class="sxs-lookup"><span data-stu-id="1dab1-117">This encoding supports all Unicode character values.</span></span> <span data-ttu-id="1dab1-118">代码页65001。</span><span class="sxs-lookup"><span data-stu-id="1dab1-118">Code page 65001.</span></span> <span data-ttu-id="1dab1-119">还可通过 <xref:System.Text.Encoding.UTF8%2A> 属性获取。</span><span class="sxs-lookup"><span data-stu-id="1dab1-119">Also available through the <xref:System.Text.Encoding.UTF8%2A> property.</span></span>

-   <span data-ttu-id="1dab1-120"><xref:System.Text.UnicodeEncoding> 使用 UTF-16 编码对 Unicode 字符进行编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-120"><xref:System.Text.UnicodeEncoding> encodes Unicode characters using the UTF-16 encoding.</span></span> <span data-ttu-id="1dab1-121">支持 little endian 和大型 endian 字节顺序。</span><span class="sxs-lookup"><span data-stu-id="1dab1-121">Both little endian and big endian byte orders are supported.</span></span> <span data-ttu-id="1dab1-122">还可以通过 <xref:System.Text.Encoding.Unicode%2A> 属性和 <xref:System.Text.Encoding.BigEndianUnicode%2A> 属性提供。</span><span class="sxs-lookup"><span data-stu-id="1dab1-122">Also available through the <xref:System.Text.Encoding.Unicode%2A> property and the <xref:System.Text.Encoding.BigEndianUnicode%2A> property.</span></span>

-   <span data-ttu-id="1dab1-123"><xref:System.Text.UTF32Encoding> 使用32编码对 Unicode 字符进行编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-123"><xref:System.Text.UTF32Encoding> encodes Unicode characters using the UTF-32 encoding.</span></span> <span data-ttu-id="1dab1-124">支持 little endian （代码页12000）和大型 endian （代码页12001）字节顺序。</span><span class="sxs-lookup"><span data-stu-id="1dab1-124">Both little endian (code page 12000) and big endian (code page 12001) byte orders are supported.</span></span> <span data-ttu-id="1dab1-125">还可通过 <xref:System.Text.Encoding.UTF32%2A> 属性获取。</span><span class="sxs-lookup"><span data-stu-id="1dab1-125">Also available through the <xref:System.Text.Encoding.UTF32%2A> property.</span></span>

 <span data-ttu-id="1dab1-126"><xref:System.Text.Encoding> 类主要用于在不同的编码和 Unicode 之间转换。</span><span class="sxs-lookup"><span data-stu-id="1dab1-126">The <xref:System.Text.Encoding> class is primarily intended to convert between different encodings and Unicode.</span></span> <span data-ttu-id="1dab1-127">通常，其中一个派生的 Unicode 类是适用于你的应用程序的正确选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-127">Often one of the derived Unicode classes is the correct choice for your app.</span></span>

 <span data-ttu-id="1dab1-128">使用 <xref:System.Text.Encoding.GetEncoding%2A> 方法获取其他编码，并调用 <xref:System.Text.Encoding.GetEncodings%2A> 方法获取所有编码的列表。</span><span class="sxs-lookup"><span data-stu-id="1dab1-128">Use the <xref:System.Text.Encoding.GetEncoding%2A> method to obtain other encodings, and call the <xref:System.Text.Encoding.GetEncodings%2A> method to get a list of all encodings.</span></span>

 <span data-ttu-id="1dab1-129">下表列出了 .NET Framework 和 .NET Core 支持的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-129">The following table lists the encodings supported by .NET Framework and .NET Core.</span></span> <span data-ttu-id="1dab1-130">它列出了每个编码的代码页编号以及编码的 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> 和 <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> 属性的值。</span><span class="sxs-lookup"><span data-stu-id="1dab1-130">It lists each encoding's code page number and the values of the encoding's <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> and <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> properties.</span></span> <span data-ttu-id="1dab1-131">" **.NET Framework 支持**" 和 " **.net Core 支持**" 列中的复选标记指示该 .net 实现本机支持代码页，而不考虑基础平台。</span><span class="sxs-lookup"><span data-stu-id="1dab1-131">A check mark in the **.NET Framework support** and **.NET Core support** columns indicates that the code page is natively supported by that .NET implementation, regardless of the underlying platform.</span></span> <span data-ttu-id="1dab1-132">对于 .NET Framework，表中列出的其他编码的可用性取决于操作系统。</span><span class="sxs-lookup"><span data-stu-id="1dab1-132">For .NET Framework, the availability of other encodings listed in the table depends on the operating system.</span></span> <span data-ttu-id="1dab1-133">对于 .NET Core，可以通过使用 <xref:System.Text.CodePagesEncodingProvider?displayProperty=nameWithType> 类或从 <xref:System.Text.EncodingProvider?displayProperty=nameWithType> 类派生来使用其他编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-133">For .NET Core, other encodings are available by using the <xref:System.Text.CodePagesEncodingProvider?displayProperty=nameWithType> class or by deriving from the <xref:System.Text.EncodingProvider?displayProperty=nameWithType> class.</span></span>

> [!NOTE]
> <span data-ttu-id="1dab1-134"><xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> 属性对应于国际标准的代码页不一定完全符合该标准。</span><span class="sxs-lookup"><span data-stu-id="1dab1-134">Code pages whose <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> property corresponds to an international standard do not necessarily comply in full with that standard.</span></span>

|<span data-ttu-id="1dab1-135">代码页</span><span class="sxs-lookup"><span data-stu-id="1dab1-135">Code page</span></span>|<span data-ttu-id="1dab1-136">名称</span><span class="sxs-lookup"><span data-stu-id="1dab1-136">Name</span></span>|<span data-ttu-id="1dab1-137">显示名称</span><span class="sxs-lookup"><span data-stu-id="1dab1-137">Display name</span></span>|<span data-ttu-id="1dab1-138">.NET Framework 支持</span><span class="sxs-lookup"><span data-stu-id="1dab1-138">.NET Framework support</span></span>| <span data-ttu-id="1dab1-139">.NET Core 支持</span><span class="sxs-lookup"><span data-stu-id="1dab1-139">.NET Core support</span></span> |
|---------|----|------------|----------------------|-------------------|
|<span data-ttu-id="1dab1-140">37</span><span class="sxs-lookup"><span data-stu-id="1dab1-140">37</span></span>|<span data-ttu-id="1dab1-141">IBM037</span><span class="sxs-lookup"><span data-stu-id="1dab1-141">IBM037</span></span>|<span data-ttu-id="1dab1-142">IBM EBCDIC （美国-加拿大）</span><span class="sxs-lookup"><span data-stu-id="1dab1-142">IBM EBCDIC (US-Canada)</span></span>|||
|<span data-ttu-id="1dab1-143">437</span><span class="sxs-lookup"><span data-stu-id="1dab1-143">437</span></span>|<span data-ttu-id="1dab1-144">IBM437</span><span class="sxs-lookup"><span data-stu-id="1dab1-144">IBM437</span></span>|<span data-ttu-id="1dab1-145">OEM 美国</span><span class="sxs-lookup"><span data-stu-id="1dab1-145">OEM United States</span></span>|||
|<span data-ttu-id="1dab1-146">500</span><span class="sxs-lookup"><span data-stu-id="1dab1-146">500</span></span>|<span data-ttu-id="1dab1-147">IBM500</span><span class="sxs-lookup"><span data-stu-id="1dab1-147">IBM500</span></span>|<span data-ttu-id="1dab1-148">IBM EBCDIC （国际）</span><span class="sxs-lookup"><span data-stu-id="1dab1-148">IBM EBCDIC (International)</span></span>|||
|<span data-ttu-id="1dab1-149">708</span><span class="sxs-lookup"><span data-stu-id="1dab1-149">708</span></span>|<span data-ttu-id="1dab1-150">ASMO-708</span><span class="sxs-lookup"><span data-stu-id="1dab1-150">ASMO-708</span></span>|<span data-ttu-id="1dab1-151">阿拉伯语（ASMO 708）</span><span class="sxs-lookup"><span data-stu-id="1dab1-151">Arabic (ASMO 708)</span></span>|||
|<span data-ttu-id="1dab1-152">720</span><span class="sxs-lookup"><span data-stu-id="1dab1-152">720</span></span>|<span data-ttu-id="1dab1-153">DOS-720</span><span class="sxs-lookup"><span data-stu-id="1dab1-153">DOS-720</span></span>|<span data-ttu-id="1dab1-154">阿拉伯语（DOS）</span><span class="sxs-lookup"><span data-stu-id="1dab1-154">Arabic (DOS)</span></span>|||
|<span data-ttu-id="1dab1-155">737</span><span class="sxs-lookup"><span data-stu-id="1dab1-155">737</span></span>|<span data-ttu-id="1dab1-156">ibm737</span><span class="sxs-lookup"><span data-stu-id="1dab1-156">ibm737</span></span>|<span data-ttu-id="1dab1-157">希腊语（DOS）</span><span class="sxs-lookup"><span data-stu-id="1dab1-157">Greek (DOS)</span></span>|||
|<span data-ttu-id="1dab1-158">775</span><span class="sxs-lookup"><span data-stu-id="1dab1-158">775</span></span>|<span data-ttu-id="1dab1-159">ibm775</span><span class="sxs-lookup"><span data-stu-id="1dab1-159">ibm775</span></span>|<span data-ttu-id="1dab1-160">波罗的语（DOS）</span><span class="sxs-lookup"><span data-stu-id="1dab1-160">Baltic (DOS)</span></span>|||
|<span data-ttu-id="1dab1-161">850</span><span class="sxs-lookup"><span data-stu-id="1dab1-161">850</span></span>|<span data-ttu-id="1dab1-162">ibm850</span><span class="sxs-lookup"><span data-stu-id="1dab1-162">ibm850</span></span>|<span data-ttu-id="1dab1-163">西欧（DOS）</span><span class="sxs-lookup"><span data-stu-id="1dab1-163">Western European (DOS)</span></span>|||
|<span data-ttu-id="1dab1-164">852</span><span class="sxs-lookup"><span data-stu-id="1dab1-164">852</span></span>|<span data-ttu-id="1dab1-165">ibm852</span><span class="sxs-lookup"><span data-stu-id="1dab1-165">ibm852</span></span>|<span data-ttu-id="1dab1-166">中欧语（DOS）</span><span class="sxs-lookup"><span data-stu-id="1dab1-166">Central European (DOS)</span></span>|||
|<span data-ttu-id="1dab1-167">855</span><span class="sxs-lookup"><span data-stu-id="1dab1-167">855</span></span>|<span data-ttu-id="1dab1-168">IBM855</span><span class="sxs-lookup"><span data-stu-id="1dab1-168">IBM855</span></span>|<span data-ttu-id="1dab1-169">OEM 西里尔语</span><span class="sxs-lookup"><span data-stu-id="1dab1-169">OEM Cyrillic</span></span>|||
|<span data-ttu-id="1dab1-170">857</span><span class="sxs-lookup"><span data-stu-id="1dab1-170">857</span></span>|<span data-ttu-id="1dab1-171">ibm857</span><span class="sxs-lookup"><span data-stu-id="1dab1-171">ibm857</span></span>|<span data-ttu-id="1dab1-172">土耳其语（DOS）</span><span class="sxs-lookup"><span data-stu-id="1dab1-172">Turkish (DOS)</span></span>|||
|<span data-ttu-id="1dab1-173">858</span><span class="sxs-lookup"><span data-stu-id="1dab1-173">858</span></span>|<span data-ttu-id="1dab1-174">IBM00858</span><span class="sxs-lookup"><span data-stu-id="1dab1-174">IBM00858</span></span>|<span data-ttu-id="1dab1-175">OEM 多语言拉丁语 I</span><span class="sxs-lookup"><span data-stu-id="1dab1-175">OEM Multilingual Latin I</span></span>|||
|<span data-ttu-id="1dab1-176">860</span><span class="sxs-lookup"><span data-stu-id="1dab1-176">860</span></span>|<span data-ttu-id="1dab1-177">IBM860</span><span class="sxs-lookup"><span data-stu-id="1dab1-177">IBM860</span></span>|<span data-ttu-id="1dab1-178">葡萄牙语（DOS）</span><span class="sxs-lookup"><span data-stu-id="1dab1-178">Portuguese (DOS)</span></span>|||
|<span data-ttu-id="1dab1-179">861</span><span class="sxs-lookup"><span data-stu-id="1dab1-179">861</span></span>|<span data-ttu-id="1dab1-180">ibm861</span><span class="sxs-lookup"><span data-stu-id="1dab1-180">ibm861</span></span>|<span data-ttu-id="1dab1-181">冰岛语（DOS）</span><span class="sxs-lookup"><span data-stu-id="1dab1-181">Icelandic (DOS)</span></span>|||
|<span data-ttu-id="1dab1-182">862</span><span class="sxs-lookup"><span data-stu-id="1dab1-182">862</span></span>|<span data-ttu-id="1dab1-183">DOS-862</span><span class="sxs-lookup"><span data-stu-id="1dab1-183">DOS-862</span></span>|<span data-ttu-id="1dab1-184">希伯来语（DOS）</span><span class="sxs-lookup"><span data-stu-id="1dab1-184">Hebrew (DOS)</span></span>|||
|<span data-ttu-id="1dab1-185">863</span><span class="sxs-lookup"><span data-stu-id="1dab1-185">863</span></span>|<span data-ttu-id="1dab1-186">IBM863</span><span class="sxs-lookup"><span data-stu-id="1dab1-186">IBM863</span></span>|<span data-ttu-id="1dab1-187">加拿大法语（DOS）</span><span class="sxs-lookup"><span data-stu-id="1dab1-187">French Canadian (DOS)</span></span>|||
|<span data-ttu-id="1dab1-188">864</span><span class="sxs-lookup"><span data-stu-id="1dab1-188">864</span></span>|<span data-ttu-id="1dab1-189">IBM864</span><span class="sxs-lookup"><span data-stu-id="1dab1-189">IBM864</span></span>|<span data-ttu-id="1dab1-190">阿拉伯语（864）</span><span class="sxs-lookup"><span data-stu-id="1dab1-190">Arabic (864)</span></span>|||
|<span data-ttu-id="1dab1-191">865</span><span class="sxs-lookup"><span data-stu-id="1dab1-191">865</span></span>|<span data-ttu-id="1dab1-192">IBM865</span><span class="sxs-lookup"><span data-stu-id="1dab1-192">IBM865</span></span>|<span data-ttu-id="1dab1-193">北欧语（DOS）</span><span class="sxs-lookup"><span data-stu-id="1dab1-193">Nordic (DOS)</span></span>|||
|<span data-ttu-id="1dab1-194">866</span><span class="sxs-lookup"><span data-stu-id="1dab1-194">866</span></span>|<span data-ttu-id="1dab1-195">cp866</span><span class="sxs-lookup"><span data-stu-id="1dab1-195">cp866</span></span>|<span data-ttu-id="1dab1-196">西里尔语（DOS）</span><span class="sxs-lookup"><span data-stu-id="1dab1-196">Cyrillic (DOS)</span></span>|||
|<span data-ttu-id="1dab1-197">869</span><span class="sxs-lookup"><span data-stu-id="1dab1-197">869</span></span>|<span data-ttu-id="1dab1-198">ibm869</span><span class="sxs-lookup"><span data-stu-id="1dab1-198">ibm869</span></span>|<span data-ttu-id="1dab1-199">现代希腊语（DOS）</span><span class="sxs-lookup"><span data-stu-id="1dab1-199">Greek, Modern (DOS)</span></span>|||
|<span data-ttu-id="1dab1-200">870</span><span class="sxs-lookup"><span data-stu-id="1dab1-200">870</span></span>|<span data-ttu-id="1dab1-201">IBM870</span><span class="sxs-lookup"><span data-stu-id="1dab1-201">IBM870</span></span>|<span data-ttu-id="1dab1-202">IBM EBCDIC （多语言拉丁语-2）</span><span class="sxs-lookup"><span data-stu-id="1dab1-202">IBM EBCDIC (Multilingual Latin-2)</span></span>|||
|<span data-ttu-id="1dab1-203">874</span><span class="sxs-lookup"><span data-stu-id="1dab1-203">874</span></span>|<span data-ttu-id="1dab1-204">windows-874</span><span class="sxs-lookup"><span data-stu-id="1dab1-204">windows-874</span></span>|<span data-ttu-id="1dab1-205">泰语（Windows）</span><span class="sxs-lookup"><span data-stu-id="1dab1-205">Thai (Windows)</span></span>|||
|<span data-ttu-id="1dab1-206">875</span><span class="sxs-lookup"><span data-stu-id="1dab1-206">875</span></span>|<span data-ttu-id="1dab1-207">cp875</span><span class="sxs-lookup"><span data-stu-id="1dab1-207">cp875</span></span>|<span data-ttu-id="1dab1-208">IBM EBCDIC （现代希腊语）</span><span class="sxs-lookup"><span data-stu-id="1dab1-208">IBM EBCDIC (Greek Modern)</span></span>|||
|<span data-ttu-id="1dab1-209">932</span><span class="sxs-lookup"><span data-stu-id="1dab1-209">932</span></span>|<span data-ttu-id="1dab1-210">shift_jis</span><span class="sxs-lookup"><span data-stu-id="1dab1-210">shift_jis</span></span>|<span data-ttu-id="1dab1-211">日语 (Shift-JIS)</span><span class="sxs-lookup"><span data-stu-id="1dab1-211">Japanese (Shift-JIS)</span></span>|||
|<span data-ttu-id="1dab1-212">936</span><span class="sxs-lookup"><span data-stu-id="1dab1-212">936</span></span>|<span data-ttu-id="1dab1-213">gb2312</span><span class="sxs-lookup"><span data-stu-id="1dab1-213">gb2312</span></span>|<span data-ttu-id="1dab1-214">简体中文(GB2312)</span><span class="sxs-lookup"><span data-stu-id="1dab1-214">Chinese Simplified (GB2312)</span></span>|<span data-ttu-id="1dab1-215">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-215">✓</span></span>||
|<span data-ttu-id="1dab1-216">949</span><span class="sxs-lookup"><span data-stu-id="1dab1-216">949</span></span>|<span data-ttu-id="1dab1-217">ks_c_5601-1987</span><span class="sxs-lookup"><span data-stu-id="1dab1-217">ks_c_5601-1987</span></span>|<span data-ttu-id="1dab1-218">韩语</span><span class="sxs-lookup"><span data-stu-id="1dab1-218">Korean</span></span>|||
|<span data-ttu-id="1dab1-219">950</span><span class="sxs-lookup"><span data-stu-id="1dab1-219">950</span></span>|<span data-ttu-id="1dab1-220">big5</span><span class="sxs-lookup"><span data-stu-id="1dab1-220">big5</span></span>|<span data-ttu-id="1dab1-221">繁体中文(Big5)</span><span class="sxs-lookup"><span data-stu-id="1dab1-221">Chinese Traditional (Big5)</span></span>|||
|<span data-ttu-id="1dab1-222">1026</span><span class="sxs-lookup"><span data-stu-id="1dab1-222">1026</span></span>|<span data-ttu-id="1dab1-223">IBM1026</span><span class="sxs-lookup"><span data-stu-id="1dab1-223">IBM1026</span></span>|<span data-ttu-id="1dab1-224">IBM EBCDIC （土耳其拉丁语-5）</span><span class="sxs-lookup"><span data-stu-id="1dab1-224">IBM EBCDIC (Turkish Latin-5)</span></span>|||
|<span data-ttu-id="1dab1-225">1047</span><span class="sxs-lookup"><span data-stu-id="1dab1-225">1047</span></span>|<span data-ttu-id="1dab1-226">IBM01047</span><span class="sxs-lookup"><span data-stu-id="1dab1-226">IBM01047</span></span>|<span data-ttu-id="1dab1-227">IBM 拉丁语-1</span><span class="sxs-lookup"><span data-stu-id="1dab1-227">IBM Latin-1</span></span>|||
|<span data-ttu-id="1dab1-228">1140</span><span class="sxs-lookup"><span data-stu-id="1dab1-228">1140</span></span>|<span data-ttu-id="1dab1-229">IBM01140</span><span class="sxs-lookup"><span data-stu-id="1dab1-229">IBM01140</span></span>|<span data-ttu-id="1dab1-230">IBM EBCDIC （美国-加拿大-欧洲）</span><span class="sxs-lookup"><span data-stu-id="1dab1-230">IBM EBCDIC (US-Canada-Euro)</span></span>|||
|<span data-ttu-id="1dab1-231">1141</span><span class="sxs-lookup"><span data-stu-id="1dab1-231">1141</span></span>|<span data-ttu-id="1dab1-232">IBM01141</span><span class="sxs-lookup"><span data-stu-id="1dab1-232">IBM01141</span></span>|<span data-ttu-id="1dab1-233">IBM EBCDIC （德国-欧洲）</span><span class="sxs-lookup"><span data-stu-id="1dab1-233">IBM EBCDIC (Germany-Euro)</span></span>|||
|<span data-ttu-id="1dab1-234">1142</span><span class="sxs-lookup"><span data-stu-id="1dab1-234">1142</span></span>|<span data-ttu-id="1dab1-235">IBM01142</span><span class="sxs-lookup"><span data-stu-id="1dab1-235">IBM01142</span></span>|<span data-ttu-id="1dab1-236">IBM EBCDIC （丹麦-挪威-欧洲）</span><span class="sxs-lookup"><span data-stu-id="1dab1-236">IBM EBCDIC (Denmark-Norway-Euro)</span></span>|||
|<span data-ttu-id="1dab1-237">1143</span><span class="sxs-lookup"><span data-stu-id="1dab1-237">1143</span></span>|<span data-ttu-id="1dab1-238">IBM01143</span><span class="sxs-lookup"><span data-stu-id="1dab1-238">IBM01143</span></span>|<span data-ttu-id="1dab1-239">IBM EBCDIC （芬兰-瑞典-欧洲）</span><span class="sxs-lookup"><span data-stu-id="1dab1-239">IBM EBCDIC (Finland-Sweden-Euro)</span></span>|||
|<span data-ttu-id="1dab1-240">1144</span><span class="sxs-lookup"><span data-stu-id="1dab1-240">1144</span></span>|<span data-ttu-id="1dab1-241">IBM01144</span><span class="sxs-lookup"><span data-stu-id="1dab1-241">IBM01144</span></span>|<span data-ttu-id="1dab1-242">IBM EBCDIC （意大利-欧洲）</span><span class="sxs-lookup"><span data-stu-id="1dab1-242">IBM EBCDIC (Italy-Euro)</span></span>|||
|<span data-ttu-id="1dab1-243">1145</span><span class="sxs-lookup"><span data-stu-id="1dab1-243">1145</span></span>|<span data-ttu-id="1dab1-244">IBM01145</span><span class="sxs-lookup"><span data-stu-id="1dab1-244">IBM01145</span></span>|<span data-ttu-id="1dab1-245">IBM EBCDIC （西班牙-欧洲）</span><span class="sxs-lookup"><span data-stu-id="1dab1-245">IBM EBCDIC (Spain-Euro)</span></span>|||
|<span data-ttu-id="1dab1-246">1146</span><span class="sxs-lookup"><span data-stu-id="1dab1-246">1146</span></span>|<span data-ttu-id="1dab1-247">IBM01146</span><span class="sxs-lookup"><span data-stu-id="1dab1-247">IBM01146</span></span>|<span data-ttu-id="1dab1-248">IBM EBCDIC （英国-欧洲）</span><span class="sxs-lookup"><span data-stu-id="1dab1-248">IBM EBCDIC (UK-Euro)</span></span>|||
|<span data-ttu-id="1dab1-249">1147</span><span class="sxs-lookup"><span data-stu-id="1dab1-249">1147</span></span>|<span data-ttu-id="1dab1-250">IBM01147</span><span class="sxs-lookup"><span data-stu-id="1dab1-250">IBM01147</span></span>|<span data-ttu-id="1dab1-251">IBM EBCDIC （法国-欧洲）</span><span class="sxs-lookup"><span data-stu-id="1dab1-251">IBM EBCDIC (France-Euro)</span></span>|||
|<span data-ttu-id="1dab1-252">1148</span><span class="sxs-lookup"><span data-stu-id="1dab1-252">1148</span></span>|<span data-ttu-id="1dab1-253">IBM01148</span><span class="sxs-lookup"><span data-stu-id="1dab1-253">IBM01148</span></span>|<span data-ttu-id="1dab1-254">IBM EBCDIC （国际-欧洲）</span><span class="sxs-lookup"><span data-stu-id="1dab1-254">IBM EBCDIC (International-Euro)</span></span>|||
|<span data-ttu-id="1dab1-255">1149</span><span class="sxs-lookup"><span data-stu-id="1dab1-255">1149</span></span>|<span data-ttu-id="1dab1-256">IBM01149</span><span class="sxs-lookup"><span data-stu-id="1dab1-256">IBM01149</span></span>|<span data-ttu-id="1dab1-257">IBM EBCDIC （冰岛语-欧洲）</span><span class="sxs-lookup"><span data-stu-id="1dab1-257">IBM EBCDIC (Icelandic-Euro)</span></span>|||
|<span data-ttu-id="1dab1-258">1200</span><span class="sxs-lookup"><span data-stu-id="1dab1-258">1200</span></span>|<span data-ttu-id="1dab1-259">utf-16</span><span class="sxs-lookup"><span data-stu-id="1dab1-259">utf-16</span></span>|<span data-ttu-id="1dab1-260">Unicode</span><span class="sxs-lookup"><span data-stu-id="1dab1-260">Unicode</span></span>|<span data-ttu-id="1dab1-261">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-261">✓</span></span>|<span data-ttu-id="1dab1-262">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-262">✓</span></span>|
|<span data-ttu-id="1dab1-263">1201</span><span class="sxs-lookup"><span data-stu-id="1dab1-263">1201</span></span>|<span data-ttu-id="1dab1-264">unicodeFFFE</span><span class="sxs-lookup"><span data-stu-id="1dab1-264">unicodeFFFE</span></span>|<span data-ttu-id="1dab1-265">Unicode （大字节序）</span><span class="sxs-lookup"><span data-stu-id="1dab1-265">Unicode (Big endian)</span></span>|<span data-ttu-id="1dab1-266">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-266">✓</span></span>|<span data-ttu-id="1dab1-267">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-267">✓</span></span>|
|<span data-ttu-id="1dab1-268">1250</span><span class="sxs-lookup"><span data-stu-id="1dab1-268">1250</span></span>|<span data-ttu-id="1dab1-269">windows-1250</span><span class="sxs-lookup"><span data-stu-id="1dab1-269">windows-1250</span></span>|<span data-ttu-id="1dab1-270">中欧语（Windows）</span><span class="sxs-lookup"><span data-stu-id="1dab1-270">Central European (Windows)</span></span>|||
|<span data-ttu-id="1dab1-271">1251</span><span class="sxs-lookup"><span data-stu-id="1dab1-271">1251</span></span>|<span data-ttu-id="1dab1-272">windows-1251</span><span class="sxs-lookup"><span data-stu-id="1dab1-272">windows-1251</span></span>|<span data-ttu-id="1dab1-273">西里尔语（Windows）</span><span class="sxs-lookup"><span data-stu-id="1dab1-273">Cyrillic (Windows)</span></span>|||
|<span data-ttu-id="1dab1-274">1252</span><span class="sxs-lookup"><span data-stu-id="1dab1-274">1252</span></span>|<span data-ttu-id="1dab1-275">GB2312</span><span class="sxs-lookup"><span data-stu-id="1dab1-275">Windows-1252</span></span>|<span data-ttu-id="1dab1-276">西欧语(Windows)</span><span class="sxs-lookup"><span data-stu-id="1dab1-276">Western European (Windows)</span></span>|<span data-ttu-id="1dab1-277">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-277">✓</span></span>||
|<span data-ttu-id="1dab1-278">1253</span><span class="sxs-lookup"><span data-stu-id="1dab1-278">1253</span></span>|<span data-ttu-id="1dab1-279">windows-1253</span><span class="sxs-lookup"><span data-stu-id="1dab1-279">windows-1253</span></span>|<span data-ttu-id="1dab1-280">希腊语（Windows）</span><span class="sxs-lookup"><span data-stu-id="1dab1-280">Greek (Windows)</span></span>|||
|<span data-ttu-id="1dab1-281">1254</span><span class="sxs-lookup"><span data-stu-id="1dab1-281">1254</span></span>|<span data-ttu-id="1dab1-282">windows-1254</span><span class="sxs-lookup"><span data-stu-id="1dab1-282">windows-1254</span></span>|<span data-ttu-id="1dab1-283">土耳其语（Windows）</span><span class="sxs-lookup"><span data-stu-id="1dab1-283">Turkish (Windows)</span></span>|||
|<span data-ttu-id="1dab1-284">1255</span><span class="sxs-lookup"><span data-stu-id="1dab1-284">1255</span></span>|<span data-ttu-id="1dab1-285">windows-1255</span><span class="sxs-lookup"><span data-stu-id="1dab1-285">windows-1255</span></span>|<span data-ttu-id="1dab1-286">希伯来语（Windows）</span><span class="sxs-lookup"><span data-stu-id="1dab1-286">Hebrew (Windows)</span></span>|||
|<span data-ttu-id="1dab1-287">1256</span><span class="sxs-lookup"><span data-stu-id="1dab1-287">1256</span></span>|<span data-ttu-id="1dab1-288">windows-1256</span><span class="sxs-lookup"><span data-stu-id="1dab1-288">windows-1256</span></span>|<span data-ttu-id="1dab1-289">阿拉伯语（Windows）</span><span class="sxs-lookup"><span data-stu-id="1dab1-289">Arabic (Windows)</span></span>|||
|<span data-ttu-id="1dab1-290">1257</span><span class="sxs-lookup"><span data-stu-id="1dab1-290">1257</span></span>|<span data-ttu-id="1dab1-291">windows-1257</span><span class="sxs-lookup"><span data-stu-id="1dab1-291">windows-1257</span></span>|<span data-ttu-id="1dab1-292">波罗的语（Windows）</span><span class="sxs-lookup"><span data-stu-id="1dab1-292">Baltic (Windows)</span></span>|||
|<span data-ttu-id="1dab1-293">1258</span><span class="sxs-lookup"><span data-stu-id="1dab1-293">1258</span></span>|<span data-ttu-id="1dab1-294">windows-1258</span><span class="sxs-lookup"><span data-stu-id="1dab1-294">windows-1258</span></span>|<span data-ttu-id="1dab1-295">越南语（Windows）</span><span class="sxs-lookup"><span data-stu-id="1dab1-295">Vietnamese (Windows)</span></span>|||
|<span data-ttu-id="1dab1-296">1361</span><span class="sxs-lookup"><span data-stu-id="1dab1-296">1361</span></span>|<span data-ttu-id="1dab1-297">Johab</span><span class="sxs-lookup"><span data-stu-id="1dab1-297">Johab</span></span>|<span data-ttu-id="1dab1-298">韩语（Johab）</span><span class="sxs-lookup"><span data-stu-id="1dab1-298">Korean (Johab)</span></span>|||
|<span data-ttu-id="1dab1-299">10000</span><span class="sxs-lookup"><span data-stu-id="1dab1-299">10000</span></span>|<span data-ttu-id="1dab1-300">macintosh</span><span class="sxs-lookup"><span data-stu-id="1dab1-300">macintosh</span></span>|<span data-ttu-id="1dab1-301">西欧（Mac）</span><span class="sxs-lookup"><span data-stu-id="1dab1-301">Western European (Mac)</span></span>|||
|<span data-ttu-id="1dab1-302">10001</span><span class="sxs-lookup"><span data-stu-id="1dab1-302">10001</span></span>|<span data-ttu-id="1dab1-303">x-mac-日语</span><span class="sxs-lookup"><span data-stu-id="1dab1-303">x-mac-japanese</span></span>|<span data-ttu-id="1dab1-304">日语（Mac）</span><span class="sxs-lookup"><span data-stu-id="1dab1-304">Japanese (Mac)</span></span>|||
|<span data-ttu-id="1dab1-305">10002</span><span class="sxs-lookup"><span data-stu-id="1dab1-305">10002</span></span>|<span data-ttu-id="1dab1-306">x-mac-chinesetrad</span><span class="sxs-lookup"><span data-stu-id="1dab1-306">x-mac-chinesetrad</span></span>|<span data-ttu-id="1dab1-307">繁体中文（Mac）</span><span class="sxs-lookup"><span data-stu-id="1dab1-307">Chinese Traditional (Mac)</span></span>|||
|<span data-ttu-id="1dab1-308">10003</span><span class="sxs-lookup"><span data-stu-id="1dab1-308">10003</span></span>|<span data-ttu-id="1dab1-309">x-mac-韩语</span><span class="sxs-lookup"><span data-stu-id="1dab1-309">x-mac-korean</span></span>|<span data-ttu-id="1dab1-310">朝鲜语(Mac)</span><span class="sxs-lookup"><span data-stu-id="1dab1-310">Korean (Mac)</span></span>|<span data-ttu-id="1dab1-311">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-311">✓</span></span>||
|<span data-ttu-id="1dab1-312">10004</span><span class="sxs-lookup"><span data-stu-id="1dab1-312">10004</span></span>|<span data-ttu-id="1dab1-313">x-mac-arabic</span><span class="sxs-lookup"><span data-stu-id="1dab1-313">x-mac-arabic</span></span>|<span data-ttu-id="1dab1-314">阿拉伯语（Mac）</span><span class="sxs-lookup"><span data-stu-id="1dab1-314">Arabic (Mac)</span></span>|||
|<span data-ttu-id="1dab1-315">10005</span><span class="sxs-lookup"><span data-stu-id="1dab1-315">10005</span></span>|<span data-ttu-id="1dab1-316">x-mac-hebrew</span><span class="sxs-lookup"><span data-stu-id="1dab1-316">x-mac-hebrew</span></span>|<span data-ttu-id="1dab1-317">希伯来语（Mac）</span><span class="sxs-lookup"><span data-stu-id="1dab1-317">Hebrew (Mac)</span></span>|||
|<span data-ttu-id="1dab1-318">10006</span><span class="sxs-lookup"><span data-stu-id="1dab1-318">10006</span></span>|<span data-ttu-id="1dab1-319">x-mac-希腊语</span><span class="sxs-lookup"><span data-stu-id="1dab1-319">x-mac-greek</span></span>|<span data-ttu-id="1dab1-320">希腊语（Mac）</span><span class="sxs-lookup"><span data-stu-id="1dab1-320">Greek (Mac)</span></span>|||
|<span data-ttu-id="1dab1-321">10007</span><span class="sxs-lookup"><span data-stu-id="1dab1-321">10007</span></span>|<span data-ttu-id="1dab1-322">x-mac-cyrillic</span><span class="sxs-lookup"><span data-stu-id="1dab1-322">x-mac-cyrillic</span></span>|<span data-ttu-id="1dab1-323">西里尔语（Mac）</span><span class="sxs-lookup"><span data-stu-id="1dab1-323">Cyrillic (Mac)</span></span>|||
|<span data-ttu-id="1dab1-324">10008</span><span class="sxs-lookup"><span data-stu-id="1dab1-324">10008</span></span>|<span data-ttu-id="1dab1-325">x-mac-chinesesimp</span><span class="sxs-lookup"><span data-stu-id="1dab1-325">x-mac-chinesesimp</span></span>|<span data-ttu-id="1dab1-326">简体中文(Mac)</span><span class="sxs-lookup"><span data-stu-id="1dab1-326">Chinese Simplified (Mac)</span></span>|<span data-ttu-id="1dab1-327">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-327">✓</span></span>||
|<span data-ttu-id="1dab1-328">10010</span><span class="sxs-lookup"><span data-stu-id="1dab1-328">10010</span></span>|<span data-ttu-id="1dab1-329">x-mac</span><span class="sxs-lookup"><span data-stu-id="1dab1-329">x-mac-romanian</span></span>|<span data-ttu-id="1dab1-330">罗马尼亚语（Mac）</span><span class="sxs-lookup"><span data-stu-id="1dab1-330">Romanian (Mac)</span></span>|||
|<span data-ttu-id="1dab1-331">10017</span><span class="sxs-lookup"><span data-stu-id="1dab1-331">10017</span></span>|<span data-ttu-id="1dab1-332">x-mac-乌克兰语</span><span class="sxs-lookup"><span data-stu-id="1dab1-332">x-mac-ukrainian</span></span>|<span data-ttu-id="1dab1-333">乌克兰语（Mac）</span><span class="sxs-lookup"><span data-stu-id="1dab1-333">Ukrainian (Mac)</span></span>|||
|<span data-ttu-id="1dab1-334">10021</span><span class="sxs-lookup"><span data-stu-id="1dab1-334">10021</span></span>|<span data-ttu-id="1dab1-335">x-mac-泰语</span><span class="sxs-lookup"><span data-stu-id="1dab1-335">x-mac-thai</span></span>|<span data-ttu-id="1dab1-336">泰语（Mac）</span><span class="sxs-lookup"><span data-stu-id="1dab1-336">Thai (Mac)</span></span>|||
|<span data-ttu-id="1dab1-337">10029</span><span class="sxs-lookup"><span data-stu-id="1dab1-337">10029</span></span>|<span data-ttu-id="1dab1-338">x-mac-ce</span><span class="sxs-lookup"><span data-stu-id="1dab1-338">x-mac-ce</span></span>|<span data-ttu-id="1dab1-339">中欧语（Mac）</span><span class="sxs-lookup"><span data-stu-id="1dab1-339">Central European (Mac)</span></span>|||
|<span data-ttu-id="1dab1-340">10079</span><span class="sxs-lookup"><span data-stu-id="1dab1-340">10079</span></span>|<span data-ttu-id="1dab1-341">x-mac-冰岛语</span><span class="sxs-lookup"><span data-stu-id="1dab1-341">x-mac-icelandic</span></span>|<span data-ttu-id="1dab1-342">冰岛语（Mac）</span><span class="sxs-lookup"><span data-stu-id="1dab1-342">Icelandic (Mac)</span></span>|||
|<span data-ttu-id="1dab1-343">10081</span><span class="sxs-lookup"><span data-stu-id="1dab1-343">10081</span></span>|<span data-ttu-id="1dab1-344">x-mac-turkish</span><span class="sxs-lookup"><span data-stu-id="1dab1-344">x-mac-turkish</span></span>|<span data-ttu-id="1dab1-345">土耳其语（Mac）</span><span class="sxs-lookup"><span data-stu-id="1dab1-345">Turkish (Mac)</span></span>|||
|<span data-ttu-id="1dab1-346">10082</span><span class="sxs-lookup"><span data-stu-id="1dab1-346">10082</span></span>|<span data-ttu-id="1dab1-347">x-mac-克罗地亚语</span><span class="sxs-lookup"><span data-stu-id="1dab1-347">x-mac-croatian</span></span>|<span data-ttu-id="1dab1-348">克罗地亚语（Mac）</span><span class="sxs-lookup"><span data-stu-id="1dab1-348">Croatian (Mac)</span></span>|||
|<span data-ttu-id="1dab1-349">12000</span><span class="sxs-lookup"><span data-stu-id="1dab1-349">12000</span></span>|<span data-ttu-id="1dab1-350">utf-32</span><span class="sxs-lookup"><span data-stu-id="1dab1-350">utf-32</span></span>|<span data-ttu-id="1dab1-351">Unicode （UTF-32）</span><span class="sxs-lookup"><span data-stu-id="1dab1-351">Unicode (UTF-32)</span></span>|<span data-ttu-id="1dab1-352">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-352">✓</span></span>|<span data-ttu-id="1dab1-353">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-353">✓</span></span>|
|<span data-ttu-id="1dab1-354">12001</span><span class="sxs-lookup"><span data-stu-id="1dab1-354">12001</span></span>|<span data-ttu-id="1dab1-355">utf-32BE</span><span class="sxs-lookup"><span data-stu-id="1dab1-355">utf-32BE</span></span>|<span data-ttu-id="1dab1-356">Unicode （UTF-16 32 大字节序）</span><span class="sxs-lookup"><span data-stu-id="1dab1-356">Unicode (UTF-32 Big endian)</span></span>|<span data-ttu-id="1dab1-357">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-357">✓</span></span>|<span data-ttu-id="1dab1-358">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-358">✓</span></span>|
|<span data-ttu-id="1dab1-359">20000</span><span class="sxs-lookup"><span data-stu-id="1dab1-359">20000</span></span>|<span data-ttu-id="1dab1-360">x-中文-CNS</span><span class="sxs-lookup"><span data-stu-id="1dab1-360">x-Chinese-CNS</span></span>|<span data-ttu-id="1dab1-361">繁体中文（CNS）</span><span class="sxs-lookup"><span data-stu-id="1dab1-361">Chinese Traditional (CNS)</span></span>|||
|<span data-ttu-id="1dab1-362">20001</span><span class="sxs-lookup"><span data-stu-id="1dab1-362">20001</span></span>|<span data-ttu-id="1dab1-363">x-cp20001</span><span class="sxs-lookup"><span data-stu-id="1dab1-363">x-cp20001</span></span>|<span data-ttu-id="1dab1-364">TCA 台湾</span><span class="sxs-lookup"><span data-stu-id="1dab1-364">TCA Taiwan</span></span>|||
|<span data-ttu-id="1dab1-365">20002</span><span class="sxs-lookup"><span data-stu-id="1dab1-365">20002</span></span>|<span data-ttu-id="1dab1-366">x-中文-Eten</span><span class="sxs-lookup"><span data-stu-id="1dab1-366">x-Chinese-Eten</span></span>|<span data-ttu-id="1dab1-367">繁体中文（Eten）</span><span class="sxs-lookup"><span data-stu-id="1dab1-367">Chinese Traditional (Eten)</span></span>|||
|<span data-ttu-id="1dab1-368">20003</span><span class="sxs-lookup"><span data-stu-id="1dab1-368">20003</span></span>|<span data-ttu-id="1dab1-369">x-cp20003</span><span class="sxs-lookup"><span data-stu-id="1dab1-369">x-cp20003</span></span>|<span data-ttu-id="1dab1-370">IBM5550 台湾</span><span class="sxs-lookup"><span data-stu-id="1dab1-370">IBM5550 Taiwan</span></span>|||
|<span data-ttu-id="1dab1-371">20004</span><span class="sxs-lookup"><span data-stu-id="1dab1-371">20004</span></span>|<span data-ttu-id="1dab1-372">x-cp20004</span><span class="sxs-lookup"><span data-stu-id="1dab1-372">x-cp20004</span></span>|<span data-ttu-id="1dab1-373">TeleText 台湾</span><span class="sxs-lookup"><span data-stu-id="1dab1-373">TeleText Taiwan</span></span>|||
|<span data-ttu-id="1dab1-374">20005</span><span class="sxs-lookup"><span data-stu-id="1dab1-374">20005</span></span>|<span data-ttu-id="1dab1-375">x-cp20005</span><span class="sxs-lookup"><span data-stu-id="1dab1-375">x-cp20005</span></span>|<span data-ttu-id="1dab1-376">Wang 台湾</span><span class="sxs-lookup"><span data-stu-id="1dab1-376">Wang Taiwan</span></span>|||
|<span data-ttu-id="1dab1-377">20105</span><span class="sxs-lookup"><span data-stu-id="1dab1-377">20105</span></span>|<span data-ttu-id="1dab1-378">x-IA5</span><span class="sxs-lookup"><span data-stu-id="1dab1-378">x-IA5</span></span>|<span data-ttu-id="1dab1-379">西欧（IA5）</span><span class="sxs-lookup"><span data-stu-id="1dab1-379">Western European (IA5)</span></span>|||
|<span data-ttu-id="1dab1-380">20106</span><span class="sxs-lookup"><span data-stu-id="1dab1-380">20106</span></span>|<span data-ttu-id="1dab1-381">x-IA5-德语</span><span class="sxs-lookup"><span data-stu-id="1dab1-381">x-IA5-German</span></span>|<span data-ttu-id="1dab1-382">德语（IA5）</span><span class="sxs-lookup"><span data-stu-id="1dab1-382">German (IA5)</span></span>|||
|<span data-ttu-id="1dab1-383">20107</span><span class="sxs-lookup"><span data-stu-id="1dab1-383">20107</span></span>|<span data-ttu-id="1dab1-384">x IA5-瑞典语</span><span class="sxs-lookup"><span data-stu-id="1dab1-384">x-IA5-Swedish</span></span>|<span data-ttu-id="1dab1-385">瑞典语（IA5）</span><span class="sxs-lookup"><span data-stu-id="1dab1-385">Swedish (IA5)</span></span>|||
|<span data-ttu-id="1dab1-386">20108</span><span class="sxs-lookup"><span data-stu-id="1dab1-386">20108</span></span>|<span data-ttu-id="1dab1-387">x-IA5-Norwegian</span><span class="sxs-lookup"><span data-stu-id="1dab1-387">x-IA5-Norwegian</span></span>|<span data-ttu-id="1dab1-388">挪威语（IA5）</span><span class="sxs-lookup"><span data-stu-id="1dab1-388">Norwegian (IA5)</span></span>|||
|<span data-ttu-id="1dab1-389">20127</span><span class="sxs-lookup"><span data-stu-id="1dab1-389">20127</span></span>|<span data-ttu-id="1dab1-390">us-ascii</span><span class="sxs-lookup"><span data-stu-id="1dab1-390">us-ascii</span></span>|<span data-ttu-id="1dab1-391">US-ASCII</span><span class="sxs-lookup"><span data-stu-id="1dab1-391">US-ASCII</span></span>|<span data-ttu-id="1dab1-392">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-392">✓</span></span>|<span data-ttu-id="1dab1-393">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-393">✓</span></span>|
|<span data-ttu-id="1dab1-394">20261</span><span class="sxs-lookup"><span data-stu-id="1dab1-394">20261</span></span>|<span data-ttu-id="1dab1-395">x-cp20261</span><span class="sxs-lookup"><span data-stu-id="1dab1-395">x-cp20261</span></span>|<span data-ttu-id="1dab1-396">T.61</span><span class="sxs-lookup"><span data-stu-id="1dab1-396">T.61</span></span>|||
|<span data-ttu-id="1dab1-397">20269</span><span class="sxs-lookup"><span data-stu-id="1dab1-397">20269</span></span>|<span data-ttu-id="1dab1-398">x-cp20269</span><span class="sxs-lookup"><span data-stu-id="1dab1-398">x-cp20269</span></span>|<span data-ttu-id="1dab1-399">ISO-6937</span><span class="sxs-lookup"><span data-stu-id="1dab1-399">ISO-6937</span></span>|||
|<span data-ttu-id="1dab1-400">20273</span><span class="sxs-lookup"><span data-stu-id="1dab1-400">20273</span></span>|<span data-ttu-id="1dab1-401">IBM273</span><span class="sxs-lookup"><span data-stu-id="1dab1-401">IBM273</span></span>|<span data-ttu-id="1dab1-402">IBM EBCDIC （德国）</span><span class="sxs-lookup"><span data-stu-id="1dab1-402">IBM EBCDIC (Germany)</span></span>|||
|<span data-ttu-id="1dab1-403">20277</span><span class="sxs-lookup"><span data-stu-id="1dab1-403">20277</span></span>|<span data-ttu-id="1dab1-404">IBM277</span><span class="sxs-lookup"><span data-stu-id="1dab1-404">IBM277</span></span>|<span data-ttu-id="1dab1-405">IBM EBCDIC （丹麦-挪威）</span><span class="sxs-lookup"><span data-stu-id="1dab1-405">IBM EBCDIC (Denmark-Norway)</span></span>|||
|<span data-ttu-id="1dab1-406">20278</span><span class="sxs-lookup"><span data-stu-id="1dab1-406">20278</span></span>|<span data-ttu-id="1dab1-407">IBM278</span><span class="sxs-lookup"><span data-stu-id="1dab1-407">IBM278</span></span>|<span data-ttu-id="1dab1-408">IBM EBCDIC （芬兰-瑞典）</span><span class="sxs-lookup"><span data-stu-id="1dab1-408">IBM EBCDIC (Finland-Sweden)</span></span>|||
|<span data-ttu-id="1dab1-409">20280</span><span class="sxs-lookup"><span data-stu-id="1dab1-409">20280</span></span>|<span data-ttu-id="1dab1-410">IBM280</span><span class="sxs-lookup"><span data-stu-id="1dab1-410">IBM280</span></span>|<span data-ttu-id="1dab1-411">IBM EBCDIC （意大利）</span><span class="sxs-lookup"><span data-stu-id="1dab1-411">IBM EBCDIC (Italy)</span></span>|||
|<span data-ttu-id="1dab1-412">20284</span><span class="sxs-lookup"><span data-stu-id="1dab1-412">20284</span></span>|<span data-ttu-id="1dab1-413">IBM284</span><span class="sxs-lookup"><span data-stu-id="1dab1-413">IBM284</span></span>|<span data-ttu-id="1dab1-414">IBM EBCDIC （西班牙）</span><span class="sxs-lookup"><span data-stu-id="1dab1-414">IBM EBCDIC (Spain)</span></span>|||
|<span data-ttu-id="1dab1-415">20285</span><span class="sxs-lookup"><span data-stu-id="1dab1-415">20285</span></span>|<span data-ttu-id="1dab1-416">IBM285</span><span class="sxs-lookup"><span data-stu-id="1dab1-416">IBM285</span></span>|<span data-ttu-id="1dab1-417">IBM EBCDIC （英国）</span><span class="sxs-lookup"><span data-stu-id="1dab1-417">IBM EBCDIC (UK)</span></span>|||
|<span data-ttu-id="1dab1-418">20290</span><span class="sxs-lookup"><span data-stu-id="1dab1-418">20290</span></span>|<span data-ttu-id="1dab1-419">IBM290</span><span class="sxs-lookup"><span data-stu-id="1dab1-419">IBM290</span></span>|<span data-ttu-id="1dab1-420">IBM EBCDIC （日语片假名）</span><span class="sxs-lookup"><span data-stu-id="1dab1-420">IBM EBCDIC (Japanese katakana)</span></span>|||
|<span data-ttu-id="1dab1-421">20297</span><span class="sxs-lookup"><span data-stu-id="1dab1-421">20297</span></span>|<span data-ttu-id="1dab1-422">IBM297</span><span class="sxs-lookup"><span data-stu-id="1dab1-422">IBM297</span></span>|<span data-ttu-id="1dab1-423">IBM EBCDIC （法国）</span><span class="sxs-lookup"><span data-stu-id="1dab1-423">IBM EBCDIC (France)</span></span>|||
|<span data-ttu-id="1dab1-424">20420</span><span class="sxs-lookup"><span data-stu-id="1dab1-424">20420</span></span>|<span data-ttu-id="1dab1-425">IBM420</span><span class="sxs-lookup"><span data-stu-id="1dab1-425">IBM420</span></span>|<span data-ttu-id="1dab1-426">IBM EBCDIC （阿拉伯语）</span><span class="sxs-lookup"><span data-stu-id="1dab1-426">IBM EBCDIC (Arabic)</span></span>|||
|<span data-ttu-id="1dab1-427">20423</span><span class="sxs-lookup"><span data-stu-id="1dab1-427">20423</span></span>|<span data-ttu-id="1dab1-428">IBM423</span><span class="sxs-lookup"><span data-stu-id="1dab1-428">IBM423</span></span>|<span data-ttu-id="1dab1-429">IBM EBCDIC （希腊语）</span><span class="sxs-lookup"><span data-stu-id="1dab1-429">IBM EBCDIC (Greek)</span></span>|||
|<span data-ttu-id="1dab1-430">20424</span><span class="sxs-lookup"><span data-stu-id="1dab1-430">20424</span></span>|<span data-ttu-id="1dab1-431">IBM424</span><span class="sxs-lookup"><span data-stu-id="1dab1-431">IBM424</span></span>|<span data-ttu-id="1dab1-432">IBM EBCDIC （希伯来语）</span><span class="sxs-lookup"><span data-stu-id="1dab1-432">IBM EBCDIC (Hebrew)</span></span>|||
|<span data-ttu-id="1dab1-433">20833</span><span class="sxs-lookup"><span data-stu-id="1dab1-433">20833</span></span>|<span data-ttu-id="1dab1-434">x-EBCDIC-KoreanExtended</span><span class="sxs-lookup"><span data-stu-id="1dab1-434">x-EBCDIC-KoreanExtended</span></span>|<span data-ttu-id="1dab1-435">IBM EBCDIC （朝鲜语扩展）</span><span class="sxs-lookup"><span data-stu-id="1dab1-435">IBM EBCDIC (Korean Extended)</span></span>|||
|<span data-ttu-id="1dab1-436">20838</span><span class="sxs-lookup"><span data-stu-id="1dab1-436">20838</span></span>|<span data-ttu-id="1dab1-437">IBM-泰语</span><span class="sxs-lookup"><span data-stu-id="1dab1-437">IBM-Thai</span></span>|<span data-ttu-id="1dab1-438">IBM EBCDIC （泰语）</span><span class="sxs-lookup"><span data-stu-id="1dab1-438">IBM EBCDIC (Thai)</span></span>|||
|<span data-ttu-id="1dab1-439">20866</span><span class="sxs-lookup"><span data-stu-id="1dab1-439">20866</span></span>|<span data-ttu-id="1dab1-440">koi8-r</span><span class="sxs-lookup"><span data-stu-id="1dab1-440">koi8-r</span></span>|<span data-ttu-id="1dab1-441">西里尔语（KOI8-RU-R）</span><span class="sxs-lookup"><span data-stu-id="1dab1-441">Cyrillic (KOI8-R)</span></span>|||
|<span data-ttu-id="1dab1-442">20871</span><span class="sxs-lookup"><span data-stu-id="1dab1-442">20871</span></span>|<span data-ttu-id="1dab1-443">IBM871</span><span class="sxs-lookup"><span data-stu-id="1dab1-443">IBM871</span></span>|<span data-ttu-id="1dab1-444">IBM EBCDIC （冰岛语）</span><span class="sxs-lookup"><span data-stu-id="1dab1-444">IBM EBCDIC (Icelandic)</span></span>|||
|<span data-ttu-id="1dab1-445">20880</span><span class="sxs-lookup"><span data-stu-id="1dab1-445">20880</span></span>|<span data-ttu-id="1dab1-446">IBM880</span><span class="sxs-lookup"><span data-stu-id="1dab1-446">IBM880</span></span>|<span data-ttu-id="1dab1-447">IBM EBCDIC （西里尔语俄语）</span><span class="sxs-lookup"><span data-stu-id="1dab1-447">IBM EBCDIC (Cyrillic Russian)</span></span>|||
|<span data-ttu-id="1dab1-448">20905</span><span class="sxs-lookup"><span data-stu-id="1dab1-448">20905</span></span>|<span data-ttu-id="1dab1-449">IBM905</span><span class="sxs-lookup"><span data-stu-id="1dab1-449">IBM905</span></span>|<span data-ttu-id="1dab1-450">IBM EBCDIC （土耳其语）</span><span class="sxs-lookup"><span data-stu-id="1dab1-450">IBM EBCDIC (Turkish)</span></span>|||
|<span data-ttu-id="1dab1-451">20924</span><span class="sxs-lookup"><span data-stu-id="1dab1-451">20924</span></span>|<span data-ttu-id="1dab1-452">IBM00924</span><span class="sxs-lookup"><span data-stu-id="1dab1-452">IBM00924</span></span>|<span data-ttu-id="1dab1-453">IBM 拉丁语-1</span><span class="sxs-lookup"><span data-stu-id="1dab1-453">IBM Latin-1</span></span>|||
|<span data-ttu-id="1dab1-454">20932</span><span class="sxs-lookup"><span data-stu-id="1dab1-454">20932</span></span>|<span data-ttu-id="1dab1-455">EUC-JP</span><span class="sxs-lookup"><span data-stu-id="1dab1-455">EUC-JP</span></span>|<span data-ttu-id="1dab1-456">日语（JIS 0208-1990 和0212-1990）</span><span class="sxs-lookup"><span data-stu-id="1dab1-456">Japanese (JIS 0208-1990 and 0212-1990)</span></span>|||
|<span data-ttu-id="1dab1-457">20936</span><span class="sxs-lookup"><span data-stu-id="1dab1-457">20936</span></span>|<span data-ttu-id="1dab1-458">x-cp20936</span><span class="sxs-lookup"><span data-stu-id="1dab1-458">x-cp20936</span></span>|<span data-ttu-id="1dab1-459">简体中文(GB2312-80)</span><span class="sxs-lookup"><span data-stu-id="1dab1-459">Chinese Simplified (GB2312-80)</span></span>|<span data-ttu-id="1dab1-460">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-460">✓</span></span>||
|<span data-ttu-id="1dab1-461">20949</span><span class="sxs-lookup"><span data-stu-id="1dab1-461">20949</span></span>|<span data-ttu-id="1dab1-462">x-cp20949</span><span class="sxs-lookup"><span data-stu-id="1dab1-462">x-cp20949</span></span>|<span data-ttu-id="1dab1-463">韩语 Wansung</span><span class="sxs-lookup"><span data-stu-id="1dab1-463">Korean Wansung</span></span>|<span data-ttu-id="1dab1-464">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-464">✓</span></span>||
|<span data-ttu-id="1dab1-465">21025</span><span class="sxs-lookup"><span data-stu-id="1dab1-465">21025</span></span>|<span data-ttu-id="1dab1-466">cp1025</span><span class="sxs-lookup"><span data-stu-id="1dab1-466">cp1025</span></span>|<span data-ttu-id="1dab1-467">IBM EBCDIC （西里尔语塞尔维亚语-保加利亚语）</span><span class="sxs-lookup"><span data-stu-id="1dab1-467">IBM EBCDIC (Cyrillic Serbian-Bulgarian)</span></span>|||
|<span data-ttu-id="1dab1-468">21866</span><span class="sxs-lookup"><span data-stu-id="1dab1-468">21866</span></span>|<span data-ttu-id="1dab1-469">koi8-ru-u</span><span class="sxs-lookup"><span data-stu-id="1dab1-469">koi8-u</span></span>|<span data-ttu-id="1dab1-470">西里尔语（KOI8-RU）</span><span class="sxs-lookup"><span data-stu-id="1dab1-470">Cyrillic (KOI8-U)</span></span>|||
|<span data-ttu-id="1dab1-471">28591</span><span class="sxs-lookup"><span data-stu-id="1dab1-471">28591</span></span>|<span data-ttu-id="1dab1-472">iso-8859-1</span><span class="sxs-lookup"><span data-stu-id="1dab1-472">iso-8859-1</span></span>|<span data-ttu-id="1dab1-473">西欧语(ISO)</span><span class="sxs-lookup"><span data-stu-id="1dab1-473">Western European (ISO)</span></span>|<span data-ttu-id="1dab1-474">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-474">✓</span></span>|<span data-ttu-id="1dab1-475">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-475">✓</span></span>|
|<span data-ttu-id="1dab1-476">28592</span><span class="sxs-lookup"><span data-stu-id="1dab1-476">28592</span></span>|<span data-ttu-id="1dab1-477">iso-8859-2</span><span class="sxs-lookup"><span data-stu-id="1dab1-477">iso-8859-2</span></span>|<span data-ttu-id="1dab1-478">中欧语（ISO）</span><span class="sxs-lookup"><span data-stu-id="1dab1-478">Central European (ISO)</span></span>|||
|<span data-ttu-id="1dab1-479">28593</span><span class="sxs-lookup"><span data-stu-id="1dab1-479">28593</span></span>|<span data-ttu-id="1dab1-480">iso-8859-3</span><span class="sxs-lookup"><span data-stu-id="1dab1-480">iso-8859-3</span></span>|<span data-ttu-id="1dab1-481">拉丁语3（ISO）</span><span class="sxs-lookup"><span data-stu-id="1dab1-481">Latin 3 (ISO)</span></span>|||
|<span data-ttu-id="1dab1-482">28594</span><span class="sxs-lookup"><span data-stu-id="1dab1-482">28594</span></span>|<span data-ttu-id="1dab1-483">iso-8859-4</span><span class="sxs-lookup"><span data-stu-id="1dab1-483">iso-8859-4</span></span>|<span data-ttu-id="1dab1-484">波罗的语（ISO）</span><span class="sxs-lookup"><span data-stu-id="1dab1-484">Baltic (ISO)</span></span>|||
|<span data-ttu-id="1dab1-485">28595</span><span class="sxs-lookup"><span data-stu-id="1dab1-485">28595</span></span>|<span data-ttu-id="1dab1-486">iso-8859-5</span><span class="sxs-lookup"><span data-stu-id="1dab1-486">iso-8859-5</span></span>|<span data-ttu-id="1dab1-487">西里尔语（ISO）</span><span class="sxs-lookup"><span data-stu-id="1dab1-487">Cyrillic (ISO)</span></span>|||
|<span data-ttu-id="1dab1-488">28596</span><span class="sxs-lookup"><span data-stu-id="1dab1-488">28596</span></span>|<span data-ttu-id="1dab1-489">iso-8859-6</span><span class="sxs-lookup"><span data-stu-id="1dab1-489">iso-8859-6</span></span>|<span data-ttu-id="1dab1-490">阿拉伯语（ISO）</span><span class="sxs-lookup"><span data-stu-id="1dab1-490">Arabic (ISO)</span></span>|||
|<span data-ttu-id="1dab1-491">28597</span><span class="sxs-lookup"><span data-stu-id="1dab1-491">28597</span></span>|<span data-ttu-id="1dab1-492">iso-8859-7</span><span class="sxs-lookup"><span data-stu-id="1dab1-492">iso-8859-7</span></span>|<span data-ttu-id="1dab1-493">希腊语（ISO）</span><span class="sxs-lookup"><span data-stu-id="1dab1-493">Greek (ISO)</span></span>|||
|<span data-ttu-id="1dab1-494">28598</span><span class="sxs-lookup"><span data-stu-id="1dab1-494">28598</span></span>|<span data-ttu-id="1dab1-495">iso-8859-8</span><span class="sxs-lookup"><span data-stu-id="1dab1-495">iso-8859-8</span></span>|<span data-ttu-id="1dab1-496">希伯来语(ISO-Visual)</span><span class="sxs-lookup"><span data-stu-id="1dab1-496">Hebrew (ISO-Visual)</span></span>|<span data-ttu-id="1dab1-497">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-497">✓</span></span>||
|<span data-ttu-id="1dab1-498">28599</span><span class="sxs-lookup"><span data-stu-id="1dab1-498">28599</span></span>|<span data-ttu-id="1dab1-499">iso-8859-9</span><span class="sxs-lookup"><span data-stu-id="1dab1-499">iso-8859-9</span></span>|<span data-ttu-id="1dab1-500">土耳其语（ISO）</span><span class="sxs-lookup"><span data-stu-id="1dab1-500">Turkish (ISO)</span></span>|||
|<span data-ttu-id="1dab1-501">28603</span><span class="sxs-lookup"><span data-stu-id="1dab1-501">28603</span></span>|<span data-ttu-id="1dab1-502">iso-8859-13</span><span class="sxs-lookup"><span data-stu-id="1dab1-502">iso-8859-13</span></span>|<span data-ttu-id="1dab1-503">爱沙尼亚语（ISO）</span><span class="sxs-lookup"><span data-stu-id="1dab1-503">Estonian (ISO)</span></span>|||
|<span data-ttu-id="1dab1-504">28605</span><span class="sxs-lookup"><span data-stu-id="1dab1-504">28605</span></span>|<span data-ttu-id="1dab1-505">iso-8859-15</span><span class="sxs-lookup"><span data-stu-id="1dab1-505">iso-8859-15</span></span>|<span data-ttu-id="1dab1-506">拉丁语9（ISO）</span><span class="sxs-lookup"><span data-stu-id="1dab1-506">Latin 9 (ISO)</span></span>|||
|<span data-ttu-id="1dab1-507">29001</span><span class="sxs-lookup"><span data-stu-id="1dab1-507">29001</span></span>|<span data-ttu-id="1dab1-508">x-Europa</span><span class="sxs-lookup"><span data-stu-id="1dab1-508">x-Europa</span></span>|<span data-ttu-id="1dab1-509">欧洲</span><span class="sxs-lookup"><span data-stu-id="1dab1-509">Europa</span></span>|||
|<span data-ttu-id="1dab1-510">38598</span><span class="sxs-lookup"><span data-stu-id="1dab1-510">38598</span></span>|<span data-ttu-id="1dab1-511">iso-8859-8-i</span><span class="sxs-lookup"><span data-stu-id="1dab1-511">iso-8859-8-i</span></span>|<span data-ttu-id="1dab1-512">希伯来语（ISO-逻辑）</span><span class="sxs-lookup"><span data-stu-id="1dab1-512">Hebrew (ISO-Logical)</span></span>|<span data-ttu-id="1dab1-513">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-513">✓</span></span>||
|<span data-ttu-id="1dab1-514">50220</span><span class="sxs-lookup"><span data-stu-id="1dab1-514">50220</span></span>|<span data-ttu-id="1dab1-515">iso-2022-jp</span><span class="sxs-lookup"><span data-stu-id="1dab1-515">iso-2022-jp</span></span>|<span data-ttu-id="1dab1-516">日语(JIS)</span><span class="sxs-lookup"><span data-stu-id="1dab1-516">Japanese (JIS)</span></span>|<span data-ttu-id="1dab1-517">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-517">✓</span></span>||
|<span data-ttu-id="1dab1-518">50221</span><span class="sxs-lookup"><span data-stu-id="1dab1-518">50221</span></span>|<span data-ttu-id="1dab1-519">csISO2022JP</span><span class="sxs-lookup"><span data-stu-id="1dab1-519">csISO2022JP</span></span>|<span data-ttu-id="1dab1-520">日语（JIS-允许1字节假名）</span><span class="sxs-lookup"><span data-stu-id="1dab1-520">Japanese (JIS-Allow 1 byte Kana)</span></span>|<span data-ttu-id="1dab1-521">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-521">✓</span></span>||
|<span data-ttu-id="1dab1-522">50222</span><span class="sxs-lookup"><span data-stu-id="1dab1-522">50222</span></span>|<span data-ttu-id="1dab1-523">iso-2022-jp</span><span class="sxs-lookup"><span data-stu-id="1dab1-523">iso-2022-jp</span></span>|<span data-ttu-id="1dab1-524">日语（JIS-允许1字节假名-SO/SI）</span><span class="sxs-lookup"><span data-stu-id="1dab1-524">Japanese (JIS-Allow 1 byte Kana - SO/SI)</span></span>|<span data-ttu-id="1dab1-525">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-525">✓</span></span>||
|<span data-ttu-id="1dab1-526">50225</span><span class="sxs-lookup"><span data-stu-id="1dab1-526">50225</span></span>|<span data-ttu-id="1dab1-527">iso-2022-kr</span><span class="sxs-lookup"><span data-stu-id="1dab1-527">iso-2022-kr</span></span>|<span data-ttu-id="1dab1-528">朝鲜语(ISO)</span><span class="sxs-lookup"><span data-stu-id="1dab1-528">Korean (ISO)</span></span>|<span data-ttu-id="1dab1-529">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-529">✓</span></span>||
|<span data-ttu-id="1dab1-530">50227</span><span class="sxs-lookup"><span data-stu-id="1dab1-530">50227</span></span>|<span data-ttu-id="1dab1-531">x-cp50227</span><span class="sxs-lookup"><span data-stu-id="1dab1-531">x-cp50227</span></span>|<span data-ttu-id="1dab1-532">简体中文(ISO-2022)</span><span class="sxs-lookup"><span data-stu-id="1dab1-532">Chinese Simplified (ISO-2022)</span></span>|<span data-ttu-id="1dab1-533">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-533">✓</span></span>||
|<span data-ttu-id="1dab1-534">51932</span><span class="sxs-lookup"><span data-stu-id="1dab1-534">51932</span></span>|<span data-ttu-id="1dab1-535">euc-jp</span><span class="sxs-lookup"><span data-stu-id="1dab1-535">euc-jp</span></span>|<span data-ttu-id="1dab1-536">日语（EUC）</span><span class="sxs-lookup"><span data-stu-id="1dab1-536">Japanese (EUC)</span></span>|<span data-ttu-id="1dab1-537">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-537">✓</span></span>||
|<span data-ttu-id="1dab1-538">51936</span><span class="sxs-lookup"><span data-stu-id="1dab1-538">51936</span></span>|<span data-ttu-id="1dab1-539">EUC-CN</span><span class="sxs-lookup"><span data-stu-id="1dab1-539">EUC-CN</span></span>|<span data-ttu-id="1dab1-540">简体中文（EUC）</span><span class="sxs-lookup"><span data-stu-id="1dab1-540">Chinese Simplified (EUC)</span></span>|<span data-ttu-id="1dab1-541">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-541">✓</span></span>||
|<span data-ttu-id="1dab1-542">51949</span><span class="sxs-lookup"><span data-stu-id="1dab1-542">51949</span></span>|<span data-ttu-id="1dab1-543">euc-kr</span><span class="sxs-lookup"><span data-stu-id="1dab1-543">euc-kr</span></span>|<span data-ttu-id="1dab1-544">韩语（EUC）</span><span class="sxs-lookup"><span data-stu-id="1dab1-544">Korean (EUC)</span></span>|<span data-ttu-id="1dab1-545">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-545">✓</span></span>||
|<span data-ttu-id="1dab1-546">52936</span><span class="sxs-lookup"><span data-stu-id="1dab1-546">52936</span></span>|<span data-ttu-id="1dab1-547">hz-gb-2312</span><span class="sxs-lookup"><span data-stu-id="1dab1-547">hz-gb-2312</span></span>|<span data-ttu-id="1dab1-548">简体中文（HZ）</span><span class="sxs-lookup"><span data-stu-id="1dab1-548">Chinese Simplified (HZ)</span></span>|<span data-ttu-id="1dab1-549">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-549">✓</span></span>||
|<span data-ttu-id="1dab1-550">54936</span><span class="sxs-lookup"><span data-stu-id="1dab1-550">54936</span></span>|<span data-ttu-id="1dab1-551">GB18030</span><span class="sxs-lookup"><span data-stu-id="1dab1-551">GB18030</span></span>|<span data-ttu-id="1dab1-552">简体中文(GB18030)</span><span class="sxs-lookup"><span data-stu-id="1dab1-552">Chinese Simplified (GB18030)</span></span>|<span data-ttu-id="1dab1-553">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-553">✓</span></span>||
|<span data-ttu-id="1dab1-554">57002</span><span class="sxs-lookup"><span data-stu-id="1dab1-554">57002</span></span>|<span data-ttu-id="1dab1-555">x-iscii-de</span><span class="sxs-lookup"><span data-stu-id="1dab1-555">x-iscii-de</span></span>|<span data-ttu-id="1dab1-556">ISCII 梵文</span><span class="sxs-lookup"><span data-stu-id="1dab1-556">ISCII Devanagari</span></span>|<span data-ttu-id="1dab1-557">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-557">✓</span></span>||
|<span data-ttu-id="1dab1-558">57003</span><span class="sxs-lookup"><span data-stu-id="1dab1-558">57003</span></span>|<span data-ttu-id="1dab1-559">x-iscii-be</span><span class="sxs-lookup"><span data-stu-id="1dab1-559">x-iscii-be</span></span>|<span data-ttu-id="1dab1-560">ISCII 孟加拉语</span><span class="sxs-lookup"><span data-stu-id="1dab1-560">ISCII Bengali</span></span>|<span data-ttu-id="1dab1-561">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-561">✓</span></span>||
|<span data-ttu-id="1dab1-562">57004</span><span class="sxs-lookup"><span data-stu-id="1dab1-562">57004</span></span>|<span data-ttu-id="1dab1-563">x-iscii-ta</span><span class="sxs-lookup"><span data-stu-id="1dab1-563">x-iscii-ta</span></span>|<span data-ttu-id="1dab1-564">ISCII 泰米尔语</span><span class="sxs-lookup"><span data-stu-id="1dab1-564">ISCII Tamil</span></span>|<span data-ttu-id="1dab1-565">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-565">✓</span></span>||
|<span data-ttu-id="1dab1-566">57005</span><span class="sxs-lookup"><span data-stu-id="1dab1-566">57005</span></span>|<span data-ttu-id="1dab1-567">x-iscii-te</span><span class="sxs-lookup"><span data-stu-id="1dab1-567">x-iscii-te</span></span>|<span data-ttu-id="1dab1-568">ISCII 泰卢固语</span><span class="sxs-lookup"><span data-stu-id="1dab1-568">ISCII Telugu</span></span>|<span data-ttu-id="1dab1-569">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-569">✓</span></span>||
|<span data-ttu-id="1dab1-570">57006</span><span class="sxs-lookup"><span data-stu-id="1dab1-570">57006</span></span>|<span data-ttu-id="1dab1-571">x-iscii-as</span><span class="sxs-lookup"><span data-stu-id="1dab1-571">x-iscii-as</span></span>|<span data-ttu-id="1dab1-572">ISCII 阿萨姆语</span><span class="sxs-lookup"><span data-stu-id="1dab1-572">ISCII Assamese</span></span>|<span data-ttu-id="1dab1-573">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-573">✓</span></span>||
|<span data-ttu-id="1dab1-574">57007</span><span class="sxs-lookup"><span data-stu-id="1dab1-574">57007</span></span>|<span data-ttu-id="1dab1-575">x-iscii-or</span><span class="sxs-lookup"><span data-stu-id="1dab1-575">x-iscii-or</span></span>|<span data-ttu-id="1dab1-576">ISCII 奥里雅语</span><span class="sxs-lookup"><span data-stu-id="1dab1-576">ISCII Oriya</span></span>|<span data-ttu-id="1dab1-577">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-577">✓</span></span>||
|<span data-ttu-id="1dab1-578">57008</span><span class="sxs-lookup"><span data-stu-id="1dab1-578">57008</span></span>|<span data-ttu-id="1dab1-579">x-iscii-ka</span><span class="sxs-lookup"><span data-stu-id="1dab1-579">x-iscii-ka</span></span>|<span data-ttu-id="1dab1-580">ISCII 埃纳德文</span><span class="sxs-lookup"><span data-stu-id="1dab1-580">ISCII Kannada</span></span>|<span data-ttu-id="1dab1-581">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-581">✓</span></span>||
|<span data-ttu-id="1dab1-582">57009</span><span class="sxs-lookup"><span data-stu-id="1dab1-582">57009</span></span>|<span data-ttu-id="1dab1-583">x-iscii-ma</span><span class="sxs-lookup"><span data-stu-id="1dab1-583">x-iscii-ma</span></span>|<span data-ttu-id="1dab1-584">ISCII 马拉雅拉姆语</span><span class="sxs-lookup"><span data-stu-id="1dab1-584">ISCII Malayalam</span></span>|<span data-ttu-id="1dab1-585">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-585">✓</span></span>||
|<span data-ttu-id="1dab1-586">57010</span><span class="sxs-lookup"><span data-stu-id="1dab1-586">57010</span></span>|<span data-ttu-id="1dab1-587">x-iscii-gu</span><span class="sxs-lookup"><span data-stu-id="1dab1-587">x-iscii-gu</span></span>|<span data-ttu-id="1dab1-588">ISCII 古吉拉特语</span><span class="sxs-lookup"><span data-stu-id="1dab1-588">ISCII Gujarati</span></span>|<span data-ttu-id="1dab1-589">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-589">✓</span></span>||
|<span data-ttu-id="1dab1-590">57011</span><span class="sxs-lookup"><span data-stu-id="1dab1-590">57011</span></span>|<span data-ttu-id="1dab1-591">x-iscii-pa</span><span class="sxs-lookup"><span data-stu-id="1dab1-591">x-iscii-pa</span></span>|<span data-ttu-id="1dab1-592">ISCII 旁遮普语</span><span class="sxs-lookup"><span data-stu-id="1dab1-592">ISCII Punjabi</span></span>|<span data-ttu-id="1dab1-593">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-593">✓</span></span>||
|<span data-ttu-id="1dab1-594">65000</span><span class="sxs-lookup"><span data-stu-id="1dab1-594">65000</span></span>|<span data-ttu-id="1dab1-595">utf-7</span><span class="sxs-lookup"><span data-stu-id="1dab1-595">utf-7</span></span>|<span data-ttu-id="1dab1-596">Unicode （UTF-7）</span><span class="sxs-lookup"><span data-stu-id="1dab1-596">Unicode (UTF-7)</span></span>|<span data-ttu-id="1dab1-597">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-597">✓</span></span>|<span data-ttu-id="1dab1-598">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-598">✓</span></span>|
|<span data-ttu-id="1dab1-599">65001</span><span class="sxs-lookup"><span data-stu-id="1dab1-599">65001</span></span>|<span data-ttu-id="1dab1-600">utf-8</span><span class="sxs-lookup"><span data-stu-id="1dab1-600">utf-8</span></span>|<span data-ttu-id="1dab1-601">Unicode (UTF-8)</span><span class="sxs-lookup"><span data-stu-id="1dab1-601">Unicode (UTF-8)</span></span>|<span data-ttu-id="1dab1-602">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-602">✓</span></span>|<span data-ttu-id="1dab1-603">✓</span><span class="sxs-lookup"><span data-stu-id="1dab1-603">✓</span></span>|

 <span data-ttu-id="1dab1-604">下面的示例调用 <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> 和 <xref:System.Text.Encoding.GetEncoding%28System.String%29> 方法来获取希腊语（Windows）代码页编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-604">The following example calls the <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> and <xref:System.Text.Encoding.GetEncoding%28System.String%29> methods to get the Greek (Windows) code page encoding.</span></span> <span data-ttu-id="1dab1-605">它将方法调用返回的 <xref:System.Text.Encoding> 对象进行比较，以显示它们相等，然后 maps 显示每个字符在希腊语字母表中的 Unicode 码位和相应的代码页值。</span><span class="sxs-lookup"><span data-stu-id="1dab1-605">It compares the <xref:System.Text.Encoding> objects returned by the method calls to show that they are equal, and then maps displays the Unicode code point and the corresponding code page value for each character in the Greek alphabet.</span></span>

 [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]

 <span data-ttu-id="1dab1-606">如果要转换的数据仅适用于连续块（如从流中读取的数据），或者如果数据量很大以致需要分为更小块，则应使用派生类的 <xref:System.Text.Encoding.GetDecoder%2A> 方法或 <xref:System.Text.Encoding.GetEncoder%2A> 方法提供的 <xref:System.Text.Decoder> 或 <xref:System.Text.Encoder>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-606">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="1dab1-607">UTF-16 和32编码器可以使用大 endian 字节顺序（首先是最重要的字节），也可以是 little endian 字节顺序（首先是最不重要的字节）。</span><span class="sxs-lookup"><span data-stu-id="1dab1-607">The UTF-16 and the UTF-32 encoders can use the big endian byte order (most significant byte first) or the little endian byte order (least significant byte first).</span></span> <span data-ttu-id="1dab1-608">例如，拉丁文大写字母 A （U + 0041）按以下方式序列化（十六进制）：</span><span class="sxs-lookup"><span data-stu-id="1dab1-608">For example, the Latin Capital Letter A (U+0041) is serialized as follows (in hexadecimal):</span></span>

-   <span data-ttu-id="1dab1-609">UTF-16 大 endian 字节顺序： 00 41</span><span class="sxs-lookup"><span data-stu-id="1dab1-609">UTF-16 big endian byte order: 00 41</span></span>

-   <span data-ttu-id="1dab1-610">UTF-16 little endian 字节顺序： 41 00</span><span class="sxs-lookup"><span data-stu-id="1dab1-610">UTF-16 little endian byte order: 41 00</span></span>

-   <span data-ttu-id="1dab1-611">32大 endian 字节顺序： 00 00 00 41</span><span class="sxs-lookup"><span data-stu-id="1dab1-611">UTF-32 big endian byte order: 00 00 00 41</span></span>

-   <span data-ttu-id="1dab1-612">32 little endian 字节顺序： 41 00 00 00</span><span class="sxs-lookup"><span data-stu-id="1dab1-612">UTF-32 little endian byte order: 41 00 00 00</span></span>

 <span data-ttu-id="1dab1-613">使用本机字节顺序存储 Unicode 字符通常更有效。</span><span class="sxs-lookup"><span data-stu-id="1dab1-613">It is generally more efficient to store Unicode characters using the native byte order.</span></span> <span data-ttu-id="1dab1-614">例如，最好使用 little endian 平台（如 Intel 计算机）上的 little endian 字节顺序。</span><span class="sxs-lookup"><span data-stu-id="1dab1-614">For example, it is better to use the little endian byte order on little endian platforms, such as Intel computers.</span></span>

 <span data-ttu-id="1dab1-615"><xref:System.Text.Encoding.GetPreamble%2A> 方法检索包含字节顺序标记（BOM）的字节数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-615">The <xref:System.Text.Encoding.GetPreamble%2A> method retrieves an array of bytes that includes the byte order mark (BOM).</span></span> <span data-ttu-id="1dab1-616">如果此字节数组的前缀为编码的流，则它有助于解码器识别所使用的编码格式。</span><span class="sxs-lookup"><span data-stu-id="1dab1-616">If this byte array is prefixed to an encoded stream, it helps the decoder to identify the encoding format used.</span></span>

 <span data-ttu-id="1dab1-617">有关字节顺序和字节顺序标记的详细信息，请参阅[unicode 主页](https://go.microsoft.com/fwlink/?LinkId=37123)上的 unicode 标准。</span><span class="sxs-lookup"><span data-stu-id="1dab1-617">For more information on byte order and the byte order mark, see The Unicode Standard at the [Unicode home page](https://go.microsoft.com/fwlink/?LinkId=37123).</span></span>

 <span data-ttu-id="1dab1-618">请注意，编码类允许错误：</span><span class="sxs-lookup"><span data-stu-id="1dab1-618">Note that the encoding classes allow errors to:</span></span>

-   <span data-ttu-id="1dab1-619">以无提示方式更改为 "？" 字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-619">Silently change to a "?" character.</span></span>

-   <span data-ttu-id="1dab1-620">使用 "最佳匹配" 字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-620">Use a "best fit" character.</span></span>

-   <span data-ttu-id="1dab1-621">通过将 <xref:System.Text.EncoderFallback> 和 <xref:System.Text.DecoderFallback> 类与 U + FFFD Unicode 替换字符一起使用，更改为应用程序特定的行为。</span><span class="sxs-lookup"><span data-stu-id="1dab1-621">Change to an application-specific behavior through use of the <xref:System.Text.EncoderFallback> and <xref:System.Text.DecoderFallback> classes with the U+FFFD Unicode replacement character.</span></span>

 <span data-ttu-id="1dab1-622">应在出现任何数据流错误时引发异常。</span><span class="sxs-lookup"><span data-stu-id="1dab1-622">You should throw an exception on any data stream error.</span></span> <span data-ttu-id="1dab1-623">应用在适用或使用 <xref:System.Text.EncoderExceptionFallback> 和 <xref:System.Text.DecoderExceptionFallback> 类时，使用 "throwonerror" 标志。</span><span class="sxs-lookup"><span data-stu-id="1dab1-623">An app either uses a "throwonerror" flag when applicable or uses the <xref:System.Text.EncoderExceptionFallback> and <xref:System.Text.DecoderExceptionFallback> classes.</span></span> <span data-ttu-id="1dab1-624">通常不建议使用最佳回退，因为这可能会导致数据丢失或混乱，并比简单字符替换慢。</span><span class="sxs-lookup"><span data-stu-id="1dab1-624">Best fit fallback is often not recommended because it can cause data loss or confusion and is slower than simple character replacements.</span></span> <span data-ttu-id="1dab1-625">对于 ANSI 编码，最佳行为是默认值。</span><span class="sxs-lookup"><span data-stu-id="1dab1-625">For ANSI encodings, the best fit behavior is the default.</span></span>



## Examples
 <span data-ttu-id="1dab1-626">下面的示例将字符串从一种编码转换为另一种编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-626">The following example converts a string from one encoding to another.</span></span>

> [!NOTE]
>  <span data-ttu-id="1dab1-627">在此示例中，byte [] 数组是包含编码数据的唯一类型。</span><span class="sxs-lookup"><span data-stu-id="1dab1-627">The byte[] array is the only type in this example that contains the encoded data.</span></span> <span data-ttu-id="1dab1-628">.NET Char 和 String 类型本身是 Unicode，因此 <xref:System.Text.Encoding.GetChars%2A> 调用会将数据解码回 Unicode。</span><span class="sxs-lookup"><span data-stu-id="1dab1-628">The .NET Char and String types are themselves Unicode, so the <xref:System.Text.Encoding.GetChars%2A> call decodes the data back to Unicode.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb" id="Snippet1":::

 ]]></format>
    </remarks>
    <related type="Article" href="/dotnet/standard/base-types/character-encoding"><span data-ttu-id="1dab1-629">了解编码</span><span class="sxs-lookup"><span data-stu-id="1dab1-629">Understanding Encodings</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1dab1-630">初始化 <see cref="T:System.Text.Encoding" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="1dab1-630">Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1dab1-631">初始化 <see cref="T:System.Text.Encoding" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="1dab1-631">Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-632">派生类重写此构造函数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-632">Derived classes override this constructor.</span></span>

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (codePage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int -&gt; System.Text.Encoding" Usage="new System.Text.Encoding codePage" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codePage"><span data-ttu-id="1dab1-633">首选编码的代码页标识符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-633">The code page identifier of the preferred encoding.</span></span>

 <span data-ttu-id="1dab1-634">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1dab1-634">-or-</span></span>

 <span data-ttu-id="1dab1-635">0，使用默认编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-635">0, to use the default encoding.</span></span></param>
        <summary><span data-ttu-id="1dab1-636">初始化对应于指定代码页的 <see cref="T:System.Text.Encoding" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="1dab1-636">Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class that corresponds to the specified code page.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-637">派生类重写此构造函数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-637">Derived classes override this constructor.</span></span>

 <span data-ttu-id="1dab1-638">从派生类调用此构造函数将创建一个 <xref:System.Text.Encoding> 对象，该对象使用最佳回退来执行编码和解码操作。</span><span class="sxs-lookup"><span data-stu-id="1dab1-638">Calls to this constructor from a derived class create an <xref:System.Text.Encoding> object that uses best-fit fallback for both encoding and decoding operations.</span></span> <span data-ttu-id="1dab1-639"><xref:System.Text.Encoding.DecoderFallback%2A> 和 <xref:System.Text.Encoding.EncoderFallback%2A> 属性都是只读的，不能修改。</span><span class="sxs-lookup"><span data-stu-id="1dab1-639">Both the <xref:System.Text.Encoding.DecoderFallback%2A> and <xref:System.Text.Encoding.EncoderFallback%2A> properties are read-only and cannot be modified.</span></span> <span data-ttu-id="1dab1-640">若要控制派生自 <xref:System.Text.Encoding>的类的回退策略，请调用 <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> 构造函数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-640">To control the fallback strategy for a class derived from <xref:System.Text.Encoding>, call the <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> constructor.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1dab1-641"><paramref name="codePage" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="1dab1-641"><paramref name="codePage" /> is less than zero.</span></span></exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (codePage As Integer, encoderFallback As EncoderFallback, decoderFallback As DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="new System.Text.Encoding (codePage, encoderFallback, decoderFallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codePage"><span data-ttu-id="1dab1-642">编码的代码页标识符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-642">The encoding code page identifier.</span></span></param>
        <param name="encoderFallback"><span data-ttu-id="1dab1-643">一个对象，在无法用当前编码对字符进行编码时，该对象可用来提供错误处理过程。</span><span class="sxs-lookup"><span data-stu-id="1dab1-643">An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</span></span></param>
        <param name="decoderFallback"><span data-ttu-id="1dab1-644">一个对象，在无法用当前编码对字节序列进行解码时，该对象可用来提供错误处理过程。</span><span class="sxs-lookup"><span data-stu-id="1dab1-644">An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</span></span></param>
        <summary><span data-ttu-id="1dab1-645">使用指定编码器和解码器回退策略初始化对应于指定代码页的 <see cref="T:System.Text.Encoding" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="1dab1-645">Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class that corresponds to the specified code page with the specified encoder and decoder fallback strategies.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-646">此构造函数是 `protected`的;派生类将重写它。</span><span class="sxs-lookup"><span data-stu-id="1dab1-646">This constructor is `protected`; derived classes override it.</span></span>

 <span data-ttu-id="1dab1-647">从派生类调用此构造函数以控制回退编码和解码策略。</span><span class="sxs-lookup"><span data-stu-id="1dab1-647">You call this constructor from a derived class to control the fallback encoding and decoding strategies.</span></span> <span data-ttu-id="1dab1-648"><xref:System.Text.Encoding> 类构造函数创建只读编码对象，这些对象在创建对象之后不允许编码器或解码器回退设置。</span><span class="sxs-lookup"><span data-stu-id="1dab1-648">The <xref:System.Text.Encoding> class constructors create read-only encoding objects that don't allow encoder or decoder fallback to be set after the object is created.</span></span>

 <span data-ttu-id="1dab1-649">如果 `encoderFallback` 或 `decoderFallback` 为 null，最佳回退将用作相应的回退策略。</span><span class="sxs-lookup"><span data-stu-id="1dab1-649">If either `encoderFallback` or `decoderFallback` is null, best-fit fallback is used as the corresponding fallback strategy.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1dab1-650"><paramref name="codePage" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="1dab1-650"><paramref name="codePage" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ASCII As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ ASCII { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ASCII : System.Text.Encoding" Usage="System.Text.Encoding.ASCII" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1dab1-651">获取 ASCII（7 位）字符集的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-651">Gets an encoding for the ASCII (7-bit) character set.</span></span></summary>
        <value><span data-ttu-id="1dab1-652">ASCII（7 位）字符集的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-652">An  encoding for the ASCII (7-bit) character set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-653">ASCII 字符限制为128个 Unicode 字符（从 U + 0000 到 U + 007F）。</span><span class="sxs-lookup"><span data-stu-id="1dab1-653">ASCII characters are limited to the lowest 128 Unicode characters, from U+0000 to U+007F.</span></span>

 <span data-ttu-id="1dab1-654">为应用选择 ASCII 编码时，请考虑以下事项：</span><span class="sxs-lookup"><span data-stu-id="1dab1-654">When selecting the ASCII encoding for your app, consider the following:</span></span>

-   <span data-ttu-id="1dab1-655">ASCII 编码通常适用于需要 ASCII 的协议。</span><span class="sxs-lookup"><span data-stu-id="1dab1-655">The ASCII encoding is usually appropriate for protocols that require ASCII.</span></span>

-   <span data-ttu-id="1dab1-656">如果需要8位编码（有时错误地称为 "ASCII"），建议使用 UTF-8 编码，而不是 ASCII 编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-656">If you requires 8-bit encoding (which is sometimes incorrectly referred to as "ASCII"), the UTF-8 encoding is recommended over the ASCII encoding.</span></span> <span data-ttu-id="1dab1-657">对于字符 0-7F，结果完全相同，但使用 UTF-8 可通过允许表示所有可表示的 Unicode 字符来避免数据丢失。</span><span class="sxs-lookup"><span data-stu-id="1dab1-657">For the characters 0-7F, the results are identical, but use of UTF-8 avoids data loss by allowing representation of all Unicode characters that are representable.</span></span> <span data-ttu-id="1dab1-658">请注意，ASCII 编码具有可允许恶意使用的第8位歧义，但 UTF-8 编码消除了有关第8位的歧义。</span><span class="sxs-lookup"><span data-stu-id="1dab1-658">Note that the ASCII encoding has an 8th bit ambiguity that can allow malicious use, but the UTF-8 encoding removes ambiguity about the 8th bit.</span></span>

-   <span data-ttu-id="1dab1-659">在 .NET Framework 版本2.0 之前，.NET Framework 将忽略第8位，从而允许欺骗。</span><span class="sxs-lookup"><span data-stu-id="1dab1-659">Prior to the .NET Framework version 2.0, the .NET Framework allowed spoofing by ignoring the 8th bit.</span></span> <span data-ttu-id="1dab1-660">从 .NET Framework 2.0 开始，在解码过程中，非 ASCII 码位将回退。</span><span class="sxs-lookup"><span data-stu-id="1dab1-660">Beginning with the .NET Framework 2.0, non-ASCII code points fall back during decoding.</span></span>

 <span data-ttu-id="1dab1-661">此属性返回的 <xref:System.Text.ASCIIEncoding> 对象可能没有适用于你的应用程序的行为。</span><span class="sxs-lookup"><span data-stu-id="1dab1-661">The <xref:System.Text.ASCIIEncoding> object that is returned by this property might not have the appropriate behavior for your app.</span></span> <span data-ttu-id="1dab1-662">它使用替换回退来替换每个不能进行编码的字符串，以及无法使用问号（"？"）字符解码的每个字节。</span><span class="sxs-lookup"><span data-stu-id="1dab1-662">It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character.</span></span> <span data-ttu-id="1dab1-663">相反，你可以调用 <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> 方法来实例化一个 <xref:System.Text.ASCIIEncoding> 对象，该对象的回退是 <xref:System.Text.EncoderFallbackException> 或 <xref:System.Text.DecoderFallbackException>，如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="1dab1-663">Instead, you can call the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> method to instantiate an <xref:System.Text.ASCIIEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.</span></span>

 [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]



## Examples
 <span data-ttu-id="1dab1-664">下面的示例演示 ASCII 编码对 ASCII 范围外的字符的影响。</span><span class="sxs-lookup"><span data-stu-id="1dab1-664">The following example demonstrates the effect of the ASCII encoding on characters that are outside the ASCII range.</span></span>

 [!code-cpp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]
 [!code-csharp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.ASCIIEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="/dotnet/standard/base-types/character-encoding"><span data-ttu-id="1dab1-665">了解编码</span><span class="sxs-lookup"><span data-stu-id="1dab1-665">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BigEndianUnicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ BigEndianUnicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BigEndianUnicode : System.Text.Encoding" Usage="System.Text.Encoding.BigEndianUnicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1dab1-666">获取使用 Big Endian 字节顺序的 UTF-16 格式的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-666">Gets an encoding for the UTF-16 format that uses the big endian byte order.</span></span></summary>
        <value><span data-ttu-id="1dab1-667">使用 Big Endian 字节顺序的 UTF-16 格式的编码对象。</span><span class="sxs-lookup"><span data-stu-id="1dab1-667">An encoding object for the UTF-16 format that uses the big endian byte order.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-668">此属性返回的 <xref:System.Text.UnicodeEncoding> 对象可能没有适用于你的应用程序的行为。</span><span class="sxs-lookup"><span data-stu-id="1dab1-668">The <xref:System.Text.UnicodeEncoding> object that is returned by this property may not have the appropriate behavior for your app.</span></span> <span data-ttu-id="1dab1-669">它使用替换回退来替换每个不能进行编码的字符串，以及无法使用问号（"？"）字符解码的每个字节。</span><span class="sxs-lookup"><span data-stu-id="1dab1-669">It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character.</span></span> <span data-ttu-id="1dab1-670">相反，你可以调用 <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 构造函数来实例化大的 endian <xref:System.Text.UnicodeEncoding> 对象，该对象的 fallback 为 <xref:System.Text.EncoderFallbackException> 或 <xref:System.Text.DecoderFallbackException>，如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="1dab1-670">Instead, you can call the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor to instantiate a big endian <xref:System.Text.UnicodeEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.</span></span>

 [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]

 <span data-ttu-id="1dab1-671">返回 <xref:System.Text.UnicodeEncoding> 对象具有 <xref:System.Text.Encoding.BodyName%2A>、<xref:System.Text.Encoding.HeaderName%2A>和 <xref:System.Text.Encoding.WebName%2A> 属性，这将生成名称 "unicodeFFFE"。</span><span class="sxs-lookup"><span data-stu-id="1dab1-671">The returned <xref:System.Text.UnicodeEncoding> object has <xref:System.Text.Encoding.BodyName%2A>, <xref:System.Text.Encoding.HeaderName%2A>, and <xref:System.Text.Encoding.WebName%2A> properties, which yield the name "unicodeFFFE".</span></span> <span data-ttu-id="1dab1-672">尽管 UTF-16 大 endian 字节顺序标记是十六进制 FEFF，但却选择了名称 "unicodeFFFE"，因为字节顺序标记在 little endian Windows 计算机上显示为十六进制 FFFE。</span><span class="sxs-lookup"><span data-stu-id="1dab1-672">Although the UTF-16 big endian byte order mark is hexadecimal FEFF, the name "unicodeFFFE" was chosen because the byte order mark appears as hexadecimal FFFE on little endian Windows computers.</span></span>



## Examples
 <span data-ttu-id="1dab1-673">下面的示例使用大字节序字节顺序读取带有 UTF-16 编码的文本文件。</span><span class="sxs-lookup"><span data-stu-id="1dab1-673">The following example reads a text file with a UTF-16 encoding using the big endian byte order.</span></span>

 [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]

 <span data-ttu-id="1dab1-674">下面的示例确定对字符数组进行编码、对字符进行编码并显示生成的字节所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-674">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="/dotnet/standard/base-types/character-encoding"><span data-ttu-id="1dab1-675">了解编码</span><span class="sxs-lookup"><span data-stu-id="1dab1-675">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BodyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BodyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BodyName : string" Usage="System.Text.Encoding.BodyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1dab1-676">在派生类中重写时，获取可与邮件代理正文标记一起使用的当前编码的名称。</span><span class="sxs-lookup"><span data-stu-id="1dab1-676">When overridden in a derived class, gets a name for the current encoding that can be used with mail agent body tags.</span></span></summary>
        <value><span data-ttu-id="1dab1-677">可与邮件代理正文标记一起使用的当前 <see cref="T:System.Text.Encoding" /> 的名称。</span><span class="sxs-lookup"><span data-stu-id="1dab1-677">A name for the current <see cref="T:System.Text.Encoding" /> that can be used with mail agent body tags.</span></span>

<span data-ttu-id="1dab1-678">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1dab1-678">-or-</span></span>

<span data-ttu-id="1dab1-679">如果当前 <see cref="T:System.Text.Encoding" /> 无法使用，则为空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="1dab1-679">An empty string (""), if the current <see cref="T:System.Text.Encoding" /> cannot be used.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-680">如果需要主体名称的编码，则应使用 <xref:System.Text.Encoding.BodyName%2A> 属性调用 <xref:System.Text.Encoding.GetEncoding%2A>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-680">If you need an encoding for a body name, you should call <xref:System.Text.Encoding.GetEncoding%2A> with the <xref:System.Text.Encoding.BodyName%2A> property.</span></span> <span data-ttu-id="1dab1-681">通常，方法从调用中提供的测试编码检索不同的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-681">Often the method retrieves a different encoding from the test encoding furnished in the call.</span></span> <span data-ttu-id="1dab1-682">通常，电子邮件应用程序通常只需检索这样一种编码;需要描述编码的其他大多数应用程序应使用其 <xref:System.Text.Encoding.WebName%2A>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-682">Generally only email applications need to retrieve such an encoding; most other applications that need to describe an encoding should use its <xref:System.Text.Encoding.WebName%2A>.</span></span>

 <span data-ttu-id="1dab1-683">在某些情况下，<xref:System.Text.Encoding.BodyName%2A> 属性的值对应于定义该编码的国际标准。</span><span class="sxs-lookup"><span data-stu-id="1dab1-683">In some cases, the value of the <xref:System.Text.Encoding.BodyName%2A> property corresponds to the international standard that defines that encoding.</span></span> <span data-ttu-id="1dab1-684">这并不意味着实现完全符合该标准。</span><span class="sxs-lookup"><span data-stu-id="1dab1-684">This doesn't mean that the implementation complies in full with that standard.</span></span>



## Examples
 <span data-ttu-id="1dab1-685">下面的示例将检索每个编码的不同名称，并显示包含一个或多个名称不同于 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-685">The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1dab1-686">它会显示 <xref:System.Text.Encoding.EncodingName%2A>，但不会对其进行比较。</span><span class="sxs-lookup"><span data-stu-id="1dab1-686">It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.</span></span>

 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="encoding.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1dab1-687">当在派生类中重写时，创建当前 <see cref="T:System.Text.Encoding" /> 对象的一个卷影副本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-687">When overridden in a derived class, creates a shallow copy of the current <see cref="T:System.Text.Encoding" /> object.</span></span></summary>
        <returns><span data-ttu-id="1dab1-688">当前 <see cref="T:System.Text.Encoding" /> 对象的副本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-688">A copy of the current <see cref="T:System.Text.Encoding" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-689">即使原始 <xref:System.Text.Encoding> 对象是只读的，克隆也是可写的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-689">The clone is writable even if the original <xref:System.Text.Encoding> object is read-only.</span></span> <span data-ttu-id="1dab1-690">因此，可以修改克隆的属性。</span><span class="sxs-lookup"><span data-stu-id="1dab1-690">Therefore, the properties of the clone can be modified.</span></span>

 <span data-ttu-id="1dab1-691">对象的浅表副本只是对象的副本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-691">A shallow copy of an object is a copy of the object only.</span></span> <span data-ttu-id="1dab1-692">如果对象包含对其他对象的引用，则浅表副本不会创建所引用对象的副本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-692">If the object contains references to other objects, the shallow copy does not create copies of the referred objects.</span></span> <span data-ttu-id="1dab1-693">改为引用原始对象。</span><span class="sxs-lookup"><span data-stu-id="1dab1-693">It refers to the original objects instead.</span></span> <span data-ttu-id="1dab1-694">与此相反，对象的深层副本将创建对象的副本和该对象直接或间接引用的所有内容的副本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-694">In contrast, a deep copy of an object creates a copy of the object and a copy of everything directly or indirectly referenced by that object.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CodePage : int" Usage="System.Text.Encoding.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1dab1-695">在派生类中重写时，获取当前 <see cref="T:System.Text.Encoding" /> 的代码页标识符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-695">When overridden in a derived class, gets the code page identifier of the current <see cref="T:System.Text.Encoding" />.</span></span></summary>
        <value><span data-ttu-id="1dab1-696">当前 <see cref="T:System.Text.Encoding" /> 的代码页标识符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-696">The code page identifier of the current <see cref="T:System.Text.Encoding" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 <span data-ttu-id="1dab1-697">下面的示例将检索每个编码的不同名称，并显示包含一个或多个名称不同于 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-697">The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1dab1-698">它会显示 <xref:System.Text.Encoding.EncodingName%2A>，但不会对其进行比较。</span><span class="sxs-lookup"><span data-stu-id="1dab1-698">It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.</span></span>

 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
        <altmember cref="P:System.Text.Encoding.WindowsCodePage" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1dab1-699">将字节数组从一种编码转换为另一种。</span><span class="sxs-lookup"><span data-stu-id="1dab1-699">Converts a byte array from one encoding to another.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding"><span data-ttu-id="1dab1-700"><paramref name="bytes" /> 的编码格式。</span><span class="sxs-lookup"><span data-stu-id="1dab1-700">The encoding format of <paramref name="bytes" />.</span></span></param>
        <param name="dstEncoding"><span data-ttu-id="1dab1-701">目标编码格式。</span><span class="sxs-lookup"><span data-stu-id="1dab1-701">The target encoding format.</span></span></param>
        <param name="bytes"><span data-ttu-id="1dab1-702">要转换的字节。</span><span class="sxs-lookup"><span data-stu-id="1dab1-702">The bytes to convert.</span></span></param>
        <summary><span data-ttu-id="1dab1-703">将整个字节数组从一种编码转换为另一种编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-703">Converts an entire byte array from one encoding to another.</span></span></summary>
        <returns><span data-ttu-id="1dab1-704"><see cref="T:System.Byte" /> 类型的数组，其中包含将 <paramref name="bytes" /> 从 <paramref name="srcEncoding" /> 转换为 <paramref name="dstEncoding" /> 的结果。</span><span class="sxs-lookup"><span data-stu-id="1dab1-704">An array of type <see cref="T:System.Byte" /> containing the results of converting <paramref name="bytes" /> from <paramref name="srcEncoding" /> to <paramref name="dstEncoding" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 <span data-ttu-id="1dab1-705">下面的示例将 Unicode 编码的字符串转换为 ASCII 编码的字符串。</span><span class="sxs-lookup"><span data-stu-id="1dab1-705">The following example converts a Unicode-encoded string to an ASCII-encoded string.</span></span> <span data-ttu-id="1dab1-706">由于 <xref:System.Text.Encoding.ASCII%2A> 属性返回的 ASCII 编码对象使用替换回退，并且 Pi 字符不是 ASCII 字符集的一部分，因此，Pi 字符将替换为问号，如示例中的输出所示。</span><span class="sxs-lookup"><span data-stu-id="1dab1-706">Because the ASCII encoding object returned by the <xref:System.Text.Encoding.ASCII%2A> property uses replacement fallback and the Pi character is not part of the ASCII character set, the Pi character is replaced with a question mark, as the output from the example shows.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1dab1-707"><paramref name="srcEncoding" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-707"><paramref name="srcEncoding" /> is <see langword="null" />.</span></span>

<span data-ttu-id="1dab1-708">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1dab1-708">-or-</span></span>

 <span data-ttu-id="1dab1-709"><paramref name="dstEncoding" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-709"><paramref name="dstEncoding" /> is <see langword="null" />.</span></span>

<span data-ttu-id="1dab1-710">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1dab1-710">-or-</span></span>

 <span data-ttu-id="1dab1-711"><paramref name="bytes" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-711"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1dab1-712">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）</span><span class="sxs-lookup"><span data-stu-id="1dab1-712">A fallback occurred (for more information, see <see href="/dotnet/standard/base-types/character-encoding">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1dab1-713">和</span><span class="sxs-lookup"><span data-stu-id="1dab1-713">-and-</span></span>

 <span data-ttu-id="1dab1-714">**srcEncoding.**</span><span class="sxs-lookup"><span data-stu-id="1dab1-714">**srcEncoding.**</span></span> <span data-ttu-id="1dab1-715"><see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-715"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1dab1-716">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）</span><span class="sxs-lookup"><span data-stu-id="1dab1-716">A fallback occurred (for more information, see <see href="/dotnet/standard/base-types/character-encoding">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1dab1-717">和</span><span class="sxs-lookup"><span data-stu-id="1dab1-717">-and-</span></span>

 <span data-ttu-id="1dab1-718">**dstEncoding.**</span><span class="sxs-lookup"><span data-stu-id="1dab1-718">**dstEncoding.**</span></span> <span data-ttu-id="1dab1-719"><see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-719"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] * int * int -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding"><span data-ttu-id="1dab1-720">源数组 <paramref name="bytes" /> 的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-720">The encoding of the source array, <paramref name="bytes" />.</span></span></param>
        <param name="dstEncoding"><span data-ttu-id="1dab1-721">输出数组的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-721">The encoding of the output array.</span></span></param>
        <param name="bytes"><span data-ttu-id="1dab1-722">要转换的字节数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-722">The array of bytes to convert.</span></span></param>
        <param name="index"><span data-ttu-id="1dab1-723">要转换的 <paramref name="bytes" /> 中第一个元素的索引。</span><span class="sxs-lookup"><span data-stu-id="1dab1-723">The index of the first element of <paramref name="bytes" /> to convert.</span></span></param>
        <param name="count"><span data-ttu-id="1dab1-724">要转换的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-724">The number of bytes to convert.</span></span></param>
        <summary><span data-ttu-id="1dab1-725">将字节数组内某个范围的字节从一种编码转换为另一种编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-725">Converts a range of bytes in a byte array from one encoding to another.</span></span></summary>
        <returns><span data-ttu-id="1dab1-726">一个 <see cref="T:System.Byte" /> 类型的数组，其中包含将 <paramref name="bytes" /> 中某个范围的字节从 <paramref name="srcEncoding" /> 转换为 <paramref name="dstEncoding" /> 的结果。</span><span class="sxs-lookup"><span data-stu-id="1dab1-726">An array of type <see cref="T:System.Byte" /> containing the result of converting a range of bytes in <paramref name="bytes" /> from <paramref name="srcEncoding" /> to <paramref name="dstEncoding" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1dab1-727"><paramref name="srcEncoding" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-727"><paramref name="srcEncoding" /> is <see langword="null" />.</span></span>

<span data-ttu-id="1dab1-728">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1dab1-728">-or-</span></span>

 <span data-ttu-id="1dab1-729"><paramref name="dstEncoding" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-729"><paramref name="dstEncoding" /> is <see langword="null" />.</span></span>

<span data-ttu-id="1dab1-730">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1dab1-730">-or-</span></span>

 <span data-ttu-id="1dab1-731"><paramref name="bytes" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-731"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1dab1-732"><paramref name="index" /> 和 <paramref name="count" /> 不指定字节数组中的有效范围。</span><span class="sxs-lookup"><span data-stu-id="1dab1-732"><paramref name="index" /> and <paramref name="count" /> do not specify a valid range in the byte array.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1dab1-733">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）</span><span class="sxs-lookup"><span data-stu-id="1dab1-733">A fallback occurred (for more information, see <see href="/dotnet/standard/base-types/character-encoding">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1dab1-734">和</span><span class="sxs-lookup"><span data-stu-id="1dab1-734">-and-</span></span>

 <span data-ttu-id="1dab1-735">**srcEncoding.**</span><span class="sxs-lookup"><span data-stu-id="1dab1-735">**srcEncoding.**</span></span> <span data-ttu-id="1dab1-736"><see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-736"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1dab1-737">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）</span><span class="sxs-lookup"><span data-stu-id="1dab1-737">A fallback occurred (for more information, see <see href="/dotnet/standard/base-types/character-encoding">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1dab1-738">和</span><span class="sxs-lookup"><span data-stu-id="1dab1-738">-and-</span></span>

 <span data-ttu-id="1dab1-739">**dstEncoding.**</span><span class="sxs-lookup"><span data-stu-id="1dab1-739">**dstEncoding.**</span></span> <span data-ttu-id="1dab1-740"><see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-740"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DecoderFallback As DecoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback" Usage="System.Text.Encoding.DecoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Property DecoderFallback As DecoderFallback" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback with get, set" Usage="System.Text.Encoding.DecoderFallback" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1dab1-741">获取或设置当前 <see cref="T:System.Text.DecoderFallback" /> 对象的 <see cref="T:System.Text.Encoding" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="1dab1-741">Gets or sets the <see cref="T:System.Text.DecoderFallback" /> object for the current <see cref="T:System.Text.Encoding" /> object.</span></span></summary>
        <value><span data-ttu-id="1dab1-742">当前 <see cref="T:System.Text.Encoding" /> 对象的解码器回退对象。</span><span class="sxs-lookup"><span data-stu-id="1dab1-742">The decoder fallback object for the current <see cref="T:System.Text.Encoding" /> object.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-743"><xref:System.Text.DecoderFallback> 对象表示一个错误处理程序，当无法将编码的字节序列解码为一个字符时，将调用该处理程序。</span><span class="sxs-lookup"><span data-stu-id="1dab1-743">The <xref:System.Text.DecoderFallback> object represents an error handler that is invoked when an encoded byte sequence cannot be decoded into a character.</span></span> <span data-ttu-id="1dab1-744">支持以下处理程序类型之一：</span><span class="sxs-lookup"><span data-stu-id="1dab1-744">Any one of the following handler types is supported:</span></span>

-   <span data-ttu-id="1dab1-745">最佳回退处理程序，它将不能解码的字节替换为某些合适的替换字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-745">A best-fit fallback handler, which replaces bytes that cannot be decoded with some suitable replacement character.</span></span>

-   <span data-ttu-id="1dab1-746">替换回退处理程序，它将不能解码的字节替换为任意替换字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-746">A replacement fallback handler, which replaces bytes that cannot be decoded with some arbitrary replacement character.</span></span> <span data-ttu-id="1dab1-747">.NET 包含一个替换回退处理程序，<xref:System.Text.DecoderFallback>，默认情况下，这会替换无法使用问号（"？"）字符解码的字节。</span><span class="sxs-lookup"><span data-stu-id="1dab1-747">.NET includes one replacement fallback handler, <xref:System.Text.DecoderFallback>, which by default replaces bytes that cannot be decoded with a question mark ("?") character.</span></span>

-   <span data-ttu-id="1dab1-748">异常回退处理程序，如果无法对字节进行解码，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="1dab1-748">An exception fallback handler, which throws an exception when bytes cannot be decoded.</span></span> <span data-ttu-id="1dab1-749">.NET 包含一个异常回退处理程序，<xref:System.Text.DecoderExceptionFallback>，当无法对字节进行解码时，将引发 <xref:System.Text.DecoderFallbackException>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-749">.NET includes one exception fallback handler, <xref:System.Text.DecoderExceptionFallback>, which throws a <xref:System.Text.DecoderFallbackException> when bytes cannot be decoded.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1dab1-750">设置操作中的值为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-750">The value in a set operation is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1dab1-751">由于当前 <see cref="T:System.Text.Encoding" /> 对象为只读，所以无法在设置操作中赋值。</span><span class="sxs-lookup"><span data-stu-id="1dab1-751">A value cannot be assigned in a set operation because the current <see cref="T:System.Text.Encoding" /> object is read-only.</span></span></exception>
        <altmember cref="T:System.Text.DecoderFallback" />
        <altmember cref="T:System.Text.DecoderFallbackBuffer" />
        <related type="Article" href="/dotnet/standard/base-types/character-encoding"><span data-ttu-id="1dab1-752">了解编码</span><span class="sxs-lookup"><span data-stu-id="1dab1-752">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Default { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Text.Encoding" Usage="System.Text.Encoding.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1dab1-753">获取此 .NET 实现的默认编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-753">Gets the default encoding for this .NET implementation.</span></span></summary>
        <value><span data-ttu-id="1dab1-754">此 .NET 实现的默认编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-754">The default encoding for this .NET implementation.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!WARNING]
>  <span data-ttu-id="1dab1-755">不同的计算机可以使用不同的编码作为默认编码，并且在一台计算机上可以更改默认编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-755">Different computers can use different encodings as the default, and the default encoding can change on a single computer.</span></span> <span data-ttu-id="1dab1-756">如果使用 <xref:System.Text.Encoding.Default%2A> 编码对在计算机之间流式传输的数据进行编码和解码，或在同一台计算机上的不同时间检索数据，则可能会错误地转换该数据。</span><span class="sxs-lookup"><span data-stu-id="1dab1-756">If you use the <xref:System.Text.Encoding.Default%2A> encoding to encode and decode data streamed between computers or retrieved at different times on the same computer, it may translate that data incorrectly.</span></span> <span data-ttu-id="1dab1-757">此外，<xref:System.Text.Encoding.Default%2A> 属性返回的编码使用最佳回退将不支持的字符映射到代码页支持的字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-757">In addition, the encoding returned by the <xref:System.Text.Encoding.Default%2A> property uses best-fit fallback to map unsupported characters to characters supported by the code page.</span></span> <span data-ttu-id="1dab1-758">由于这些原因，不建议使用默认编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-758">For these reasons, using the default encoding is not recommended.</span></span> <span data-ttu-id="1dab1-759">若要确保编码的字节解码正确，应使用 Unicode 编码，例如 <xref:System.Text.UTF8Encoding> 或 <xref:System.Text.UnicodeEncoding>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-759">To ensure that encoded bytes are decoded properly, you should use a Unicode encoding, such as <xref:System.Text.UTF8Encoding> or <xref:System.Text.UnicodeEncoding>.</span></span> <span data-ttu-id="1dab1-760">你还可以使用较高级别的协议来确保用于编码和解码的格式相同。</span><span class="sxs-lookup"><span data-stu-id="1dab1-760">You could also use a higher-level protocol to ensure that the same format is used for encoding and decoding.</span></span>

### <a name="the-default-property-in-the-net-framework"></a><span data-ttu-id="1dab1-761">.NET Framework 中的默认属性</span><span class="sxs-lookup"><span data-stu-id="1dab1-761">The Default property in the .NET Framework</span></span>

<span data-ttu-id="1dab1-762">在 Windows 桌面上的 .NET Framework 中，<xref:System.Text.Encoding.Default%2A> 属性始终获取系统的活动代码页，并创建对应于它的 <xref:System.Text.Encoding> 对象。</span><span class="sxs-lookup"><span data-stu-id="1dab1-762">In the .NET Framework on the Windows desktop, the <xref:System.Text.Encoding.Default%2A> property always gets the system's active code page and creates a <xref:System.Text.Encoding> object that corresponds to it.</span></span> <span data-ttu-id="1dab1-763">活动代码页可能是 ANSI 代码页，其中包括 ASCII 字符集以及不同于代码页的其他字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-763">The active code page may be an ANSI code page, which includes the ASCII character set along with additional characters that vary by code page.</span></span> <span data-ttu-id="1dab1-764">由于所有基于 ANSI 代码页的 <xref:System.Text.Encoding.Default%2A> 编码都将丢失数据，因此请考虑改用 <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> 编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-764">Because all <xref:System.Text.Encoding.Default%2A> encodings based on ANSI code pages lose data, consider using the <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> encoding instead.</span></span> <span data-ttu-id="1dab1-765">在 U + 00 到 U + 7F 范围内，UTF-8 通常是相同的，但可以在不丢失的情况下在 ASCII 范围外对字符进行编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-765">UTF-8 is often identical in the U+00 to U+7F range, but can encode characters outside the ASCII range without loss.</span></span>

## <a name="the-default-property-on-net-core"></a><span data-ttu-id="1dab1-766">.NET Core 上的默认属性</span><span class="sxs-lookup"><span data-stu-id="1dab1-766">The Default property on .NET Core</span></span>

<span data-ttu-id="1dab1-767">在 .NET Core 中，<xref:System.Text.Encoding.Default%2A> 属性始终返回 <xref:System.Text.UTF8Encoding>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-767">On .NET Core, the <xref:System.Text.Encoding.Default%2A> property always returns the <xref:System.Text.UTF8Encoding>.</span></span> <span data-ttu-id="1dab1-768">在运行 .NET Core 应用程序的所有操作系统（Windows、Linux 和 Max OS X）上都支持 UTF-8。</span><span class="sxs-lookup"><span data-stu-id="1dab1-768">UTF-8 is supported on all the operating systems (Windows, Linux, and Max OS X) on which .NET Core applications run.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EncoderFallback As EncoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback" Usage="System.Text.Encoding.EncoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Property EncoderFallback As EncoderFallback" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback with get, set" Usage="System.Text.Encoding.EncoderFallback" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1dab1-769">获取或设置当前 <see cref="T:System.Text.EncoderFallback" /> 对象的 <see cref="T:System.Text.Encoding" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="1dab1-769">Gets or sets the <see cref="T:System.Text.EncoderFallback" /> object for the current <see cref="T:System.Text.Encoding" /> object.</span></span></summary>
        <value><span data-ttu-id="1dab1-770">当前 <see cref="T:System.Text.Encoding" /> 对象的编码器回退对象。</span><span class="sxs-lookup"><span data-stu-id="1dab1-770">The encoder fallback object for the current <see cref="T:System.Text.Encoding" /> object.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-771"><xref:System.Text.EncoderFallback> 对象表示一个错误处理程序，当不能将字符转换为编码的字节序列时，将调用该处理程序。</span><span class="sxs-lookup"><span data-stu-id="1dab1-771">The <xref:System.Text.EncoderFallback> object represents an error handler that is invoked when a character cannot be converted into an encoded byte sequence.</span></span> <span data-ttu-id="1dab1-772">支持以下处理程序类型之一：</span><span class="sxs-lookup"><span data-stu-id="1dab1-772">Any one of the following handler types is supported:</span></span>

-   <span data-ttu-id="1dab1-773">最佳回退处理程序，该处理程序将替换无法使用某些合适的替换字符编码的字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-773">A best-fit fallback handler, which replaces characters that cannot be encoded with some suitable replacement character.</span></span>

-   <span data-ttu-id="1dab1-774">替换回退处理程序，它将替换不能用一些任意替换字符编码的字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-774">A replacement fallback handler, which replaces characters that cannot be encoded with some arbitrary replacement character.</span></span> <span data-ttu-id="1dab1-775">.NET 包含一个替换回退处理程序，<xref:System.Text.EncoderFallback>，默认情况下，这会替换无法用问号（"？"）字符编码的字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-775">.NET includes one replacement fallback handler, <xref:System.Text.EncoderFallback>, which by default replaces characters that cannot be encoded with a question mark ("?") character.</span></span>

-   <span data-ttu-id="1dab1-776">异常回退处理程序，当无法对字符进行编码时，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="1dab1-776">An exception fallback handler, which throws an exception when characters cannot be encoded.</span></span> <span data-ttu-id="1dab1-777">.NET 包含一个异常回退处理程序，<xref:System.Text.EncoderExceptionFallback>，当无法对字符进行解码时，将引发 <xref:System.Text.EncoderFallbackException>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-777">.NET includes one exception fallback handler, <xref:System.Text.EncoderExceptionFallback>, which throws an <xref:System.Text.EncoderFallbackException> when characters cannot be decoded.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1dab1-778">设置操作中的值为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-778">The value in a set operation is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1dab1-779">由于当前 <see cref="T:System.Text.Encoding" /> 对象为只读，所以无法在设置操作中赋值。</span><span class="sxs-lookup"><span data-stu-id="1dab1-779">A value cannot be assigned in a set operation because the current <see cref="T:System.Text.Encoding" /> object is read-only.</span></span></exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallbackBuffer" />
        <related type="Article" href="/dotnet/standard/base-types/character-encoding"><span data-ttu-id="1dab1-780">了解编码</span><span class="sxs-lookup"><span data-stu-id="1dab1-780">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EncodingName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EncodingName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EncodingName : string" Usage="System.Text.Encoding.EncodingName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1dab1-781">在派生类中重写时，获取当前编码的用户可读说明。</span><span class="sxs-lookup"><span data-stu-id="1dab1-781">When overridden in a derived class, gets the human-readable description of the current encoding.</span></span></summary>
        <value><span data-ttu-id="1dab1-782">当前 <see cref="T:System.Text.Encoding" /> 的用户可读说明。</span><span class="sxs-lookup"><span data-stu-id="1dab1-782">The human-readable description of the current <see cref="T:System.Text.Encoding" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-783"><xref:System.Text.Encoding.EncodingName%2A> 属性用于显示。</span><span class="sxs-lookup"><span data-stu-id="1dab1-783">The <xref:System.Text.Encoding.EncodingName%2A> property is intended for display.</span></span> <span data-ttu-id="1dab1-784">若要查找可以传递到 <xref:System.Text.Encoding.GetEncoding%2A> 方法的名称，请使用 <xref:System.Text.Encoding.WebName%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="1dab1-784">To find a name that can be passed to the <xref:System.Text.Encoding.GetEncoding%2A> method, use the <xref:System.Text.Encoding.WebName%2A> property.</span></span>



## Examples
 <span data-ttu-id="1dab1-785">下面的示例将检索每个编码的不同名称，并显示包含一个或多个名称不同于 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-785">The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1dab1-786">它会显示 <xref:System.Text.Encoding.EncodingName%2A>，但不会对其进行比较。</span><span class="sxs-lookup"><span data-stu-id="1dab1-786">It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.</span></span>

 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.DisplayName" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="1dab1-787">与当前实例进行比较的 <see cref="T:System.Object" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-787">The <see cref="T:System.Object" /> to compare with the current instance.</span></span></param>
        <summary><span data-ttu-id="1dab1-788">确定指定的 <see cref="T:System.Object" /> 是否等同于当前实例。</span><span class="sxs-lookup"><span data-stu-id="1dab1-788">Determines whether the specified <see cref="T:System.Object" /> is equal to the current instance.</span></span></summary>
        <returns><span data-ttu-id="1dab1-789">如果 <paramref name="value" /> 是 <see cref="T:System.Text.Encoding" /> 的一个实例并且等于当前实例，则为 <see langword="true" />；否则，为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-789"><see langword="true" /> if <paramref name="value" /> is an instance of <see cref="T:System.Text.Encoding" /> and is equal to the current instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-790">如果两个 <xref:System.Text.Encoding> 实例对应于同一个代码页并且其 `EncoderFallback` 和 `DecoderFallback` 对象相等，则这些实例将被视为相等。</span><span class="sxs-lookup"><span data-stu-id="1dab1-790">Two instances of <xref:System.Text.Encoding> are considered equal if they correspond to the same code page and their `EncoderFallback` and `DecoderFallback` objects are equal.</span></span> <span data-ttu-id="1dab1-791">具体而言，派生代码页都具有0的代码页，其回退通常是 `null` （Visual Basic .NET 中的`Nothing`）。</span><span class="sxs-lookup"><span data-stu-id="1dab1-791">In particular, derived code pages all have a code page of 0 and their fallbacks are normally `null` (`Nothing` in Visual Basic .NET).</span></span> <span data-ttu-id="1dab1-792">因此，它们被视为彼此相等。</span><span class="sxs-lookup"><span data-stu-id="1dab1-792">Thus they are all considered equal to one another.</span></span> <span data-ttu-id="1dab1-793">一种结果是，当 <xref:System.Text.Encoding.Equals%2A> 用来填充哈希表时，所有派生编码都相等并位于同一哈希表槽。</span><span class="sxs-lookup"><span data-stu-id="1dab1-793">One consequence is that when <xref:System.Text.Encoding.Equals%2A> is used to populate a hash table, all derived encodings compare equal and fall into the same hash table slot.</span></span>



## Examples
 <span data-ttu-id="1dab1-794">下面的示例获取相同编码的两个实例（一个按代码页，另一个按名称），并检查它们是否相等。</span><span class="sxs-lookup"><span data-stu-id="1dab1-794">The following example gets two instances of the same encoding (one by codepage and another by name), and checks their equality.</span></span>

 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Text.Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1dab1-795">在派生类中重写时，计算对一组字符进行编码所产生的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-795">When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] -&gt; int&#xA;override this.GetByteCount : char[] -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="1dab1-796">包含要编码的字符的字符数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-796">The character array containing the characters to encode.</span></span></param>
        <summary><span data-ttu-id="1dab1-797">在派生类中重写时，计算对指定字符数组中的所有字符进行编码所产生的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-797">When overridden in a derived class, calculates the number of bytes produced by encoding all the characters in the specified character array.</span></span></summary>
        <returns><span data-ttu-id="1dab1-798">对指定字符数组中的所有字符进行编码后产生的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-798">The number of bytes produced by encoding all the characters in the specified character array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-799">若要计算 <xref:System.Text.Encoding.GetBytes%2A> 存储生成的字节所需的确切数组大小，请调用 <xref:System.Text.Encoding.GetByteCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-799">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1dab1-800">若要计算最大数组大小，请调用 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-800">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1dab1-801"><xref:System.Text.Encoding.GetByteCount%2A> 方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法的执行速度通常更快。</span><span class="sxs-lookup"><span data-stu-id="1dab1-801">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1dab1-802"><xref:System.Text.Encoding.GetByteCount%2A> 方法确定导致对一组 Unicode 字符进行编码的字节数，并且 <xref:System.Text.Encoding.GetBytes%2A> 方法执行实际编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-802">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="1dab1-803">与处理单个输入流上的多个转换的 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 方法相比，<xref:System.Text.Encoding.GetBytes%2A> 方法需要离散转换。</span><span class="sxs-lookup"><span data-stu-id="1dab1-803">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="1dab1-804">支持 <xref:System.Text.Encoding.GetByteCount%2A> 和 <xref:System.Text.Encoding.GetBytes%2A> 的多个版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-804">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="1dab1-805">下面是有关使用这些方法的一些编程注意事项：</span><span class="sxs-lookup"><span data-stu-id="1dab1-805">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1dab1-806">您的应用程序可能需要将许多输入字符编码为代码页，并使用多个调用处理这些字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-806">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="1dab1-807">在这种情况下，您可能需要维护两次调用之间的状态，同时考虑所使用的 <xref:System.Text.Encoder> 对象所保留的状态。</span><span class="sxs-lookup"><span data-stu-id="1dab1-807">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span>

-   <span data-ttu-id="1dab1-808">如果你的应用程序处理字符串输入，则应使用 <xref:System.Text.Encoding.GetBytes%2A> 方法的字符串版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-808">If your app handles string inputs, you should use the string versions of the <xref:System.Text.Encoding.GetBytes%2A> method.</span></span>

-   <span data-ttu-id="1dab1-809"><xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 的 Unicode 字符缓冲区版本允许一些快速的技巧，尤其是使用 <xref:System.Text.Encoder> 对象的多个调用或插入现有缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-809">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="1dab1-810">但请记住，此方法版本有时不安全，因为指针是必需的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-810">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1dab1-811">如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-811">If your app must convert a large amount of data, you should reuse the output buffer.</span></span> <span data-ttu-id="1dab1-812">在这种情况下，支持字节数组的 <xref:System.Text.Encoding.GetBytes%2A> 版本是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-812">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="1dab1-813">请考虑使用 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 方法，而不是 <xref:System.Text.Encoding.GetByteCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-813">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="1dab1-814">转换方法可转换尽可能多的数据，如果输出缓冲区太小，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="1dab1-814">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="1dab1-815">对于流的连续编码，此方法通常是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-815">For continuous encoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="1dab1-816">下面的示例确定对字符数组进行编码、对字符进行编码并显示生成的字节所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-816">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1dab1-817"><paramref name="chars" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-817"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1dab1-818">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）</span><span class="sxs-lookup"><span data-stu-id="1dab1-818">A fallback occurred (for more information, see <see href="/dotnet/standard/base-types/character-encoding">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1dab1-819">和</span><span class="sxs-lookup"><span data-stu-id="1dab1-819">-and-</span></span>

 <span data-ttu-id="1dab1-820"><see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-820"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int&#xA;override this.GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="1dab1-821">要编码的字符范围。</span><span class="sxs-lookup"><span data-stu-id="1dab1-821">The span of characters to encode.</span></span></param>
        <summary><span data-ttu-id="1dab1-822">在派生类中重写时，计算对指定字符范围的字符进行编码所产生的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-822">When overridden in a derived class, calculates the number of bytes produced by encoding the characters in the specified character span.</span></span></summary>
        <returns><span data-ttu-id="1dab1-823">对指定字符范围进行编码所产生的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-823">The number of bytes produced by encoding the specified character span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-824">若要计算 <xref:System.Text.Encoding.GetBytes%2A> 存储生成的字节所需的确切范围大小，请调用 <xref:System.Text.Encoding.GetByteCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-824">To calculate the exact span size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1dab1-825">若要计算最大跨度大小，请调用 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-825">To calculate the maximum span size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1dab1-826"><xref:System.Text.Encoding.GetByteCount%2A> 方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法的执行速度通常更快。</span><span class="sxs-lookup"><span data-stu-id="1dab1-826">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1dab1-827"><xref:System.Text.Encoding.GetByteCount%2A> 方法确定导致对一组 Unicode 字符进行编码的字节数，并且 <xref:System.Text.Encoding.GetBytes%2A> 方法执行实际编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-827">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="1dab1-828">与处理单个输入流上的多个转换的 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 方法相比，<xref:System.Text.Encoding.GetBytes%2A> 方法需要离散转换。</span><span class="sxs-lookup"><span data-stu-id="1dab1-828">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="1dab1-829">支持 <xref:System.Text.Encoding.GetByteCount%2A> 和 <xref:System.Text.Encoding.GetBytes%2A> 的多个版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-829">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="1dab1-830">下面是有关使用这些方法的一些编程注意事项：</span><span class="sxs-lookup"><span data-stu-id="1dab1-830">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1dab1-831">您的应用程序可能需要将许多输入字符编码为代码页，并使用多个调用处理这些字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-831">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="1dab1-832">在这种情况下，您可能需要维护两次调用之间的状态，同时考虑所使用的 <xref:System.Text.Encoder> 对象所保留的状态。</span><span class="sxs-lookup"><span data-stu-id="1dab1-832">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span>

-   <span data-ttu-id="1dab1-833">如果你的应用程序处理多个字符输入，则建议 <xref:System.Text.Encoding.GetBytes%2A> 的跨度版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-833">If your app handles span of characters inputs, the span version of <xref:System.Text.Encoding.GetBytes%2A> is recommended.</span></span>

-   <span data-ttu-id="1dab1-834">请考虑使用 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 方法，而不是 <xref:System.Text.Encoding.GetByteCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-834">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="1dab1-835">转换方法可转换尽可能多的数据，如果输出范围缓冲区太小，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="1dab1-835">The conversion method converts as much data as possible, and does throw an exception if the output span buffer is too small.</span></span> <span data-ttu-id="1dab1-836">对于流的连续编码，此方法通常是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-836">For continuous encoding of a stream, this method is often the best choice.</span></span>
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : string -&gt; int&#xA;override this.GetByteCount : string -&gt; int" Usage="encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="1dab1-837">包含要编码的字符集的字符串。</span><span class="sxs-lookup"><span data-stu-id="1dab1-837">The string containing the set of characters to encode.</span></span></param>
        <summary><span data-ttu-id="1dab1-838">在派生类中重写时，计算对指定字符串中的字符进行编码所产生的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-838">When overridden in a derived class, calculates the number of bytes produced by encoding the characters in the specified string.</span></span></summary>
        <returns><span data-ttu-id="1dab1-839">对指定字符进行编码后生成的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-839">The number of bytes produced by encoding the specified characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-840">若要计算 <xref:System.Text.Encoding.GetBytes%2A> 存储生成的字节所需的确切数组大小，请调用 <xref:System.Text.Encoding.GetByteCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-840">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1dab1-841">若要计算最大数组大小，请调用 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-841">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1dab1-842"><xref:System.Text.Encoding.GetByteCount%2A> 方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法的执行速度通常更快。</span><span class="sxs-lookup"><span data-stu-id="1dab1-842">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1dab1-843"><xref:System.Text.Encoding.GetByteCount%2A> 方法确定导致对一组 Unicode 字符进行编码的字节数，并且 <xref:System.Text.Encoding.GetBytes%2A> 方法执行实际编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-843">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="1dab1-844">与处理单个输入流上的多个转换的 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 方法相比，<xref:System.Text.Encoding.GetBytes%2A> 方法需要离散转换。</span><span class="sxs-lookup"><span data-stu-id="1dab1-844">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="1dab1-845">支持 <xref:System.Text.Encoding.GetByteCount%2A> 和 <xref:System.Text.Encoding.GetBytes%2A> 的多个版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-845">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="1dab1-846">下面是有关使用这些方法的一些编程注意事项：</span><span class="sxs-lookup"><span data-stu-id="1dab1-846">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1dab1-847">您的应用程序可能需要将许多输入字符编码为代码页，并使用多个调用处理这些字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-847">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="1dab1-848">在这种情况下，您可能需要维护两次调用之间的状态，同时考虑所使用的 <xref:System.Text.Encoder> 对象所保留的状态。</span><span class="sxs-lookup"><span data-stu-id="1dab1-848">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span>

-   <span data-ttu-id="1dab1-849">如果你的应用程序处理字符串输入，则建议 <xref:System.Text.Encoding.GetBytes%2A> 的字符串版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-849">If your app handles string inputs, the string version of <xref:System.Text.Encoding.GetBytes%2A> is recommended.</span></span>

-   <span data-ttu-id="1dab1-850"><xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 的 Unicode 字符缓冲区版本允许一些快速的技巧，尤其是使用 <xref:System.Text.Encoder> 对象的多个调用或插入现有缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-850">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="1dab1-851">但请记住，此方法版本有时不安全，因为指针是必需的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-851">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1dab1-852">如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-852">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1dab1-853">在这种情况下，支持字节数组的 <xref:System.Text.Encoding.GetBytes%2A> 版本是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-853">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="1dab1-854">请考虑使用 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 方法，而不是 <xref:System.Text.Encoding.GetByteCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-854">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="1dab1-855">转换方法可转换尽可能多的数据，如果输出缓冲区太小，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="1dab1-855">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="1dab1-856">对于流的连续编码，此方法通常是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-856">For continuous encoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="1dab1-857">下面的示例确定了对字符串中的字符串或范围进行编码、对字符进行编码并显示生成的字节所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-857">The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1dab1-858"><paramref name="s" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-858"><paramref name="s" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1dab1-859">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）</span><span class="sxs-lookup"><span data-stu-id="1dab1-859">A fallback occurred (for more information, see <see href="/dotnet/standard/base-types/character-encoding">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1dab1-860">和</span><span class="sxs-lookup"><span data-stu-id="1dab1-860">-and-</span></span>

 <span data-ttu-id="1dab1-861"><see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-861"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="1dab1-862">指向第一个要编码的字符的指针。</span><span class="sxs-lookup"><span data-stu-id="1dab1-862">A pointer to the first character to encode.</span></span></param>
        <param name="count"><span data-ttu-id="1dab1-863">要编码的字符的数目。</span><span class="sxs-lookup"><span data-stu-id="1dab1-863">The number of characters to encode.</span></span></param>
        <summary><span data-ttu-id="1dab1-864">在派生类中重写时，计算对一组字符（从指定的字符指针处开始）进行编码所产生的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-864">When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.</span></span></summary>
        <returns><span data-ttu-id="1dab1-865">对指定字符进行编码后生成的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-865">The number of bytes produced by encoding the specified characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-866">若要计算 <xref:System.Text.Encoding.GetBytes%2A> 存储生成的字节所需的确切数组大小，应调用 <xref:System.Text.Encoding.GetByteCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-866">To calculate the exact array size that <xref:System.Text.Encoding.GetBytes%2A> requires to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1dab1-867">若要计算最大数组大小，请调用 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-867">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1dab1-868"><xref:System.Text.Encoding.GetByteCount%2A> 方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法的执行速度通常更快。</span><span class="sxs-lookup"><span data-stu-id="1dab1-868">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1dab1-869"><xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> 方法确定导致对一组 Unicode 字符进行编码的字节数，并且 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 方法执行实际编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-869">The <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> method performs the actual encoding.</span></span> <span data-ttu-id="1dab1-870">与处理单个输入流上的多个转换的 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 方法相比，<xref:System.Text.Encoding.GetBytes%2A> 方法需要离散转换。</span><span class="sxs-lookup"><span data-stu-id="1dab1-870">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="1dab1-871">支持 <xref:System.Text.Encoding.GetByteCount%2A> 和 <xref:System.Text.Encoding.GetBytes%2A> 的多个版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-871">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="1dab1-872">下面是使用这些方法时的一些注意事项：</span><span class="sxs-lookup"><span data-stu-id="1dab1-872">The following are some considerations for using these methods:</span></span>

-   <span data-ttu-id="1dab1-873">您的应用程序可能需要将许多输入字符编码为代码页，并使用多个调用处理这些字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-873">Your app may need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="1dab1-874">在这种情况下，您可能需要维护两次调用之间的状态，同时考虑所使用的 <xref:System.Text.Encoder> 对象所保留的状态。</span><span class="sxs-lookup"><span data-stu-id="1dab1-874">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span>

-   <span data-ttu-id="1dab1-875">如果你的应用程序处理字符串输入，则应使用 <xref:System.Text.Encoding.GetBytes%2A> 方法的字符串版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-875">If your app handles string inputs, you should use the string version of the <xref:System.Text.Encoding.GetBytes%2A> method.</span></span>

-   <span data-ttu-id="1dab1-876"><xref:System.Text.Encoding.GetBytes%2A> 的 Unicode 字符缓冲区版本允许一些快速的技巧，尤其是使用 <xref:System.Text.Encoder> 对象的多个调用或插入现有缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-876">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%2A> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="1dab1-877">但请记住，此方法版本有时不安全，因为指针是必需的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-877">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1dab1-878">如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-878">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1dab1-879">在这种情况下，支持字节数组的 <xref:System.Text.Encoding.GetBytes%2A> 版本是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-879">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="1dab1-880">请考虑使用 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 方法，而不是 <xref:System.Text.Encoding.GetByteCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-880">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="1dab1-881">转换方法可转换尽可能多的数据，如果输出缓冲区太小，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="1dab1-881">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="1dab1-882">对于流的连续编码，此方法通常是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-882">For continuous encoding of a stream, this method is often the best choice.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1dab1-883"><paramref name="chars" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-883"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1dab1-884"><paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="1dab1-884"><paramref name="count" /> is less than zero.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1dab1-885">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）</span><span class="sxs-lookup"><span data-stu-id="1dab1-885">A fallback occurred (for more information, see <see href="/dotnet/standard/base-types/character-encoding">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1dab1-886">和</span><span class="sxs-lookup"><span data-stu-id="1dab1-886">-and-</span></span>

 <span data-ttu-id="1dab1-887"><see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-887"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] * int * int -&gt; int" Usage="encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="1dab1-888">包含要编码的字符集的字符数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-888">The character array containing the set of characters to encode.</span></span></param>
        <param name="index"><span data-ttu-id="1dab1-889">第一个要编码的字符的索引。</span><span class="sxs-lookup"><span data-stu-id="1dab1-889">The index of the first character to encode.</span></span></param>
        <param name="count"><span data-ttu-id="1dab1-890">要编码的字符的数目。</span><span class="sxs-lookup"><span data-stu-id="1dab1-890">The number of characters to encode.</span></span></param>
        <summary><span data-ttu-id="1dab1-891">在派生类中重写时，计算对指定字符数组中的一组字符进行编码所产生的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-891">When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters from the specified character array.</span></span></summary>
        <returns><span data-ttu-id="1dab1-892">对指定字符进行编码后生成的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-892">The number of bytes produced by encoding the specified characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-893">若要计算 <xref:System.Text.Encoding.GetBytes%2A> 存储生成的字节所需的确切数组大小，请调用 <xref:System.Text.Encoding.GetByteCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-893">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1dab1-894">若要计算最大数组大小，请调用 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-894">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1dab1-895"><xref:System.Text.Encoding.GetByteCount%2A> 方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法的执行速度通常更快。</span><span class="sxs-lookup"><span data-stu-id="1dab1-895">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1dab1-896"><xref:System.Text.Encoding.GetByteCount%2A> 方法确定导致对一组 Unicode 字符进行编码的字节数，并且 <xref:System.Text.Encoding.GetBytes%2A> 方法执行实际编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-896">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="1dab1-897">与处理单个输入流上的多个转换的 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 方法相比，<xref:System.Text.Encoding.GetBytes%2A> 方法需要离散转换。</span><span class="sxs-lookup"><span data-stu-id="1dab1-897">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="1dab1-898">支持 <xref:System.Text.Encoding.GetByteCount%2A> 和 <xref:System.Text.Encoding.GetBytes%2A> 的多个版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-898">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="1dab1-899">下面是有关使用这些方法的一些编程注意事项：</span><span class="sxs-lookup"><span data-stu-id="1dab1-899">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1dab1-900">您的应用程序可能需要将许多输入字符编码为代码页，并使用多个调用处理这些字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-900">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="1dab1-901">在这种情况下，您可能需要维护两次调用之间的状态，同时考虑所使用的 <xref:System.Text.Encoder> 对象所保留的状态。</span><span class="sxs-lookup"><span data-stu-id="1dab1-901">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span>

-   <span data-ttu-id="1dab1-902">如果你的应用程序处理字符串输入，则建议 <xref:System.Text.Encoding.GetBytes%2A> 的字符串版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-902">If your app handles string inputs, the string version of <xref:System.Text.Encoding.GetBytes%2A> is recommended.</span></span>

-   <span data-ttu-id="1dab1-903"><xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 的 Unicode 字符缓冲区版本允许一些快速的技巧，尤其是使用 <xref:System.Text.Encoder> 对象的多个调用或插入现有缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-903">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="1dab1-904">但请记住，此方法版本有时不安全，因为指针是必需的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-904">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1dab1-905">如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-905">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1dab1-906">在这种情况下，支持字节数组的 <xref:System.Text.Encoding.GetBytes%2A> 版本是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-906">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="1dab1-907">请考虑使用 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 方法，而不是 <xref:System.Text.Encoding.GetByteCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-907">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="1dab1-908">转换方法可转换尽可能多的数据，如果输出缓冲区太小，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="1dab1-908">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="1dab1-909">对于流的连续编码，此方法通常是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-909">For continuous encoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="1dab1-910">下面的示例确定对字符数组中的三个字符进行编码、对字符进行编码并显示生成的字节所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-910">The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1dab1-911"><paramref name="chars" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-911"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1dab1-912"><paramref name="index" /> 或 <paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="1dab1-912"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span>

<span data-ttu-id="1dab1-913">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1dab1-913">-or-</span></span>

 <span data-ttu-id="1dab1-914"><paramref name="index" /> 和 <paramref name="count" /> 不表示 <paramref name="chars" /> 中的有效范围。</span><span class="sxs-lookup"><span data-stu-id="1dab1-914"><paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="chars" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1dab1-915">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）</span><span class="sxs-lookup"><span data-stu-id="1dab1-915">A fallback occurred (for more information, see <see href="/dotnet/standard/base-types/character-encoding">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1dab1-916">和</span><span class="sxs-lookup"><span data-stu-id="1dab1-916">-and-</span></span>

 <span data-ttu-id="1dab1-917"><see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-917"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (s As String, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetByteCount(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : string * int * int -&gt; int" Usage="encoding.GetByteCount (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="1dab1-918">包含要编码的字符集的字符串。</span><span class="sxs-lookup"><span data-stu-id="1dab1-918">The string containing the set of characters to encode.</span></span></param>
        <param name="index"><span data-ttu-id="1dab1-919">第一个要编码的字符的索引。</span><span class="sxs-lookup"><span data-stu-id="1dab1-919">The index of the first character to encode.</span></span></param>
        <param name="count"><span data-ttu-id="1dab1-920">要编码的字符的数目。</span><span class="sxs-lookup"><span data-stu-id="1dab1-920">The number of characters to encode.</span></span></param>
        <summary><span data-ttu-id="1dab1-921">在派生类中重写时，计算对指定字符串中的一组字符进行编码所产生的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-921">When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters from the specified string.</span></span></summary>
        <returns><span data-ttu-id="1dab1-922">对字符串进行编码后生成的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-922">The number of bytes produced by encoding the string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-923">若要计算 <xref:System.Text.Encoding.GetBytes%2A> 存储生成的字节所需的确切数组大小，请调用 <xref:System.Text.Encoding.GetByteCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-923">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1dab1-924">若要计算最大数组大小，请调用 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-924">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1dab1-925"><xref:System.Text.Encoding.GetByteCount%2A> 方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法的执行速度通常更快。</span><span class="sxs-lookup"><span data-stu-id="1dab1-925">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1dab1-926"><xref:System.Text.Encoding.GetByteCount%2A> 方法确定导致对一组 Unicode 字符进行编码的字节数，并且 <xref:System.Text.Encoding.GetBytes%2A> 方法执行实际编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-926">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="1dab1-927">与处理单个输入流上的多个转换的 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 方法相比，<xref:System.Text.Encoding.GetBytes%2A> 方法需要离散转换。</span><span class="sxs-lookup"><span data-stu-id="1dab1-927">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="1dab1-928">支持 <xref:System.Text.Encoding.GetByteCount%2A> 和 <xref:System.Text.Encoding.GetBytes%2A> 的多个版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-928">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="1dab1-929">下面是有关使用这些方法的一些编程注意事项：</span><span class="sxs-lookup"><span data-stu-id="1dab1-929">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1dab1-930">您的应用程序可能需要将许多输入字符编码为代码页，并使用多个调用处理这些字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-930">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="1dab1-931">在这种情况下，您可能需要维护两次调用之间的状态，同时考虑所使用的 <xref:System.Text.Encoder> 对象所保留的状态。</span><span class="sxs-lookup"><span data-stu-id="1dab1-931">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span>

-   <span data-ttu-id="1dab1-932">如果你的应用程序处理字符串输入，则建议 <xref:System.Text.Encoding.GetBytes%2A> 的字符串版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-932">If your app handles string inputs, the string version of <xref:System.Text.Encoding.GetBytes%2A> is recommended.</span></span>

-   <span data-ttu-id="1dab1-933"><xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 的 Unicode 字符缓冲区版本允许一些快速的技巧，尤其是使用 <xref:System.Text.Encoder> 对象的多个调用或插入现有缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-933">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="1dab1-934">但请记住，此方法版本有时不安全，因为指针是必需的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-934">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1dab1-935">如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-935">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1dab1-936">在这种情况下，支持字节数组的 <xref:System.Text.Encoding.GetBytes%2A> 版本是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-936">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="1dab1-937">请考虑使用 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 方法，而不是 <xref:System.Text.Encoding.GetByteCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-937">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="1dab1-938">转换方法可转换尽可能多的数据，如果输出缓冲区太小，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="1dab1-938">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="1dab1-939">对于流的连续编码，此方法通常是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-939">For continuous encoding of a stream, this method is often the best choice.</span></span>


## Examples
 <span data-ttu-id="1dab1-940">下面的示例确定对字符数组中的三个字符进行编码、对字符进行编码并显示生成的字节所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-940">The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1dab1-941">在派生类中重写时，将一组字符编码为一个字节序列。</span><span class="sxs-lookup"><span data-stu-id="1dab1-941">When overridden in a derived class, encodes a set of characters into a sequence of bytes.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] -&gt; byte[]&#xA;override this.GetBytes : char[] -&gt; byte[]" Usage="encoding.GetBytes chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="1dab1-942">包含要编码的字符的字符数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-942">The character array containing the characters to encode.</span></span></param>
        <summary><span data-ttu-id="1dab1-943">在派生类中重写时，将指定字符数组中的所有字符编码为一个字节序列。</span><span class="sxs-lookup"><span data-stu-id="1dab1-943">When overridden in a derived class, encodes all the characters in the specified character array into a sequence of bytes.</span></span></summary>
        <returns><span data-ttu-id="1dab1-944">一个字节数组，包含对指定的字符集进行编码的结果。</span><span class="sxs-lookup"><span data-stu-id="1dab1-944">A byte array containing the results of encoding the specified set of characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-945">如果要转换的数据仅适用于连续块（如从流中读取的数据），或者如果数据量很大以致需要分为更小块，则应使用派生类的 <xref:System.Text.Encoding.GetDecoder%2A> 方法或 <xref:System.Text.Encoding.GetEncoder%2A> 方法提供的 <xref:System.Text.Decoder> 或 <xref:System.Text.Encoder>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-945">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="1dab1-946"><xref:System.Text.Encoding.GetByteCount%2A> 方法确定导致对一组 Unicode 字符进行编码的字节数，并且 <xref:System.Text.Encoding.GetBytes%2A> 方法执行实际编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-946">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="1dab1-947">与处理单个输入流上的多个转换的 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 方法相比，<xref:System.Text.Encoding.GetBytes%2A> 方法需要离散转换。</span><span class="sxs-lookup"><span data-stu-id="1dab1-947">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="1dab1-948">支持 <xref:System.Text.Encoding.GetByteCount%2A> 和 <xref:System.Text.Encoding.GetBytes%2A> 的多个版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-948">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="1dab1-949">下面是有关使用这些方法的一些编程注意事项：</span><span class="sxs-lookup"><span data-stu-id="1dab1-949">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1dab1-950">您的应用程序可能需要将许多输入字符编码为代码页，并使用多个调用处理这些字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-950">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="1dab1-951">在这种情况下，您可能需要维护两次调用之间的状态，同时考虑所使用的 <xref:System.Text.Encoder> 对象所保留的状态。</span><span class="sxs-lookup"><span data-stu-id="1dab1-951">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="1dab1-952">（例如，包含代理项对的字符序列可能以高代理项结束。</span><span class="sxs-lookup"><span data-stu-id="1dab1-952">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="1dab1-953"><xref:System.Text.Encoder> 将记住高代理项，以便可以在以下调用开始时将其与低代理项组合在一起。</span><span class="sxs-lookup"><span data-stu-id="1dab1-953">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="1dab1-954"><xref:System.Text.Encoding> 无法维护状态，因此字符将发送到 <xref:System.Text.EncoderFallback>。）</span><span class="sxs-lookup"><span data-stu-id="1dab1-954"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>

-   <span data-ttu-id="1dab1-955">如果你的应用程序处理字符串输入，则应调用 <xref:System.Text.Encoding.GetBytes%2A> 方法的字符串版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-955">If your app handles string inputs, you should call the string version of the <xref:System.Text.Encoding.GetBytes%2A> method.</span></span>

-   <span data-ttu-id="1dab1-956"><xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 的 Unicode 字符缓冲区版本允许一些快速的技巧，尤其是使用 <xref:System.Text.Encoder> 对象的多个调用或插入现有缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-956">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="1dab1-957">但请记住，此方法版本有时不安全，因为指针是必需的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-957">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1dab1-958">如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-958">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1dab1-959">在这种情况下，支持字节数组的 <xref:System.Text.Encoding.GetBytes%2A> 版本是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-959">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="1dab1-960">请考虑使用 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 方法，而不是 <xref:System.Text.Encoding.GetByteCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-960">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="1dab1-961">转换方法可转换尽可能多的数据，如果输出缓冲区太小，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="1dab1-961">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="1dab1-962">对于流的连续编码，此方法通常是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-962">For continuous encoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="1dab1-963">下面的示例确定对字符数组进行编码、对字符进行编码并显示生成的字节所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-963">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1dab1-964"><paramref name="chars" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-964"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1dab1-965">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）</span><span class="sxs-lookup"><span data-stu-id="1dab1-965">A fallback occurred (for more information, see <see href="/dotnet/standard/base-types/character-encoding">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1dab1-966">和</span><span class="sxs-lookup"><span data-stu-id="1dab1-966">-and-</span></span>

 <span data-ttu-id="1dab1-967"><see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-967"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string -&gt; byte[]&#xA;override this.GetBytes : string -&gt; byte[]" Usage="encoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="1dab1-968">包含要编码的字符的字符串。</span><span class="sxs-lookup"><span data-stu-id="1dab1-968">The string containing the characters to encode.</span></span></param>
        <summary><span data-ttu-id="1dab1-969">在派生类中重写时，将指定字符串中的所有字符编码为一个字节序列。</span><span class="sxs-lookup"><span data-stu-id="1dab1-969">When overridden in a derived class, encodes all the characters in the specified string into a sequence of bytes.</span></span></summary>
        <returns><span data-ttu-id="1dab1-970">一个字节数组，包含对指定的字符集进行编码的结果。</span><span class="sxs-lookup"><span data-stu-id="1dab1-970">A byte array containing the results of encoding the specified set of characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-971">如果要转换的数据仅适用于连续块（如从流中读取的数据），或者如果数据量很大以致需要分为更小块，则应使用派生类的 <xref:System.Text.Encoding.GetDecoder%2A> 方法或 <xref:System.Text.Encoding.GetEncoder%2A> 方法提供的 <xref:System.Text.Decoder> 或 <xref:System.Text.Encoder>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-971">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="1dab1-972"><xref:System.Text.Encoding.GetByteCount%2A> 方法确定导致对一组 Unicode 字符进行编码的字节数，并且 <xref:System.Text.Encoding.GetBytes%2A> 方法执行实际编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-972">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="1dab1-973">与处理单个输入流上的多个转换的 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 方法相比，<xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> 方法需要离散转换。</span><span class="sxs-lookup"><span data-stu-id="1dab1-973">The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="1dab1-974">支持 <xref:System.Text.Encoding.GetByteCount%2A> 和 <xref:System.Text.Encoding.GetBytes%2A> 的多个版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-974">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="1dab1-975">下面是有关使用这些方法的一些编程注意事项：</span><span class="sxs-lookup"><span data-stu-id="1dab1-975">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1dab1-976">您的应用程序可能需要将许多输入字符编码为代码页，并使用多个调用处理这些字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-976">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="1dab1-977">在这种情况下，您可能需要维护两次调用之间的状态，同时考虑所使用的 <xref:System.Text.Encoder> 对象所保留的状态。</span><span class="sxs-lookup"><span data-stu-id="1dab1-977">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="1dab1-978">（例如，包含代理项对的字符序列可能以高代理项结束。</span><span class="sxs-lookup"><span data-stu-id="1dab1-978">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="1dab1-979"><xref:System.Text.Encoder> 将记住高代理项，以便可以在以下调用开始时将其与低代理项组合在一起。</span><span class="sxs-lookup"><span data-stu-id="1dab1-979">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="1dab1-980"><xref:System.Text.Encoding> 无法维护状态，因此字符将发送到 <xref:System.Text.EncoderFallback>。）</span><span class="sxs-lookup"><span data-stu-id="1dab1-980"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>

-   <span data-ttu-id="1dab1-981">如果你的应用程序处理字符串输入，则应使用 <xref:System.Text.Encoding.GetBytes%2A>的字符串版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-981">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>

-   <span data-ttu-id="1dab1-982"><xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 的 Unicode 字符缓冲区版本允许一些快速的技巧，尤其是使用 <xref:System.Text.Encoder> 对象的多个调用或插入现有缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-982">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="1dab1-983">但请记住，此方法版本有时不安全，因为指针是必需的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-983">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1dab1-984">如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-984">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1dab1-985">在这种情况下，支持字节数组的 <xref:System.Text.Encoding.GetBytes%2A> 版本是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-985">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="1dab1-986">请考虑使用 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 方法，而不是 <xref:System.Text.Encoding.GetByteCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-986">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="1dab1-987">转换方法可转换尽可能多的数据，如果输出缓冲区太小，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="1dab1-987">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="1dab1-988">对于流的连续编码，此方法通常是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-988">For continuous encoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="1dab1-989">下面的示例确定了对字符串中的字符串或范围进行编码、对字符进行编码并显示生成的字节所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-989">The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1dab1-990"><paramref name="s" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-990"><paramref name="s" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1dab1-991">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）</span><span class="sxs-lookup"><span data-stu-id="1dab1-991">A fallback occurred (for more information, see <see href="/dotnet/standard/base-types/character-encoding">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1dab1-992">和</span><span class="sxs-lookup"><span data-stu-id="1dab1-992">-and-</span></span>

 <span data-ttu-id="1dab1-993"><see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-993"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int&#xA;override this.GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int" Usage="encoding.GetBytes (chars, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="1dab1-994">包含要编码的字符集的范围。</span><span class="sxs-lookup"><span data-stu-id="1dab1-994">The span containing the set of characters to encode.</span></span></param>
        <param name="bytes"><span data-ttu-id="1dab1-995">用于保存已编码字节的字节范围。</span><span class="sxs-lookup"><span data-stu-id="1dab1-995">The byte span to hold the encoded bytes.</span></span></param>
        <summary><span data-ttu-id="1dab1-996">在派生类中重写时，将指定只读范围中的一组字符编码为字节范围。</span><span class="sxs-lookup"><span data-stu-id="1dab1-996">When overridden in a derived class, encodes into a span of bytes a set of characters from the specified read-only span.</span></span></summary>
        <returns><span data-ttu-id="1dab1-997">已编码的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-997">The number of encoded bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-998">如果要转换的数据仅适用于连续块（如从流中读取的数据），或者如果数据量很大以致需要分为更小块，则应使用派生类的 <xref:System.Text.Encoding.GetDecoder%2A> 方法或 <xref:System.Text.Encoding.GetEncoder%2A> 方法提供的 <xref:System.Text.Decoder> 或 <xref:System.Text.Encoder>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-998">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="1dab1-999"><xref:System.Text.Encoding.GetByteCount%2A> 方法确定导致对一组 Unicode 字符进行编码的字节数，并且 <xref:System.Text.Encoding.GetBytes%2A> 方法执行实际编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-999">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="1dab1-1000">与处理单个输入流上的多个转换的 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 方法相比，<xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> 方法需要离散转换。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1000">The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="1dab1-1001">支持 <xref:System.Text.Encoding.GetByteCount%2A> 和 <xref:System.Text.Encoding.GetBytes%2A> 的多个版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1001">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="1dab1-1002">下面是有关使用这些方法的一些编程注意事项：</span><span class="sxs-lookup"><span data-stu-id="1dab1-1002">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1dab1-1003">您的应用程序可能需要将许多输入字符编码为代码页，并使用多个调用处理这些字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1003">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="1dab1-1004">在这种情况下，您可能需要维护两次调用之间的状态，同时考虑所使用的 <xref:System.Text.Encoder> 对象所保留的状态。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1004">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="1dab1-1005">（例如，包含代理项对的字符序列可能以高代理项结束。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1005">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="1dab1-1006"><xref:System.Text.Encoder> 将记住高代理项，以便可以在以下调用开始时将其与低代理项组合在一起。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1006">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="1dab1-1007"><xref:System.Text.Encoding> 无法维护状态，因此字符将发送到 <xref:System.Text.EncoderFallback>。）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1007"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>

-   <span data-ttu-id="1dab1-1008">如果你的应用程序处理字符串输入，则应使用 <xref:System.Text.Encoding.GetBytes%2A>的字符串版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1008">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>

-   <span data-ttu-id="1dab1-1009">如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1009">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1dab1-1010">在这种情况下，支持字节数组的 <xref:System.Text.Encoding.GetBytes%2A> 版本是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1010">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="1dab1-1011">请考虑使用 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 方法，而不是 <xref:System.Text.Encoding.GetByteCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1011">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="1dab1-1012">转换方法可转换尽可能多的数据，如果输出缓冲区太小，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1012">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="1dab1-1013">对于流的连续编码，此方法通常是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1013">For continuous encoding of a stream, this method is often the best choice.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int -&gt; byte[]&#xA;override this.GetBytes : char[] * int * int -&gt; byte[]" Usage="encoding.GetBytes (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="1dab1-1014">包含要编码的字符集的字符数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1014">The character array containing the set of characters to encode.</span></span></param>
        <param name="index"><span data-ttu-id="1dab1-1015">第一个要编码的字符的索引。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1015">The index of the first character to encode.</span></span></param>
        <param name="count"><span data-ttu-id="1dab1-1016">要编码的字符的数目。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1016">The number of characters to encode.</span></span></param>
        <summary><span data-ttu-id="1dab1-1017">在派生类中重写时，将指定字符数组中的一组字符编码为一个字节序列。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1017">When overridden in a derived class, encodes a set of characters from the specified character array into a sequence of bytes.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1018">一个字节数组，包含对指定的字符集进行编码的结果。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1018">A byte array containing the results of encoding the specified set of characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1019">如果要转换的数据仅适用于连续块（如从流中读取的数据），或者如果数据量很大以致需要分为更小块，则应使用派生类的 <xref:System.Text.Encoding.GetDecoder%2A> 方法或 <xref:System.Text.Encoding.GetEncoder%2A> 方法提供的 <xref:System.Text.Decoder> 或 <xref:System.Text.Encoder>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1019">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="1dab1-1020"><xref:System.Text.Encoding.GetByteCount%2A> 方法确定导致对一组 Unicode 字符进行编码的字节数，并且 <xref:System.Text.Encoding.GetBytes%2A> 方法执行实际编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1020">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="1dab1-1021">与处理单个输入流上的多个转换的 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 方法相比，<xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> 方法需要离散转换。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1021">The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="1dab1-1022">支持 <xref:System.Text.Encoding.GetByteCount%2A> 和 <xref:System.Text.Encoding.GetBytes%2A> 的多个版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1022">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="1dab1-1023">下面是有关使用这些方法的一些编程注意事项：</span><span class="sxs-lookup"><span data-stu-id="1dab1-1023">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1dab1-1024">您的应用程序可能需要将许多输入字符编码为代码页，并使用多个调用处理这些字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1024">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="1dab1-1025">在这种情况下，您可能需要维护两次调用之间的状态，同时考虑所使用的 <xref:System.Text.Encoder> 对象所保留的状态。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1025">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="1dab1-1026">（例如，包含代理项对的字符序列可能以高代理项结束。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1026">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="1dab1-1027"><xref:System.Text.Encoder> 将记住高代理项，以便可以在以下调用开始时将其与低代理项组合在一起。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1027">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="1dab1-1028"><xref:System.Text.Encoding> 无法维护状态，因此字符将发送到 <xref:System.Text.EncoderFallback>。）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1028"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>

-   <span data-ttu-id="1dab1-1029">如果你的应用程序处理字符串输入，则应使用 <xref:System.Text.Encoding.GetBytes%2A>的字符串版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1029">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>

-   <span data-ttu-id="1dab1-1030"><xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 的 Unicode 字符缓冲区版本允许一些快速的技巧，尤其是使用 <xref:System.Text.Encoder> 对象的多个调用或插入现有缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1030">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="1dab1-1031">但请记住，此方法版本有时不安全，因为指针是必需的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1031">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1dab1-1032">如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1032">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1dab1-1033">在这种情况下，支持字节数组的 <xref:System.Text.Encoding.GetBytes%2A> 版本是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1033">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="1dab1-1034">请考虑使用 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 方法，而不是 <xref:System.Text.Encoding.GetByteCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1034">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="1dab1-1035">转换方法可转换尽可能多的数据，如果输出缓冲区太小，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1035">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="1dab1-1036">对于流的连续编码，此方法通常是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1036">For continuous encoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="1dab1-1037">下面的示例确定对字符数组中的三个字符进行编码、对字符进行编码并显示生成的字节所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1037">The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1dab1-1038"><paramref name="chars" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1038"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1dab1-1039"><paramref name="index" /> 或 <paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1039"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span>

<span data-ttu-id="1dab1-1040">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1dab1-1040">-or-</span></span>

 <span data-ttu-id="1dab1-1041"><paramref name="index" /> 和 <paramref name="count" /> 不表示 <paramref name="chars" /> 中的有效范围。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1041"><paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="chars" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1dab1-1042">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1042">A fallback occurred (for more information, see <see href="/dotnet/standard/base-types/character-encoding">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1dab1-1043">和</span><span class="sxs-lookup"><span data-stu-id="1dab1-1043">-and-</span></span>

 <span data-ttu-id="1dab1-1044"><see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1044"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytes (s As String, index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetBytes : string * int * int -&gt; byte[]" Usage="encoding.GetBytes (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="1dab1-1045">包含要编码的字符的字符串。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1045">The string containing the characters to encode.</span></span></param>
        <param name="index"><span data-ttu-id="1dab1-1046">字符串内的索引，要从该位置开始编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1046">The index inside the string to start the encoding from.</span></span></param>
        <param name="count"><span data-ttu-id="1dab1-1047">要编码的字符的数目。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1047">The number of characters to encode.</span></span></param>
        <summary><span data-ttu-id="1dab1-1048">在派生类中重写时，从指定的 <paramref name="index" /> 开始，将指定字符串中由 <paramref name="count" /> 指定的字符数编码为字节数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1048">When overridden in a derived class, encodes into an array of bytes the number of characters specified by <paramref name="count" /> in the specified string, starting from the specified <paramref name="index" />.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1049">一个字节数组，包含对指定的字符集进行编码的结果。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1049">A byte array containing the results of encoding the specified set of characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1050">如果要转换的数据仅适用于连续块（如从流中读取的数据），或者如果数据量很大以致需要分为更小块，则应使用派生类的 <xref:System.Text.Encoding.GetDecoder%2A> 方法或 <xref:System.Text.Encoding.GetEncoder%2A> 方法提供的 <xref:System.Text.Decoder> 或 <xref:System.Text.Encoder>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1050">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="1dab1-1051"><xref:System.Text.Encoding.GetByteCount%2A> 方法确定导致对一组 Unicode 字符进行编码的字节数，并且 <xref:System.Text.Encoding.GetBytes%2A> 方法执行实际编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1051">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="1dab1-1052">与处理单个输入流上的多个转换的 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 方法相比，<xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> 方法需要离散转换。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1052">The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="1dab1-1053">支持 <xref:System.Text.Encoding.GetByteCount%2A> 和 <xref:System.Text.Encoding.GetBytes%2A> 的多个版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1053">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="1dab1-1054">下面是有关使用这些方法的一些编程注意事项：</span><span class="sxs-lookup"><span data-stu-id="1dab1-1054">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1dab1-1055">您的应用程序可能需要将许多输入字符编码为代码页，并使用多个调用处理这些字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1055">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="1dab1-1056">在这种情况下，您可能需要维护两次调用之间的状态，同时考虑所使用的 <xref:System.Text.Encoder> 对象所保留的状态。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1056">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="1dab1-1057">（例如，包含代理项对的字符序列可能以高代理项结束。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1057">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="1dab1-1058"><xref:System.Text.Encoder> 将记住高代理项，以便可以在以下调用开始时将其与低代理项组合在一起。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1058">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="1dab1-1059"><xref:System.Text.Encoding> 无法维护状态，因此字符将发送到 <xref:System.Text.EncoderFallback>。）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1059"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>

-   <span data-ttu-id="1dab1-1060">如果你的应用程序处理字符串输入，则应使用 <xref:System.Text.Encoding.GetBytes%2A>的字符串版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1060">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>

-   <span data-ttu-id="1dab1-1061"><xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 的 Unicode 字符缓冲区版本允许一些快速的技巧，尤其是使用 <xref:System.Text.Encoder> 对象的多个调用或插入现有缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1061">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="1dab1-1062">但请记住，此方法版本有时不安全，因为指针是必需的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1062">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1dab1-1063">如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1063">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1dab1-1064">在这种情况下，支持字节数组的 <xref:System.Text.Encoding.GetBytes%2A> 版本是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1064">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="1dab1-1065">请考虑使用 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 方法，而不是 <xref:System.Text.Encoding.GetByteCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1065">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="1dab1-1066">转换方法可转换尽可能多的数据，如果输出缓冲区太小，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1066">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="1dab1-1067">对于流的连续编码，此方法通常是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1067">For continuous encoding of a stream, this method is often the best choice.</span></span>


## Examples
 <span data-ttu-id="1dab1-1068">下面的示例确定了对字符串中的字符串或范围进行编码、对字符进行编码并显示生成的字节所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1068">The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bytes" Type="System.Byte*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="1dab1-1069">指向第一个要编码的字符的指针。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1069">A pointer to the first character to encode.</span></span></param>
        <param name="charCount"><span data-ttu-id="1dab1-1070">要编码的字符的数目。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1070">The number of characters to encode.</span></span></param>
        <param name="bytes"><span data-ttu-id="1dab1-1071">一个指针，指向开始写入所产生的字节序列的位置。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1071">A pointer to the location at which to start writing the resulting sequence of bytes.</span></span></param>
        <param name="byteCount"><span data-ttu-id="1dab1-1072">要写入的最大字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1072">The maximum number of bytes to write.</span></span></param>
        <summary><span data-ttu-id="1dab1-1073">在派生类中重写时，将一组字符（从指定的字符指针开始）编码为一个字节序列，并从指定的字节指针开始存储该字节序列。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1073">When overridden in a derived class, encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1074">在由 <paramref name="bytes" /> 参数指示的位置处写入的实际字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1074">The actual number of bytes written at the location indicated by the <paramref name="bytes" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1075">若要计算 <xref:System.Text.Encoding.GetBytes%2A> 存储生成的字节所需的确切数组大小，请调用 <xref:System.Text.Encoding.GetByteCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1075">To calculate the exact array size that <xref:System.Text.Encoding.GetBytes%2A> requires to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1dab1-1076">若要计算最大数组大小，请调用 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1076">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1dab1-1077"><xref:System.Text.Encoding.GetByteCount%2A> 方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法的执行速度通常更快。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1077">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1dab1-1078">如果要转换的数据仅在 （如从流中读取的数据） 的顺序块中可用，或者如果数据量很大，它需要划分为较小的块，则应使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>提供对象<xref:System.Text.Encoding.GetDecoder%2A>或<xref:System.Text.Encoding.GetEncoder%2A>方法，分别的派生类。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1078">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.Encoding.GetDecoder%2A> or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="1dab1-1079"><xref:System.Text.Encoding.GetByteCount%2A> 方法确定导致对一组 Unicode 字符进行编码的字节数，并且 <xref:System.Text.Encoding.GetBytes%2A> 方法执行实际编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1079">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="1dab1-1080">与处理单个输入流上的多个转换的 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 方法相比，<xref:System.Text.Encoding.GetBytes%2A> 方法需要离散转换。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1080">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="1dab1-1081">支持 <xref:System.Text.Encoding.GetByteCount%2A> 和 <xref:System.Text.Encoding.GetBytes%2A> 的多个版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1081">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="1dab1-1082">下面是有关使用这些方法的一些编程注意事项：</span><span class="sxs-lookup"><span data-stu-id="1dab1-1082">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1dab1-1083">您的应用程序可能需要将许多输入字符编码为代码页，并使用多个调用处理这些字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1083">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="1dab1-1084">在这种情况下，您可能需要维护两次调用之间的状态，同时考虑所使用的 <xref:System.Text.Encoder> 对象所保留的状态。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1084">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="1dab1-1085">（例如，包含代理项对的字符序列可能以高代理项结束。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1085">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="1dab1-1086"><xref:System.Text.Encoder> 将记住高代理项，以便可以在以下调用开始时将其与低代理项组合在一起。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1086">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="1dab1-1087"><xref:System.Text.Encoding> 无法维护状态，因此字符将发送到 <xref:System.Text.EncoderFallback>。）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1087"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>

-   <span data-ttu-id="1dab1-1088">如果你的应用程序处理字符串输入，则应使用 <xref:System.Text.Encoding.GetBytes%2A>的字符串版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1088">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>

-   <span data-ttu-id="1dab1-1089"><xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 的 Unicode 字符缓冲区版本允许一些快速的技巧，尤其是使用 <xref:System.Text.Encoder> 对象的多个调用或插入现有缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1089">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="1dab1-1090">但请记住，此方法版本有时不安全，因为指针是必需的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1090">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1dab1-1091">如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1091">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1dab1-1092">在这种情况下，支持字节数组的 <xref:System.Text.Encoding.GetBytes%2A> 版本是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1092">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="1dab1-1093">请考虑使用 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 方法，而不是 <xref:System.Text.Encoding.GetByteCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1093">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="1dab1-1094">转换方法可转换尽可能多的数据，如果输出缓冲区太小，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1094">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="1dab1-1095">对于流的连续编码，此方法通常是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1095">For continuous encoding of a stream, this method is often the best choice.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1dab1-1096"><paramref name="chars" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1096"><paramref name="chars" /> is <see langword="null" />.</span></span>

<span data-ttu-id="1dab1-1097">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1dab1-1097">-or-</span></span>

 <span data-ttu-id="1dab1-1098"><paramref name="bytes" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1098"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1dab1-1099"><paramref name="charCount" /> 或 <paramref name="byteCount" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1099"><paramref name="charCount" /> or <paramref name="byteCount" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1dab1-1100"><paramref name="byteCount" /> 少于所产生的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1100"><paramref name="byteCount" /> is less than the resulting number of bytes.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1dab1-1101">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1101">A fallback occurred (for more information, see <see href="/dotnet/standard/base-types/character-encoding">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1dab1-1102">和</span><span class="sxs-lookup"><span data-stu-id="1dab1-1102">-and-</span></span>

 <span data-ttu-id="1dab1-1103"><see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1103"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="1dab1-1104">包含要编码的字符集的字符数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1104">The character array containing the set of characters to encode.</span></span></param>
        <param name="charIndex"><span data-ttu-id="1dab1-1105">第一个要编码的字符的索引。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1105">The index of the first character to encode.</span></span></param>
        <param name="charCount"><span data-ttu-id="1dab1-1106">要编码的字符的数目。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1106">The number of characters to encode.</span></span></param>
        <param name="bytes"><span data-ttu-id="1dab1-1107">要包含所产生的字节序列的字节数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1107">The byte array to contain the resulting sequence of bytes.</span></span></param>
        <param name="byteIndex"><span data-ttu-id="1dab1-1108">要开始写入所产生的字节序列的索引位置。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1108">The index at which to start writing the resulting sequence of bytes.</span></span></param>
        <summary><span data-ttu-id="1dab1-1109">在派生类中重写时，将指定字符数组中的一组字符编码为指定的字节数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1109">When overridden in a derived class, encodes a set of characters from the specified character array into the specified byte array.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1110">写入 <paramref name="bytes" /> 的实际字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1110">The actual number of bytes written into <paramref name="bytes" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1111">若要计算 <xref:System.Text.Encoding.GetBytes%2A> 存储生成的字节所需的确切数组大小，应调用 <xref:System.Text.Encoding.GetByteCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1111">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1dab1-1112">若要计算最大数组大小，请调用 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1112">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1dab1-1113"><xref:System.Text.Encoding.GetByteCount%2A> 方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法的执行速度通常更快。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1113">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1dab1-1114">如果要转换的数据仅适用于连续块（如从流中读取的数据），或者如果数据量很大以致需要分为更小块，则应使用派生类的 <xref:System.Text.Encoding.GetDecoder%2A> 方法或 <xref:System.Text.Encoding.GetEncoder%2A> 方法提供的 <xref:System.Text.Decoder> 或 <xref:System.Text.Encoder>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1114">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="1dab1-1115"><xref:System.Text.Encoding.GetByteCount%2A> 方法确定导致对一组 Unicode 字符进行编码的字节数，并且 <xref:System.Text.Encoding.GetBytes%2A> 方法执行实际编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1115">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="1dab1-1116">与处理单个输入流上的多个转换的 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 方法相比，<xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> 方法需要离散转换。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1116">The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="1dab1-1117">支持 <xref:System.Text.Encoding.GetByteCount%2A> 和 <xref:System.Text.Encoding.GetBytes%2A> 的多个版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1117">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="1dab1-1118">下面是有关使用这些方法的一些编程注意事项：</span><span class="sxs-lookup"><span data-stu-id="1dab1-1118">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1dab1-1119">您的应用程序可能需要将许多输入字符编码为代码页，并使用多个调用处理这些字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1119">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="1dab1-1120">在这种情况下，您可能需要维护两次调用之间的状态，同时考虑所使用的 <xref:System.Text.Encoder> 对象所保留的状态。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1120">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="1dab1-1121">（例如，包含代理项对的字符序列可能以高代理项结束。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1121">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="1dab1-1122"><xref:System.Text.Encoder> 将记住高代理项，以便可以在以下调用开始时将其与低代理项组合在一起。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1122">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="1dab1-1123"><xref:System.Text.Encoding> 无法维护状态，因此字符将发送到 <xref:System.Text.EncoderFallback>。）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1123"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>

-   <span data-ttu-id="1dab1-1124">如果你的应用程序处理字符串输入，则应使用 <xref:System.Text.Encoding.GetBytes%2A>的字符串版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1124">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>

-   <span data-ttu-id="1dab1-1125"><xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 的 Unicode 字符缓冲区版本允许一些快速的技巧，尤其是使用 <xref:System.Text.Encoder> 对象的多个调用或插入现有缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1125">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="1dab1-1126">但请记住，此方法版本有时不安全，因为指针是必需的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1126">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1dab1-1127">如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1127">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1dab1-1128">在这种情况下，支持字节数组的 <xref:System.Text.Encoding.GetBytes%2A> 版本是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1128">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="1dab1-1129">请考虑使用 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 方法，而不是 <xref:System.Text.Encoding.GetByteCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1129">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="1dab1-1130">转换方法可转换尽可能多的数据，如果输出缓冲区太小，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1130">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="1dab1-1131">对于流的连续编码，此方法通常是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1131">For continuous encoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="1dab1-1132">下面的示例确定对字符数组中的三个字符进行编码、对字符进行编码并显示生成的字节所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1132">The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1dab1-1133"><paramref name="chars" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1133"><paramref name="chars" /> is <see langword="null" />.</span></span>

<span data-ttu-id="1dab1-1134">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1dab1-1134">-or-</span></span>

 <span data-ttu-id="1dab1-1135"><paramref name="bytes" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1135"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1dab1-1136"><paramref name="charIndex" />、<paramref name="charCount" /> 或 <paramref name="byteIndex" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1136"><paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.</span></span>

<span data-ttu-id="1dab1-1137">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1dab1-1137">-or-</span></span>

 <span data-ttu-id="1dab1-1138"><paramref name="charIndex" /> 和 <paramref name="charCount" /> 不表示 <paramref name="chars" /> 中的有效范围。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1138"><paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.</span></span>

<span data-ttu-id="1dab1-1139">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1dab1-1139">-or-</span></span>

 <span data-ttu-id="1dab1-1140"><paramref name="byteIndex" /> 不是 <paramref name="bytes" /> 中的有效索引。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1140"><paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1dab1-1141"><paramref name="bytes" /> 中从 <paramref name="byteIndex" /> 到数组结尾没有足够的容量来容纳所产生的字节。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1141"><paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1dab1-1142">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1142">A fallback occurred (for more information, see <see href="/dotnet/standard/base-types/character-encoding">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1dab1-1143">和</span><span class="sxs-lookup"><span data-stu-id="1dab1-1143">-and-</span></span>

 <span data-ttu-id="1dab1-1144"><see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1144"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string * int * int * byte[] * int -&gt; int&#xA;override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="1dab1-1145">包含要编码的字符集的字符串。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1145">The string containing the set of characters to encode.</span></span></param>
        <param name="charIndex"><span data-ttu-id="1dab1-1146">第一个要编码的字符的索引。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1146">The index of the first character to encode.</span></span></param>
        <param name="charCount"><span data-ttu-id="1dab1-1147">要编码的字符的数目。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1147">The number of characters to encode.</span></span></param>
        <param name="bytes"><span data-ttu-id="1dab1-1148">要包含所产生的字节序列的字节数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1148">The byte array to contain the resulting sequence of bytes.</span></span></param>
        <param name="byteIndex"><span data-ttu-id="1dab1-1149">要开始写入所产生的字节序列的索引位置。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1149">The index at which to start writing the resulting sequence of bytes.</span></span></param>
        <summary><span data-ttu-id="1dab1-1150">在派生类中重写时，将指定字符串中的一组字符编码为指定的字节数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1150">When overridden in a derived class, encodes a set of characters from the specified string into the specified byte array.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1151">写入 <paramref name="bytes" /> 的实际字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1151">The actual number of bytes written into <paramref name="bytes" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1152">若要计算 <xref:System.Text.Encoding.GetBytes%2A> 存储生成的字节所需的确切数组大小，应调用 <xref:System.Text.Encoding.GetByteCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1152">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1dab1-1153">若要计算最大数组大小，请调用 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1153">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1dab1-1154"><xref:System.Text.Encoding.GetByteCount%2A> 方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法的执行速度通常更快。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1154">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1dab1-1155">如果要转换的数据仅适用于连续块（如从流中读取的数据），或者如果数据量很大以致需要分为更小块，则应使用派生类的 <xref:System.Text.Encoding.GetDecoder%2A> 方法或 <xref:System.Text.Encoding.GetEncoder%2A> 方法提供的 <xref:System.Text.Decoder> 或 <xref:System.Text.Encoder>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1155">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="1dab1-1156"><xref:System.Text.Encoding.GetByteCount%2A> 方法确定导致对一组 Unicode 字符进行编码的字节数，并且 <xref:System.Text.Encoding.GetBytes%2A> 方法执行实际编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1156">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="1dab1-1157">与处理单个输入流上的多个转换的 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 方法相比，<xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> 方法需要离散转换。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1157">The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="1dab1-1158">支持 <xref:System.Text.Encoding.GetByteCount%2A> 和 <xref:System.Text.Encoding.GetBytes%2A> 的多个版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1158">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="1dab1-1159">下面是有关使用这些方法的一些编程注意事项：</span><span class="sxs-lookup"><span data-stu-id="1dab1-1159">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1dab1-1160">您的应用程序可能需要将许多输入字符编码为代码页，并使用多个调用处理这些字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1160">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="1dab1-1161">在这种情况下，您可能需要维护两次调用之间的状态，同时考虑所使用的 <xref:System.Text.Encoder> 对象所保留的状态。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1161">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="1dab1-1162">（例如，包含代理项对的字符序列可能以高代理项结束。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1162">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="1dab1-1163"><xref:System.Text.Encoder> 将记住高代理项，以便可以在以下调用开始时将其与低代理项组合在一起。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1163">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="1dab1-1164"><xref:System.Text.Encoding> 无法维护状态，因此字符将发送到 <xref:System.Text.EncoderFallback>。）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1164"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>

-   <span data-ttu-id="1dab1-1165">如果你的应用程序处理字符串输入，则应使用 <xref:System.Text.Encoding.GetBytes%2A>的字符串版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1165">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>

-   <span data-ttu-id="1dab1-1166"><xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 的 Unicode 字符缓冲区版本允许一些快速的技巧，尤其是使用 <xref:System.Text.Encoder> 对象的多个调用或插入现有缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1166">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="1dab1-1167">但请记住，此方法版本有时不安全，因为指针是必需的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1167">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1dab1-1168">如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1168">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1dab1-1169">在这种情况下，支持字节数组的 <xref:System.Text.Encoding.GetBytes%2A> 版本是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1169">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="1dab1-1170">请考虑使用 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 方法，而不是 <xref:System.Text.Encoding.GetByteCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1170">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="1dab1-1171">转换方法可转换尽可能多的数据，如果输出缓冲区太小，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1171">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="1dab1-1172">对于流的连续编码，此方法通常是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1172">For continuous encoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="1dab1-1173">下面的示例确定了对字符串中的字符串或范围进行编码、对字符进行编码并显示生成的字节所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1173">The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1dab1-1174"><paramref name="s" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1174"><paramref name="s" /> is <see langword="null" />.</span></span>

<span data-ttu-id="1dab1-1175">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1dab1-1175">-or-</span></span>

 <span data-ttu-id="1dab1-1176"><paramref name="bytes" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1176"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1dab1-1177"><paramref name="charIndex" />、<paramref name="charCount" /> 或 <paramref name="byteIndex" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1177"><paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.</span></span>

<span data-ttu-id="1dab1-1178">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1dab1-1178">-or-</span></span>

 <span data-ttu-id="1dab1-1179"><paramref name="charIndex" /> 和 <paramref name="charCount" /> 不表示 <paramref name="chars" /> 中的有效范围。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1179"><paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.</span></span>

<span data-ttu-id="1dab1-1180">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1dab1-1180">-or-</span></span>

 <span data-ttu-id="1dab1-1181"><paramref name="byteIndex" /> 不是 <paramref name="bytes" /> 中的有效索引。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1181"><paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1dab1-1182"><paramref name="bytes" /> 中从 <paramref name="byteIndex" /> 到数组结尾没有足够的容量来容纳所产生的字节。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1182"><paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1dab1-1183">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1183">A fallback occurred (for more information, see <see href="/dotnet/standard/base-types/character-encoding">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1dab1-1184">和</span><span class="sxs-lookup"><span data-stu-id="1dab1-1184">-and-</span></span>

 <span data-ttu-id="1dab1-1185"><see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1185"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1dab1-1186">在派生类中重写时，计算对字节序列进行解码所产生的字符数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1186">When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] -&gt; int&#xA;override this.GetCharCount : byte[] -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1dab1-1187">包含要解码的字节序列的字节数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1187">The byte array containing the sequence of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="1dab1-1188">在派生类中重写时，计算对指定字节数组中的所有字节进行解码所产生的字符数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1188">When overridden in a derived class, calculates the number of characters produced by decoding all the bytes in the specified byte array.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1189">对指定字节序列进行解码所产生的字符数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1189">The number of characters produced by decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1190">若要计算 <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> 存储所生成的字符所需的确切数组大小，应使用 <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1190">To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method.</span></span> <span data-ttu-id="1dab1-1191">若要计算最大数组大小，应使用 <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1191">To calculate the maximum array size, you should use the <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> method.</span></span> <span data-ttu-id="1dab1-1192"><xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> 方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxCharCount%2A> 方法的执行速度通常更快。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1192">The <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1dab1-1193"><xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> 方法确定多少个字符会导致对一个字节序列进行解码，而 <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> 方法执行实际解码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1193">The <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method determines how many characters result in decoding a sequence of bytes, and the  <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> method performs the actual decoding.</span></span> <span data-ttu-id="1dab1-1194">与处理单个输入流上的多个传递的 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 方法相比，<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 方法需要离散转换。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1194">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>

 <span data-ttu-id="1dab1-1195">支持 <xref:System.Text.Encoding.GetCharCount%2A> 和 <xref:System.Text.Encoding.GetChars%2A> 的多个版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1195">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="1dab1-1196">下面是有关使用这些方法的一些编程注意事项：</span><span class="sxs-lookup"><span data-stu-id="1dab1-1196">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1dab1-1197">您的应用程序可能需要从代码页解码多个输入字节，并使用多个调用处理这些字节。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1197">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="1dab1-1198">在这种情况下，可能需要在调用之间维护状态。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1198">In this case, you probably need to maintain state between calls.</span></span>

-   <span data-ttu-id="1dab1-1199">如果你的应用程序处理字符串输出，则应使用 <xref:System.Text.Encoding.GetString%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1199">If your app handles string outputs, you should use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="1dab1-1200">由于此方法必须检查字符串长度并分配一个缓冲区，因此速度稍慢，但生成的 <xref:System.String> 类型是首选的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1200">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>

-   <span data-ttu-id="1dab1-1201"><xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 的字节版本允许一些快速的技巧，尤其是对大缓冲区进行多次调用。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1201">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="1dab1-1202">但请记住，此方法版本有时不安全，因为指针是必需的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1202">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1dab1-1203">如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1203">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1dab1-1204">在这种情况下，支持输出字符缓冲区的 [\]，Int32，Int32，Char\<x： GetChars% 28System.object% 2csystem.string% 2csystem.string% 2csystem.string%% > 版本是最佳选择，这是最合适的选择方式。）。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1204">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>

-   <span data-ttu-id="1dab1-1205">请考虑使用 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 方法，而不是 <xref:System.Text.Encoding.GetCharCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1205">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="1dab1-1206">转换方法尽可能多地转换数据，如果输出缓冲区太小，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1206">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="1dab1-1207">对于流的连续解码，此方法通常是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1207">For continuous decoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="1dab1-1208">下面的示例将字符串编码为一个字节数组，然后将这些字节解码为一个字符数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1208">The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.</span></span>

 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1dab1-1209"><paramref name="bytes" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1209"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1dab1-1210">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1210">A fallback occurred (for more information, see <see href="/dotnet/standard/base-types/character-encoding">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1dab1-1211">和</span><span class="sxs-lookup"><span data-stu-id="1dab1-1211">-and-</span></span>

 <span data-ttu-id="1dab1-1212"><see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1212"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int&#xA;override this.GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1dab1-1213">要解码的只读字节范围。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1213">A read-only byte span to decode.</span></span></param>
        <summary><span data-ttu-id="1dab1-1214">在派生类中重写时，计算对提供的只读字节范围进行解码所产生的字符数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1214">When overridden in a derived class, calculates the number of characters produced by decoding the provided read-only byte span.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1215">对字节范围进行解码所产生的字符数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1215">The number of characters produced by decoding the byte span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1216">若要计算 <xref:System.Text.Encoding.GetChars%2A> 存储所生成的字符所需的确切数组大小，应使用 <xref:System.Text.Encoding.GetCharCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1216">To calculate the exact array size that <xref:System.Text.Encoding.GetChars%2A> requires to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="1dab1-1217">若要计算最大数组大小，请使用 <xref:System.Text.Encoding.GetMaxCharCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1217">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="1dab1-1218"><xref:System.Text.Encoding.GetCharCount%2A> 方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxCharCount%2A> 方法的执行速度通常更快。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1218">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1dab1-1219"><xref:System.Text.Encoding.GetCharCount%2A> 方法确定多少个字符会导致对一个字节序列进行解码，而 <xref:System.Text.Encoding.GetChars%2A> 方法执行实际解码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1219">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="1dab1-1220">与处理单个输入流上的多个传递的 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 方法相比，<xref:System.Text.Encoding.GetChars%2A> 方法需要离散转换。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1220">The <xref:System.Text.Encoding.GetChars%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>

 <span data-ttu-id="1dab1-1221">支持 <xref:System.Text.Encoding.GetCharCount%2A> 和 <xref:System.Text.Encoding.GetChars%2A> 的多个版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1221">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="1dab1-1222">下面是有关使用这些方法的一些编程注意事项：</span><span class="sxs-lookup"><span data-stu-id="1dab1-1222">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1dab1-1223">您的应用程序可能需要从代码页解码多个输入字节，并使用多个调用处理这些字节。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1223">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="1dab1-1224">在这种情况下，可能需要在调用之间维护状态。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1224">In this case, you probably need to maintain state between calls.</span></span>

-   <span data-ttu-id="1dab1-1225">如果你的应用程序处理字符串输出，则建议使用 <xref:System.Text.Encoding.GetString%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1225">If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="1dab1-1226">由于此方法必须检查字符串长度并分配一个缓冲区，因此速度稍慢，但生成的 <xref:System.String> 类型是首选的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1226">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>

-   <span data-ttu-id="1dab1-1227">如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1227">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1dab1-1228">在这种情况下，支持输出字符缓冲区的 [\]，Int32，Int32，Char\<x： GetChars% 28System.object% 2csystem.string% 2csystem.string% 2csystem.string%% > 版本是最佳选择，这是最合适的选择方式。）。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1228">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>

-   <span data-ttu-id="1dab1-1229">请考虑使用 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 方法，而不是 <xref:System.Text.Encoding.GetCharCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1229">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="1dab1-1230">转换方法尽可能多地转换数据，如果输出缓冲区太小，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1230">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="1dab1-1231">对于流的连续解码，此方法通常是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1231">For continuous decoding of a stream, this method is often the best choice.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1dab1-1232">指向第一个要解码的字节的指针。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1232">A pointer to the first byte to decode.</span></span></param>
        <param name="count"><span data-ttu-id="1dab1-1233">要解码的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1233">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="1dab1-1234">在派生类中重写时，计算对字节序列（从指定的字节指针开始）进行解码所产生的字符数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1234">When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1235">对指定字节序列进行解码所产生的字符数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1235">The number of characters produced by decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1236">若要计算 <xref:System.Text.Encoding.GetChars%2A> 存储所生成的字符所需的确切数组大小，应使用 <xref:System.Text.Encoding.GetCharCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1236">To calculate the exact array size that <xref:System.Text.Encoding.GetChars%2A> requires to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="1dab1-1237">若要计算最大数组大小，请使用 <xref:System.Text.Encoding.GetMaxCharCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1237">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="1dab1-1238"><xref:System.Text.Encoding.GetCharCount%2A> 方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxCharCount%2A> 方法的执行速度通常更快。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1238">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1dab1-1239"><xref:System.Text.Encoding.GetCharCount%2A> 方法确定多少个字符会导致对一个字节序列进行解码，而 <xref:System.Text.Encoding.GetChars%2A> 方法执行实际解码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1239">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="1dab1-1240">与处理单个输入流上的多个传递的 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 方法相比，<xref:System.Text.Encoding.GetChars%2A> 方法需要离散转换。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1240">The <xref:System.Text.Encoding.GetChars%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>

 <span data-ttu-id="1dab1-1241">支持 <xref:System.Text.Encoding.GetCharCount%2A> 和 <xref:System.Text.Encoding.GetChars%2A> 的多个版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1241">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="1dab1-1242">下面是有关使用这些方法的一些编程注意事项：</span><span class="sxs-lookup"><span data-stu-id="1dab1-1242">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1dab1-1243">您的应用程序可能需要从代码页解码多个输入字节，并使用多个调用处理这些字节。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1243">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="1dab1-1244">在这种情况下，可能需要在调用之间维护状态。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1244">In this case, you probably need to maintain state between calls.</span></span>

-   <span data-ttu-id="1dab1-1245">如果你的应用程序处理字符串输出，则建议使用 <xref:System.Text.Encoding.GetString%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1245">If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="1dab1-1246">由于此方法必须检查字符串长度并分配一个缓冲区，因此速度稍慢，但生成的 <xref:System.String> 类型是首选的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1246">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>

-   <span data-ttu-id="1dab1-1247"><xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 的字节版本允许一些快速的技巧，尤其是对大缓冲区进行多次调用。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1247">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="1dab1-1248">但请记住，此方法版本有时不安全，因为指针是必需的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1248">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1dab1-1249">如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1249">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1dab1-1250">在这种情况下，支持输出字符缓冲区的 [\]，Int32，Int32，Char\<x： GetChars% 28System.object% 2csystem.string% 2csystem.string% 2csystem.string%% > 版本是最佳选择，这是最合适的选择方式。）。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1250">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>

-   <span data-ttu-id="1dab1-1251">请考虑使用 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 方法，而不是 <xref:System.Text.Encoding.GetCharCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1251">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="1dab1-1252">转换方法尽可能多地转换数据，如果输出缓冲区太小，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1252">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="1dab1-1253">对于流的连续解码，此方法通常是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1253">For continuous decoding of a stream, this method is often the best choice.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1dab1-1254"><paramref name="bytes" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1254"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1dab1-1255"><paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1255"><paramref name="count" /> is less than zero.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1dab1-1256">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1256">A fallback occurred (for more information, see <see href="/dotnet/standard/base-types/character-encoding">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1dab1-1257">和</span><span class="sxs-lookup"><span data-stu-id="1dab1-1257">-and-</span></span>

 <span data-ttu-id="1dab1-1258"><see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1258"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int -&gt; int" Usage="encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1dab1-1259">包含要解码的字节序列的字节数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1259">The byte array containing the sequence of bytes to decode.</span></span></param>
        <param name="index"><span data-ttu-id="1dab1-1260">第一个要解码的字节的索引。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1260">The index of the first byte to decode.</span></span></param>
        <param name="count"><span data-ttu-id="1dab1-1261">要解码的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1261">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="1dab1-1262">在派生类中重写时，计算对字节序列（从指定字节数组开始）进行解码所产生的字符数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1262">When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1263">对指定字节序列进行解码所产生的字符数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1263">The number of characters produced by decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1264">若要计算 <xref:System.Text.Encoding.GetChars%2A> 存储所生成的字符所需的确切数组大小，应使用 <xref:System.Text.Encoding.GetCharCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1264">To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="1dab1-1265">若要计算最大数组大小，请使用 <xref:System.Text.Encoding.GetMaxCharCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1265">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="1dab1-1266"><xref:System.Text.Encoding.GetCharCount%2A> 方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxCharCount%2A> 方法的执行速度通常更快。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1266">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1dab1-1267"><xref:System.Text.Encoding.GetCharCount%2A> 方法确定多少个字符会导致对一个字节序列进行解码，而 <xref:System.Text.Encoding.GetChars%2A> 方法执行实际解码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1267">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="1dab1-1268">与处理单个输入流上的多个传递的 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 方法相比，<xref:System.Text.Encoding.GetChars%2A> 方法需要离散转换。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1268">The <xref:System.Text.Encoding.GetChars%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>

 <span data-ttu-id="1dab1-1269">支持 <xref:System.Text.Encoding.GetCharCount%2A> 和 <xref:System.Text.Encoding.GetChars%2A> 的多个版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1269">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="1dab1-1270">下面是有关使用这些方法的一些编程注意事项：</span><span class="sxs-lookup"><span data-stu-id="1dab1-1270">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1dab1-1271">您的应用程序可能需要从代码页解码多个输入字节，并使用多个调用处理这些字节。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1271">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="1dab1-1272">在这种情况下，可能需要在调用之间维护状态。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1272">In this case, you probably need to maintain state between calls.</span></span>

-   <span data-ttu-id="1dab1-1273">如果你的应用程序处理字符串输出，则建议使用 <xref:System.Text.Encoding.GetString%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1273">If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="1dab1-1274">由于此方法必须检查字符串长度并分配一个缓冲区，因此速度稍慢，但生成的 <xref:System.String> 类型是首选的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1274">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>

-   <span data-ttu-id="1dab1-1275"><xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 的字节版本允许一些快速的技巧，尤其是对大缓冲区进行多次调用。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1275">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="1dab1-1276">但请记住，此方法版本有时不安全，因为指针是必需的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1276">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1dab1-1277">如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1277">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1dab1-1278">在这种情况下，支持输出字符缓冲区的 [\]，Int32，Int32，Char\<x： GetChars% 28System.object% 2csystem.string% 2csystem.string% 2csystem.string%% > 版本是最佳选择，这是最合适的选择方式。）。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1278">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>

-   <span data-ttu-id="1dab1-1279">请考虑使用 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 方法，而不是 <xref:System.Text.Encoding.GetCharCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1279">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="1dab1-1280">转换方法尽可能多地转换数据，如果输出缓冲区太小，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1280">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="1dab1-1281">对于流的连续解码，此方法通常是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1281">For continuous decoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="1dab1-1282">下面的示例将字符串从一种编码转换为另一种编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1282">The following example converts a string from one encoding to another.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb" id="Snippet1":::

 <span data-ttu-id="1dab1-1283">下面的示例将字符串编码为一个字节数组，然后将一系列字节解码为字符数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1283">The following example encodes a string into an array of bytes, and then decodes a range of the bytes into an array of characters.</span></span>

 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1dab1-1284"><paramref name="bytes" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1284"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1dab1-1285"><paramref name="index" /> 或 <paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1285"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span>

<span data-ttu-id="1dab1-1286">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1dab1-1286">-or-</span></span>

 <span data-ttu-id="1dab1-1287"><paramref name="index" /> 和 <paramref name="count" /> 不表示 <paramref name="bytes" /> 中的有效范围。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1287"><paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1dab1-1288">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1288">A fallback occurred (for more information, see <see href="/dotnet/standard/base-types/character-encoding">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1dab1-1289">和</span><span class="sxs-lookup"><span data-stu-id="1dab1-1289">-and-</span></span>

 <span data-ttu-id="1dab1-1290"><see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1290"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1dab1-1291">在派生类中重写时，将一个字节序列解码为一组字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1291">When overridden in a derived class, decodes a sequence of bytes into a set of characters.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte()) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] -&gt; char[]&#xA;override this.GetChars : byte[] -&gt; char[]" Usage="encoding.GetChars bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1dab1-1292">包含要解码的字节序列的字节数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1292">The byte array containing the sequence of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="1dab1-1293">在派生类中重写时，将指定字节数组中的所有字节解码为一组字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1293">When overridden in a derived class, decodes all the bytes in the specified byte array into a set of characters.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1294">一个字节数组，包含对指定的字节序列进行解码的结果。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1294">A character array containing the results of decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1295"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 从输入字节序列中获取字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1295"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> gets characters from an input byte sequence.</span></span> <span data-ttu-id="1dab1-1296"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 与 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 不同，因为 <xref:System.Text.Encoding> 需要离散转换，而 <xref:System.Text.Decoder> 是为单个输入流上的多个传递设计的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1296"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.</span></span>

 <span data-ttu-id="1dab1-1297">如果要转换的数据仅适用于连续块（如从流中读取的数据），或者如果数据量很大以致需要分为更小块，则应使用派生类的 <xref:System.Text.Encoding.GetDecoder%2A> 方法或 <xref:System.Text.Encoding.GetEncoder%2A> 方法提供的 <xref:System.Text.Decoder> 或 <xref:System.Text.Encoder>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1297">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="1dab1-1298">**注意**此方法用于对 Unicode 字符进行操作，而不是针对任意二进制数据（如字节数组）。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1298">**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</span></span> <span data-ttu-id="1dab1-1299">如果需要将任意二进制数据编码为文本，则应使用诸如 uuencode 这样的协议，该协议由 <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>等方法实现。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1299">If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="1dab1-1300"><xref:System.Text.Encoding.GetCharCount%2A> 方法确定多少个字符会导致对一个字节序列进行解码，而 <xref:System.Text.Encoding.GetChars%2A> 方法执行实际解码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1300">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="1dab1-1301">与处理单个输入流上的多个传递的 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 方法相比，<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 方法需要离散转换。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1301">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>

 <span data-ttu-id="1dab1-1302">支持 <xref:System.Text.Encoding.GetCharCount%2A> 和 <xref:System.Text.Encoding.GetChars%2A> 的多个版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1302">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="1dab1-1303">下面是有关使用这些方法的一些编程注意事项：</span><span class="sxs-lookup"><span data-stu-id="1dab1-1303">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1dab1-1304">您的应用程序可能需要从代码页解码多个输入字节，并使用多个调用处理这些字节。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1304">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="1dab1-1305">在这种情况下，您可能需要维护两次调用之间的状态，因为在分批处理时，字节序列可能会中断。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1305">In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</span></span> <span data-ttu-id="1dab1-1306">（例如，ISO-2022 移位序列的一部分可能结束一个 <xref:System.Text.Encoding.GetChars%2A> 调用，并在下一次 <xref:System.Text.Encoding.GetChars%2A> 调用开始时继续。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1306">(For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call.</span></span> <span data-ttu-id="1dab1-1307"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 将为这些不完整的序列调用回退，但 <xref:System.Text.Decoder> 会记住这些序列的后续调用。）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1307"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)</span></span>

-   <span data-ttu-id="1dab1-1308">如果你的应用程序处理字符串输出，则建议使用 <xref:System.Text.Encoding.GetString%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1308">If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="1dab1-1309">由于此方法必须检查字符串长度并分配一个缓冲区，因此速度稍慢，但生成的 <xref:System.String> 类型是首选的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1309">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>

-   <span data-ttu-id="1dab1-1310"><xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 的字节版本允许一些快速的技巧，尤其是对大缓冲区进行多次调用。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1310">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="1dab1-1311">但请记住，此方法版本有时不安全，因为指针是必需的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1311">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1dab1-1312">如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1312">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1dab1-1313">在这种情况下，支持输出字符缓冲区的 [\]，Int32，Int32，Char\<x： GetChars% 28System.object% 2csystem.string% 2csystem.string% 2csystem.string%% > 版本是最佳选择，这是最合适的选择方式。）。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1313">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>

-   <span data-ttu-id="1dab1-1314">请考虑使用 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 方法，而不是 <xref:System.Text.Encoding.GetCharCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1314">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="1dab1-1315">转换方法尽可能多地转换数据，如果输出缓冲区太小，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1315">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="1dab1-1316">对于流的连续解码，此方法通常是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1316">For continuous decoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="1dab1-1317">下面的示例将字符串编码为一个字节数组，然后将这些字节解码为一个字符数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1317">The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.</span></span>

 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1dab1-1318"><paramref name="bytes" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1318"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1dab1-1319">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1319">A fallback occurred (for more information, see <see href="/dotnet/standard/base-types/character-encoding">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1dab1-1320">和</span><span class="sxs-lookup"><span data-stu-id="1dab1-1320">-and-</span></span>

 <span data-ttu-id="1dab1-1321"><see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1321"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int&#xA;override this.GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int" Usage="encoding.GetChars (bytes, chars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1dab1-1322">包含要解码的字节序列的只读范围。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1322">A read-only span containing the sequence of bytes to decode.</span></span></param>
        <param name="chars"><span data-ttu-id="1dab1-1323">接收已解码字节的字符范围。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1323">The character span receiving the decoded bytes.</span></span></param>
        <summary><span data-ttu-id="1dab1-1324">在派生类中重写时，将指定只读字节范围中的所有字节解码为字符范围。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1324">When overridden in a derived class, decodes all the bytes in the specified read-only byte span into a character span.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1325">已解码的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1325">The number of decoded bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1326"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 从输入字节跨度中获取字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1326"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> gets characters from an input byte span.</span></span> <span data-ttu-id="1dab1-1327"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 与 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 不同，因为 <xref:System.Text.Encoding> 需要离散转换，而 <xref:System.Text.Decoder> 是为单个输入流上的多个传递设计的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1327"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.</span></span>

 <span data-ttu-id="1dab1-1328">如果要转换的数据仅适用于连续块（如从流中读取的数据），或者如果数据量很大以致需要分为更小块，则应使用派生类的 <xref:System.Text.Encoding.GetDecoder%2A> 方法或 <xref:System.Text.Encoding.GetEncoder%2A> 方法提供的 <xref:System.Text.Decoder> 或 <xref:System.Text.Encoder>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1328">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="1dab1-1329"><xref:System.Text.Encoding.GetCharCount%2A> 方法确定多少个字符会导致对一个字节序列进行解码，而 <xref:System.Text.Encoding.GetChars%2A> 方法执行实际解码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1329">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="1dab1-1330">与处理单个输入流上的多个传递的 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 方法相比，<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 方法需要离散转换。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1330">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>

 <span data-ttu-id="1dab1-1331">支持 <xref:System.Text.Encoding.GetCharCount%2A> 和 <xref:System.Text.Encoding.GetChars%2A> 的多个版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1331">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="1dab1-1332">下面是有关使用这些方法的一些编程注意事项：</span><span class="sxs-lookup"><span data-stu-id="1dab1-1332">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1dab1-1333">您的应用程序可能需要从代码页解码多个输入字节，并使用多个调用处理这些字节。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1333">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="1dab1-1334">在这种情况下，您可能需要维护两次调用之间的状态，因为在分批处理时，字节序列可能会中断。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1334">In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</span></span> <span data-ttu-id="1dab1-1335">（例如，ISO-2022 移位序列的一部分可能结束一个 <xref:System.Text.Encoding.GetChars%2A> 调用，并在下一次 <xref:System.Text.Encoding.GetChars%2A> 调用开始时继续。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1335">(For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call.</span></span> <span data-ttu-id="1dab1-1336"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 将为这些不完整的序列调用回退，但 <xref:System.Text.Decoder> 会记住这些序列的后续调用。）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1336"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)</span></span>

-   <span data-ttu-id="1dab1-1337">如果你的应用程序处理字符串输出，则建议使用 <xref:System.Text.Encoding.GetString%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1337">If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="1dab1-1338">由于此方法必须检查字符串长度并分配一个缓冲区，因此速度稍慢，但生成的 <xref:System.String> 类型是首选的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1338">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>

-   <span data-ttu-id="1dab1-1339"><xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 的字节版本允许一些快速的技巧，尤其是对大缓冲区进行多次调用。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1339">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="1dab1-1340">但请记住，此方法版本有时不安全，因为指针是必需的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1340">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1dab1-1341">如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1341">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1dab1-1342">在这种情况下，支持输出字符缓冲区的 [\]，Int32，Int32，Char\<x： GetChars% 28System.object% 2csystem.string% 2csystem.string% 2csystem.string%% > 版本是最佳选择，这是最合适的选择方式。）。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1342">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>

-   <span data-ttu-id="1dab1-1343">请考虑使用 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 方法，而不是 <xref:System.Text.Encoding.GetCharCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1343">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="1dab1-1344">转换方法尽可能多地转换数据，如果输出缓冲区太小，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1344">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="1dab1-1345">对于流的连续解码，此方法通常是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1345">For continuous decoding of a stream, this method is often the best choice.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), index As Integer, count As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int -&gt; char[]&#xA;override this.GetChars : byte[] * int * int -&gt; char[]" Usage="encoding.GetChars (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1dab1-1346">包含要解码的字节序列的字节数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1346">The byte array containing the sequence of bytes to decode.</span></span></param>
        <param name="index"><span data-ttu-id="1dab1-1347">第一个要解码的字节的索引。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1347">The index of the first byte to decode.</span></span></param>
        <param name="count"><span data-ttu-id="1dab1-1348">要解码的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1348">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="1dab1-1349">在派生类中重写时，将指定字节数组中的一个字节序列解码为一组字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1349">When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a set of characters.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1350">一个字节数组，包含对指定的字节序列进行解码的结果。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1350">A character array containing the results of decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1351"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 从输入字节序列中获取字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1351"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> gets characters from an input byte sequence.</span></span> <span data-ttu-id="1dab1-1352"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 与 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 不同，因为 <xref:System.Text.Encoding> 需要离散转换，而 <xref:System.Text.Decoder> 是为单个输入流上的多个传递设计的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1352"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.</span></span>

 <span data-ttu-id="1dab1-1353">如果要转换的数据仅适用于连续块（如从流中读取的数据），或者如果数据量很大以致需要分为更小块，则应使用派生类的 <xref:System.Text.Encoding.GetDecoder%2A> 方法或 <xref:System.Text.Encoding.GetEncoder%2A> 方法提供的 <xref:System.Text.Decoder> 或 <xref:System.Text.Encoder>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1353">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="1dab1-1354">**注意**此方法用于对 Unicode 字符进行操作，而不是针对任意二进制数据（如字节数组）。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1354">**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</span></span> <span data-ttu-id="1dab1-1355">如果需要将任意二进制数据编码为文本，则应使用诸如 uuencode 这样的协议，该协议由 <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>等方法实现。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1355">If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="1dab1-1356"><xref:System.Text.Encoding.GetCharCount%2A> 方法确定多少个字符会导致对一个字节序列进行解码，而 <xref:System.Text.Encoding.GetChars%2A> 方法执行实际解码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1356">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="1dab1-1357">与处理单个输入流上的多个传递的 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 方法相比，<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 方法需要离散转换。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1357">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>

 <span data-ttu-id="1dab1-1358">支持 <xref:System.Text.Encoding.GetCharCount%2A> 和 <xref:System.Text.Encoding.GetChars%2A> 的多个版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1358">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="1dab1-1359">下面是有关使用这些方法的一些编程注意事项：</span><span class="sxs-lookup"><span data-stu-id="1dab1-1359">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1dab1-1360">您的应用程序可能需要从代码页解码多个输入字节，并使用多个调用处理这些字节。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1360">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="1dab1-1361">在这种情况下，您可能需要维护两次调用之间的状态，因为在分批处理时，字节序列可能会中断。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1361">In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</span></span> <span data-ttu-id="1dab1-1362">（例如，ISO-2022 移位序列的一部分可能结束一个 <xref:System.Text.Encoding.GetChars%2A> 调用，并在下一次 <xref:System.Text.Encoding.GetChars%2A> 调用开始时继续。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1362">(For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call.</span></span> <span data-ttu-id="1dab1-1363"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 将为这些不完整的序列调用回退，但 <xref:System.Text.Decoder> 会记住这些序列的后续调用。）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1363"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)</span></span>

-   <span data-ttu-id="1dab1-1364">如果你的应用程序处理字符串输出，则建议使用 <xref:System.Text.Encoding.GetString%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1364">If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="1dab1-1365">由于此方法必须检查字符串长度并分配一个缓冲区，因此速度稍慢，但生成的 <xref:System.String> 类型是首选的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1365">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>

-   <span data-ttu-id="1dab1-1366"><xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 的字节版本允许一些快速的技巧，尤其是对大缓冲区进行多次调用。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1366">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="1dab1-1367">但请记住，此方法版本有时不安全，因为指针是必需的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1367">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1dab1-1368">如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1368">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1dab1-1369">在这种情况下，支持输出字符缓冲区的 [\]，Int32，Int32，Char\<x： GetChars% 28System.object% 2csystem.string% 2csystem.string% 2csystem.string%% > 版本是最佳选择，这是最合适的选择方式。）。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1369">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>

-   <span data-ttu-id="1dab1-1370">请考虑使用 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 方法，而不是 <xref:System.Text.Encoding.GetCharCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1370">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="1dab1-1371">转换方法尽可能多地转换数据，如果输出缓冲区太小，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1371">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="1dab1-1372">对于流的连续解码，此方法通常是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1372">For continuous decoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="1dab1-1373">下面的示例将字符串编码为一个字节数组，然后将一系列字节解码为字符数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1373">The following example encodes a string into an array of bytes, and then decodes a range of the bytes into an array of characters.</span></span>

 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1dab1-1374"><paramref name="bytes" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1374"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1dab1-1375"><paramref name="index" /> 或 <paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1375"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span>

<span data-ttu-id="1dab1-1376">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1dab1-1376">-or-</span></span>

 <span data-ttu-id="1dab1-1377"><paramref name="index" /> 和 <paramref name="count" /> 不表示 <paramref name="bytes" /> 中的有效范围。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1377"><paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1dab1-1378">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1378">A fallback occurred (for more information, see <see href="/dotnet/standard/base-types/character-encoding">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1dab1-1379">和</span><span class="sxs-lookup"><span data-stu-id="1dab1-1379">-and-</span></span>

 <span data-ttu-id="1dab1-1380"><see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1380"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="chars" Type="System.Char*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1dab1-1381">指向第一个要解码的字节的指针。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1381">A pointer to the first byte to decode.</span></span></param>
        <param name="byteCount"><span data-ttu-id="1dab1-1382">要解码的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1382">The number of bytes to decode.</span></span></param>
        <param name="chars"><span data-ttu-id="1dab1-1383">一个指针，指向开始写入所产生的字符集的位置。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1383">A pointer to the location at which to start writing the resulting set of characters.</span></span></param>
        <param name="charCount"><span data-ttu-id="1dab1-1384">要写入的最大字符数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1384">The maximum number of characters to write.</span></span></param>
        <summary><span data-ttu-id="1dab1-1385">在派生类中重写时，将一个字节序列（从指定的字节指针开始）解码为一组字符，并从指定的字符指针开始存储该组字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1385">When overridden in a derived class, decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1386">在由 <paramref name="chars" /> 参数指示的位置处写入的实际字符数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1386">The actual number of characters written at the location indicated by the <paramref name="chars" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1387">若要计算 <xref:System.Text.Encoding.GetChars%2A> 存储所生成的字符所需的确切数组大小，应使用 <xref:System.Text.Encoding.GetCharCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1387">To calculate the exact array size that <xref:System.Text.Encoding.GetChars%2A> requires to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="1dab1-1388">若要计算最大数组大小，请使用 <xref:System.Text.Encoding.GetMaxCharCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1388">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="1dab1-1389"><xref:System.Text.Encoding.GetCharCount%2A> 方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxCharCount%2A> 方法的执行速度通常更快。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1389">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1dab1-1390"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 从输入字节序列中获取字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1390"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> gets characters from an input byte sequence.</span></span> <span data-ttu-id="1dab1-1391"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 与 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 不同，因为 <xref:System.Text.Encoding> 需要离散转换，而 <xref:System.Text.Decoder> 是为单个输入流上的多个传递设计的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1391"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.</span></span>

 <span data-ttu-id="1dab1-1392">如果要转换的数据仅在 （如从流中读取的数据） 的顺序块中可用，或者如果数据量很大，它需要划分为较小的块，则应使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>提供对象<xref:System.Text.Encoding.GetDecoder%2A>或<xref:System.Text.Encoding.GetEncoder%2A>方法，分别的派生类。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1392">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.Encoding.GetDecoder%2A> or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="1dab1-1393">**注意**此方法用于对 Unicode 字符进行操作，而不是针对任意二进制数据（如字节数组）。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1393">**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</span></span> <span data-ttu-id="1dab1-1394">如果需要将任意二进制数据编码为文本，则应使用诸如 uuencode 这样的协议，该协议由 <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>等方法实现。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1394">If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="1dab1-1395"><xref:System.Text.Encoding.GetCharCount%2A> 方法确定多少个字符会导致对一个字节序列进行解码，而 <xref:System.Text.Encoding.GetChars%2A> 方法执行实际解码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1395">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="1dab1-1396">与处理单个输入流上的多个传递的 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 方法相比，<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 方法需要离散转换。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1396">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>

 <span data-ttu-id="1dab1-1397">支持 <xref:System.Text.Encoding.GetCharCount%2A> 和 <xref:System.Text.Encoding.GetChars%2A> 的多个版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1397">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="1dab1-1398">下面是有关使用这些方法的一些编程注意事项：</span><span class="sxs-lookup"><span data-stu-id="1dab1-1398">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1dab1-1399">您的应用程序可能需要从代码页解码多个输入字节，并使用多个调用处理这些字节。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1399">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="1dab1-1400">在这种情况下，您可能需要维护两次调用之间的状态，因为在分批处理时，字节序列可能会中断。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1400">In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</span></span> <span data-ttu-id="1dab1-1401">（例如，ISO-2022 移位序列的一部分可能结束一个 <xref:System.Text.Encoding.GetChars%2A> 调用，并在下一次 <xref:System.Text.Encoding.GetChars%2A> 调用开始时继续。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1401">(For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call.</span></span> <span data-ttu-id="1dab1-1402"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 将为这些不完整的序列调用回退，但 <xref:System.Text.Decoder> 会记住这些序列的后续调用。）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1402"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)</span></span>

-   <span data-ttu-id="1dab1-1403">如果你的应用程序处理字符串输出，则建议使用 <xref:System.Text.Encoding.GetString%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1403">If your app handles string outputs, the <xref:System.Text.Encoding.GetString%2A> method is recommended.</span></span> <span data-ttu-id="1dab1-1404">由于此方法必须检查字符串长度并分配一个缓冲区，因此速度稍慢，但生成的 <xref:System.String> 类型是首选的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1404">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>

-   <span data-ttu-id="1dab1-1405"><xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 的字节版本允许一些快速的技巧，尤其是对大缓冲区进行多次调用。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1405">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="1dab1-1406">但请记住，此方法版本有时不安全，因为指针是必需的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1406">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1dab1-1407">如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1407">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1dab1-1408">在这种情况下，支持输出字符缓冲区的 [\]，Int32，Int32，Char\<x： GetChars% 28System.object% 2csystem.string% 2csystem.string% 2csystem.string%% > 版本是最佳选择，这是最合适的选择方式。）。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1408">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>

-   <span data-ttu-id="1dab1-1409">请考虑使用 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 方法，而不是 <xref:System.Text.Encoding.GetCharCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1409">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="1dab1-1410">转换方法尽可能多地转换数据，如果输出缓冲区太小，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1410">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="1dab1-1411">对于流的连续解码，此方法通常是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1411">For continuous decoding of a stream, this method is often the best choice.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1dab1-1412"><paramref name="bytes" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1412"><paramref name="bytes" /> is <see langword="null" />.</span></span>

<span data-ttu-id="1dab1-1413">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1dab1-1413">-or-</span></span>

 <span data-ttu-id="1dab1-1414"><paramref name="chars" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1414"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1dab1-1415"><paramref name="byteCount" /> 或 <paramref name="charCount" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1415"><paramref name="byteCount" /> or <paramref name="charCount" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1dab1-1416"><paramref name="charCount" /> 少于所产生的字符数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1416"><paramref name="charCount" /> is less than the resulting number of characters.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1dab1-1417">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1417">A fallback occurred (for more information, see <see href="/dotnet/standard/base-types/character-encoding">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1dab1-1418">和</span><span class="sxs-lookup"><span data-stu-id="1dab1-1418">-and-</span></span>

 <span data-ttu-id="1dab1-1419"><see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1419"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1dab1-1420">包含要解码的字节序列的字节数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1420">The byte array containing the sequence of bytes to decode.</span></span></param>
        <param name="byteIndex"><span data-ttu-id="1dab1-1421">第一个要解码的字节的索引。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1421">The index of the first byte to decode.</span></span></param>
        <param name="byteCount"><span data-ttu-id="1dab1-1422">要解码的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1422">The number of bytes to decode.</span></span></param>
        <param name="chars"><span data-ttu-id="1dab1-1423">要用于包含所产生的字符集的字符数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1423">The character array to contain the resulting set of characters.</span></span></param>
        <param name="charIndex"><span data-ttu-id="1dab1-1424">开始写入所产生的字符集的索引位置。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1424">The index at which to start writing the resulting set of characters.</span></span></param>
        <summary><span data-ttu-id="1dab1-1425">在派生类中重写时，将指定字节数组中的字节序列解码为指定的字符数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1425">When overridden in a derived class, decodes a sequence of bytes from the specified byte array into the specified character array.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1426">写入 <paramref name="chars" /> 的实际字符数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1426">The actual number of characters written into <paramref name="chars" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1427">若要计算 <xref:System.Text.Encoding.GetChars%2A> 存储所生成的字符所需的确切数组大小，应使用 <xref:System.Text.Encoding.GetCharCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1427">To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="1dab1-1428">若要计算最大数组大小，请使用 <xref:System.Text.Encoding.GetMaxCharCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1428">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="1dab1-1429"><xref:System.Text.Encoding.GetCharCount%2A> 方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxCharCount%2A> 方法的执行速度通常更快。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1429">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1dab1-1430">[\]，Int32，Int32，Char\<x： GetChars% 2A？ displayProperty = Namewithtype> > 从输入字节序列中获取字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1430">[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> gets characters from an input byte sequence.</span></span> <span data-ttu-id="1dab1-1431">[\]，Int32，Int32，Char\<x： GetChars% 2A？ displayProperty = Namewithtype> > 不同于 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>，因为 <xref:System.Text.Encoding> 需要离散转换，而 <xref:System.Text.Decoder> 是为单个输入流上的多个传递设计的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1431">[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.</span></span>

 <span data-ttu-id="1dab1-1432">如果要转换的数据仅适用于连续块（如从流中读取的数据），或者如果数据量很大以致需要分为更小块，则应使用派生类的 <xref:System.Text.Encoding.GetDecoder%2A> 方法或 <xref:System.Text.Encoding.GetEncoder%2A> 方法提供的 <xref:System.Text.Decoder> 或 <xref:System.Text.Encoder>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1432">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="1dab1-1433">**注意**此方法用于对 Unicode 字符进行操作，而不是针对任意二进制数据（如字节数组）。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1433">**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</span></span> <span data-ttu-id="1dab1-1434">如果需要将任意二进制数据编码为文本，则应使用诸如 uuencode 这样的协议，该协议由 <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>等方法实现。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1434">If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="1dab1-1435"><xref:System.Text.Encoding.GetCharCount%2A> 方法确定多少个字符会导致对一个字节序列进行解码，而 <xref:System.Text.Encoding.GetChars%2A> 方法执行实际解码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1435">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="1dab1-1436">与处理单个输入流上的多个传递的 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 方法相比，<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 方法需要离散转换。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1436">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>

 <span data-ttu-id="1dab1-1437">支持 <xref:System.Text.Encoding.GetCharCount%2A> 和 <xref:System.Text.Encoding.GetChars%2A> 的多个版本。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1437">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="1dab1-1438">下面是有关使用这些方法的一些编程注意事项：</span><span class="sxs-lookup"><span data-stu-id="1dab1-1438">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1dab1-1439">您的应用程序可能需要从代码页解码多个输入字节，并使用多个调用处理这些字节。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1439">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="1dab1-1440">在这种情况下，您可能需要维护两次调用之间的状态，因为在分批处理时，字节序列可能会中断。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1440">In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</span></span> <span data-ttu-id="1dab1-1441">（例如，ISO-2022 移位序列的一部分可能会终止一个 [\]，Int32，Int32，Char\<x： GetChars% 2A > 调用，并在下一个 [\]，Int32，Int32，Char\<x： GetChars% 2A > 调用的开头继续。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1441">(For example, part of an ISO-2022 shift sequence may end one [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A> call.</span></span> <span data-ttu-id="1dab1-1442">[\]，Int32，Int32，Char\<x： GetChars% 2A？ displayProperty = Namewithtype> > 将为这些不完整的序列调用回退，但 <xref:System.Text.Decoder> 会记住这些用于下一个调用的序列。）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1442">[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)</span></span>

-   <span data-ttu-id="1dab1-1443">如果你的应用程序处理字符串输出，则建议使用 <xref:System.Text.Encoding.GetString%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1443">If your app handles string outputs, the <xref:System.Text.Encoding.GetString%2A> method is recommended.</span></span> <span data-ttu-id="1dab1-1444">由于此方法必须检查字符串长度并分配一个缓冲区，因此速度稍慢，但生成的 <xref:System.String> 类型是首选的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1444">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>

-   <span data-ttu-id="1dab1-1445"><xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 的字节版本允许一些快速的技巧，尤其是对大缓冲区进行多次调用。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1445">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="1dab1-1446">但请记住，此方法版本有时不安全，因为指针是必需的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1446">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1dab1-1447">如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1447">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1dab1-1448">在这种情况下，支持输出字符缓冲区的 [\]，Int32，Int32，Char\<x： GetChars% 28System.object% 2csystem.string% 2csystem.string% 2csystem.string%% > 版本是最佳选择，这是最合适的选择方式。）。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1448">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>

-   <span data-ttu-id="1dab1-1449">请考虑使用 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 方法，而不是 <xref:System.Text.Encoding.GetCharCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1449">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="1dab1-1450">转换方法尽可能多地转换数据，如果输出缓冲区太小，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1450">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="1dab1-1451">对于流的连续解码，此方法通常是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1451">For continuous decoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="1dab1-1452">下面的示例将字符串从一种编码转换为另一种编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1452">The following example converts a string from one encoding to another.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb" id="Snippet1":::

 <span data-ttu-id="1dab1-1453">下面的示例将字符串编码为一个字节数组，然后将一系列字节解码为字符数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1453">The following example encodes a string into an array of bytes, and then decodes a range of the bytes into an array of characters.</span></span>

 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1dab1-1454"><paramref name="bytes" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1454"><paramref name="bytes" /> is <see langword="null" />.</span></span>

<span data-ttu-id="1dab1-1455">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1dab1-1455">-or-</span></span>

 <span data-ttu-id="1dab1-1456"><paramref name="chars" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1456"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1dab1-1457"><paramref name="byteIndex" />、<paramref name="byteCount" /> 或 <paramref name="charIndex" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1457"><paramref name="byteIndex" /> or <paramref name="byteCount" /> or <paramref name="charIndex" /> is less than zero.</span></span>

<span data-ttu-id="1dab1-1458">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1dab1-1458">-or-</span></span>

 <span data-ttu-id="1dab1-1459"><paramref name="byteindex" /> 和 <paramref name="byteCount" /> 不表示 <paramref name="bytes" /> 中的有效范围。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1459"><paramref name="byteindex" /> and <paramref name="byteCount" /> do not denote a valid range in <paramref name="bytes" />.</span></span>

<span data-ttu-id="1dab1-1460">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1dab1-1460">-or-</span></span>

 <span data-ttu-id="1dab1-1461"><paramref name="charIndex" /> 不是 <paramref name="chars" /> 中的有效索引。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1461"><paramref name="charIndex" /> is not a valid index in <paramref name="chars" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1dab1-1462"><paramref name="chars" /> 中从 <paramref name="charIndex" /> 到数组结尾没有足够容量来容纳所产生的字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1462"><paramref name="chars" /> does not have enough capacity from <paramref name="charIndex" /> to the end of the array to accommodate the resulting characters.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1dab1-1463">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1463">A fallback occurred (for more information, see <see href="/dotnet/standard/base-types/character-encoding">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1dab1-1464">和</span><span class="sxs-lookup"><span data-stu-id="1dab1-1464">-and-</span></span>

 <span data-ttu-id="1dab1-1465"><see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1465"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="abstract member GetDecoder : unit -&gt; System.Text.Decoder&#xA;override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1dab1-1466">在派生类中重写时，获取一个解码器，该解码器将已编码的字节序列转换为字符序列。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1466">When overridden in a derived class, obtains a decoder that converts an encoded sequence of bytes into a sequence of characters.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1467">一个 <see cref="T:System.Text.Decoder" />，它将已编码的字节序列转换为字符序列。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1467">A <see cref="T:System.Text.Decoder" /> that converts an encoded sequence of bytes into a sequence of characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1468"><xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 方法以类似于此类的 <xref:System.Text.Encoding.GetChars%2A> 方法的方式将连续字节块转换为连续的字符块。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1468">The <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <xref:System.Text.Encoding.GetChars%2A> method of this class.</span></span> <span data-ttu-id="1dab1-1469">但 <xref:System.Text.Decoder> 会在调用之间维护状态信息，以便它正确地对跨块的字节序列进行解码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1469">However, a <xref:System.Text.Decoder> maintains state information between calls so it correctly decodes byte sequences that span blocks.</span></span> <span data-ttu-id="1dab1-1470"><xref:System.Text.Decoder> 还将保留数据块末尾的尾随字节，并在下一个解码操作中使用尾随字节。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1470">The <xref:System.Text.Decoder> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation.</span></span> <span data-ttu-id="1dab1-1471">因此，<xref:System.Text.Encoding.GetDecoder%2A> 和 <xref:System.Text.Encoding.GetEncoder%2A> 对于网络传输和文件操作非常有用，因为这些操作经常处理数据块，而不是完整的数据流。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1471">Therefore, <xref:System.Text.Encoding.GetDecoder%2A> and <xref:System.Text.Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</span></span>

 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="1dab1-1472">默认实现返回 <see cref="T:System.Text.Decoder" />，它调用当前 <see cref="T:System.Text.Encoding" />的 <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> 和 <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1472">The default implementation returns a <see cref="T:System.Text.Decoder" /> that calls the <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> and <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> methods of the current <see cref="T:System.Text.Encoding" />.</span></span> <span data-ttu-id="1dab1-1473">必须重写此方法才能返回在调用之间保持其状态的 <see cref="T:System.Text.Decoder" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1473">You must override this method to return a <see cref="T:System.Text.Decoder" /> that maintains its state between calls.</span></span></para></block>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <related type="Article" href="/dotnet/standard/base-types/character-encoding"><span data-ttu-id="1dab1-1474">了解编码</span><span class="sxs-lookup"><span data-stu-id="1dab1-1474">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="abstract member GetEncoder : unit -&gt; System.Text.Encoder&#xA;override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1dab1-1475">在派生类中重写时，获取一个解码器，该解码器将 Unicode 字符序列转换为已编码的字节序列。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1475">When overridden in a derived class, obtains an encoder that converts a sequence of Unicode characters into an encoded sequence of bytes.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1476">一个 <see cref="T:System.Text.Encoder" />，它将 Unicode 字符序列转换为已编码的字节序列。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1476">A <see cref="T:System.Text.Encoder" /> that converts a sequence of Unicode characters into an encoded sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1477"><xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 方法以类似于此类的 <xref:System.Text.Encoding.GetBytes%2A> 方法的方式将顺序块字符转换为按顺序排列的字节块。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1477">The <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method converts sequential blocks of characters into sequential blocks of bytes, in a manner similar to the <xref:System.Text.Encoding.GetBytes%2A> method of this class.</span></span> <span data-ttu-id="1dab1-1478">但 <xref:System.Text.Encoder> 会在调用之间维护状态信息，因此它会正确地对跨块的字符序列进行编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1478">However, a <xref:System.Text.Encoder> maintains state information between calls so it correctly encodes character sequences that span blocks.</span></span> <span data-ttu-id="1dab1-1479"><xref:System.Text.Encoder> 还在数据块的末尾保留尾部字符，并在下一编码操作中使用尾随字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1479">The <xref:System.Text.Encoder> also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation.</span></span> <span data-ttu-id="1dab1-1480">例如，数据块可能以不匹配的高代理项结束，并且匹配的低代理项可能位于下一个数据块中。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1480">For example, a data block might end with an unmatched high surrogate, and the matching low surrogate might be in the next data block.</span></span> <span data-ttu-id="1dab1-1481">因此，<xref:System.Text.Encoding.GetDecoder%2A> 和 <xref:System.Text.Encoding.GetEncoder%2A> 对于网络传输和文件操作非常有用，因为这些操作经常处理数据块，而不是完整的数据流。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1481">Therefore, <xref:System.Text.Encoding.GetDecoder%2A> and <xref:System.Text.Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</span></span>

 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="1dab1-1482">默认实现返回 <see cref="T:System.Text.Encoder" />，它调用当前 <see cref="T:System.Text.Encoding" />的 <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> 和 <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1482">The default implementation returns a <see cref="T:System.Text.Encoder" /> that calls the <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> and <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> methods of the current <see cref="T:System.Text.Encoding" />.</span></span> <span data-ttu-id="1dab1-1483">必须重写此方法才能返回在调用之间保持其状态的 <see cref="T:System.Text.Encoder" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1483">You must override this method to return a <see cref="T:System.Text.Encoder" /> that maintains its state between calls.</span></span></para></block>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <related type="Article" href="/dotnet/standard/base-types/character-encoding"><span data-ttu-id="1dab1-1484">了解编码</span><span class="sxs-lookup"><span data-stu-id="1dab1-1484">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEncoding">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1dab1-1485">返回指定代码页的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1485">Returns an encoding for the specified code page.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (codepage As Integer) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding codepage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codepage"><span data-ttu-id="1dab1-1486">首选编码的代码页标识符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1486">The code page identifier of the preferred encoding.</span></span> <span data-ttu-id="1dab1-1487">可能值均在 <see cref="T:System.Text.Encoding" /> 类主题中出现的表的“代码页”一列中列出。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1487">Possible values are listed in the Code Page column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</span></span>

<span data-ttu-id="1dab1-1488">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1dab1-1488">-or-</span></span>

<span data-ttu-id="1dab1-1489">0（零），使用默认编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1489">0 (zero), to use the default encoding.</span></span></param>
        <summary><span data-ttu-id="1dab1-1490">返回与指定代码页标识符关联的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1490">Returns the encoding associated with the specified code page identifier.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1491">与指定代码页关联的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1491">The encoding that is associated with the specified code page.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1492">回退处理程序取决于 `codepage`的编码类型。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1492">The fallback handler depends on the encoding type of `codepage`.</span></span> <span data-ttu-id="1dab1-1493">如果 `codepage` 是代码页或双字节字符集（DBCS）编码，则使用最佳回退处理程序。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1493">If `codepage` is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used.</span></span> <span data-ttu-id="1dab1-1494">否则，将使用替代回退处理程序。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1494">Otherwise, a replacement fallback handler is used.</span></span> <span data-ttu-id="1dab1-1495">这些回退处理程序可能不适合您的应用程序。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1495">These fallback handlers may not be appropriate for your app.</span></span> <span data-ttu-id="1dab1-1496">若要指定 `codepage`指定的编码使用的回退处理程序，可以调用 <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> 重载。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1496">To specify the fallback handler used by the encoding specified by `codepage`, you can call the <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> overload.</span></span>

 <span data-ttu-id="1dab1-1497">在 .NET Framework 中，<xref:System.Text.Encoding.GetEncoding%2A> 方法依赖于基础平台来支持大多数代码页。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1497">In the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages.</span></span> <span data-ttu-id="1dab1-1498">但 .NET Framework 本身就支持某些编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1498">However, the .NET Framework natively supports some encodings.</span></span> <span data-ttu-id="1dab1-1499">有关代码页的列表，请参阅 <xref:System.Text.Encoding> 类主题。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1499">For a list of code pages, see the <xref:System.Text.Encoding> class topic.</span></span> <span data-ttu-id="1dab1-1500">在 .NET Core 中，<xref:System.Text.Encoding.GetEncoding%2A> 方法返回 .NET Core 本机支持的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1500">In .NET Core, the <xref:System.Text.Encoding.GetEncoding%2A> method returns the encodings natively supported by .NET Core.</span></span> <span data-ttu-id="1dab1-1501">在这两种 .NET 实现上，都可以调用 <xref:System.Text.Encoding.GetEncodings%2A> 方法来获取包含所有可用编码相关信息的 <xref:System.Text.EncodingInfo> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1501">On both .NET implementations, you can call the <xref:System.Text.Encoding.GetEncodings%2A> method to get an array of <xref:System.Text.EncodingInfo> objects that contains information about all available encodings.</span></span>

 <span data-ttu-id="1dab1-1502">除了在 .NET Core 本机可用的编码或特定平台版本的 .NET Framework 中，<xref:System.Text.Encoding.GetEncoding%2A> 方法还会返回通过注册 <xref:System.Text.EncodingProvider> 对象提供的任何其他编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1502">In addition to the encodings that are natively available on .NET Core or that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.</span></span> <span data-ttu-id="1dab1-1503">如果多个 <xref:System.Text.EncodingProvider> 对象已注册了相同的编码，则此方法将返回最后一个注册的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1503">If the same encoding has been registered by multiple <xref:System.Text.EncodingProvider> objects, this method returns the last one registered.</span></span>

<span data-ttu-id="1dab1-1504">还可以为 `codepage` 参数提供0值。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1504">You can also supply a value of 0 for the `codepage` argument.</span></span> <span data-ttu-id="1dab1-1505">其确切行为取决于是否已通过注册 <xref:System.Text.EncodingProvider> 对象提供了任何编码：</span><span class="sxs-lookup"><span data-stu-id="1dab1-1505">Its precise behavior depends on whether any encodings have been made available by registering an <xref:System.Text.EncodingProvider> object:</span></span>

- <span data-ttu-id="1dab1-1506">如果注册了一个或多个编码提供程序，则它会返回上次注册的提供程序的编码，该提供程序已选择在 <xref:System.Text.Encoding.GetEncoding%2A> 方法传递 `codepage` 参数0时返回编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1506">If one or more encoding providers have been registered, it returns the encoding of the last registered provider that has chosen to return a encoding when the <xref:System.Text.Encoding.GetEncoding%2A> method is passed a `codepage` argument of 0.</span></span>

- <span data-ttu-id="1dab1-1507">在 .NET Framework 上，如果没有注册任何编码提供程序，则为; 如果 <xref:System.Text.CodePagesEncodingProvider> 为注册的编码提供程序，或者没有任何注册的编码提供程序处理 `codepage` 值0，则返回操作系统的活动代码页。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1507">On the .NET Framework, if no encoding provider has been registered, if the <xref:System.Text.CodePagesEncodingProvider> is the registered encoding provider, or if no registered encoding provider handles a `codepage` value of 0, it returns the operating system's active code page.</span></span> <span data-ttu-id="1dab1-1508">若要确定 Windows 系统上的活动代码页，请从 Windows 桌面上的 .NET Framework 调用 Windows [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx)函数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1508">To determine the active code page on Windows systems, call the Windows [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) function from the .NET Framework on the Windows desktop.</span></span>

- <span data-ttu-id="1dab1-1509">在 .NET Core 中，如果未注册任何编码提供程序或者注册的编码提供程序未处理 `codepage` 值0，则返回 <xref:System.Text.UTF8Encoding>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1509">On .NET Core, if no encoding provider has been registered or if no registered encoding provider handles a `codepage` value of 0, it returns the <xref:System.Text.UTF8Encoding>.</span></span>

> [!NOTE]
>  <span data-ttu-id="1dab1-1510">某些不受支持的代码页会引发 <xref:System.ArgumentException>，而另一些则导致 <xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1510">Some unsupported code pages cause an <xref:System.ArgumentException> to be thrown, whereas others cause a <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="1dab1-1511">因此，您的代码必须捕获 "异常" 部分中指示的所有异常。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1511">Therefore, your code must catch all exceptions indicated in the Exceptions section.</span></span>

> [!NOTE]
>  <span data-ttu-id="1dab1-1512">ANSI 代码页在不同计算机上可能不同，并且可以在一台计算机上更改，导致数据损坏。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1512">The ANSI code pages can be different on different computers and can change on a single computer, leading to data corruption.</span></span> <span data-ttu-id="1dab1-1513">出于此原因，如果活动代码页是 ANSI 代码页，则不建议使用 `Encoding.GetEncoding(0)` 返回的默认代码页对数据进行编码和解码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1513">For this reason, if the active code page is an ANSI code page, encoding and decoding data using the default code page returned by `Encoding.GetEncoding(0)` is not recommended.</span></span> <span data-ttu-id="1dab1-1514">为获得最一致的结果，应使用 Unicode 编码，例如 UTF-8 （代码页65001）或 UTF-16，而不是使用特定的代码页。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1514">For the most consistent results, you should use a Unicode encoding, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</span></span>

 <span data-ttu-id="1dab1-1515"><xref:System.Text.Encoding.GetEncoding%2A> 使用默认设置返回缓存的实例。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1515"><xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings.</span></span> <span data-ttu-id="1dab1-1516">应使用派生类的构造函数获取具有不同设置的实例。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1516">You should use the constructors of derived classes to get an instance with different settings.</span></span> <span data-ttu-id="1dab1-1517">例如，<xref:System.Text.UTF32Encoding> 类提供了一个构造函数，用于启用错误检测。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1517">For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.</span></span>



## Examples
 <span data-ttu-id="1dab1-1518">下面的示例获取相同编码的两个实例（一个按代码页，另一个按名称），并检查它们是否相等。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1518">The following example gets two instances of the same encoding (one by code page and another by name), and checks their equality.</span></span>

 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1dab1-1519"><paramref name="codepage" /> 小于零或大于 65535。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1519"><paramref name="codepage" /> is less than zero or greater than 65535.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1dab1-1520">基础平台不支持 <paramref name="codepage" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1520"><paramref name="codepage" /> is not supported by the underlying platform.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1dab1-1521">基础平台不支持 <paramref name="codepage" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1521"><paramref name="codepage" /> is not supported by the underlying platform.</span></span></exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="/dotnet/standard/base-types/character-encoding"><span data-ttu-id="1dab1-1522">了解编码</span><span class="sxs-lookup"><span data-stu-id="1dab1-1522">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (name As String) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="1dab1-1523">首选编码的代码页名称。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1523">The code page name of the preferred encoding.</span></span> <span data-ttu-id="1dab1-1524"><see cref="P:System.Text.Encoding.WebName" /> 属性返回的所有值均有效。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1524">Any value returned by the <see cref="P:System.Text.Encoding.WebName" /> property is valid.</span></span> <span data-ttu-id="1dab1-1525">可能值均在 <see cref="T:System.Text.Encoding" /> 类主题中出现的表的“名称”一列中列出。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1525">Possible values are listed in the Name column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</span></span></param>
        <summary><span data-ttu-id="1dab1-1526">返回与指定代码页名称关联的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1526">Returns the encoding associated with the specified code page name.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1527">与指定代码页关联的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1527">The encoding  associated with the specified code page.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1528">回退处理程序取决于 `name`的编码类型。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1528">The fallback handler depends on the encoding type of `name`.</span></span> <span data-ttu-id="1dab1-1529">如果 `name` 是代码页或双字节字符集（DBCS）编码，则使用最佳回退处理程序。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1529">If `name` is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used.</span></span> <span data-ttu-id="1dab1-1530">否则，将使用替代回退处理程序。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1530">Otherwise, a replacement fallback handler is used.</span></span> <span data-ttu-id="1dab1-1531">这些回退处理程序可能不适合您的应用程序。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1531">These fallback handlers may not be appropriate for your app.</span></span> <span data-ttu-id="1dab1-1532">若要指定 `name`指定的编码使用的回退处理程序，可以调用 <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> 重载。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1532">To specify the fallback handler used by the encoding specified by `name`, you can call the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> overload.</span></span>

<span data-ttu-id="1dab1-1533">在 .NET Framework 中，<xref:System.Text.Encoding.GetEncoding%2A> 方法依赖于基础平台来支持大多数代码页。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1533">In the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages.</span></span> <span data-ttu-id="1dab1-1534">但 .NET Framework 本身就支持某些编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1534">However, the .NET Framework natively supports some encodings.</span></span> <span data-ttu-id="1dab1-1535">有关代码页的列表，请参阅 <xref:System.Text.Encoding> 类主题。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1535">For a list of code pages, see the <xref:System.Text.Encoding> class topic.</span></span> <span data-ttu-id="1dab1-1536">在 .NET Core 中，<xref:System.Text.Encoding.GetEncoding%2A> 方法返回 .NET Core 本机支持的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1536">In .NET Core, the <xref:System.Text.Encoding.GetEncoding%2A> method returns the encodings natively supported by .NET Core.</span></span> <span data-ttu-id="1dab1-1537">在这两种 .NET 实现上，都可以调用 <xref:System.Text.Encoding.GetEncodings%2A> 方法来获取包含所有可用编码相关信息的 <xref:System.Text.EncodingInfo> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1537">On both .NET implementations, you can call the <xref:System.Text.Encoding.GetEncodings%2A> method to get an array of <xref:System.Text.EncodingInfo> objects that contains information about all available encodings.</span></span>

 <span data-ttu-id="1dab1-1538">除了在 .NET Core 本机可用的编码或特定平台版本的 .NET Framework 中，<xref:System.Text.Encoding.GetEncoding%2A> 方法还会返回通过注册 <xref:System.Text.EncodingProvider> 对象提供的任何其他编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1538">In addition to the encodings that are natively available on .NET Core or that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.</span></span> <span data-ttu-id="1dab1-1539">如果多个 <xref:System.Text.EncodingProvider> 对象已注册了相同的编码，则此方法将返回最后一个注册的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1539">If the same encoding has been registered by multiple <xref:System.Text.EncodingProvider> objects, this method returns the last one registered.</span></span>

> [!NOTE]
>  <span data-ttu-id="1dab1-1540">ANSI 代码页在不同的计算机上可能不同，或者可以针对一台计算机进行更改，从而导致数据损坏。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1540">The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption.</span></span> <span data-ttu-id="1dab1-1541">为获得最一致的结果，应使用 Unicode，如 UTF-8 （代码页65001）或 UTF-16，而不是特定的代码页。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1541">For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</span></span>


 <span data-ttu-id="1dab1-1542"><xref:System.Text.Encoding.GetEncoding%2A> 使用默认设置返回缓存的实例。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1542"><xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings.</span></span> <span data-ttu-id="1dab1-1543">应使用派生类的构造函数获取具有不同设置的实例。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1543">You should use the constructors of derived classes to get an instance with different settings.</span></span> <span data-ttu-id="1dab1-1544">例如，<xref:System.Text.UTF32Encoding> 类提供了一个构造函数，用于启用错误检测。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1544">For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.</span></span>

## Examples
 <span data-ttu-id="1dab1-1545">下面的示例获取相同编码的两个实例（一个按代码页，另一个按名称），并检查它们是否相等。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1545">The following example gets two instances of the same encoding (one by code page and another by name), and checks their equality.</span></span>

 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1dab1-1546"><paramref name="name" /> 不是有效的代码页名称。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1546"><paramref name="name" /> is not a valid code page name.</span></span>

<span data-ttu-id="1dab1-1547">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1dab1-1547">-or-</span></span>

<span data-ttu-id="1dab1-1548">基础平台不支持 <paramref name="name" /> 所指示的代码页。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1548">The code page indicated by <paramref name="name" /> is not supported by the underlying platform.</span></span></exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="/dotnet/standard/base-types/character-encoding"><span data-ttu-id="1dab1-1549">了解编码</span><span class="sxs-lookup"><span data-stu-id="1dab1-1549">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (codepage As Integer, encoderFallback As EncoderFallback, decoderFallback As DecoderFallback) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (codepage, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codepage"><span data-ttu-id="1dab1-1550">首选编码的代码页标识符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1550">The code page identifier of the preferred encoding.</span></span> <span data-ttu-id="1dab1-1551">可能值均在 <see cref="T:System.Text.Encoding" /> 类主题中出现的表的“代码页”一列中列出。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1551">Possible values are listed in the Code Page column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</span></span>

<span data-ttu-id="1dab1-1552">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1dab1-1552">-or-</span></span>

<span data-ttu-id="1dab1-1553">0（零），使用默认编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1553">0 (zero), to use the default encoding.</span></span></param>
        <param name="encoderFallback"><span data-ttu-id="1dab1-1554">一个对象，在无法用当前编码对字符进行编码时，该对象可用来提供错误处理过程。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1554">An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</span></span></param>
        <param name="decoderFallback"><span data-ttu-id="1dab1-1555">一个对象，在无法用当前编码对字节序列进行解码时，该对象可用来提供错误处理过程。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1555">An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</span></span></param>
        <summary><span data-ttu-id="1dab1-1556">返回与指定代码页标识符关联的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1556">Returns the encoding associated with the specified code page identifier.</span></span> <span data-ttu-id="1dab1-1557">参数指定一个错误处理程序，用于处理无法编码的字符和无法解码的字节序列。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1557">Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1558">与指定代码页关联的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1558">The encoding that is associated with the specified code page.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
>  <span data-ttu-id="1dab1-1559">某些不受支持的代码页会引发异常 <xref:System.ArgumentException> 引发异常，而其他一些则导致 <xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1559">Some unsupported code pages cause the exception <xref:System.ArgumentException> to be thrown, whereas others cause <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="1dab1-1560">因此，您的代码必须捕获 "异常" 部分中指示的所有异常。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1560">Therefore, your code must catch all exceptions indicated in the Exceptions section.</span></span>

<span data-ttu-id="1dab1-1561">在 .NET Framework 中，<xref:System.Text.Encoding.GetEncoding%2A> 方法依赖于基础平台来支持大多数代码页。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1561">In the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages.</span></span> <span data-ttu-id="1dab1-1562">但 .NET Framework 本身就支持某些编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1562">However, the .NET Framework natively supports some encodings.</span></span> <span data-ttu-id="1dab1-1563">有关代码页的列表，请参阅 <xref:System.Text.Encoding> 类主题。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1563">For a list of code pages, see the <xref:System.Text.Encoding> class topic.</span></span> <span data-ttu-id="1dab1-1564">在 .NET Core 中，<xref:System.Text.Encoding.GetEncoding%2A> 方法返回 .NET Core 本机支持的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1564">In .NET Core, the <xref:System.Text.Encoding.GetEncoding%2A> method returns the encodings natively supported by .NET Core.</span></span> <span data-ttu-id="1dab1-1565">在这两种 .NET 实现上，都可以调用 <xref:System.Text.Encoding.GetEncodings%2A> 方法来获取包含所有可用编码相关信息的 <xref:System.Text.EncodingInfo> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1565">On both .NET implementations, you can call the <xref:System.Text.Encoding.GetEncodings%2A> method to get an array of <xref:System.Text.EncodingInfo> objects that contains information about all available encodings.</span></span>

 <span data-ttu-id="1dab1-1566">除了在 .NET Core 本机可用的编码或特定平台版本的 .NET Framework 中，<xref:System.Text.Encoding.GetEncoding%2A> 方法还会返回通过注册 <xref:System.Text.EncodingProvider> 对象提供的任何其他编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1566">In addition to the encodings that are natively available on .NET Core or that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.</span></span> <span data-ttu-id="1dab1-1567">如果多个 <xref:System.Text.EncodingProvider> 对象已注册了相同的编码，则此方法将返回最后一个注册的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1567">If the same encoding has been registered by multiple <xref:System.Text.EncodingProvider> objects, this method returns the last one registered.</span></span>

<span data-ttu-id="1dab1-1568">还可以为 `codepage` 参数提供0值。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1568">You can also supply a value of 0 for the `codepage` argument.</span></span> <span data-ttu-id="1dab1-1569">其确切行为取决于是否已通过注册 <xref:System.Text.EncodingProvider> 对象提供了任何编码：</span><span class="sxs-lookup"><span data-stu-id="1dab1-1569">Its precise behavior depends on whether any encodings have been made available by registering an <xref:System.Text.EncodingProvider> object:</span></span>

- <span data-ttu-id="1dab1-1570">如果注册了一个或多个编码提供程序，则它会返回上次注册的提供程序的编码，该提供程序已选择在 <xref:System.Text.Encoding.GetEncoding%2A> 方法传递 `codepage` 参数0时返回编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1570">If one or more encoding providers have been registered, it returns the encoding of the last registered provider that has chosen to return a encoding when the <xref:System.Text.Encoding.GetEncoding%2A> method is passed a `codepage` argument of 0.</span></span>

- <span data-ttu-id="1dab1-1571">在 .NET Framework 上，如果没有注册任何编码提供程序，则为; 如果 <xref:System.Text.CodePagesEncodingProvider> 为注册的编码提供程序，或者没有任何注册的编码提供程序处理 `codepage` 值0，则返回活动代码页。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1571">On the .NET Framework, if no encoding provider has been registered, if the <xref:System.Text.CodePagesEncodingProvider> is the registered encoding provider, or if no registered encoding provider handles a `codepage` value of 0, it returns the active code page.</span></span>

- <span data-ttu-id="1dab1-1572">在 .NET Core 中，如果未注册任何编码提供程序，或者如果没有已注册的编码提供程序处理 `codepage` 值0，它将返回 <xref:System.Text.UTF8Encoding> 编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1572">On .NET Core, if no encoding provider has been registered or if no registered encoding provider handles a `codepage` value of 0, it returns the <xref:System.Text.UTF8Encoding> encoding.</span></span>

> [!NOTE]
>  <span data-ttu-id="1dab1-1573">ANSI 代码页在不同计算机上可能不同，并且可以在一台计算机上更改，导致数据损坏。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1573">The ANSI code pages can be different on different computers and can change on a single computer, leading to data corruption.</span></span> <span data-ttu-id="1dab1-1574">出于此原因，如果活动代码页是 ANSI 代码页，则不建议使用 `Encoding.GetEncoding(0)` 返回的默认代码页对数据进行编码和解码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1574">For this reason, if the active code page is an ANSI code page, encoding and decoding data using the default code page returned by `Encoding.GetEncoding(0)` is not recommended.</span></span> <span data-ttu-id="1dab1-1575">为获得最一致的结果，应使用 Unicode，如 UTF-8 （代码页65001）或 UTF-16，而不是特定的代码页。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1575">For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</span></span>

 <span data-ttu-id="1dab1-1576">若要获取与活动代码页关联的编码，可以为 `codepage` 参数提供0值，或者，如果代码在 Windows 桌面上的 .NET Framework 上运行，则检索 <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> 属性的值。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1576">To get the encoding associated with the active code page, you can either supply a value of 0 for the `codepage` argument or, if your code is running on the .NET Framework on the Windows desktop, retrieve the value of the <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="1dab1-1577">若要确定当前的活动代码页，请从 Windows 桌面上的 .NET Framework 调用 Windows [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx)函数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1577">To determine the current active code page, call the Windows [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) function from the .NET Framework on the Windows desktop.</span></span>

 <span data-ttu-id="1dab1-1578"><xref:System.Text.Encoding.GetEncoding%2A> 使用默认设置返回缓存的实例。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1578"><xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings.</span></span> <span data-ttu-id="1dab1-1579">应使用派生类的构造函数获取具有不同设置的实例。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1579">You should use the constructors of derived classes to get an instance with different settings.</span></span> <span data-ttu-id="1dab1-1580">例如，<xref:System.Text.UTF32Encoding> 类提供了一个构造函数，用于启用错误检测。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1580">For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.</span></span>



## Examples
 <span data-ttu-id="1dab1-1581">下面的示例演示 <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1581">The following example demonstrates the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> method.</span></span>

 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1dab1-1582"><paramref name="codepage" /> 小于零或大于 65535。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1582"><paramref name="codepage" /> is less than zero or greater than 65535.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1dab1-1583">基础平台不支持 <paramref name="codepage" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1583"><paramref name="codepage" /> is not supported by the underlying platform.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1dab1-1584">基础平台不支持 <paramref name="codepage" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1584"><paramref name="codepage" /> is not supported by the underlying platform.</span></span></exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="/dotnet/standard/base-types/character-encoding"><span data-ttu-id="1dab1-1585">了解编码</span><span class="sxs-lookup"><span data-stu-id="1dab1-1585">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (name As String, encoderFallback As EncoderFallback, decoderFallback As DecoderFallback) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (name, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="1dab1-1586">首选编码的代码页名称。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1586">The code page name of the preferred encoding.</span></span> <span data-ttu-id="1dab1-1587"><see cref="P:System.Text.Encoding.WebName" /> 属性返回的所有值均有效。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1587">Any value returned by the <see cref="P:System.Text.Encoding.WebName" /> property is valid.</span></span> <span data-ttu-id="1dab1-1588">可能值均在 <see cref="T:System.Text.Encoding" /> 类主题中出现的表的“名称”一列中列出。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1588">Possible values are listed in the Name column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</span></span></param>
        <param name="encoderFallback"><span data-ttu-id="1dab1-1589">一个对象，在无法用当前编码对字符进行编码时，该对象可用来提供错误处理过程。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1589">An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</span></span></param>
        <param name="decoderFallback"><span data-ttu-id="1dab1-1590">一个对象，在无法用当前编码对字节序列进行解码时，该对象可用来提供错误处理过程。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1590">An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</span></span></param>
        <summary><span data-ttu-id="1dab1-1591">返回与指定代码页名称关联的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1591">Returns the encoding associated with the specified code page name.</span></span> <span data-ttu-id="1dab1-1592">参数指定一个错误处理程序，用于处理无法编码的字符和无法解码的字节序列。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1592">Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1593">与指定代码页关联的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1593">The encoding that is associated with the specified code page.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="1dab1-1594">在 .NET Framework 中，<xref:System.Text.Encoding.GetEncoding%2A> 方法依赖于基础平台来支持大多数代码页。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1594">In the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages.</span></span> <span data-ttu-id="1dab1-1595">但 .NET Framework 本身就支持某些编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1595">However, the .NET Framework natively supports some encodings.</span></span> <span data-ttu-id="1dab1-1596">有关代码页的列表，请参阅 <xref:System.Text.Encoding> 类主题。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1596">For a list of code pages, see the <xref:System.Text.Encoding> class topic.</span></span> <span data-ttu-id="1dab1-1597">在 .NET Core 中，<xref:System.Text.Encoding.GetEncoding%2A> 方法返回 .NET Core 本机支持的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1597">In .NET Core, the <xref:System.Text.Encoding.GetEncoding%2A> method returns the encodings natively supported by .NET Core.</span></span> <span data-ttu-id="1dab1-1598">在这两种 .NET 实现上，都可以调用 <xref:System.Text.Encoding.GetEncodings%2A> 方法来获取包含所有可用编码相关信息的 <xref:System.Text.EncodingInfo> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1598">On both .NET implementations, you can call the <xref:System.Text.Encoding.GetEncodings%2A> method to get an array of <xref:System.Text.EncodingInfo> objects that contains information about all available encodings.</span></span>

 <span data-ttu-id="1dab1-1599">除了在 .NET Core 本机可用的编码或特定平台版本的 .NET Framework 中，<xref:System.Text.Encoding.GetEncoding%2A> 方法还会返回通过注册 <xref:System.Text.EncodingProvider> 对象提供的任何其他编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1599">In addition to the encodings that are natively available on .NET Core or that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.</span></span> <span data-ttu-id="1dab1-1600">如果多个 <xref:System.Text.EncodingProvider> 对象已注册了相同的编码，则此方法将返回最后一个注册的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1600">If the same encoding has been registered by multiple <xref:System.Text.EncodingProvider> objects, this method returns the last one registered.</span></span>

> [!NOTE]
>  <span data-ttu-id="1dab1-1601">ANSI 代码页在不同计算机上可能不同，并且可以在一台计算机上更改，导致数据损坏。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1601">The ANSI code pages can be different on different computers and can change on a single computer, leading to data corruption.</span></span> <span data-ttu-id="1dab1-1602">为获得最一致的结果，应使用 Unicode 编码，例如 UTF-8 （代码页65001）或 UTF-16，而不是使用特定的代码页。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1602">For the most consistent results, you should use a Unicode encoding, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</span></span>

 <span data-ttu-id="1dab1-1603"><xref:System.Text.Encoding.GetEncoding%2A> 使用默认设置返回缓存的实例。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1603"><xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings.</span></span> <span data-ttu-id="1dab1-1604">应使用派生类的构造函数获取具有不同设置的实例。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1604">You should use the constructors of derived classes to get an instance with different settings.</span></span> <span data-ttu-id="1dab1-1605">例如，<xref:System.Text.UTF32Encoding> 类提供了一个构造函数，用于启用错误检测。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1605">For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.</span></span>



## Examples
 <span data-ttu-id="1dab1-1606">下面的示例演示 <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1606">The following example demonstrates the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> method.</span></span>

 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1dab1-1607"><paramref name="name" /> 不是有效的代码页名称。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1607"><paramref name="name" /> is not a valid code page name.</span></span>

<span data-ttu-id="1dab1-1608">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1dab1-1608">-or-</span></span>

<span data-ttu-id="1dab1-1609">基础平台不支持 <paramref name="name" /> 所指示的代码页。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1609">The code page indicated by <paramref name="name" /> is not supported by the underlying platform.</span></span></exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="/dotnet/standard/base-types/character-encoding"><span data-ttu-id="1dab1-1610">了解编码</span><span class="sxs-lookup"><span data-stu-id="1dab1-1610">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncodings () As EncodingInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Text::EncodingInfo ^&gt; ^ GetEncodings();" />
      <MemberSignature Language="F#" Value="static member GetEncodings : unit -&gt; System.Text.EncodingInfo[]" Usage="System.Text.Encoding.GetEncodings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1dab1-1611">返回包含所有编码的数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1611">Returns an array that contains all encodings.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1612">包含所有编码的数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1612">An array that contains all encodings.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1613">此方法返回受支持的编码的列表，该列表由代码页唯一区分。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1613">This method returns a list of supported encodings, uniquely distinguished by code page.</span></span> <span data-ttu-id="1dab1-1614">有关列出受支持编码的表，请参阅 <xref:System.Text.Encoding> 类主题。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1614">For a table that lists the supported encodings, see the <xref:System.Text.Encoding> class topic.</span></span>

> [!NOTE]
>  <span data-ttu-id="1dab1-1615"><xref:System.Text.Encoding.GetEncodings%2A> 方法返回的支持编码的列表不包括任何其他编码，这些编码由通过调用 <xref:System.Text.Encoding.RegisterProvider%2A> 方法注册的任何 <xref:System.Text.EncodingProvider> 实现提供。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1615">The list of supported encodings returned by the <xref:System.Text.Encoding.GetEncodings%2A> method does not include any additional encodings made available by any <xref:System.Text.EncodingProvider> implementations that were registered by calls to the <xref:System.Text.Encoding.RegisterProvider%2A> method.</span></span>

 <span data-ttu-id="1dab1-1616">在 .NET Framework 中，编码50220和50222都与名称 "iso-2022-jp" 相关联，但它们不同。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1616">On the .NET Framework, encodings 50220 and 50222 are both associated with the name "iso-2022-jp", but they are not identical.</span></span> <span data-ttu-id="1dab1-1617">编码50220将半角片假名字符转换为全角字符，而编码50222使用 "移入/移出" 序列对半角片假名字符进行编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1617">Encoding 50220 converts half-width Katakana characters to full-width Katakana characters, whereas encoding 50222 uses a shift-in/shift-out sequence to encode half-width Katakana characters.</span></span> <span data-ttu-id="1dab1-1618">编码50222的显示名称为 "日语（JIS-允许1字节假名-SO/SI）"，以将其与显示名称为 "日语（JIS）" 的编码50220区分开来。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1618">The display name for encoding 50222 is "Japanese (JIS-Allow 1 byte Kana - SO/SI)" to distinguish it from encoding 50220, which has the display name "Japanese (JIS)".</span></span>

 <span data-ttu-id="1dab1-1619">如果请求编码名称 "iso-2022-jp"，则 .NET Framework 返回编码50220。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1619">If you request the encoding name "iso-2022-jp", the .NET Framework returns encoding 50220.</span></span> <span data-ttu-id="1dab1-1620">不过，适用于应用程序的编码取决于对半角片假名字符的首选处理方式。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1620">However, the encoding that is appropriate for your app depends on the preferred treatment of the half-width Katakana characters.</span></span>

 <span data-ttu-id="1dab1-1621">若要获取特定的编码，应使用 <xref:System.Text.Encoding.GetEncoding%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1621">To get a specific encoding, you should use the <xref:System.Text.Encoding.GetEncoding%2A> method.</span></span>

 <span data-ttu-id="1dab1-1622"><xref:System.Text.Encoding.GetEncodings%2A> 有时用于向用户显示 "**另存为**" 对话框中的编码列表。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1622"><xref:System.Text.Encoding.GetEncodings%2A> is sometimes used to present the user with a list of encodings in a File **Save as** dialog box.</span></span> <span data-ttu-id="1dab1-1623">但是，许多非 Unicode 编码都不完整，而是将多个字符转换为 "？"，或者在不同的平台上具有细微的不同行为。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1623">However, many non-Unicode encodings are either incomplete and translate many characters to "?", or have subtly different behavior on different platforms.</span></span> <span data-ttu-id="1dab1-1624">请考虑使用 UTF-8 或 UTF-16 作为默认值。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1624">Consider using UTF-8 or UTF-16 as the default.</span></span>



## Examples
 <span data-ttu-id="1dab1-1625">下面的示例检查每个编码的布尔值属性的值。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1625">The following example checks the values of the Boolean properties of each encoding.</span></span>

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="/dotnet/standard/base-types/character-encoding"><span data-ttu-id="1dab1-1626">了解编码</span><span class="sxs-lookup"><span data-stu-id="1dab1-1626">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1dab1-1627">返回当前实例的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1627">Returns the hash code for the current instance.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1628">当前实例的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1628">The hash code for the current instance.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxByteCount : int -&gt; int" Usage="encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount"><span data-ttu-id="1dab1-1629">要编码的字符的数目。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1629">The number of characters to encode.</span></span></param>
        <summary><span data-ttu-id="1dab1-1630">在派生类中重写时，计算对指定数目的字符进行编码所产生的最大字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1630">When overridden in a derived class, calculates the maximum number of bytes produced by encoding the specified number of characters.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1631">对指定数目的字符进行编码所产生的最大字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1631">The maximum number of bytes produced by encoding the specified number of characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1632">`charCount` 参数实际上指定了代表要编码的 Unicode 字符的 <xref:System.Char> 对象的数量，因为 .NET 内部使用 UTF-16 来表示 Unicode 字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1632">The `charCount` parameter actually specifies the number of <xref:System.Char> objects that represent the Unicode characters to encode, because .NET internally uses UTF-16 to represent Unicode characters.</span></span> <span data-ttu-id="1dab1-1633">因此，大多数 Unicode 字符均可由一个 <xref:System.Char> 对象表示，但例如，代理项对表示的 Unicode 字符需要两个 <xref:System.Char> 对象。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1633">Consequently, most Unicode characters can be represented by one <xref:System.Char> object, but a Unicode character represented by a surrogate pair, for example, requires two <xref:System.Char> objects.</span></span>

 <span data-ttu-id="1dab1-1634">若要计算 <xref:System.Text.Encoding.GetBytes%2A> 存储生成的字节所需的确切数组大小，应使用 <xref:System.Text.Encoding.GetByteCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1634">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should use the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1dab1-1635">若要计算最大数组大小，请使用 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1635">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1dab1-1636"><xref:System.Text.Encoding.GetByteCount%2A> 方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法的执行速度通常更快。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1636">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1dab1-1637"><xref:System.Text.Encoding.GetMaxByteCount%2A> 检索最差的事例数，包括当前所选 <xref:System.Text.EncoderFallback>的最坏情况。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1637"><xref:System.Text.Encoding.GetMaxByteCount%2A> retrieves a worst-case number, including the worst case for the currently selected <xref:System.Text.EncoderFallback>.</span></span> <span data-ttu-id="1dab1-1638">如果使用可能大的字符串选择回退，<xref:System.Text.Encoding.GetMaxByteCount%2A> 会检索到较大的值，特别是在编码的最差情况涉及切换每个字符的模式的情况下。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1638">If a fallback is chosen with a potentially large string, <xref:System.Text.Encoding.GetMaxByteCount%2A> retrieves large values, particularly in cases where the worst case for the encoding involves switching modes for every character.</span></span> <span data-ttu-id="1dab1-1639">例如，ISO-2022-JP 可能会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1639">For example, this can happen for ISO-2022-JP.</span></span> <span data-ttu-id="1dab1-1640">有关详细信息，请参阅博客文章 "[GetMaxByteCount （）和 GetMaxCharCount （）？](https://blogs.msdn.microsoft.com/shawnste/2005/03/02/whats-with-encoding-getmaxbytecount-and-encoding-getmaxcharcount/)"。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1640">For more information, see the blog post "[What's with Encoding.GetMaxByteCount() and Encoding.GetMaxCharCount()?](https://blogs.msdn.microsoft.com/shawnste/2005/03/02/whats-with-encoding-getmaxbytecount-and-encoding-getmaxcharcount/).</span></span>

 <span data-ttu-id="1dab1-1641">在大多数情况下，此方法检索小字符串的合理值。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1641">In most cases, this method retrieves reasonable values for small strings.</span></span> <span data-ttu-id="1dab1-1642">对于大字符串，可能需要在很少的情况下选择使用非常大的缓冲区，并在很少的情况下捕获错误。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1642">For large strings, you might have to choose between using very large buffers and catching errors in the rare case when a more reasonable buffer is too small.</span></span> <span data-ttu-id="1dab1-1643">你可能还需要考虑使用 <xref:System.Text.Encoding.GetByteCount%2A> 或 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>的其他方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1643">You might also want to consider a different approach using <xref:System.Text.Encoding.GetByteCount%2A> or <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="1dab1-1644">使用 <xref:System.Text.Encoding.GetMaxByteCount%2A>时，应根据输入缓冲区的最大大小分配输出缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1644">When using <xref:System.Text.Encoding.GetMaxByteCount%2A>, you should allocate the output buffer based on the maximum size of the input buffer.</span></span> <span data-ttu-id="1dab1-1645">如果输出缓冲区的大小受到限制，可以使用 <xref:System.Text.Encoding.Convert%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1645">If the output buffer is constrained in size, you might use the <xref:System.Text.Encoding.Convert%2A> method.</span></span>

 <span data-ttu-id="1dab1-1646">请注意，<xref:System.Text.Encoding.GetMaxByteCount%2A> 会考虑以前的解码器操作的潜在遗留代理项。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1646">Note that <xref:System.Text.Encoding.GetMaxByteCount%2A> considers potential leftover surrogates from a previous decoder operation.</span></span> <span data-ttu-id="1dab1-1647">由于解码器的原因，向方法传递值1时，将为单字节编码（如 ASCII）检索2。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1647">Because of the decoder, passing a value of 1 to the method retrieves 2 for a single-byte encoding, such as ASCII.</span></span> <span data-ttu-id="1dab1-1648">如果此信息是必需的，则应使用 <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1648">You should use the <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> property if this information is necessary.</span></span>

> [!NOTE]
>  <span data-ttu-id="1dab1-1649">`GetMaxByteCount(N)` 不一定与 `N* GetMaxByteCount(1)`相同。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1649">`GetMaxByteCount(N)` is not necessarily the same value as `N* GetMaxByteCount(1)`.</span></span>



## Examples
 <span data-ttu-id="1dab1-1650">下面的示例确定对字符数组进行编码、对字符进行编码并显示生成的字节所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1650">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1dab1-1651"><paramref name="charCount" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1651"><paramref name="charCount" /> is less than zero.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1dab1-1652">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1652">A fallback occurred (for more information, see <see href="/dotnet/standard/base-types/character-encoding">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1dab1-1653">和</span><span class="sxs-lookup"><span data-stu-id="1dab1-1653">-and-</span></span>

 <span data-ttu-id="1dab1-1654"><see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1654"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="1dab1-1655">如果根据此方法的计算结果调整了缓冲区的大小，则所有 <see cref="T:System.Text.Encoding" /> 实现都必须确保不会发生缓冲区溢出异常。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1655">All <see cref="T:System.Text.Encoding" /> implementations must guarantee that no buffer overflow exceptions occur if buffers are sized according to the results of this method's calculations.</span></span></para></block>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxCharCount : int -&gt; int" Usage="encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount"><span data-ttu-id="1dab1-1656">要解码的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1656">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="1dab1-1657">在派生类中重写时，计算对指定数目的字节进行解码时所产生的最大字符数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1657">When overridden in a derived class, calculates the maximum number of characters produced by decoding the specified number of bytes.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1658">对指定数目的字节进行解码时所产生的最大字符数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1658">The maximum number of characters produced by decoding the specified number of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1659">若要计算 <xref:System.Text.Encoding.GetChars%2A> 存储所生成的字符所需的确切数组大小，应使用 <xref:System.Text.Encoding.GetCharCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1659">To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="1dab1-1660">若要计算最大数组大小，请使用 <xref:System.Text.Encoding.GetMaxCharCount%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1660">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="1dab1-1661"><xref:System.Text.Encoding.GetCharCount%2A> 方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxCharCount%2A> 方法的执行速度通常更快。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1661">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1dab1-1662"><xref:System.Text.Encoding.GetMaxCharCount%2A> 检索最差的事例数，包括当前所选 <xref:System.Text.DecoderFallback>的最坏情况。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1662"><xref:System.Text.Encoding.GetMaxCharCount%2A> retrieves a worst-case number, including the worst case for the currently selected <xref:System.Text.DecoderFallback>.</span></span> <span data-ttu-id="1dab1-1663">如果使用可能大的字符串选择回退，<xref:System.Text.Encoding.GetMaxCharCount%2A> 会检索到较大的值。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1663">If a fallback is chosen with a potentially large string, <xref:System.Text.Encoding.GetMaxCharCount%2A> retrieves large values.</span></span>

 <span data-ttu-id="1dab1-1664">在大多数情况下，此方法检索小字符串的合理数字。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1664">In most cases, this method retrieves reasonable numbers for small strings.</span></span> <span data-ttu-id="1dab1-1665">对于大字符串，你可能需要在很少的情况下选择使用非常大的缓冲区，并捕获更合理的缓冲区太小的错误。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1665">For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is too small.</span></span> <span data-ttu-id="1dab1-1666">你可能还需要考虑使用 <xref:System.Text.Encoding.GetCharCount%2A> 或 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>的其他方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1666">You might also want to consider a different approach using <xref:System.Text.Encoding.GetCharCount%2A> or <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="1dab1-1667"><xref:System.Text.Encoding.GetMaxCharCount%2A> 与 <xref:System.Text.Encoding.GetBytes%2A>无关。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1667"><xref:System.Text.Encoding.GetMaxCharCount%2A> has no relation to <xref:System.Text.Encoding.GetBytes%2A>.</span></span> <span data-ttu-id="1dab1-1668">如果需要一个类似的函数来与 <xref:System.Text.Encoding.GetBytes%2A>一起使用，则应使用 <xref:System.Text.Encoding.GetMaxByteCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1668">If you needs a similar function to use with <xref:System.Text.Encoding.GetBytes%2A>, you should use <xref:System.Text.Encoding.GetMaxByteCount%2A>.</span></span>

 <span data-ttu-id="1dab1-1669">使用 <xref:System.Text.Encoding.GetMaxCharCount%2A>时，应根据输入缓冲区的最大大小分配输出缓冲区。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1669">When using <xref:System.Text.Encoding.GetMaxCharCount%2A>, you should allocate the output buffer based on the maximum size of the input buffer.</span></span> <span data-ttu-id="1dab1-1670">如果输出缓冲区的大小受到限制，可以使用 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1670">If the output buffer is constrained in size, you might use the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method.</span></span>

 <span data-ttu-id="1dab1-1671">请注意，<xref:System.Text.Encoding.GetMaxCharCount%2A> 认为最坏的情况是以前的编码器操作遗留了个字节。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1671">Note that <xref:System.Text.Encoding.GetMaxCharCount%2A> considers the worst case for leftover bytes from a previous encoder operation.</span></span> <span data-ttu-id="1dab1-1672">对于大多数代码页，将值0传递到此方法将检索大于或等于1的值。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1672">For most code pages, passing a value of 0 to this method retrieves values greater than or equal to 1.</span></span>

> [!NOTE]
>  <span data-ttu-id="1dab1-1673">`GetMaxCharCount(N)` 不一定与 `N* GetMaxCharCount(1)`相同。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1673">`GetMaxCharCount(N)` is not necessarily the same value as `N* GetMaxCharCount(1)`.</span></span>



## Examples
 <span data-ttu-id="1dab1-1674">下面的示例将字符串编码为一个字节数组，然后将这些字节解码为一个字符数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1674">The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.</span></span>

 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1dab1-1675"><paramref name="byteCount" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1675"><paramref name="byteCount" /> is less than zero.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1dab1-1676">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1676">A fallback occurred (for more information, see <see href="/dotnet/standard/base-types/character-encoding">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1dab1-1677">和</span><span class="sxs-lookup"><span data-stu-id="1dab1-1677">-and-</span></span>

 <span data-ttu-id="1dab1-1678"><see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1678"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="1dab1-1679">如果根据此方法的计算结果调整了缓冲区的大小，则所有 <see cref="T:System.Text.Encoding" /> 实现都必须确保不会发生缓冲区溢出异常。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1679">All <see cref="T:System.Text.Encoding" /> implementations must guarantee that no buffer overflow exceptions occur if buffers are sized according to the results of this method's calculations.</span></span></para></block>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="abstract member GetPreamble : unit -&gt; byte[]&#xA;override this.GetPreamble : unit -&gt; byte[]" Usage="encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1dab1-1680">在派生类中重写时，返回指定所用编码的字节序列。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1680">When overridden in a derived class, returns a sequence of bytes that specifies the encoding used.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1681">一个字节数组，包含指定所用编码的字节序列。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1681">A byte array containing a sequence of bytes that specifies the encoding used.</span></span>

 <span data-ttu-id="1dab1-1682">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1dab1-1682">-or-</span></span>

 <span data-ttu-id="1dab1-1683">长度为零的字节数组（如果不需要前导码）。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1683">A byte array of length zero, if a preamble is not required.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1684">（可选） <xref:System.Text.Encoding> 对象提供了前导码，它是一个字节数组，可以作为编码过程中所产生的字节序列的前缀。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1684">Optionally, the <xref:System.Text.Encoding> object provides a preamble that is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process.</span></span> <span data-ttu-id="1dab1-1685">如果引言包含字节顺序标记（在 Unicode、码位 U + FEFF 中），则它有助于解码器确定字节顺序和转换格式或 UTF。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1685">If the preamble contains a byte order mark (in Unicode, code point U+FEFF), it helps the decoder determine the byte order and the transformation format or UTF.</span></span>

 <span data-ttu-id="1dab1-1686">Unicode 字节顺序标记（BOM）按以下方式序列化（十六进制）：</span><span class="sxs-lookup"><span data-stu-id="1dab1-1686">The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal):</span></span>

-   <span data-ttu-id="1dab1-1687">UTF-8： EF BB BF</span><span class="sxs-lookup"><span data-stu-id="1dab1-1687">UTF-8: EF BB BF</span></span>

-   <span data-ttu-id="1dab1-1688">UTF-16 大 endian 字节顺序： FE FF</span><span class="sxs-lookup"><span data-stu-id="1dab1-1688">UTF-16 big endian byte order: FE FF</span></span>

-   <span data-ttu-id="1dab1-1689">UTF-16 little endian 字节顺序： FF FE</span><span class="sxs-lookup"><span data-stu-id="1dab1-1689">UTF-16 little endian byte order: FF FE</span></span>

-   <span data-ttu-id="1dab1-1690">32大 endian 字节顺序： 00 00 FE FF</span><span class="sxs-lookup"><span data-stu-id="1dab1-1690">UTF-32 big endian byte order: 00 00 FE FF</span></span>

-   <span data-ttu-id="1dab1-1691">32 little endian 字节顺序： FF FE 00 00</span><span class="sxs-lookup"><span data-stu-id="1dab1-1691">UTF-32 little endian byte order: FF FE 00 00</span></span>

 <span data-ttu-id="1dab1-1692">你应使用 BOM，因为它为 <xref:System.Text.Encoding> 其他的文件的编码提供了几乎特定的标识，例如，在业务不具有国际顾虑或其他数据时存储的未标记或标记的 web 数据或随机文本文件。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1692">You should use the BOM, because it provides nearly certain identification of an encoding for files that otherwise have lost reference to the <xref:System.Text.Encoding> object, for example, untagged or improperly tagged web data or random text files stored when a business did not have international concerns or other data.</span></span> <span data-ttu-id="1dab1-1693">如果数据一致且标记正确（最好是 UTF-8 或 UTF-16），通常可以避免用户问题。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1693">Often user problems might be avoided if data is consistently and properly tagged, preferably in UTF-8 or UTF-16.</span></span>

 <span data-ttu-id="1dab1-1694">对于提供编码类型的标准，BOM 有些多余。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1694">For standards that provide an encoding type, a BOM is somewhat redundant.</span></span> <span data-ttu-id="1dab1-1695">但是，可以使用它来帮助服务器发送正确的编码标头。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1695">However, it can be used to help a server send the correct encoding header.</span></span> <span data-ttu-id="1dab1-1696">或者，它可以用作回退，以防编码在其他情况下丢失。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1696">Alternatively, it can be used as a fallback in case the encoding is otherwise lost.</span></span>

 <span data-ttu-id="1dab1-1697">使用 BOM 存在一些缺点。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1697">There are some disadvantages to using a BOM.</span></span> <span data-ttu-id="1dab1-1698">例如，了解如何限制使用 BOM 的数据库字段可能很困难。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1698">For example, knowing how to limit the database fields that use a BOM can be difficult.</span></span> <span data-ttu-id="1dab1-1699">文件的串联可能也是一个问题，例如，当文件以这样一种方式进行合并时，不需要的字符会在数据中间结束。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1699">Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data.</span></span> <span data-ttu-id="1dab1-1700">但尽管有几个缺点，但强烈建议使用 BOM。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1700">In spite of the few disadvantages, however, the use of a BOM is highly recommended.</span></span>

 <span data-ttu-id="1dab1-1701">有关字节顺序和字节顺序标记的详细信息，请参阅[unicode 主页](https://go.microsoft.com/fwlink/?LinkId=37123)上的 unicode 标准。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1701">For more information on byte order and the byte order mark, see The Unicode Standard at the [Unicode home page](https://go.microsoft.com/fwlink/?LinkId=37123).</span></span>

> [!CAUTION]
>  <span data-ttu-id="1dab1-1702">若要确保编码的字节解码正确，应使用前导码作为编码字节的前缀。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1702">To ensure that the encoded bytes are decoded properly, you should prefix encoded bytes with a preamble.</span></span> <span data-ttu-id="1dab1-1703">但是，大多数编码不提供前导码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1703">However, most encodings do not provide a preamble.</span></span> <span data-ttu-id="1dab1-1704">若要确保已编码的字节解码正确，应使用 Unicode 编码，即 <xref:System.Text.UTF8Encoding>、<xref:System.Text.UnicodeEncoding>或 <xref:System.Text.UTF32Encoding>，使用前导码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1704">To ensure that the encoded bytes are decoded properly, you should use a Unicode encoding, that is, <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, or <xref:System.Text.UTF32Encoding>, with a preamble.</span></span>



## Examples
 <span data-ttu-id="1dab1-1705">下面的示例根据前导头确定编码的字节顺序。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1705">The following example determines the byte order of the encoding based on the preamble.</span></span>

 [!code-cpp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]
 [!code-vb[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1dab1-1706">在派生类中重写时，将一个字节序列解码为一个字符串。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1706">When overridden in a derived class, decodes a sequence of bytes into a string.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] -&gt; string&#xA;override this.GetString : byte[] -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1dab1-1707">包含要解码的字节序列的字节数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1707">The byte array containing the sequence of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="1dab1-1708">在派生类中重写时，将指定字节数组中的所有字节解码为一个字符串。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1708">When overridden in a derived class, decodes all the bytes in the specified byte array into a string.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1709">包含指定字节序列解码结果的字符串。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1709">A string that contains the results of decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1710">如果要转换的数据仅适用于连续块（如从流中读取的数据），或者如果数据量很大以致需要分为更小块，则应使用派生类的 <xref:System.Text.Encoding.GetDecoder%2A> 方法返回的 <xref:System.Text.Decoder> 对象。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1710">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> object returned by the <xref:System.Text.Encoding.GetDecoder%2A> method of a derived class.</span></span>

 <span data-ttu-id="1dab1-1711">请参阅 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 参考主题的 "备注" 部分，了解解码方法和注意事项。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1711">See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> reference topic for a discussion of decoding techniques and considerations.</span></span>

 <span data-ttu-id="1dab1-1712">请注意，<xref:System.Text.Encoding.GetString%2A> 方法对于特定 <xref:System.Text.Encoding> 实现的确切行为取决于为该 <xref:System.Text.Encoding> 对象定义的回退策略。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1712">Note that the precise behavior of the <xref:System.Text.Encoding.GetString%2A> method for a particular <xref:System.Text.Encoding> implementation depends on the fallback strategy defined for that <xref:System.Text.Encoding> object.</span></span> <span data-ttu-id="1dab1-1713">有关详细信息，请参阅[.net 中的字符编码](/dotnet/standard/base-types/character-encoding)主题的 "选择回退策略" 部分。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1713">For more information, see the "Choosing a Fallback Strategy" section of the [Character Encoding in .NET](/dotnet/standard/base-types/character-encoding) topic.</span></span>



## Examples
 <span data-ttu-id="1dab1-1714">下面的示例从 <xref:System.IO.FileStream> 对象表示的二进制文件中读取 UTF-8 编码的字符串。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1714">The following example reads a UTF-8 encoded string from a binary file represented by a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="1dab1-1715">对于小于2048个字节的文件，它会将整个文件的内容读入一个字节数组，并调用 <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> 方法来执行解码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1715">For files that are smaller than 2,048 bytes, it reads the contents of the entire file into a byte array and calls the <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> method to perform the decoding.</span></span> <span data-ttu-id="1dab1-1716">对于较大的文件，它一次读取到字节数组中的2048个字节，调用 <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 方法来确定数组中包含的字符数，然后调用 <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> 方法来执行解码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1716">For larger files, it reads 2,048 bytes at a time into a byte array, calls the <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to determine how many characters are contained in the array, and then calls the <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> method to perform the decoding.</span></span>

 [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]

 <span data-ttu-id="1dab1-1717">该示例使用以下文本，该文本应保存到名为 Utf8Example 的 UTF-8 编码文件中。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1717">The example uses the following text, which should be saved to a UTF-8 encoded file named Utf8Example.txt.</span></span>

```

This is a UTF-8-encoded file that contains primarily Latin text, although it
does list the first twelve letters of the Russian (Cyrillic) alphabet:

А б в г д е ё ж з и й к

The goal is to save this file, then open and decode it as a binary stream.

```

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1dab1-1718">字节数组中包含无效的 Unicode 码位。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1718">The byte array contains invalid Unicode code points.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1dab1-1719"><paramref name="bytes" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1719"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1dab1-1720">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1720">A fallback occurred (for more information, see <see href="/dotnet/standard/base-types/character-encoding">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1dab1-1721">和</span><span class="sxs-lookup"><span data-stu-id="1dab1-1721">-and-</span></span>

 <span data-ttu-id="1dab1-1722"><see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1722"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString (bytes As ReadOnlySpan(Of Byte)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="member this.GetString : ReadOnlySpan&lt;byte&gt; -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1dab1-1723">要解码为 Unicode 字符串的只读字节范围。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1723">A read-only byte span to decode to a Unicode string.</span></span></param>
        <summary><span data-ttu-id="1dab1-1724">在派生类中重写时，将指定字节范围中的所有字节解码为一个字符串。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1724">When overridden in a derived class, decodes all the bytes in the specified byte span into a string.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1725">一个字符串，其中包含提供的只读范围中的已解码字节。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1725">A string that contains the decoded bytes from the provided read-only span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1726"><xref:System.Text.Encoding.GetString%2A> 方法旨在优化性能。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1726">The <xref:System.Text.Encoding.GetString%2A> method is designed to optimize performance.</span></span> <span data-ttu-id="1dab1-1727">可以改为调用此方法而无需创建任何中间对象，而不是先创建托管字节数组再对其进行解码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1727">Instead of creating a managed byte array and then decoding it, you can instead call this method without having to create any intermediate objects.</span></span>

 <span data-ttu-id="1dab1-1728">如果要转换的数据仅适用于连续块（如从流中读取的数据），或者如果数据量很大以致需要分为更小块，则应使用派生类的 <xref:System.Text.Encoding.GetDecoder%2A> 方法返回的 <xref:System.Text.Decoder> 对象。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1728">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> object returned by the <xref:System.Text.Encoding.GetDecoder%2A> method of a derived class.</span></span>

 <span data-ttu-id="1dab1-1729">请参阅 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 参考主题的 "备注" 部分，了解解码方法和注意事项。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1729">See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> reference topic for a discussion of decoding techniques and considerations.</span></span>

 <span data-ttu-id="1dab1-1730">请注意，<xref:System.Text.Encoding.GetString%2A> 方法对于特定 <xref:System.Text.Encoding> 实现的确切行为取决于为该 <xref:System.Text.Encoding> 对象定义的回退策略。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1730">Note that the precise behavior of the <xref:System.Text.Encoding.GetString%2A> method for a particular <xref:System.Text.Encoding> implementation depends on the fallback strategy defined for that <xref:System.Text.Encoding> object.</span></span> <span data-ttu-id="1dab1-1731">有关详细信息，请参阅[.net 中的字符编码](/dotnet/standard/base-types/character-encoding)主题的 "选择回退策略" 部分。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1731">For more information, see the "Choosing a Fallback Strategy" section of the [Character Encoding in .NET](/dotnet/standard/base-types/character-encoding) topic.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="member this.GetString : nativeptr&lt;byte&gt; * int -&gt; string" Usage="encoding.GetString (bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1dab1-1732">指向字节数组的指针。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1732">A pointer to a byte array.</span></span></param>
        <param name="byteCount"><span data-ttu-id="1dab1-1733">要解码的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1733">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="1dab1-1734">在派生类中重写时，将在指定地址开始的指定字节数解码为字符串。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1734">When overridden in a derived class, decodes a specified number of bytes starting at a specified address into a string.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1735">包含指定字节序列解码结果的字符串。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1735">A string that contains the results of decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1736">当你具有指向字节数组的本机指针时，<xref:System.Text.Encoding.GetString%2A> 方法旨在优化性能。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1736">The <xref:System.Text.Encoding.GetString%2A> method is designed to optimize performance when you have a native pointer to a byte array.</span></span> <span data-ttu-id="1dab1-1737">可以改为调用此方法而无需创建任何中间对象，而不是先创建托管字节数组再对其进行解码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1737">Instead of creating a managed byte array and then decoding it, you can instead call this method without having to create any intermediate objects.</span></span>

 <span data-ttu-id="1dab1-1738">如果要转换的数据仅适用于连续块（如从流中读取的数据），或者如果数据量很大以致需要分为更小块，则应使用派生类的 <xref:System.Text.Encoding.GetDecoder%2A> 方法返回的 <xref:System.Text.Decoder> 对象。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1738">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> object returned by the <xref:System.Text.Encoding.GetDecoder%2A> method of a derived class.</span></span>

 <span data-ttu-id="1dab1-1739">请参阅 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 参考主题的 "备注" 部分，了解解码方法和注意事项。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1739">See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> reference topic for a discussion of decoding techniques and considerations.</span></span>

 <span data-ttu-id="1dab1-1740">请注意，<xref:System.Text.Encoding.GetString%2A> 方法对于特定 <xref:System.Text.Encoding> 实现的确切行为取决于为该 <xref:System.Text.Encoding> 对象定义的回退策略。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1740">Note that the precise behavior of the <xref:System.Text.Encoding.GetString%2A> method for a particular <xref:System.Text.Encoding> implementation depends on the fallback strategy defined for that <xref:System.Text.Encoding> object.</span></span> <span data-ttu-id="1dab1-1741">有关详细信息，请参阅[.net 中的字符编码](/dotnet/standard/base-types/character-encoding)主题的 "选择回退策略" 部分。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1741">For more information, see the "Choosing a Fallback Strategy" section of the [Character Encoding in .NET](/dotnet/standard/base-types/character-encoding) topic.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1dab1-1742"><paramref name="bytes" /> 为 null 指针。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1742"><paramref name="bytes" /> is a null pointer.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1dab1-1743"><paramref name="byteCount" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1743"><paramref name="byteCount" /> is less than zero.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1dab1-1744">发生了回退（如需完整说明，请参阅 <see href="/dotnet/standard/base-types/character-encoding">.NET 中的字符编码</see>）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1744">A fallback occurred (see <see href="/dotnet/standard/base-types/character-encoding">Character Encoding in .NET</see>) for a complete explanation)</span></span>

<span data-ttu-id="1dab1-1745">和</span><span class="sxs-lookup"><span data-stu-id="1dab1-1745">-and-</span></span>

 <span data-ttu-id="1dab1-1746"><see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1746"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] * int * int -&gt; string&#xA;override this.GetString : byte[] * int * int -&gt; string" Usage="encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1dab1-1747">包含要解码的字节序列的字节数组。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1747">The byte array containing the sequence of bytes to decode.</span></span></param>
        <param name="index"><span data-ttu-id="1dab1-1748">第一个要解码的字节的索引。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1748">The index of the first byte to decode.</span></span></param>
        <param name="count"><span data-ttu-id="1dab1-1749">要解码的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1749">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="1dab1-1750">在派生类中重写时，将指定字节数组中的一个字节序列解码为一个字符串。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1750">When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a string.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1751">包含指定字节序列解码结果的字符串。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1751">A string that contains the results of decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1752">如果要转换的数据仅适用于连续块（如从流中读取的数据），或者如果数据量很大以致需要分为更小块，则应使用派生类的 <xref:System.Text.Encoding.GetDecoder%2A> 方法或 <xref:System.Text.Encoding.GetEncoder%2A> 方法提供的 <xref:System.Text.Decoder> 或 <xref:System.Text.Encoder>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1752">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="1dab1-1753">请参阅 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 参考主题的 "备注" 部分，了解解码方法和注意事项。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1753">See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> reference topic for a discussion of decoding techniques and considerations.</span></span>



## Examples
 <span data-ttu-id="1dab1-1754">下面的示例从由 <xref:System.IO.FileStream> 对象表示的二进制文件中读取 UTF-8 编码的字符串。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1754">The following example reads a UTF-8 encoded string from a binary file that is represented by a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="1dab1-1755">对于小于2048个字节的文件，它会将整个文件的内容读入一个字节数组，并调用 <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 方法来执行解码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1755">For files that are smaller than 2,048 bytes, it reads the contents of the entire file into a byte array and calls the <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method to perform the decoding.</span></span> <span data-ttu-id="1dab1-1756">对于较大的文件，它一次读取到字节数组中的2048个字节，调用 <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 方法来确定数组中包含的字符数，然后调用 <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> 方法来执行解码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1756">For larger files, it reads 2,048 bytes at a time into a byte array, calls the <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to determine how many characters are contained in the array, and then calls the <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> method to perform the decoding.</span></span>

 [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]

 <span data-ttu-id="1dab1-1757">该示例使用以下文本，该文本应保存到名为 Utf8Example 的 UTF-8 编码文件中。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1757">The example uses the following text, which should be saved to a UTF-8 encoded file named Utf8Example.txt.</span></span>

```

This is a UTF-8-encoded file that contains primarily Latin text, although it
does list the first twelve letters of the Russian (Cyrillic) alphabet:

А б в г д е ё ж з и й к

The goal is to save this file, then open and decode it as a binary stream.

```

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1dab1-1758">字节数组中包含无效的 Unicode 码位。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1758">The byte array contains invalid Unicode code points.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1dab1-1759"><paramref name="bytes" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1759"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1dab1-1760"><paramref name="index" /> 或 <paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1760"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span>

<span data-ttu-id="1dab1-1761">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1dab1-1761">-or-</span></span>

 <span data-ttu-id="1dab1-1762"><paramref name="index" /> 和 <paramref name="count" /> 不表示 <paramref name="bytes" /> 中的有效范围。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1762"><paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1dab1-1763">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1763">A fallback occurred (for more information, see <see href="/dotnet/standard/base-types/character-encoding">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1dab1-1764">和</span><span class="sxs-lookup"><span data-stu-id="1dab1-1764">-and-</span></span>

 <span data-ttu-id="1dab1-1765"><see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1765"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HeaderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HeaderName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HeaderName : string" Usage="System.Text.Encoding.HeaderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1dab1-1766">在派生类中重写时，获取可与邮件代理头标记一起使用的当前编码的名称。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1766">When overridden in a derived class, gets a name for the current encoding that can be used with mail agent header tags.</span></span></summary>
        <value><span data-ttu-id="1dab1-1767">与邮件代理头标记一起使用的当前 <see cref="T:System.Text.Encoding" /> 的名称。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1767">A name for the current <see cref="T:System.Text.Encoding" /> to use with mail agent header tags.</span></span>

<span data-ttu-id="1dab1-1768">- 或 -</span><span class="sxs-lookup"><span data-stu-id="1dab1-1768">-or-</span></span>

<span data-ttu-id="1dab1-1769">如果当前 <see cref="T:System.Text.Encoding" /> 无法使用，则为空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1769">An empty string (""), if the current <see cref="T:System.Text.Encoding" /> cannot be used.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1770">如果需要标头名称的编码，则应使用 <xref:System.Text.Encoding.HeaderName%2A> 属性调用 <xref:System.Text.Encoding.GetEncoding%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1770">If you need an encoding for a header name, you should call the <xref:System.Text.Encoding.GetEncoding%2A> method with the <xref:System.Text.Encoding.HeaderName%2A> property.</span></span> <span data-ttu-id="1dab1-1771">通常，方法从调用中提供的测试编码检索不同的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1771">Often the method retrieves a different encoding from the test encoding furnished in the call.</span></span> <span data-ttu-id="1dab1-1772">通常，只有电子邮件应用程序需要检索这种编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1772">Generally only email applications need to retrieve such an encoding.</span></span>

 <span data-ttu-id="1dab1-1773">在某些情况下，<xref:System.Text.Encoding.BodyName%2A> 属性的值对应于定义该编码的国际标准。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1773">In some cases, the value of the <xref:System.Text.Encoding.BodyName%2A> property corresponds to the international standard that defines that encoding.</span></span> <span data-ttu-id="1dab1-1774">这并不意味着实现完全符合该标准。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1774">This doesn't mean that the implementation complies in full with that standard.</span></span>

 <span data-ttu-id="1dab1-1775">请注意，<xref:System.Text.Encoding.WebName%2A> 返回用于描述编码的名称。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1775">Note that <xref:System.Text.Encoding.WebName%2A> returns the name to use to describe an encoding.</span></span> <span data-ttu-id="1dab1-1776">例如，<xref:System.Text.Encoding.HeaderName%2A> 属性定义了另一种可能更适用于电子邮件应用程序的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1776">The <xref:System.Text.Encoding.HeaderName%2A> property defines a different encoding that might work better for an email application, for example.</span></span> <span data-ttu-id="1dab1-1777">但是，不建议使用属性来定义编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1777">However, use of the property to define the encoding is not recommended.</span></span>



## Examples
 <span data-ttu-id="1dab1-1778">下面的示例将检索每个编码的不同名称，并显示包含一个或多个名称不同于 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1778">The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1dab1-1779">它会显示 <xref:System.Text.Encoding.EncodingName%2A>，但不会对其进行比较。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1779">It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.</span></span>

 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAlwaysNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1dab1-1780">获取一个值，该值指示当前编码是否始终被规范化。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1780">Gets a value indicating whether the current encoding is always normalized.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAlwaysNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAlwaysNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsAlwaysNormalized : unit -&gt; bool" Usage="encoding.IsAlwaysNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1dab1-1781">使用默认范式获取一个值，该值指示当前编码是否始终被规范化。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1781">Gets a value indicating whether the current encoding is always normalized, using the default normalization form.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1782">如果当前 <see cref="T:System.Text.Encoding" /> 始终被规范化，则为 <see langword="true" />；否则，为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1782"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> is always normalized; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="1dab1-1783">默认为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1783">The default is <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1784">默认范式为 <xref:System.Text.NormalizationForm.FormC>，使用完全规范分解，然后将序列替换为其主复合（如果可能）。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1784">The default normalization form is <xref:System.Text.NormalizationForm.FormC>, which uses full canonical decomposition, followed by the replacement of sequences with their primary composites, if possible.</span></span>

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAlwaysNormalized (form As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAlwaysNormalized(System::Text::NormalizationForm form);" />
      <MemberSignature Language="F#" Value="abstract member IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool&#xA;override this.IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool" Usage="encoding.IsAlwaysNormalized form" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="form"><span data-ttu-id="1dab1-1785"><see cref="T:System.Text.NormalizationForm" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1785">One of the <see cref="T:System.Text.NormalizationForm" /> values.</span></span></param>
        <summary><span data-ttu-id="1dab1-1786">在派生类中重写时，使用指定范式获取一个值，该值指示当前编码是否始终被规范化。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1786">When overridden in a derived class, gets a value indicating whether the current encoding is always normalized, using the specified normalization form.</span></span></summary>
        <returns><span data-ttu-id="1dab1-1787">如果始终使用指定的 <see langword="true" /> 值规范化当前 <see cref="T:System.Text.Encoding" /> 对象，则为 <see cref="T:System.Text.NormalizationForm" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1787"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> object is always normalized using the specified <see cref="T:System.Text.NormalizationForm" /> value; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="1dab1-1788">默认为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1788">The default is <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1789">默认范式为 <xref:System.Text.NormalizationForm.FormC>，使用完全规范分解，然后将序列替换为其主复合（如果可能）。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1789">The default normalization form is <xref:System.Text.NormalizationForm.FormC>, which uses full canonical decomposition, followed by the replacement of sequences with their primary composites, if possible.</span></span>

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserDisplay : bool" Usage="System.Text.Encoding.IsBrowserDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1dab1-1790">在派生类中重写时，获取一个值，该值指示浏览器客户端是否可以使用当前的编码显示内容。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1790">When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for displaying content.</span></span></summary>
        <value><span data-ttu-id="1dab1-1791">如果浏览器客户端可以使用当前的 <see cref="T:System.Text.Encoding" /> 显示内容，则为 <see langword="true" />；否则，为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1791"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> can be used by browser clients for displaying content; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 <span data-ttu-id="1dab1-1792">下面的示例检查每个编码的布尔值属性的值。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1792">The following example checks the values of the Boolean properties of each encoding.</span></span>

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserSave" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserSave : bool" Usage="System.Text.Encoding.IsBrowserSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1dab1-1793">在派生类中重写时，获取一个值，该值指示浏览器客户端是否可以使用当前的编码保存内容。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1793">When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for saving content.</span></span></summary>
        <value><span data-ttu-id="1dab1-1794">如果浏览器客户端可以使用当前的 <see cref="T:System.Text.Encoding" /> 保存内容，则为 <see langword="true" />；否则，为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1794"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> can be used by browser clients for saving content; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 <span data-ttu-id="1dab1-1795">下面的示例检查每个编码的布尔值属性的值。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1795">The following example checks the values of the Boolean properties of each encoding.</span></span>

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsDisplay : bool" Usage="System.Text.Encoding.IsMailNewsDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1dab1-1796">在派生类中重写时，获取一个值，该值指示邮件和新闻客户端是否可以使用当前的编码显示内容。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1796">When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for displaying content.</span></span></summary>
        <value><span data-ttu-id="1dab1-1797">如果邮件和新闻客户端可以使用当前的 <see cref="T:System.Text.Encoding" /> 显示内容，则为 <see langword="true" />；否则，为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1797"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> can be used by mail and news clients for displaying content; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 <span data-ttu-id="1dab1-1798">下面的示例检查每个编码的布尔值属性的值。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1798">The following example checks the values of the Boolean properties of each encoding.</span></span>

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsSave : bool" Usage="System.Text.Encoding.IsMailNewsSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1dab1-1799">在派生类中重写时，获取一个值，该值指示邮件和新闻客户端是否可以使用当前的编码保存内容。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1799">When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for saving content.</span></span></summary>
        <value><span data-ttu-id="1dab1-1800">如果邮件和新闻客户端可以使用当前 <see langword="true" /> 保存内容，则为 <see cref="T:System.Text.Encoding" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1800"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> can be used by mail and news clients for saving content; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 <span data-ttu-id="1dab1-1801">下面的示例检查每个编码的布尔值属性的值。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1801">The following example checks the values of the Boolean properties of each encoding.</span></span>

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsSave" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Text.Encoding.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1dab1-1802">在派生类中重写时，获取一个值，该值指示当前的编码是否为只读。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1802">When overridden in a derived class, gets a value indicating whether the current encoding is read-only.</span></span></summary>
        <value><span data-ttu-id="1dab1-1803">如果当前 <see langword="true" /> 为只读，则为 <see cref="T:System.Text.Encoding" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1803"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> is read-only; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="1dab1-1804">默认为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1804">The default is <see langword="true" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSingleByte As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSingleByte { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSingleByte : bool" Usage="System.Text.Encoding.IsSingleByte" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1dab1-1805">在派生类中重写时，获取一个值，该值指示当前的编码是否使用单字节码位。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1805">When overridden in a derived class, gets a value indicating whether the current encoding uses single-byte code points.</span></span></summary>
        <value><span data-ttu-id="1dab1-1806">如果当前 <see langword="true" /> 使用单字节码位，则为 <see cref="T:System.Text.Encoding" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1806"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> uses single-byte code points; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1807">对于单字节编码，例如 <xref:System.Text.ASCIIEncoding>，此属性检索 `true`。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1807">For a single-byte encoding, for example, <xref:System.Text.ASCIIEncoding>, this property retrieves `true`.</span></span>

> [!CAUTION]
>  <span data-ttu-id="1dab1-1808">在应用程序中，应小心处理 <xref:System.Text.Encoding.IsSingleByte%2A>的值。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1808">You should be careful in what your application does with the value for <xref:System.Text.Encoding.IsSingleByte%2A>.</span></span> <span data-ttu-id="1dab1-1809">如何进行编码的假设仍可能是错误的。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1809">An assumption of how an Encoding will proceed may still be wrong.</span></span> <span data-ttu-id="1dab1-1810">例如，Windows-1252 的值为 `true` <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>，但 GetMaxByteCount （1）返回2。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1810">For example, Windows-1252 has a value of `true` for <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>, but Encoding.GetMaxByteCount(1) returns 2.</span></span> <span data-ttu-id="1dab1-1811">这是因为该方法会考虑以前的解码器操作的潜在遗留代理项。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1811">This is because the method considers potential leftover surrogates from a previous decoder operation.</span></span>



## Examples
 <span data-ttu-id="1dab1-1812">下面的示例检查每个编码的布尔值属性的值。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1812">The following example checks the values of the Boolean properties of each encoding.</span></span>

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public virtual ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.Encoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1dab1-1813">在派生类中重写时，返回包含指定所用编码的字节序列的范围。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1813">When overridden in a derived class, returns a span containing the sequence of bytes that specifies the encoding used.</span></span></summary>
        <value><span data-ttu-id="1dab1-1814">包含指定所用编码的字节序列的字节范围，如果不需要报头，则为长度为零的范围。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1814">A byte span containing a sequence of bytes that specifies the encoding used, or a span of length zero, if a preamble is not required.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1815">（可选） <xref:System.Text.Encoding> 对象提供了前导码，它是一个字节序列，可以作为编码过程中所产生的字节的前缀。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1815">Optionally, the <xref:System.Text.Encoding> object provides a preamble that is an sequence of bytes that can be prefixed to the bytes resulting from the encoding process.</span></span> <span data-ttu-id="1dab1-1816">如果引言包含字节顺序标记（在 Unicode、码位 U + FEFF 中），则它有助于解码器确定字节顺序和转换格式或 UTF。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1816">If the preamble contains a byte order mark (in Unicode, code point U+FEFF), it helps the decoder determine the byte order and the transformation format or UTF.</span></span>

 <span data-ttu-id="1dab1-1817">Unicode 字节顺序标记（BOM）按以下方式序列化（十六进制）：</span><span class="sxs-lookup"><span data-stu-id="1dab1-1817">The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal):</span></span>

-   <span data-ttu-id="1dab1-1818">UTF-8： EF BB BF</span><span class="sxs-lookup"><span data-stu-id="1dab1-1818">UTF-8: EF BB BF</span></span>

-   <span data-ttu-id="1dab1-1819">UTF-16 大 endian 字节顺序： FE FF</span><span class="sxs-lookup"><span data-stu-id="1dab1-1819">UTF-16 big endian byte order: FE FF</span></span>

-   <span data-ttu-id="1dab1-1820">UTF-16 little endian 字节顺序： FF FE</span><span class="sxs-lookup"><span data-stu-id="1dab1-1820">UTF-16 little endian byte order: FF FE</span></span>

-   <span data-ttu-id="1dab1-1821">32大 endian 字节顺序： 00 00 FE FF</span><span class="sxs-lookup"><span data-stu-id="1dab1-1821">UTF-32 big endian byte order: 00 00 FE FF</span></span>

-   <span data-ttu-id="1dab1-1822">32 little endian 字节顺序： FF FE 00 00</span><span class="sxs-lookup"><span data-stu-id="1dab1-1822">UTF-32 little endian byte order: FF FE 00 00</span></span>

 <span data-ttu-id="1dab1-1823">你应使用 BOM，因为它为 <xref:System.Text.Encoding> 其他的文件的编码提供了几乎特定的标识，例如，在业务不具有国际顾虑或其他数据时存储的未标记或标记的 web 数据或随机文本文件。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1823">You should use the BOM, because it provides nearly certain identification of an encoding for files that otherwise have lost reference to the <xref:System.Text.Encoding> object, for example, untagged or improperly tagged web data or random text files stored when a business did not have international concerns or other data.</span></span> <span data-ttu-id="1dab1-1824">如果数据一致且标记正确（最好是 UTF-8 或 UTF-16），通常可以避免用户问题。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1824">Often user problems might be avoided if data is consistently and properly tagged, preferably in UTF-8 or UTF-16.</span></span>

 <span data-ttu-id="1dab1-1825">对于提供编码类型的标准，BOM 有些多余。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1825">For standards that provide an encoding type, a BOM is somewhat redundant.</span></span> <span data-ttu-id="1dab1-1826">但是，可以使用它来帮助服务器发送正确的编码标头。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1826">However, it can be used to help a server send the correct encoding header.</span></span> <span data-ttu-id="1dab1-1827">或者，它可以用作回退，以防编码在其他情况下丢失。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1827">Alternatively, it can be used as a fallback in case the encoding is otherwise lost.</span></span>

 <span data-ttu-id="1dab1-1828">使用 BOM 存在一些缺点。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1828">There are some disadvantages to using a BOM.</span></span> <span data-ttu-id="1dab1-1829">例如，了解如何限制使用 BOM 的数据库字段可能很困难。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1829">For example, knowing how to limit the database fields that use a BOM can be difficult.</span></span> <span data-ttu-id="1dab1-1830">文件的串联可能也是一个问题，例如，当文件以这样一种方式进行合并时，不需要的字符会在数据中间结束。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1830">Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data.</span></span> <span data-ttu-id="1dab1-1831">尽管有几个缺点，但强烈建议使用 BOM。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1831">Despite the few disadvantages, however, the use of a BOM is highly recommended.</span></span>

 <span data-ttu-id="1dab1-1832">有关字节顺序和字节顺序标记的详细信息，请参阅[unicode 主页](https://home.unicode.org/)上的 unicode 标准。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1832">For more information on byte order and the byte order mark, see The Unicode Standard at the [Unicode home page](https://home.unicode.org/).</span></span>

> [!CAUTION]
>  <span data-ttu-id="1dab1-1833">若要确保编码的字节解码正确，应使用前导码作为编码字节的前缀。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1833">To ensure that the encoded bytes are decoded properly, you should prefix encoded bytes with a preamble.</span></span> <span data-ttu-id="1dab1-1834">但是，大多数编码不提供前导码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1834">However, most encodings do not provide a preamble.</span></span> <span data-ttu-id="1dab1-1835">若要确保已编码的字节解码正确，应使用 Unicode 编码，即 <xref:System.Text.UTF8Encoding>、<xref:System.Text.UnicodeEncoding>或 <xref:System.Text.UTF32Encoding>，使用前导码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1835">To ensure that the encoded bytes are decoded properly, you should use a Unicode encoding, that is, <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, or <xref:System.Text.UTF32Encoding>, with a preamble.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterProvider (provider As EncodingProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterProvider(System::Text::EncodingProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member RegisterProvider : System.Text.EncodingProvider -&gt; unit" Usage="System.Text.Encoding.RegisterProvider provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="1dab1-1836">提供对其他字符编码的访问权限的 <see cref="T:System.Text.EncodingProvider" /> 的子类。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1836">A subclass of <see cref="T:System.Text.EncodingProvider" /> that provides access to additional character encodings.</span></span></param>
        <summary><span data-ttu-id="1dab1-1837">注册编码提供程序。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1837">Registers an encoding provider.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1838">利用 <xref:System.Text.Encoding.RegisterProvider%2A> 方法，你可以注册派生自 <xref:System.Text.EncodingProvider> 的类，使字符编码在不支持它们的平台上可用。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1838">The <xref:System.Text.Encoding.RegisterProvider%2A> method allows you to register a class derived from <xref:System.Text.EncodingProvider> that makes character encodings available on a platform that does not otherwise support them.</span></span> <span data-ttu-id="1dab1-1839">注册编码提供程序后，可通过调用任何 <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> 重载来检索它支持的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1839">Once the encoding provider is registered, the encodings that it supports can be retrieved by calling any <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> overload.</span></span> <span data-ttu-id="1dab1-1840">如果有多个编码提供程序，<xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> 方法将尝试从每个提供程序检索指定的编码，并从最近注册的提供程序开始。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1840">If there are multiple encoding providers, the <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> method attempts to retrieve a specified encoding from each provider starting with the one most recently registered.</span></span>

<span data-ttu-id="1dab1-1841">使用 <xref:System.Text.Encoding.RegisterProvider%2A> 方法注册编码提供程序还会在传递 `0`的参数时，修改[encoding.getencoding （int32）](<xref:System.Text.Encoding.GetEncoding(System.Int32)>)和[encoding.getencoding （int32，EncoderFallback，DecoderFallback）](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback))方法的行为：</span><span class="sxs-lookup"><span data-stu-id="1dab1-1841">Registering an encoding provider by using the <xref:System.Text.Encoding.RegisterProvider%2A> method also modifies the behavior of the [Encoding.GetEncoding(Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>) and [EncodingProvider.GetEncoding(Int32, EncoderFallback, DecoderFallback)](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)) methods when passed an argument of `0`:</span></span>

- <span data-ttu-id="1dab1-1842">如果注册的提供程序是 <xref:System.Text.CodePagesEncodingProvider>，则在 Windows 操作系统上运行时，该方法将返回与系统活动代码页匹配的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1842">If the registered provider is the <xref:System.Text.CodePagesEncodingProvider>, the method returns the encoding that matches the system active code page when running on the Windows operating system.</span></span>

- <span data-ttu-id="1dab1-1843">自定义编码提供程序可以选择在其中一个 <xref:System.Text.Encoding.GetEncoding%2A> 方法重载传递 `0`的参数时要返回哪种编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1843">A custom encoding provider can choose which encoding to return when either of these <xref:System.Text.Encoding.GetEncoding%2A> method overloads is passed an argument of `0`.</span></span> <span data-ttu-id="1dab1-1844">提供程序还可以选择不通过让 <xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType> 方法返回 `null`来返回编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1844">The provider can also choose to not return an encoding by having the <xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType> method return `null`.</span></span>

<span data-ttu-id="1dab1-1845">从 .NET Framework 4.6 开始，.NET Framework 包含一个 <xref:System.Text.CodePagesEncodingProvider>的编码提供程序，该提供程序使编码可用，该提供程序在完整 .NET Framework 中提供但在通用 Windows 平台中不可用。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1845">Starting with the .NET Framework 4.6, the .NET Framework includes one encoding provider, <xref:System.Text.CodePagesEncodingProvider>, that makes the encodings available that are present in the full .NET Framework but are not available in the Universal Windows Platform.</span></span> <span data-ttu-id="1dab1-1846">默认情况下，通用 Windows 平台仅支持 Unicode 编码、ASCII 和代码页28591。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1846">By default, the Universal Windows Platform only supports the Unicode encodings, ASCII, and code page 28591.</span></span>

 <span data-ttu-id="1dab1-1847">如果 <xref:System.Text.Encoding.RegisterProvider%2A> 方法的多个调用中使用了相同的编码提供程序，则只有第一个方法调用将注册该提供程序。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1847">If the same encoding provider is used in multiple calls to the <xref:System.Text.Encoding.RegisterProvider%2A> method, only the first method call registers the provider.</span></span> <span data-ttu-id="1dab1-1848">后续调用将被忽略。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1848">Subsequent calls are ignored.</span></span>

 <span data-ttu-id="1dab1-1849">如果调用 <xref:System.Text.Encoding.RegisterProvider%2A> 方法来注册处理相同编码的多个提供程序，则最后一个注册的提供程序将用于所有编码和解码操作。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1849">If the <xref:System.Text.Encoding.RegisterProvider%2A> method is called to register multiple providers that handle the same encoding, the last registered provider is the used for all encoding and decoding operations.</span></span> <span data-ttu-id="1dab1-1850">将忽略任何以前注册的提供程序。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1850">Any previously registered providers are ignored.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1dab1-1851"><paramref name="provider" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1851"><paramref name="provider" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Text.CodePagesEncodingProvider" />
        <altmember cref="T:System.Text.EncodingProvider" />
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Unicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Unicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unicode : System.Text.Encoding" Usage="System.Text.Encoding.Unicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1dab1-1852">获取使用 Little-Endian 字节顺序的 UTF-16 格式的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1852">Gets an encoding for the UTF-16 format using the little endian byte order.</span></span></summary>
        <value><span data-ttu-id="1dab1-1853">使用 Little-Endian 字节顺序的 UTF-16 格式的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1853">An encoding for the UTF-16 format using the little endian byte order.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1854">有关 .NET 支持的编码以及要使用的 Unicode 编码的讨论的信息，请参阅[.net 中的字符编码](/dotnet/standard/base-types/character-encoding)。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1854">For information about the encodings supported by the .NET and a discussion of which Unicode encoding to use, see [Character Encoding in .NET](/dotnet/standard/base-types/character-encoding).</span></span>

 <span data-ttu-id="1dab1-1855">此属性返回的 <xref:System.Text.UnicodeEncoding> 对象可能没有适用于你的应用程序的行为。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1855">The <xref:System.Text.UnicodeEncoding> object that is returned by this property may not have the appropriate behavior for your app.</span></span> <span data-ttu-id="1dab1-1856">它使用替换回退来替换每个不能进行编码的字符串，以及无法使用问号（"？"）字符解码的每个字节。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1856">It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character.</span></span> <span data-ttu-id="1dab1-1857">相反，你可以调用 <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 构造函数来实例化一个 little endian <xref:System.Text.UnicodeEncoding> 对象，该对象的回退为 <xref:System.Text.EncoderFallbackException> 或 <xref:System.Text.DecoderFallbackException>，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1857">Instead, you can call the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor to instantiate a little endian <xref:System.Text.UnicodeEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.</span></span>

 [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]
 [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]



## Examples
 <span data-ttu-id="1dab1-1858">下面的示例确定对字符数组进行编码、对字符进行编码并显示生成的字节所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1858">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="/dotnet/standard/base-types/character-encoding"><span data-ttu-id="1dab1-1859">了解编码</span><span class="sxs-lookup"><span data-stu-id="1dab1-1859">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF32 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF32 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF32 : System.Text.Encoding" Usage="System.Text.Encoding.UTF32" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1dab1-1860">获取使用 Little-Endian 字节顺序的 UTF-32 格式的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1860">Gets an encoding for the UTF-32 format using the little endian byte order.</span></span></summary>
        <value><span data-ttu-id="1dab1-1861">使用 Little-Endian 字节顺序的 UTF-32 格式的编码对象。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1861">An  encoding object for the UTF-32 format using the little endian byte order.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1862">此属性返回的 <xref:System.Text.UTF32Encoding> 对象可能没有适用于你的应用程序的行为。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1862">The <xref:System.Text.UTF32Encoding> object that is returned by this property may not have the appropriate behavior for your app.</span></span> <span data-ttu-id="1dab1-1863">它使用替换回退来替换每个不能进行编码的字符串，以及无法使用 Unicode 替换字符（U + FFFE）解码的每个字节。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1863">It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with the Unicode REPLACEMENT CHARACTER (U+FFFE).</span></span> <span data-ttu-id="1dab1-1864">相反，你可以调用 <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 构造函数来实例化一个 <xref:System.Text.UTF32Encoding> 对象，该对象的回退是 <xref:System.Text.EncoderFallbackException> 或 <xref:System.Text.DecoderFallbackException>，如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1864">Instead, you can call the <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor to instantiate a <xref:System.Text.UTF32Encoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.</span></span>

 [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]
 [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]

 <span data-ttu-id="1dab1-1865">有关 little endian 字节顺序的讨论，请参阅 <xref:System.Text.Encoding> 类主题。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1865">For a discussion of little endian byte order, see the <xref:System.Text.Encoding> class topic.</span></span>

 <span data-ttu-id="1dab1-1866">有关 .NET 支持的编码以及要使用的 Unicode 编码的讨论的信息，请参阅[.net 中的字符编码](/dotnet/standard/base-types/character-encoding)。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1866">For information about the encodings supported by .NET and a discussion of which Unicode encoding to use, see [Character Encoding in .NET](/dotnet/standard/base-types/character-encoding).</span></span>



## Examples
 <span data-ttu-id="1dab1-1867">下面的示例确定对字符数组进行编码、对字符进行编码并显示生成的字节所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1867">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF32Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="/dotnet/standard/base-types/character-encoding"><span data-ttu-id="1dab1-1868">了解编码</span><span class="sxs-lookup"><span data-stu-id="1dab1-1868">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF7 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF7 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF7 : System.Text.Encoding" Usage="System.Text.Encoding.UTF7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1dab1-1869">获取 UTF-7 格式的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1869">Gets an encoding for the UTF-7 format.</span></span></summary>
        <value><span data-ttu-id="1dab1-1870">UTF-7 格式的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1870">An encoding for the UTF-7 format.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1871">UTF-7 编码主要用于在过去限制为7位（如 NNTP 和某些电子邮件应用程序）的环境中。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1871">UTF-7 encoding is used primarily in environments that historically have been restricted to 7 bits, such as NNTP and some email applications.</span></span> <span data-ttu-id="1dab1-1872">由于可靠性和安全性方面的问题，不应在可改用 UTF-8 编码的8位环境中使用 UTF7 编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1872">Because of issues with robustness and security, you should not use UTF7 encoding in 8-bit environments where UTF-8 encoding can be used instead.</span></span>



## Examples
 <span data-ttu-id="1dab1-1873">下面的示例确定对字符数组进行编码、对字符进行编码并显示生成的字节所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1873">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF7Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <related type="Article" href="/dotnet/standard/base-types/character-encoding"><span data-ttu-id="1dab1-1874">了解编码</span><span class="sxs-lookup"><span data-stu-id="1dab1-1874">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF8 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF8 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF8 : System.Text.Encoding" Usage="System.Text.Encoding.UTF8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1dab1-1875">获取 UTF-8 格式的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1875">Gets an encoding for the UTF-8 format.</span></span></summary>
        <value><span data-ttu-id="1dab1-1876">UTF-8 格式的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1876">An encoding for the UTF-8 format.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1877">此属性返回一个 <xref:System.Text.UTF8Encoding> 对象，该对象将 Unicode （UTF-16 编码的）字符编码为每个字符一到四个字节的序列，并将 UTF-8 编码的字节数组解码为 Unicode （UTF-16 编码的）字符。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1877">This property returns a <xref:System.Text.UTF8Encoding> object that encodes Unicode (UTF-16-encoded) characters into a sequence of one to four bytes per character, and that decodes a UTF-8-encoded byte array to Unicode (UTF-16-encoded) characters.</span></span> <span data-ttu-id="1dab1-1878">有关 .NET 支持的字符编码以及要使用的 Unicode 编码的讨论，请参阅[.net 中的字符编码](/dotnet/standard/base-types/character-encoding)。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1878">For information about the character encodings supported by .NET and a discussion of which Unicode encoding to use, see [Character Encoding in .NET](/dotnet/standard/base-types/character-encoding).</span></span>

 <span data-ttu-id="1dab1-1879">此属性返回的 <xref:System.Text.UTF8Encoding> 对象可能没有适用于你的应用程序的行为。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1879">The <xref:System.Text.UTF8Encoding> object that is returned by this property might not have the appropriate behavior for your app.</span></span>

-   <span data-ttu-id="1dab1-1880">它将返回一个提供 Unicode 字节顺序标记（BOM）的 <xref:System.Text.UTF8Encoding> 对象。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1880">It returns a <xref:System.Text.UTF8Encoding> object that provides a Unicode byte order mark (BOM).</span></span> <span data-ttu-id="1dab1-1881">若要实例化不提供 BOM 的 UTF8 编码，请调用 <xref:System.Text.UTF8Encoding.%23ctor%2A> 构造函数的任何重载。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1881">To instantiate a UTF8 encoding that doesn't provide a BOM, call any overload of the <xref:System.Text.UTF8Encoding.%23ctor%2A> constructor.</span></span>

-   <span data-ttu-id="1dab1-1882">它将返回一个 <xref:System.Text.UTF8Encoding> 对象，该对象使用替换回退来替换每个无法编码的字符串，以及无法使用问号（"？"）字符解码的每个字节。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1882">It returns a <xref:System.Text.UTF8Encoding> object that uses replacement fallback to replace each string that it can't encode and each byte that it can't decode with a question mark ("?") character.</span></span> <span data-ttu-id="1dab1-1883">相反，你可以调用 <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 构造函数来实例化一个 <xref:System.Text.UTF8Encoding> 对象，该对象的回退是 <xref:System.Text.EncoderFallbackException> 或 <xref:System.Text.DecoderFallbackException>，如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1883">Instead, you can call the <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor to instantiate a <xref:System.Text.UTF8Encoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.</span></span>

     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]
     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]



## Examples
 <span data-ttu-id="1dab1-1884">下面的示例定义一个包含以下字符的数组：</span><span class="sxs-lookup"><span data-stu-id="1dab1-1884">The following example defines an array that consists of the following characters:</span></span>

-   <span data-ttu-id="1dab1-1885">拉丁文小写字母 Z （U + 007A）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1885">LATIN SMALL LETTER Z (U+007A)</span></span>

-   <span data-ttu-id="1dab1-1886">拉丁文小写字母 A （U + 0061）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1886">LATIN SMALL LETTER A (U+0061)</span></span>

-   <span data-ttu-id="1dab1-1887">组合短音符（U + 0306）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1887">COMBINING BREVE (U+0306)</span></span>

-   <span data-ttu-id="1dab1-1888">拉丁文小写字母 AE WITH 锐音符（U + 01FD）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1888">LATIN SMALL LETTER AE WITH ACUTE (U+01FD)</span></span>

-   <span data-ttu-id="1dab1-1889">希腊文小写字母 BETA （U + 03B2）</span><span class="sxs-lookup"><span data-stu-id="1dab1-1889">GREEK SMALL LETTER BETA (U+03B2)</span></span>

-   <span data-ttu-id="1dab1-1890">构成希腊语 ACROPHONIC 阁楼 1000 STATERS （U + 10154）的代理项对（U + D800 U + DD54）。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1890">A surrogate pair (U+D800 U+DD54) that forms GREEK ACROPHONIC ATTIC ONE THOUSAND STATERS (U+10154).</span></span>

 <span data-ttu-id="1dab1-1891">它显示每个字符的 UTF-16 代码单元，并确定 UTF-8 编码器对字符数组进行编码所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1891">It displays the UTF-16 code units of each character and determines the number of bytes required by a UTF-8 encoder to encode the character array.</span></span> <span data-ttu-id="1dab1-1892">然后，它对字符进行编码，并显示生成的 UTF-8 编码字节。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1892">It then encodes the characters and displays the resulting UTF-8-encoded bytes.</span></span>

 [!code-csharp[System.Text.Encoding.UTF8#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]
 [!code-vb[System.Text.Encoding.UTF8#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF8Encoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="/dotnet/standard/base-types/character-encoding"><span data-ttu-id="1dab1-1893">了解编码</span><span class="sxs-lookup"><span data-stu-id="1dab1-1893">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WebName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ WebName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebName : string" Usage="System.Text.Encoding.WebName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1dab1-1894">在派生类中重写时，获取在 Internet 编号分配管理机构 (IANA) 注册的当前编码的名称。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1894">When overridden in a derived class, gets the name registered with the Internet Assigned Numbers Authority (IANA) for the current encoding.</span></span></summary>
        <value><span data-ttu-id="1dab1-1895">当前 <see cref="T:System.Text.Encoding" /> 的 IANA 名称。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1895">The IANA name for the current <see cref="T:System.Text.Encoding" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1896"><xref:System.Text.Encoding.WebName%2A> 属性与 <xref:System.Text.EncodingInfo.Name%2A> 属性相同。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1896">The <xref:System.Text.Encoding.WebName%2A> property is the same as the <xref:System.Text.EncodingInfo.Name%2A> property.</span></span>

 <span data-ttu-id="1dab1-1897">请注意，<xref:System.Text.Encoding.WebName%2A> 将为编码返回 IANA 注册的名称。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1897">Note that <xref:System.Text.Encoding.WebName%2A> returns an IANA-registered name for the encoding.</span></span> <span data-ttu-id="1dab1-1898">如果其值为标准的名称，则编码的实现可能不会完全符合该标准。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1898">When its value is the name of a standard, the implementation of the encoding might not conform in full to that standard.</span></span> <span data-ttu-id="1dab1-1899"><xref:System.Text.Encoding.HeaderName%2A> 属性定义了另一种可能更适用于电子邮件标头的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1899">The <xref:System.Text.Encoding.HeaderName%2A> property defines a different encoding that might work better for email headers.</span></span> <span data-ttu-id="1dab1-1900">但是，大多数应用程序应改用 <xref:System.Text.Encoding.WebName%2A>。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1900">However, most apps should use <xref:System.Text.Encoding.WebName%2A> instead.</span></span>

 <span data-ttu-id="1dab1-1901">有关 IANA 的详细信息，请参阅[www.iana.org](https://www.iana.org/)。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1901">For more information on the IANA, go to [www.iana.org](https://www.iana.org/).</span></span>

 <span data-ttu-id="1dab1-1902"><xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> 与 <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>返回的 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> 相同。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1902">The <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> is the same as the <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> returned by <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1dab1-1903">某些 web 名称是重复的;有关详细信息，请参阅 <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> 的备注。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1903">Some of the web names are duplicates; see the remarks for <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> for more information.</span></span>



## Examples
 <span data-ttu-id="1dab1-1904">下面的示例将 <xref:System.Text.Encoding.WebName%2A> 包含在 HTML 标头中。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1904">The following example includes the <xref:System.Text.Encoding.WebName%2A> in an HTML header.</span></span>

 [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]

 <span data-ttu-id="1dab1-1905">下面的示例将检索每个编码的不同名称，并显示包含一个或多个名称不同于 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>的编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1905">The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1dab1-1906">它会显示 <xref:System.Text.Encoding.EncodingName%2A>，但不会对其进行比较。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1906">It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.</span></span>

 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WindowsCodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WindowsCodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WindowsCodePage : int" Usage="System.Text.Encoding.WindowsCodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1dab1-1907">在派生类中重写时，获取与当前编码最紧密对应的 Windows 操作系统代码页。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1907">When overridden in a derived class, gets the Windows operating system code page that most closely corresponds to the current encoding.</span></span></summary>
        <value><span data-ttu-id="1dab1-1908">与当前 <see cref="T:System.Text.Encoding" /> 最紧密对应的 Windows 操作系统代码页。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1908">The Windows operating system code page that most closely corresponds to the current <see cref="T:System.Text.Encoding" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1dab1-1909">提供此属性是为了与 Windows 多语言（MLang） Api 兼容，例如确定字体系列。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1909">This property is provided for compatibility with the Windows MultiLanguage (MLang) APIs, for example, in determining font families.</span></span> <span data-ttu-id="1dab1-1910">对于全球化，建议改为使用其中一个 Unicode 编码。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1910">For globalization, using one of the Unicode encodings is recommended instead.</span></span> <span data-ttu-id="1dab1-1911">还建议使用 <xref:System.Text.Encoding.WebName%2A> 而不是 <xref:System.Text.Encoding.WindowsCodePage%2A> 来识别代码页。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1911">It is also recommended to use <xref:System.Text.Encoding.WebName%2A> instead of <xref:System.Text.Encoding.WindowsCodePage%2A> to identify the code page.</span></span>



## Examples
 <span data-ttu-id="1dab1-1912">下面的示例确定与每个编码最紧密对应的 Windows 代码页。</span><span class="sxs-lookup"><span data-stu-id="1dab1-1912">The following example determines the Windows code page that most closely corresponds to each encoding.</span></span>

 [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
      </Docs>
    </Member>
  </Members>
</Type>
