<Type Name="Encoding" FullName="System.Text.Encoding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b5b18e66943eafdd661bc86ff5bee42e12a4ed92" /><Meta Name="ms.sourcegitcommit" Value="13a6cb6fba7e05947f15d8d6cc802703ae9c21d5" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/18/2020" /><Meta Name="ms.locfileid" Value="90786439" /></Metadata><TypeSignature Language="C#" Value="public abstract class Encoding" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Encoding extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoding" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoding abstract" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
  <TypeSignature Language="F#" Value="type Encoding = class" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
  <TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Encoding extends System.Object implements class System.ICloneable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoding&#xA;Implements ICloneable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoding abstract : ICloneable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Encoding = class&#xA;    interface ICloneable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Text.Encoding" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Text.Encoding" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Text.Encoding" FromVersion="4.1.0.0" To="System.Runtime" ToVersion="4.2.0.0" FrameworkAlternate="netcore-2.0" />
    <TypeForwarding From="System.Text.Encoding" FromVersion="4.1.1.0" To="System.Runtime" ToVersion="4.2.1.0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
    <TypeForwarding From="System.Text.Encoding" FromVersion="4.1.2.0" To="System.Runtime" ToVersion="4.2.2.0" FrameworkAlternate="netcore-3.1" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示字符编码。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks

编码是将一组 Unicode 字符转换为一个字节序列的过程。 相反，解码是将编码字节序列转换为一组 Unicode 字符的过程。 有关 Unicode 转换格式（UTFs）和支持的其他编码的信息 <xref:System.Text.Encoding> ，请参阅[.net 中的字符编码](/dotnet/standard/base-types/character-encoding)。

请注意， <xref:System.Text.Encoding> 旨在对 Unicode 字符而不是任意二进制数据（如字节数组）进行操作。 如果必须将任意二进制数据编码为文本，则应使用诸如 uuencode 这样的协议，该协议是由等方法实现的 <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType> 。

.NET 提供类的以下实现 <xref:System.Text.Encoding> 来支持当前的 Unicode 编码和其他编码：

- <xref:System.Text.ASCIIEncoding>将 Unicode 字符编码为单个7位 ASCII 字符。 此编码仅支持 U + 0000 到 U + 007F 之间的字符值。 代码页20127。 还可通过 <xref:System.Text.Encoding.ASCII%2A> 属性获得。

- <xref:System.Text.UTF7Encoding>使用 UTF-7 编码对 Unicode 字符进行编码。 此编码支持所有 Unicode 字符值。 代码页65000。 还可通过 <xref:System.Text.Encoding.UTF7%2A> 属性获得。

- <xref:System.Text.UTF8Encoding>使用 UTF-8 编码对 Unicode 字符进行编码。 此编码支持所有 Unicode 字符值。 代码页65001。 还可通过 <xref:System.Text.Encoding.UTF8%2A> 属性获得。

- <xref:System.Text.UnicodeEncoding>使用 UTF-16 编码对 Unicode 字符进行编码。 支持 little endian 和大型 endian 字节顺序。 还可通过 <xref:System.Text.Encoding.Unicode%2A> 属性和属性获取 <xref:System.Text.Encoding.BigEndianUnicode%2A> 。

- <xref:System.Text.UTF32Encoding>使用 32 UTF-8 编码对 Unicode 字符进行编码。 支持 little endian （代码页12000）和大型 endian （代码页12001）字节顺序。 还可通过 <xref:System.Text.Encoding.UTF32%2A> 属性获得。

<xref:System.Text.Encoding>类主要用于在不同的编码和 Unicode 之间转换。 通常，其中一个派生的 Unicode 类是适用于你的应用程序的正确选择。

使用 <xref:System.Text.Encoding.GetEncoding%2A> 方法可获取其他编码，并调用 <xref:System.Text.Encoding.GetEncodings%2A> 方法来获取所有编码的列表。

### <a name="list-of-encodings"></a>编码列表

下表列出了 .NET 支持的编码。 它列出了每个编码的代码页编号以及编码的 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> 和属性的值 <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> 。 **.NET Framework 支持**、 **.net Core 支持**或 **.net 5.0 及更高版本支持**列中的复选标记指示该 .net 实现本机支持代码页，而不考虑基础平台。 对于 .NET Framework，表中列出的其他编码的可用性取决于操作系统。 对于 .NET Core 和 .NET 5.0 及更高版本，可以通过使用 <xref:System.Text.CodePagesEncodingProvider?displayProperty=nameWithType> 类或从类派生来使用其他编码 <xref:System.Text.EncodingProvider?displayProperty=nameWithType> 。

> [!NOTE]
> <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>属性对应于国际标准的代码页不一定完全符合该标准。

|代码页|“属性”|显示名称|.NET Framework 支持| .NET Core 支持 | .NET 5.0 和更高版本支持 |
|---------|----|------------|----------------------|-------------------|----------------------------|
|37|IBM037|IBM EBCDIC （美国-加拿大）||||
|437|IBM437|OEM 美国||||
|500|IBM500|IBM EBCDIC （国际）||||
|708|ASMO-708|阿拉伯语（ASMO 708）||||
|720|DOS-720|阿拉伯语（DOS）||||
|737|ibm737|希腊语（DOS）||||
|775|ibm775|波罗的语（DOS）||||
|850|ibm850|西欧（DOS）||||
|852|ibm852|中欧语（DOS）||||
|855|IBM855|OEM 西里尔语||||
|857|ibm857|土耳其语（DOS）||||
|858|IBM00858|OEM 多语言拉丁语 I||||
|860|IBM860|葡萄牙语（DOS）||||
|861|ibm861|冰岛语（DOS）||||
|862|DOS-862|希伯来语（DOS）||||
|863|IBM863|加拿大法语（DOS）||||
|864|IBM864|阿拉伯语（864）||||
|865|IBM865|北欧语（DOS）||||
|866|cp866|西里尔语（DOS）||||
|869|ibm869|现代希腊语（DOS）||||
|870|IBM870|IBM EBCDIC （多语言拉丁语-2）||||
|874|windows-874|泰语（Windows）||||
|875|cp875|IBM EBCDIC （现代希腊语）||||
|932|shift_jis|日语 (Shift-JIS)||||
|936|gb2312|简体中文(GB2312)|✓|||
|949|ks_c_5601-1987 年|朝鲜语||||
|950|big5|繁体中文(Big5)||||
|1026|IBM1026|IBM EBCDIC （土耳其拉丁语-5）||||
|1047|IBM01047|IBM 拉丁语-1||||
|1140|IBM01140|IBM EBCDIC （美国-加拿大-欧洲）||||
|1141|IBM01141|IBM EBCDIC （德国-欧洲）||||
|1142|IBM01142|IBM EBCDIC （丹麦-挪威-欧洲）||||
|1143|IBM01143|IBM EBCDIC （芬兰-瑞典-欧洲）||||
|1144|IBM01144|IBM EBCDIC （意大利-欧洲）||||
|1145|IBM01145|IBM EBCDIC （西班牙-欧洲）||||
|1146|IBM01146|IBM EBCDIC （英国-欧洲）||||
|1147|IBM01147|IBM EBCDIC （法国-欧洲）||||
|1148|IBM01148|IBM EBCDIC （国际-欧洲）||||
|1149|IBM01149|IBM EBCDIC （冰岛语-欧洲）||||
|1200|utf-16|Unicode|✓|✓|✓|
|1201|unicodeFFFE|Unicode （大字节序）|✓|✓|✓|
|1250|windows-1250|中欧语（Windows）||||
|1251|windows-1251|西里尔语（Windows）||||
|1252|GB2312|西欧(Windows)|✓||||
|1253|windows-1253|希腊语（Windows）||||
|1254|windows-1254|土耳其语（Windows）||||
|1255|windows-1255|希伯来语（Windows）||||
|1256|windows-1256|阿拉伯语（Windows）||||
|1257|windows-1257|波罗的语（Windows）||||
|1258|windows-1258|越南语（Windows）||||
|1361|Johab|韩语（Johab）||||
|10000|macintosh|西欧（Mac）||||
|10001|x-mac-日语|日语（Mac）||||
|10002|x-mac-chinesetrad|繁体中文（Mac）||||
|10003|x-mac-韩语|朝鲜语(Mac)|✓|||
|10004|x-mac-阿拉伯语|阿拉伯语（Mac）||||
|10005|x-mac-希伯来语|希伯来语（Mac）||||
|10006|x-mac-希腊语|希腊语（Mac）||||
|10007|x-mac-西里尔文|西里尔语（Mac）||||
|10008|x-mac-chinesesimp|简体中文(Mac)|✓|||
|10010|x-mac|罗马尼亚语（Mac）||||
|10017|x-mac-乌克兰语|乌克兰语（Mac）||||
|10021|x-mac-泰语|泰语（Mac）||||
|10029|x-mac-ce|中欧语（Mac）||||
|10079|x-mac-冰岛语|冰岛语（Mac）||||
|10081|x-mac-土耳其语|土耳其语（Mac）||||
|10082|x-mac-克罗地亚语|克罗地亚语（Mac）||||
|12000|utf-32|Unicode （UTF-32）|✓|✓|✓|
|12001|32BE|Unicode （UTF-16 32 大字节序）|✓|✓|✓|
|20000|x-中文-CNS|繁体中文（CNS）||||
|20001|x-cp20001|TCA 台湾||||
|20002|x-中文-Eten|繁体中文（Eten）||||
|20003|x-cp20003|IBM5550 台湾||||
|20004|x-cp20004|TeleText 台湾||||
|20005|x-cp20005|Wang 台湾||||
|20105|x-IA5|西欧（IA5）||||
|20106|x-IA5-德语|德语（IA5）||||
|20107|x IA5-瑞典语|瑞典语（IA5）||||
|20108|x IA5-挪威语|挪威语（IA5）||||
|20127|us-ascii|US-ASCII|✓|✓|✓|
|20261|x-cp20261|不是61||||
|20269|x-cp20269|ISO-6937||||
|20273|IBM273|IBM EBCDIC （德国）||||
|20277|IBM277|IBM EBCDIC （丹麦-挪威）||||
|20278|IBM278|IBM EBCDIC （芬兰-瑞典）||||
|20280|IBM280|IBM EBCDIC （意大利）||||
|20284|IBM284|IBM EBCDIC （西班牙）||||
|20285|IBM285|IBM EBCDIC （英国）||||
|20290|IBM290|IBM EBCDIC （日语片假名）||||
|20297|IBM297|IBM EBCDIC （法国）||||
|20420|IBM420|IBM EBCDIC （阿拉伯语）||||
|20423|IBM423|IBM EBCDIC （希腊语）||||
|20424|IBM424|IBM EBCDIC （希伯来语）||||
|20833|x-EBCDIC-KoreanExtended|IBM EBCDIC （朝鲜语扩展）||||
|20838|IBM-泰语|IBM EBCDIC （泰语）||||
|20866|koi8-ru-r|西里尔语（KOI8-RU-R）||||
|20871|IBM871|IBM EBCDIC （冰岛语）||||
|20880|IBM880|IBM EBCDIC （西里尔语俄语）||||
|20905|IBM905|IBM EBCDIC （土耳其语）||||
|20924|IBM00924|IBM 拉丁语-1||||
|20932|EUC-JP|日语（JIS 0208-1990 和0212-1990）||||
|20936|x-cp20936|简体中文(GB2312-80)|✓|||
|20949|x-cp20949|韩语 Wansung|✓|||
|21025|cp1025|IBM EBCDIC （西里尔语塞尔维亚语-保加利亚语）||||
|21866|koi8-ru-u|西里尔语（KOI8-RU）||||
|28591|iso-8859-1|西欧语(ISO)|✓|✓|✓|
|28592|iso-8859-2|中欧语（ISO）||||
|28593|iso-8859-3|拉丁语3（ISO）||||
|28594|iso-8859-4|波罗的语（ISO）||||
|28595|iso-8859-5|西里尔语（ISO）||||
|28596|iso-8859-6|阿拉伯语（ISO）||||
|28597|iso-8859-7|希腊语（ISO）||||
|28598|iso-8859-8|希伯来语(ISO-Visual)|✓|||
|28599|iso-8859-9|土耳其语（ISO）||||
|28603|iso-8859-13|爱沙尼亚语（ISO）||||
|28605|iso-8859-15|拉丁语9（ISO）||||
|29001|x-欧洲|欧洲||||
|38598|iso-8859-8-i|希伯来语（ISO-逻辑）|✓|||
|50220|iso-2022-日本|日语(JIS)|✓|||
|50221|csISO2022JP|日语（JIS-允许1字节假名）|✓|||
|50222|iso-2022-日本|日语（JIS-允许1字节假名-SO/SI）|✓|||
|50225|iso-2022-kr|朝鲜语(ISO)|✓|||
|50227|x-cp50227|简体中文(ISO-2022)|✓|||
|51932|euc-jp|日语（EUC）|✓|||
|51936|EUC-CN|简体中文（EUC）|✓|||
|51949|euc-kr|韩语（EUC）|✓|||
|52936|hz-gb-2312|简体中文（HZ）|✓|||
|54936|GB18030|简体中文(GB18030)|✓|||
|57002|x-iscii-de|ISCII 梵文|✓|||
|57003|x-iscii|ISCII 孟加拉语|✓|||
|57004|x-iscii-ta|ISCII 泰米尔语|✓|||
|57005|x-iscii-te|ISCII 泰卢固语|✓|||
|57006|x-iscii-as|ISCII 阿萨姆语|✓|||
|57007|x-iscii-或|ISCII 奥里雅语|✓|||
|57008|x-iscii-ka|ISCII 埃纳德文|✓|||
|57009|x-iscii-ma|ISCII 马拉雅拉姆语|✓|||
|57010|x-iscii-gu|ISCII 古吉拉特语|✓|||
|57011|x-iscii-pa|ISCII 旁遮普语|✓|||
|65000|utf-7|Unicode （UTF-7）|✓|✓||
|65001|utf-8|Unicode (UTF-8)|✓|✓|✓|

 下面的示例调用 <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> 和 <xref:System.Text.Encoding.GetEncoding%28System.String%29> 方法以获取希腊语（Windows）代码页编码。 它将 <xref:System.Text.Encoding> 方法调用返回的对象进行比较，以显示它们相等，然后 maps 显示每个字符在希腊语字母表中的 Unicode 码位和相应的代码页值。

 [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]

 如果要转换的数据仅在顺序块（如从流中读取的数据）中可用，或者如果数据量很大以致需要分为更小块，则应使用 <xref:System.Text.Decoder> <xref:System.Text.Encoder> <xref:System.Text.Encoding.GetDecoder%2A> 派生类的方法或方法提供的或 <xref:System.Text.Encoding.GetEncoder%2A> 。

 UTF-16 和32编码器可以使用大 endian 字节顺序（首先是最重要的字节），也可以是 little endian 字节顺序（首先是最不重要的字节）。 例如，拉丁文大写字母 A （U + 0041）按以下方式序列化（十六进制）：

- UTF-16 大 endian 字节顺序： 00 41

- UTF-16 little endian 字节顺序： 41 00

- 32大 endian 字节顺序： 00 00 00 41

- 32 little endian 字节顺序： 41 00 00 00

 使用本机字节顺序存储 Unicode 字符通常更有效。 例如，最好使用 little endian 平台（如 Intel 计算机）上的 little endian 字节顺序。

 <xref:System.Text.Encoding.GetPreamble%2A>方法检索包含字节顺序标记（BOM）的字节数组。 如果此字节数组的前缀为编码的流，则它有助于解码器识别所使用的编码格式。

 有关字节顺序和字节顺序标记的详细信息，请参阅[unicode 主页](https://home.unicode.org/)上的 unicode 标准。

 请注意，编码类允许错误：

- 以无提示方式更改为 "？" 字符。

- 使用 "最佳匹配" 字符。

- 通过将 <xref:System.Text.EncoderFallback> 和 <xref:System.Text.DecoderFallback> 类与 U + FFFD Unicode 替换字符一起使用，更改为应用程序特定的行为。

 应在出现任何数据流错误时引发异常。 应用在适用或使用和类时，使用 "throwonerror" 标志 <xref:System.Text.EncoderExceptionFallback> <xref:System.Text.DecoderExceptionFallback> 。 通常不建议使用最佳回退，因为这可能会导致数据丢失或混乱，并比简单字符替换慢。 对于 ANSI 编码，最佳行为是默认值。

## Examples
 下面的示例将字符串从一种编码转换为另一种编码。

> [!NOTE]
> `byte[]`在此示例中，数组是包含编码数据的唯一类型。 .NET `Char` 和 `String` 类型本身就是 unicode，因此调用会将 <xref:System.Text.Encoding.GetChars%2A> 数据解码回 unicode。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb" id="Snippet1":::

 ]]></format>
    </remarks>
    <related type="Article" href="/dotnet/standard/base-types/character-encoding">了解编码</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Text.Encoding" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Text.Encoding" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 派生类重写此构造函数。

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (codePage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int -&gt; System.Text.Encoding" Usage="new System.Text.Encoding codePage" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codePage">首选编码的代码页标识符。

 - 或 -

 0，使用默认编码。</param>
        <summary>初始化对应于指定代码页的 <see cref="T:System.Text.Encoding" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 派生类重写此构造函数。

 从派生类调用此构造函数将创建一个 <xref:System.Text.Encoding> 对象，该对象使用最佳回退来执行编码和解码操作。 <xref:System.Text.Encoding.DecoderFallback%2A>和 <xref:System.Text.Encoding.EncoderFallback%2A> 属性都是只读的，不能修改。 若要控制从派生的类的回退策略 <xref:System.Text.Encoding> ，请调用 <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> 构造函数。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codePage" /> 小于零。</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (codePage As Integer, encoderFallback As EncoderFallback, decoderFallback As DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="new System.Text.Encoding (codePage, encoderFallback, decoderFallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codePage">编码的代码页标识符。</param>
        <param name="encoderFallback">一个对象，在无法用当前编码对字符进行编码时，该对象可用来提供错误处理过程。</param>
        <param name="decoderFallback">一个对象，在无法用当前编码对字节序列进行解码时，该对象可用来提供错误处理过程。</param>
        <summary>使用指定编码器和解码器回退策略初始化对应于指定代码页的 <see cref="T:System.Text.Encoding" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此构造函数为 `protected` ; 派生类重写它。

 从派生类调用此构造函数以控制回退编码和解码策略。 <xref:System.Text.Encoding>类构造函数创建只读编码对象，这些对象在创建对象之后不允许编码器或解码器回退设置。

 如果 `encoderFallback` 或 `decoderFallback` 为 null，则最佳回退将用作相应的回退策略。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codePage" /> 小于零。</exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ASCII As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ ASCII { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ASCII : System.Text.Encoding" Usage="System.Text.Encoding.ASCII" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 ASCII（7 位）字符集的编码。</summary>
        <value>ASCII（7 位）字符集的编码。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 ASCII 字符限制为128个 Unicode 字符（从 U + 0000 到 U + 007F）。

 为应用选择 ASCII 编码时，请考虑以下事项：

- ASCII 编码通常适用于需要 ASCII 的协议。

- 如果需要8位编码（有时错误地称为 "ASCII"），建议使用 UTF-8 编码，而不是 ASCII 编码。 对于字符 0-7F，结果完全相同，但使用 UTF-8 可通过允许表示所有可表示的 Unicode 字符来避免数据丢失。 请注意，ASCII 编码具有可允许恶意使用的第8位歧义，但 UTF-8 编码消除了有关第8位的歧义。

- 在 .NET Framework 版本2.0 之前，通过忽略第8位 .NET Framework 允许欺骗。 从 .NET Framework 2.0 开始，在解码过程中非 ASCII 码位将回退。

 <xref:System.Text.ASCIIEncoding>此属性返回的对象可能没有适用于你的应用程序的行为。 它使用替换回退来替换每个不能进行编码的字符串，以及无法使用问号（"？"）字符解码的每个字节。 相反，您可以调用 <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> 方法来实例化 <xref:System.Text.ASCIIEncoding> 其回退为 <xref:System.Text.EncoderFallbackException> 或的对象 <xref:System.Text.DecoderFallbackException> ，如下例所示。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb" id="Snippet1":::

## Examples

下面的示例演示 ASCII 编码对 ASCII 范围外的字符的影响。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.ASCIIEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="/dotnet/standard/base-types/character-encoding">了解编码</related>
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BigEndianUnicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ BigEndianUnicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BigEndianUnicode : System.Text.Encoding" Usage="System.Text.Encoding.BigEndianUnicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取使用 Big Endian 字节顺序的 UTF-16 格式的编码。</summary>
        <value>使用 Big Endian 字节顺序的 UTF-16 格式的编码对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.UnicodeEncoding>此属性返回的对象可能没有适用于你的应用程序的行为。 它使用替换回退来替换每个不能进行编码的字符串，以及无法使用问号（"？"）字符解码的每个字节。 相反，你可以调用 <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 构造函数来实例化一个大的 endian <xref:System.Text.UnicodeEncoding> 对象，其回退为 <xref:System.Text.EncoderFallbackException> 或 <xref:System.Text.DecoderFallbackException> ，如下面的示例所示。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb" id="Snippet2":::

 返回的 <xref:System.Text.UnicodeEncoding> 对象具有 <xref:System.Text.Encoding.BodyName%2A> 、 <xref:System.Text.Encoding.HeaderName%2A> 和 <xref:System.Text.Encoding.WebName%2A> 属性，这将生成名称 "unicodeFFFE"。 尽管 UTF-16 大 endian 字节顺序标记是十六进制 FEFF，但却选择了名称 "unicodeFFFE"，因为字节顺序标记在 little endian Windows 计算机上显示为十六进制 FFFE。

## Examples
 下面的示例使用大字节序字节顺序读取带有 UTF-16 编码的文本文件。

 [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]

 下面的示例确定对字符数组进行编码、对字符进行编码并显示生成的字节所需的字节数。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="/dotnet/standard/base-types/character-encoding">了解编码</related>
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BodyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BodyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BodyName : string" Usage="System.Text.Encoding.BodyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取可与邮件代理正文标记一起使用的当前编码的名称。</summary>
        <value>可与邮件代理正文标记一起使用的当前 <see cref="T:System.Text.Encoding" /> 的名称。

- 或 -

如果当前 <see cref="T:System.Text.Encoding" /> 无法使用，则为空字符串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果需要主体名称的编码，则应 <xref:System.Text.Encoding.GetEncoding%2A> 使用 <xref:System.Text.Encoding.BodyName%2A> 属性调用。 通常，方法从调用中提供的测试编码检索不同的编码。 通常，电子邮件应用程序通常只需检索这样一种编码;需要描述编码的其他大多数应用程序应使用其 <xref:System.Text.Encoding.WebName%2A> 。

 在某些情况下，属性的值 <xref:System.Text.Encoding.BodyName%2A> 对应于定义该编码的国际标准。 这并不意味着实现完全符合该标准。

## Examples
 下面的示例检索每个编码的不同名称，并显示一个或多个名称不同于的编码 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> 。 它将显示， <xref:System.Text.Encoding.EncodingName%2A> 但不会对其进行比较。

 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="encoding.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中重写时，创建当前 <see cref="T:System.Text.Encoding" /> 对象的一个卷影副本。</summary>
        <returns>当前 <see cref="T:System.Text.Encoding" /> 对象的副本。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 即使原始对象是只读的，克隆也是可写的 <xref:System.Text.Encoding> 。 因此，可以修改克隆的属性。

 对象的浅表副本只是对象的副本。 如果对象包含对其他对象的引用，则浅表副本不会创建所引用对象的副本。 改为引用原始对象。 与此相反，对象的深层副本将创建对象的副本和该对象直接或间接引用的所有内容的副本。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CodePage : int" Usage="System.Text.Encoding.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取当前 <see cref="T:System.Text.Encoding" /> 的代码页标识符。</summary>
        <value>当前 <see cref="T:System.Text.Encoding" /> 的代码页标识符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的示例检索每个编码的不同名称，并显示一个或多个名称不同于的编码 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> 。 它将显示， <xref:System.Text.Encoding.EncodingName%2A> 但不会对其进行比较。

 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
        <altmember cref="P:System.Text.Encoding.WindowsCodePage" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将字节数组从一种编码转换为另一种。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding"><paramref name="bytes" /> 的编码格式。</param>
        <param name="dstEncoding">目标编码格式。</param>
        <param name="bytes">要转换的字节。</param>
        <summary>将整个字节数组从一种编码转换为另一种编码。</summary>
        <returns><see cref="T:System.Byte" /> 类型的数组，其中包含将 <paramref name="bytes" /> 从 <paramref name="srcEncoding" /> 转换为 <paramref name="dstEncoding" /> 的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的示例将 Unicode 编码的字符串转换为 ASCII 编码的字符串。 由于属性返回的 ASCII 编码对象 <xref:System.Text.Encoding.ASCII%2A> 使用替换回退，并且 pi 字符不是 ASCII 字符集的一部分，因此 pi 字符将替换为问号，如示例中的输出所示。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="srcEncoding" /> 为 <see langword="null" />。

- 或 -

 <paramref name="dstEncoding" /> 为 <see langword="null" />。

- 或 -

 <paramref name="bytes" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）

－和－

 **srcEncoding.** 将 <see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）

－和－

 **dstEncoding.** 将 <see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] * int * int -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">源数组 <paramref name="bytes" /> 的编码。</param>
        <param name="dstEncoding">输出数组的编码。</param>
        <param name="bytes">要转换的字节数组。</param>
        <param name="index">要转换的 <paramref name="bytes" /> 中第一个元素的索引。</param>
        <param name="count">要转换的字节数。</param>
        <summary>将字节数组内某个范围的字节从一种编码转换为另一种编码。</summary>
        <returns>一个 <see cref="T:System.Byte" /> 类型的数组，其中包含将 <paramref name="bytes" /> 中某个范围的字节从 <paramref name="srcEncoding" /> 转换为 <paramref name="dstEncoding" /> 的结果。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="srcEncoding" /> 为 <see langword="null" />。

- 或 -

 <paramref name="dstEncoding" /> 为 <see langword="null" />。

- 或 -

 <paramref name="bytes" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 和 <paramref name="count" /> 不指定字节数组中的有效范围。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）

－和－

 **srcEncoding.** 将 <see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）

－和－

 **dstEncoding.** 将 <see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateTranscodingStream">
      <MemberSignature Language="C#" Value="public static System.IO.Stream CreateTranscodingStream (System.IO.Stream innerStream, System.Text.Encoding innerStreamEncoding, System.Text.Encoding outerStreamEncoding, bool leaveOpen = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream CreateTranscodingStream(class System.IO.Stream innerStream, class System.Text.Encoding innerStreamEncoding, class System.Text.Encoding outerStreamEncoding, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.CreateTranscodingStream(System.IO.Stream,System.Text.Encoding,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateTranscodingStream (innerStream As Stream, innerStreamEncoding As Encoding, outerStreamEncoding As Encoding, Optional leaveOpen As Boolean = false) As Stream" />
      <MemberSignature Language="F#" Value="static member CreateTranscodingStream : System.IO.Stream * System.Text.Encoding * System.Text.Encoding * bool -&gt; System.IO.Stream" Usage="System.Text.Encoding.CreateTranscodingStream (innerStream, innerStreamEncoding, outerStreamEncoding, leaveOpen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="innerStreamEncoding" Type="System.Text.Encoding" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="outerStreamEncoding" Type="System.Text.Encoding" Index="2" FrameworkAlternate="net-5.0" />
        <Parameter Name="leaveOpen" Type="System.Boolean" Index="3" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="innerStream">要包装的流。</param>
        <param name="innerStreamEncoding">与 <paramref name="innerStream" /> 关联的编码。</param>
        <param name="outerStreamEncoding">与此方法返回的 <see cref="T:System.IO.Stream" /> 关联的编码。</param>
        <param name="leaveOpen">如果在处理 <see cref="T:System.IO.Stream" /> 时，该方法返回 <see langword="true" />，则<em>不</em>应处理 <paramref name="innerStream" />。</param>
        <summary>创建一个 <see cref="T:System.IO.Stream" />，用于在内部 <see cref="T:System.Text.Encoding" /> 和外部 <see cref="T:System.Text.Encoding" /> 之间进行数据转码，类似于 <see cref="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />。</summary>
        <returns>将 <paramref name="innerStream" /> 的内容转换为 <paramref name="outerStreamEncoding" /> 的流。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

返回 <xref:System.IO.Stream> 的 <xref:System.IO.Stream.CanRead> 和 <xref:System.IO.Stream.CanWrite> 属性将反映是否 `innerStream` 可读或可写。 如果 `innerStream` 是全双工，则返回的也将 <xref:System.IO.Stream> 是。 但是， <xref:System.IO.Stream> 即使 `innerStream` 的属性返回，返回的也不能查找 <xref:System.IO.Stream.CanSeek> `true` 。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DecoderFallback As DecoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback" Usage="System.Text.Encoding.DecoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Property DecoderFallback As DecoderFallback" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback with get, set" Usage="System.Text.Encoding.DecoderFallback" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前 <see cref="T:System.Text.DecoderFallback" /> 对象的 <see cref="T:System.Text.Encoding" /> 对象。</summary>
        <value>当前 <see cref="T:System.Text.Encoding" /> 对象的解码器回退对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.DecoderFallback>对象表示一个错误处理程序，当无法将编码的字节序列解码为一个字符时，将调用该处理程序。 支持以下处理程序类型之一：

- 最佳回退处理程序，它将不能解码的字节替换为某些合适的替换字符。

- 替换回退处理程序，它将不能解码的字节替换为任意替换字符。 .NET 包含一个替换回退处理程序， <xref:System.Text.DecoderFallback> 默认情况下，它会替换无法使用问号（"？"）字符解码的字节。

- 异常回退处理程序，如果无法对字节进行解码，则会引发异常。 .NET 包含一个异常回退处理程序， <xref:System.Text.DecoderExceptionFallback> 该处理程序 <xref:System.Text.DecoderFallbackException> 在无法解码时将引发。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">设置操作中的值为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">由于当前 <see cref="T:System.Text.Encoding" /> 对象为只读，所以无法在设置操作中赋值。</exception>
        <altmember cref="T:System.Text.DecoderFallback" />
        <altmember cref="T:System.Text.DecoderFallbackBuffer" />
        <related type="Article" href="/dotnet/standard/base-types/character-encoding">了解编码</related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Default { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Text.Encoding" Usage="System.Text.Encoding.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此 .NET 实现的默认编码。</summary>
        <value>此 .NET 实现的默认编码。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!WARNING]
> 不同的计算机可以使用不同的编码作为默认编码，并且在一台计算机上可以更改默认编码。 如果在 <xref:System.Text.Encoding.Default%2A> 同一台计算机上使用编码对在计算机之间传输的数据进行编码和解码，或在同一台计算机上的不同时间进行检索，则可能会错误地转换该数据。 此外，属性返回的编码 <xref:System.Text.Encoding.Default%2A> 使用最佳回退将不支持的字符映射到代码页支持的字符。 由于这些原因，不建议使用默认编码。 若要确保编码的字节解码正确，应使用 Unicode 编码，例如 <xref:System.Text.UTF8Encoding> 或 <xref:System.Text.UnicodeEncoding> 。 你还可以使用较高级别的协议来确保用于编码和解码的格式相同。

### <a name="the-default-property-in-net-framework"></a>.NET Framework 中的默认属性

在 Windows 桌面上的 .NET Framework 中， <xref:System.Text.Encoding.Default%2A> 属性始终获取系统的活动代码页并创建 <xref:System.Text.Encoding> 与其对应的对象。 活动代码页可能是 ANSI 代码页，其中包括 ASCII 字符集以及不同于代码页的其他字符。 由于所有 <xref:System.Text.Encoding.Default%2A> 基于 ANSI 代码页的编码都将丢失数据，因此请考虑 <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> 改用编码。 在 U + 00 到 U + 7F 范围内，UTF-8 通常是相同的，但可以在不丢失的情况下在 ASCII 范围外对字符进行编码。

## <a name="the-default-property-on-net-core"></a>.NET Core 上的默认属性

在 .NET Core 中， <xref:System.Text.Encoding.Default%2A> 属性始终返回 <xref:System.Text.UTF8Encoding> 。 在运行 .NET Core 应用程序的所有操作系统（Windows、Linux 和 macOS）上都支持 UTF-8。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EncoderFallback As EncoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback" Usage="System.Text.Encoding.EncoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Property EncoderFallback As EncoderFallback" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback with get, set" Usage="System.Text.Encoding.EncoderFallback" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前 <see cref="T:System.Text.EncoderFallback" /> 对象的 <see cref="T:System.Text.Encoding" /> 对象。</summary>
        <value>当前 <see cref="T:System.Text.Encoding" /> 对象的编码器回退对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.EncoderFallback>对象表示一个错误处理程序，当不能将字符转换为编码的字节序列时，将调用该处理程序。 支持以下处理程序类型之一：

- 最佳回退处理程序，该处理程序将替换无法使用某些合适的替换字符编码的字符。

- 替换回退处理程序，它将替换不能用一些任意替换字符编码的字符。 .NET 包含一个替换回退处理程序，默认情况下，此处理程序将 <xref:System.Text.EncoderFallback> 替换不能用问号（"？"）字符编码的字符。

- 异常回退处理程序，当无法对字符进行编码时，将引发异常。 .NET 包含一个异常回退处理程序， <xref:System.Text.EncoderExceptionFallback> 该处理程序 <xref:System.Text.EncoderFallbackException> 在无法解码字符时引发。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">设置操作中的值为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">由于当前 <see cref="T:System.Text.Encoding" /> 对象为只读，所以无法在设置操作中赋值。</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallbackBuffer" />
        <related type="Article" href="/dotnet/standard/base-types/character-encoding">了解编码</related>
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EncodingName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EncodingName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EncodingName : string" Usage="System.Text.Encoding.EncodingName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取当前编码的用户可读说明。</summary>
        <value>当前 <see cref="T:System.Text.Encoding" /> 的用户可读说明。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoding.EncodingName%2A>属性用于显示。 若要查找可传递给方法的名称 <xref:System.Text.Encoding.GetEncoding%2A> ，请使用 <xref:System.Text.Encoding.WebName%2A> 属性。

## Examples
 下面的示例检索每个编码的不同名称，并显示一个或多个名称不同于的编码 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> 。 它将显示， <xref:System.Text.Encoding.EncodingName%2A> 但不会对其进行比较。

 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.DisplayName" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">与当前实例进行比较的 <see cref="T:System.Object" />。</param>
        <summary>确定指定的 <see cref="T:System.Object" /> 是否等同于当前实例。</summary>
        <returns>如果 <paramref name="value" /> 是 <see cref="T:System.Text.Encoding" /> 的一个实例并且等于当前实例，则为 <see langword="true" />；否则，为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果两个实例 <xref:System.Text.Encoding> 对应于同一个代码页并且它们 `EncoderFallback` 和对象相等，则这两个实例被视为相等 `DecoderFallback` 。 具体而言，派生代码页的代码页都为0，并且它们的回退通常为 `null` （ `Nothing` 在 Visual Basic .net 中）。 因此，它们被视为彼此相等。 一种结果是，当 <xref:System.Text.Encoding.Equals%2A> 使用来填充哈希表时，所有派生的编码都相等并属于同一哈希表槽。

## Examples
 下面的示例获取相同编码的两个实例（一个按代码页，另一个按名称），并检查它们是否相等。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Text.Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在派生类中重写时，计算对一组字符进行编码所产生的字节数。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] -&gt; int&#xA;override this.GetByteCount : char[] -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">包含要编码的字符的字符数组。</param>
        <summary>在派生类中重写时，计算对指定字符数组中的所有字符进行编码所产生的字节数。</summary>
        <returns>对指定字符数组中的所有字符进行编码后产生的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 若要计算存储生成的字节所需的确切数组大小 <xref:System.Text.Encoding.GetBytes%2A> ，请调用 <xref:System.Text.Encoding.GetByteCount%2A> 方法。 若要计算最大数组大小，请调用 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法。 <xref:System.Text.Encoding.GetByteCount%2A>方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法的执行速度通常更快。

 <xref:System.Text.Encoding.GetByteCount%2A>方法确定导致对一组 Unicode 字符进行编码的字节数， <xref:System.Text.Encoding.GetBytes%2A> 方法执行实际编码。 <xref:System.Text.Encoding.GetBytes%2A>方法需要离散转换，这与方法不同， <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 后者处理单个输入流上的多个转换。

 支持和的多个版本 <xref:System.Text.Encoding.GetByteCount%2A> <xref:System.Text.Encoding.GetBytes%2A> 。 下面是有关使用这些方法的一些编程注意事项：

- 您的应用程序可能需要将许多输入字符编码为代码页，并使用多个调用处理这些字符。 在这种情况下，您可能需要维护两次调用之间的状态，同时考虑所使用的对象保留的状态 <xref:System.Text.Encoder> 。

- 如果你的应用程序处理字符串输入，则应使用该方法的字符串版本 <xref:System.Text.Encoding.GetBytes%2A> 。

- 的 Unicode 字符缓冲区版本 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 允许一些快速的技巧，尤其是使用对象的多个调用 <xref:System.Text.Encoder> 或插入现有缓冲区。 但请记住，此方法版本有时不安全，因为指针是必需的。

- 如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。 在这种情况下， <xref:System.Text.Encoding.GetBytes%2A> 支持字节数组的版本是最佳选择。

- 请考虑使用 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 方法而不是 <xref:System.Text.Encoding.GetByteCount%2A> 。 转换方法可转换尽可能多的数据，如果输出缓冲区太小，则会引发异常。 对于流的连续编码，此方法通常是最佳选择。

## Examples
 下面的示例确定对字符数组进行编码、对字符进行编码并显示生成的字节所需的字节数。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）

－和－

 将 <see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int&#xA;override this.GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="chars">要编码的字符范围。</param>
        <summary>在派生类中重写时，计算对指定字符范围的字符进行编码所产生的字节数。</summary>
        <returns>对指定字符范围进行编码所产生的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 若要计算存储生成的字节所需的确切范围大小 <xref:System.Text.Encoding.GetBytes%2A> ，请调用 <xref:System.Text.Encoding.GetByteCount%2A> 方法。 若要计算最大跨度大小，请调用 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法。 <xref:System.Text.Encoding.GetByteCount%2A>方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法的执行速度通常更快。

 <xref:System.Text.Encoding.GetByteCount%2A>方法确定导致对一组 Unicode 字符进行编码的字节数， <xref:System.Text.Encoding.GetBytes%2A> 方法执行实际编码。 <xref:System.Text.Encoding.GetBytes%2A>方法需要离散转换，这与方法不同， <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 后者处理单个输入流上的多个转换。

 支持和的多个版本 <xref:System.Text.Encoding.GetByteCount%2A> <xref:System.Text.Encoding.GetBytes%2A> 。 下面是有关使用这些方法的一些编程注意事项：

- 您的应用程序可能需要将许多输入字符编码为代码页，并使用多个调用处理这些字符。 在这种情况下，您可能需要维护两次调用之间的状态，同时考虑所使用的对象保留的状态 <xref:System.Text.Encoder> 。

- 如果你的应用程序处理多个字符输入， <xref:System.Text.Encoding.GetBytes%2A> 则建议使用的范围版本。

- 请考虑使用 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 方法而不是 <xref:System.Text.Encoding.GetByteCount%2A> 。 转换方法可转换尽可能多的数据，如果输出范围缓冲区太小，则会引发异常。 对于流的连续编码，此方法通常是最佳选择。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : string -&gt; int&#xA;override this.GetByteCount : string -&gt; int" Usage="encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">包含要编码的字符集的字符串。</param>
        <summary>在派生类中重写时，计算对指定字符串中的字符进行编码所产生的字节数。</summary>
        <returns>对指定字符进行编码后生成的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 若要计算存储生成的字节所需的确切数组大小 <xref:System.Text.Encoding.GetBytes%2A> ，请调用 <xref:System.Text.Encoding.GetByteCount%2A> 方法。 若要计算最大数组大小，请调用 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法。 <xref:System.Text.Encoding.GetByteCount%2A>方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法的执行速度通常更快。

 <xref:System.Text.Encoding.GetByteCount%2A>方法确定导致对一组 Unicode 字符进行编码的字节数， <xref:System.Text.Encoding.GetBytes%2A> 方法执行实际编码。 <xref:System.Text.Encoding.GetBytes%2A>方法需要离散转换，这与方法不同， <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 后者处理单个输入流上的多个转换。

 支持和的多个版本 <xref:System.Text.Encoding.GetByteCount%2A> <xref:System.Text.Encoding.GetBytes%2A> 。 下面是有关使用这些方法的一些编程注意事项：

- 您的应用程序可能需要将许多输入字符编码为代码页，并使用多个调用处理这些字符。 在这种情况下，您可能需要维护两次调用之间的状态，同时考虑所使用的对象保留的状态 <xref:System.Text.Encoder> 。

- 如果你的应用程序处理字符串输入， <xref:System.Text.Encoding.GetBytes%2A> 则建议使用的字符串版本。

- 的 Unicode 字符缓冲区版本 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 允许一些快速的技巧，尤其是使用对象的多个调用 <xref:System.Text.Encoder> 或插入现有缓冲区。 但请记住，此方法版本有时不安全，因为指针是必需的。

- 如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。 在这种情况下， <xref:System.Text.Encoding.GetBytes%2A> 支持字节数组的版本是最佳选择。

- 请考虑使用 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 方法而不是 <xref:System.Text.Encoding.GetByteCount%2A> 。 转换方法可转换尽可能多的数据，如果输出缓冲区太小，则会引发异常。 对于流的连续编码，此方法通常是最佳选择。

## Examples
 下面的示例确定了对字符串中的字符串或范围进行编码、对字符进行编码并显示生成的字节所需的字节数。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）

－和－

 将 <see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars">指向第一个要编码的字符的指针。</param>
        <param name="count">要编码的字符的数目。</param>
        <summary>在派生类中重写时，计算对一组字符（从指定的字符指针处开始）进行编码所产生的字节数。</summary>
        <returns>对指定字符进行编码后生成的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 若要计算 <xref:System.Text.Encoding.GetBytes%2A> 存储生成的字节所需的确切数组大小，应调用 <xref:System.Text.Encoding.GetByteCount%2A> 方法。 若要计算最大数组大小，请调用 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法。 <xref:System.Text.Encoding.GetByteCount%2A>方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法的执行速度通常更快。

 <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29>方法确定导致对一组 Unicode 字符进行编码的字节数， <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 方法执行实际编码。 <xref:System.Text.Encoding.GetBytes%2A>方法需要离散转换，这与方法不同， <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 后者处理单个输入流上的多个转换。

 支持和的多个版本 <xref:System.Text.Encoding.GetByteCount%2A> <xref:System.Text.Encoding.GetBytes%2A> 。 下面是使用这些方法时的一些注意事项：

- 您的应用程序可能需要将许多输入字符编码为代码页，并使用多个调用处理这些字符。 在这种情况下，您可能需要维护两次调用之间的状态，同时考虑所使用的对象保留的状态 <xref:System.Text.Encoder> 。

- 如果你的应用程序处理字符串输入，则应使用该方法的字符串版本 <xref:System.Text.Encoding.GetBytes%2A> 。

- 的 Unicode 字符缓冲区版本 <xref:System.Text.Encoding.GetBytes%2A> 允许一些快速的技巧，尤其是使用对象的多个调用 <xref:System.Text.Encoder> 或插入现有缓冲区。 但请记住，此方法版本有时不安全，因为指针是必需的。

- 如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。 在这种情况下， <xref:System.Text.Encoding.GetBytes%2A> 支持字节数组的版本是最佳选择。

- 请考虑使用 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 方法而不是 <xref:System.Text.Encoding.GetByteCount%2A> 。 转换方法可转换尽可能多的数据，如果输出缓冲区太小，则会引发异常。 对于流的连续编码，此方法通常是最佳选择。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 小于零。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）

－和－

 将 <see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] * int * int -&gt; int" Usage="encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">包含要编码的字符集的字符数组。</param>
        <param name="index">第一个要编码的字符的索引。</param>
        <param name="count">要编码的字符的数目。</param>
        <summary>在派生类中重写时，计算对指定字符数组中的一组字符进行编码所产生的字节数。</summary>
        <returns>对指定字符进行编码后生成的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 若要计算存储生成的字节所需的确切数组大小 <xref:System.Text.Encoding.GetBytes%2A> ，请调用 <xref:System.Text.Encoding.GetByteCount%2A> 方法。 若要计算最大数组大小，请调用 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法。 <xref:System.Text.Encoding.GetByteCount%2A>方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法的执行速度通常更快。

 <xref:System.Text.Encoding.GetByteCount%2A>方法确定导致对一组 Unicode 字符进行编码的字节数， <xref:System.Text.Encoding.GetBytes%2A> 方法执行实际编码。 <xref:System.Text.Encoding.GetBytes%2A>方法需要离散转换，这与方法不同， <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 后者处理单个输入流上的多个转换。

 支持和的多个版本 <xref:System.Text.Encoding.GetByteCount%2A> <xref:System.Text.Encoding.GetBytes%2A> 。 下面是有关使用这些方法的一些编程注意事项：

- 您的应用程序可能需要将许多输入字符编码为代码页，并使用多个调用处理这些字符。 在这种情况下，您可能需要维护两次调用之间的状态，同时考虑所使用的对象保留的状态 <xref:System.Text.Encoder> 。

- 如果你的应用程序处理字符串输入， <xref:System.Text.Encoding.GetBytes%2A> 则建议使用的字符串版本。

- 的 Unicode 字符缓冲区版本 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 允许一些快速的技巧，尤其是使用对象的多个调用 <xref:System.Text.Encoder> 或插入现有缓冲区。 但请记住，此方法版本有时不安全，因为指针是必需的。

- 如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。 在这种情况下， <xref:System.Text.Encoding.GetBytes%2A> 支持字节数组的版本是最佳选择。

- 请考虑使用 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 方法而不是 <xref:System.Text.Encoding.GetByteCount%2A> 。 转换方法可转换尽可能多的数据，如果输出缓冲区太小，则会引发异常。 对于流的连续编码，此方法通常是最佳选择。

## Examples
 下面的示例确定对字符数组中的三个字符进行编码、对字符进行编码并显示生成的字节所需的字节数。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 或 <paramref name="count" /> 小于零。

- 或 -

 <paramref name="index" /> 和 <paramref name="count" /> 不表示 <paramref name="chars" /> 中的有效范围。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）

－和－

 将 <see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (s As String, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetByteCount(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : string * int * int -&gt; int" Usage="encoding.GetByteCount (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s">包含要编码的字符集的字符串。</param>
        <param name="index">第一个要编码的字符的索引。</param>
        <param name="count">要编码的字符的数目。</param>
        <summary>在派生类中重写时，计算对指定字符串中的一组字符进行编码所产生的字节数。</summary>
        <returns>对字符串进行编码后生成的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 若要计算存储生成的字节所需的确切数组大小 <xref:System.Text.Encoding.GetBytes%2A> ，请调用 <xref:System.Text.Encoding.GetByteCount%2A> 方法。 若要计算最大数组大小，请调用 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法。 <xref:System.Text.Encoding.GetByteCount%2A>方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法的执行速度通常更快。

 <xref:System.Text.Encoding.GetByteCount%2A>方法确定导致对一组 Unicode 字符进行编码的字节数， <xref:System.Text.Encoding.GetBytes%2A> 方法执行实际编码。 <xref:System.Text.Encoding.GetBytes%2A>方法需要离散转换，这与方法不同， <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 后者处理单个输入流上的多个转换。

 支持和的多个版本 <xref:System.Text.Encoding.GetByteCount%2A> <xref:System.Text.Encoding.GetBytes%2A> 。 下面是有关使用这些方法的一些编程注意事项：

- 您的应用程序可能需要将许多输入字符编码为代码页，并使用多个调用处理这些字符。 在这种情况下，您可能需要维护两次调用之间的状态，同时考虑所使用的对象保留的状态 <xref:System.Text.Encoder> 。

- 如果你的应用程序处理字符串输入， <xref:System.Text.Encoding.GetBytes%2A> 则建议使用的字符串版本。

- 的 Unicode 字符缓冲区版本 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 允许一些快速的技巧，尤其是使用对象的多个调用 <xref:System.Text.Encoder> 或插入现有缓冲区。 但请记住，此方法版本有时不安全，因为指针是必需的。

- 如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。 在这种情况下， <xref:System.Text.Encoding.GetBytes%2A> 支持字节数组的版本是最佳选择。

- 请考虑使用 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 方法而不是 <xref:System.Text.Encoding.GetByteCount%2A> 。 转换方法可转换尽可能多的数据，如果输出缓冲区太小，则会引发异常。 对于流的连续编码，此方法通常是最佳选择。

## Examples
 下面的示例确定对字符数组中的三个字符进行编码、对字符进行编码并显示生成的字节所需的字节数。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在派生类中重写时，将一组字符编码为一个字节序列。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] -&gt; byte[]&#xA;override this.GetBytes : char[] -&gt; byte[]" Usage="encoding.GetBytes chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">包含要编码的字符的字符数组。</param>
        <summary>在派生类中重写时，将指定字符数组中的所有字符编码为一个字节序列。</summary>
        <returns>一个字节数组，包含对指定的字符集进行编码的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果要转换的数据仅在顺序块（如从流中读取的数据）中可用，或者如果数据量很大以致需要分为更小块，则应使用 <xref:System.Text.Decoder> <xref:System.Text.Encoder> <xref:System.Text.Encoding.GetDecoder%2A> 派生类的方法或方法提供的或 <xref:System.Text.Encoding.GetEncoder%2A> 。

 <xref:System.Text.Encoding.GetByteCount%2A>方法确定导致对一组 Unicode 字符进行编码的字节数， <xref:System.Text.Encoding.GetBytes%2A> 方法执行实际编码。 <xref:System.Text.Encoding.GetBytes%2A>方法需要离散转换，这与方法不同， <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 后者处理单个输入流上的多个转换。

 支持和的多个版本 <xref:System.Text.Encoding.GetByteCount%2A> <xref:System.Text.Encoding.GetBytes%2A> 。 下面是有关使用这些方法的一些编程注意事项：

- 您的应用程序可能需要将许多输入字符编码为代码页，并使用多个调用处理这些字符。 在这种情况下，您可能需要维护两次调用之间的状态，同时考虑所使用的对象保留的状态 <xref:System.Text.Encoder> 。 （例如，包含代理项对的字符序列可能以高代理项结束。 <xref:System.Text.Encoder>将记住高代理项，以便可以在以下调用开始时将其与低代理项组合在一起。 <xref:System.Text.Encoding>无法维护状态，因此字符将发送到 <xref:System.Text.EncoderFallback> 。）

- 如果你的应用程序处理字符串输入，则应调用该方法的字符串版本 <xref:System.Text.Encoding.GetBytes%2A> 。

- 的 Unicode 字符缓冲区版本 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 允许一些快速的技巧，尤其是使用对象的多个调用 <xref:System.Text.Encoder> 或插入现有缓冲区。 但请记住，此方法版本有时不安全，因为指针是必需的。

- 如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。 在这种情况下， <xref:System.Text.Encoding.GetBytes%2A> 支持字节数组的版本是最佳选择。

- 请考虑使用 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 方法而不是 <xref:System.Text.Encoding.GetByteCount%2A> 。 转换方法可转换尽可能多的数据，如果输出缓冲区太小，则会引发异常。 对于流的连续编码，此方法通常是最佳选择。

## Examples
 下面的示例确定对字符数组进行编码、对字符进行编码并显示生成的字节所需的字节数。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）

－和－

 将 <see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string -&gt; byte[]&#xA;override this.GetBytes : string -&gt; byte[]" Usage="encoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">包含要编码的字符的字符串。</param>
        <summary>在派生类中重写时，将指定字符串中的所有字符编码为一个字节序列。</summary>
        <returns>一个字节数组，包含对指定的字符集进行编码的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果要转换的数据仅在顺序块（如从流中读取的数据）中可用，或者如果数据量很大以致需要分为更小块，则应使用 <xref:System.Text.Decoder> <xref:System.Text.Encoder> <xref:System.Text.Encoding.GetDecoder%2A> 派生类的方法或方法提供的或 <xref:System.Text.Encoding.GetEncoder%2A> 。

 <xref:System.Text.Encoding.GetByteCount%2A>方法确定导致对一组 Unicode 字符进行编码的字节数， <xref:System.Text.Encoding.GetBytes%2A> 方法执行实际编码。 <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>方法需要离散转换，这与方法不同， <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 后者处理单个输入流上的多个转换。

 支持和的多个版本 <xref:System.Text.Encoding.GetByteCount%2A> <xref:System.Text.Encoding.GetBytes%2A> 。 下面是有关使用这些方法的一些编程注意事项：

- 您的应用程序可能需要将许多输入字符编码为代码页，并使用多个调用处理这些字符。 在这种情况下，您可能需要维护两次调用之间的状态，同时考虑所使用的对象保留的状态 <xref:System.Text.Encoder> 。 （例如，包含代理项对的字符序列可能以高代理项结束。 <xref:System.Text.Encoder>将记住高代理项，以便可以在以下调用开始时将其与低代理项组合在一起。 <xref:System.Text.Encoding>无法维护状态，因此字符将发送到 <xref:System.Text.EncoderFallback> 。）

- 如果你的应用程序处理字符串输入，则应使用的字符串版本 <xref:System.Text.Encoding.GetBytes%2A> 。

- 的 Unicode 字符缓冲区版本 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 允许一些快速的技巧，尤其是使用对象的多个调用 <xref:System.Text.Encoder> 或插入现有缓冲区。 但请记住，此方法版本有时不安全，因为指针是必需的。

- 如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。 在这种情况下， <xref:System.Text.Encoding.GetBytes%2A> 支持字节数组的版本是最佳选择。

- 请考虑使用 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 方法而不是 <xref:System.Text.Encoding.GetByteCount%2A> 。 转换方法可转换尽可能多的数据，如果输出缓冲区太小，则会引发异常。 对于流的连续编码，此方法通常是最佳选择。

## Examples
 下面的示例确定了对字符串中的字符串或范围进行编码、对字符进行编码并显示生成的字节所需的字节数。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）

－和－

 将 <see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int&#xA;override this.GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int" Usage="encoding.GetBytes (chars, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="chars">包含要编码的字符集的范围。</param>
        <param name="bytes">用于保存已编码字节的字节范围。</param>
        <summary>在派生类中重写时，将指定只读范围中的一组字符编码为字节范围。</summary>
        <returns>已编码的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果要转换的数据仅在顺序块（如从流中读取的数据）中可用，或者如果数据量很大以致需要分为更小块，则应使用 <xref:System.Text.Decoder> <xref:System.Text.Encoder> <xref:System.Text.Encoding.GetDecoder%2A> 派生类的方法或方法提供的或 <xref:System.Text.Encoding.GetEncoder%2A> 。

 <xref:System.Text.Encoding.GetByteCount%2A>方法确定导致对一组 Unicode 字符进行编码的字节数， <xref:System.Text.Encoding.GetBytes%2A> 方法执行实际编码。 <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>方法需要离散转换，这与方法不同， <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 后者处理单个输入流上的多个转换。

 支持和的多个版本 <xref:System.Text.Encoding.GetByteCount%2A> <xref:System.Text.Encoding.GetBytes%2A> 。 下面是有关使用这些方法的一些编程注意事项：

- 您的应用程序可能需要将许多输入字符编码为代码页，并使用多个调用处理这些字符。 在这种情况下，您可能需要维护两次调用之间的状态，同时考虑所使用的对象保留的状态 <xref:System.Text.Encoder> 。 （例如，包含代理项对的字符序列可能以高代理项结束。 <xref:System.Text.Encoder>将记住高代理项，以便可以在以下调用开始时将其与低代理项组合在一起。 <xref:System.Text.Encoding>无法维护状态，因此字符将发送到 <xref:System.Text.EncoderFallback> 。）

- 如果你的应用程序处理字符串输入，则应使用的字符串版本 <xref:System.Text.Encoding.GetBytes%2A> 。

- 如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。 在这种情况下， <xref:System.Text.Encoding.GetBytes%2A> 支持字节数组的版本是最佳选择。

- 请考虑使用 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 方法而不是 <xref:System.Text.Encoding.GetByteCount%2A> 。 转换方法可转换尽可能多的数据，如果输出缓冲区太小，则会引发异常。 对于流的连续编码，此方法通常是最佳选择。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int -&gt; byte[]&#xA;override this.GetBytes : char[] * int * int -&gt; byte[]" Usage="encoding.GetBytes (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">包含要编码的字符集的字符数组。</param>
        <param name="index">第一个要编码的字符的索引。</param>
        <param name="count">要编码的字符的数目。</param>
        <summary>在派生类中重写时，将指定字符数组中的一组字符编码为一个字节序列。</summary>
        <returns>一个字节数组，包含对指定的字符集进行编码的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果要转换的数据仅在顺序块（如从流中读取的数据）中可用，或者如果数据量很大以致需要分为更小块，则应使用 <xref:System.Text.Decoder> <xref:System.Text.Encoder> <xref:System.Text.Encoding.GetDecoder%2A> 派生类的方法或方法提供的或 <xref:System.Text.Encoding.GetEncoder%2A> 。

 <xref:System.Text.Encoding.GetByteCount%2A>方法确定导致对一组 Unicode 字符进行编码的字节数， <xref:System.Text.Encoding.GetBytes%2A> 方法执行实际编码。 <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>方法需要离散转换，这与方法不同， <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 后者处理单个输入流上的多个转换。

 支持和的多个版本 <xref:System.Text.Encoding.GetByteCount%2A> <xref:System.Text.Encoding.GetBytes%2A> 。 下面是有关使用这些方法的一些编程注意事项：

- 您的应用程序可能需要将许多输入字符编码为代码页，并使用多个调用处理这些字符。 在这种情况下，您可能需要维护两次调用之间的状态，同时考虑所使用的对象保留的状态 <xref:System.Text.Encoder> 。 （例如，包含代理项对的字符序列可能以高代理项结束。 <xref:System.Text.Encoder>将记住高代理项，以便可以在以下调用开始时将其与低代理项组合在一起。 <xref:System.Text.Encoding>无法维护状态，因此字符将发送到 <xref:System.Text.EncoderFallback> 。）

- 如果你的应用程序处理字符串输入，则应使用的字符串版本 <xref:System.Text.Encoding.GetBytes%2A> 。

- 的 Unicode 字符缓冲区版本 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 允许一些快速的技巧，尤其是使用对象的多个调用 <xref:System.Text.Encoder> 或插入现有缓冲区。 但请记住，此方法版本有时不安全，因为指针是必需的。

- 如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。 在这种情况下， <xref:System.Text.Encoding.GetBytes%2A> 支持字节数组的版本是最佳选择。

- 请考虑使用 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 方法而不是 <xref:System.Text.Encoding.GetByteCount%2A> 。 转换方法可转换尽可能多的数据，如果输出缓冲区太小，则会引发异常。 对于流的连续编码，此方法通常是最佳选择。

## Examples
 下面的示例确定对字符数组中的三个字符进行编码、对字符进行编码并显示生成的字节所需的字节数。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 或 <paramref name="count" /> 小于零。

- 或 -

 <paramref name="index" /> 和 <paramref name="count" /> 不表示 <paramref name="chars" /> 中的有效范围。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）

－和－

 将 <see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytes (s As String, index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetBytes : string * int * int -&gt; byte[]" Usage="encoding.GetBytes (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s">包含要编码的字符的字符串。</param>
        <param name="index">字符串内的索引，要从该位置开始编码。</param>
        <param name="count">要编码的字符的数目。</param>
        <summary>在派生类中重写时，从指定的 <paramref name="index" /> 开始，将指定字符串中由 <paramref name="count" /> 指定的字符数编码为字节数组。</summary>
        <returns>一个字节数组，包含对指定的字符集进行编码的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果要转换的数据仅在顺序块（如从流中读取的数据）中可用，或者如果数据量很大以致需要分为更小块，则应使用 <xref:System.Text.Decoder> <xref:System.Text.Encoder> <xref:System.Text.Encoding.GetDecoder%2A> 派生类的方法或方法提供的或 <xref:System.Text.Encoding.GetEncoder%2A> 。

 <xref:System.Text.Encoding.GetByteCount%2A>方法确定导致对一组 Unicode 字符进行编码的字节数， <xref:System.Text.Encoding.GetBytes%2A> 方法执行实际编码。 <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>方法需要离散转换，这与方法不同， <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 后者处理单个输入流上的多个转换。

 支持和的多个版本 <xref:System.Text.Encoding.GetByteCount%2A> <xref:System.Text.Encoding.GetBytes%2A> 。 下面是有关使用这些方法的一些编程注意事项：

- 您的应用程序可能需要将许多输入字符编码为代码页，并使用多个调用处理这些字符。 在这种情况下，您可能需要维护两次调用之间的状态，同时考虑所使用的对象保留的状态 <xref:System.Text.Encoder> 。 （例如，包含代理项对的字符序列可能以高代理项结束。 <xref:System.Text.Encoder>将记住高代理项，以便可以在以下调用开始时将其与低代理项组合在一起。 <xref:System.Text.Encoding>无法维护状态，因此字符将发送到 <xref:System.Text.EncoderFallback> 。）

- 如果你的应用程序处理字符串输入，则应使用的字符串版本 <xref:System.Text.Encoding.GetBytes%2A> 。

- 的 Unicode 字符缓冲区版本 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 允许一些快速的技巧，尤其是使用对象的多个调用 <xref:System.Text.Encoder> 或插入现有缓冲区。 但请记住，此方法版本有时不安全，因为指针是必需的。

- 如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。 在这种情况下， <xref:System.Text.Encoding.GetBytes%2A> 支持字节数组的版本是最佳选择。

- 请考虑使用 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 方法而不是 <xref:System.Text.Encoding.GetByteCount%2A> 。 转换方法可转换尽可能多的数据，如果输出缓冲区太小，则会引发异常。 对于流的连续编码，此方法通常是最佳选择。

## Examples
 下面的示例确定了对字符串中的字符串或范围进行编码、对字符进行编码并显示生成的字节所需的字节数。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bytes" Type="System.Byte*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars">指向第一个要编码的字符的指针。</param>
        <param name="charCount">要编码的字符的数目。</param>
        <param name="bytes">一个指针，指向开始写入所产生的字节序列的位置。</param>
        <param name="byteCount">最多写入的字节数。</param>
        <summary>在派生类中重写时，将一组字符（从指定的字符指针开始）编码为一个字节序列，并从指定的字节指针开始存储该字节序列。</summary>
        <returns>在由 <paramref name="bytes" /> 参数指示的位置处写入的实际字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 若要计算 <xref:System.Text.Encoding.GetBytes%2A> 存储生成的字节所需的确切数组大小，请调用 <xref:System.Text.Encoding.GetByteCount%2A> 方法。 若要计算最大数组大小，请调用 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法。 <xref:System.Text.Encoding.GetByteCount%2A>方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法的执行速度通常更快。

 如果要转换的数据仅在 （如从流中读取的数据） 的顺序块中可用，或者如果数据量很大，它需要划分为较小的块，则应使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>提供对象<xref:System.Text.Encoding.GetDecoder%2A>或<xref:System.Text.Encoding.GetEncoder%2A>方法，分别的派生类。

 <xref:System.Text.Encoding.GetByteCount%2A>方法确定导致对一组 Unicode 字符进行编码的字节数， <xref:System.Text.Encoding.GetBytes%2A> 方法执行实际编码。 <xref:System.Text.Encoding.GetBytes%2A>方法需要离散转换，这与方法不同， <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 后者处理单个输入流上的多个转换。

 支持和的多个版本 <xref:System.Text.Encoding.GetByteCount%2A> <xref:System.Text.Encoding.GetBytes%2A> 。 下面是有关使用这些方法的一些编程注意事项：

- 您的应用程序可能需要将许多输入字符编码为代码页，并使用多个调用处理这些字符。 在这种情况下，您可能需要维护两次调用之间的状态，同时考虑所使用的对象保留的状态 <xref:System.Text.Encoder> 。 （例如，包含代理项对的字符序列可能以高代理项结束。 <xref:System.Text.Encoder>将记住高代理项，以便可以在以下调用开始时将其与低代理项组合在一起。 <xref:System.Text.Encoding>无法维护状态，因此字符将发送到 <xref:System.Text.EncoderFallback> 。）

- 如果你的应用程序处理字符串输入，则应使用的字符串版本 <xref:System.Text.Encoding.GetBytes%2A> 。

- 的 Unicode 字符缓冲区版本 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 允许一些快速的技巧，尤其是使用对象的多个调用 <xref:System.Text.Encoder> 或插入现有缓冲区。 但请记住，此方法版本有时不安全，因为指针是必需的。

- 如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。 在这种情况下， <xref:System.Text.Encoding.GetBytes%2A> 支持字节数组的版本是最佳选择。

- 请考虑使用 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 方法而不是 <xref:System.Text.Encoding.GetByteCount%2A> 。 转换方法可转换尽可能多的数据，如果输出缓冲区太小，则会引发异常。 对于流的连续编码，此方法通常是最佳选择。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> 为 <see langword="null" />。

- 或 -

 <paramref name="bytes" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> 或 <paramref name="byteCount" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="byteCount" /> 少于所产生的字节数。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）

－和－

 将 <see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">包含要编码的字符集的字符数组。</param>
        <param name="charIndex">第一个要编码的字符的索引。</param>
        <param name="charCount">要编码的字符的数目。</param>
        <param name="bytes">要包含所产生的字节序列的字节数组。</param>
        <param name="byteIndex">要开始写入所产生的字节序列的索引位置。</param>
        <summary>在派生类中重写时，将指定字符数组中的一组字符编码为指定的字节数组。</summary>
        <returns>写入 <paramref name="bytes" /> 的实际字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 若要计算存储生成的字节所需的确切数组大小 <xref:System.Text.Encoding.GetBytes%2A> ，应调用 <xref:System.Text.Encoding.GetByteCount%2A> 方法。 若要计算最大数组大小，请调用 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法。 <xref:System.Text.Encoding.GetByteCount%2A>方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法的执行速度通常更快。

 如果要转换的数据仅在顺序块（如从流中读取的数据）中可用，或者如果数据量很大以致需要分为更小块，则应使用 <xref:System.Text.Decoder> <xref:System.Text.Encoder> <xref:System.Text.Encoding.GetDecoder%2A> 派生类的方法或方法提供的或 <xref:System.Text.Encoding.GetEncoder%2A> 。

 <xref:System.Text.Encoding.GetByteCount%2A>方法确定导致对一组 Unicode 字符进行编码的字节数， <xref:System.Text.Encoding.GetBytes%2A> 方法执行实际编码。 <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>方法需要离散转换，这与方法不同， <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 后者处理单个输入流上的多个转换。

 支持和的多个版本 <xref:System.Text.Encoding.GetByteCount%2A> <xref:System.Text.Encoding.GetBytes%2A> 。 下面是有关使用这些方法的一些编程注意事项：

- 您的应用程序可能需要将许多输入字符编码为代码页，并使用多个调用处理这些字符。 在这种情况下，您可能需要维护两次调用之间的状态，同时考虑所使用的对象保留的状态 <xref:System.Text.Encoder> 。 （例如，包含代理项对的字符序列可能以高代理项结束。 <xref:System.Text.Encoder>将记住高代理项，以便可以在以下调用开始时将其与低代理项组合在一起。 <xref:System.Text.Encoding>无法维护状态，因此字符将发送到 <xref:System.Text.EncoderFallback> 。）

- 如果你的应用程序处理字符串输入，则应使用的字符串版本 <xref:System.Text.Encoding.GetBytes%2A> 。

- 的 Unicode 字符缓冲区版本 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 允许一些快速的技巧，尤其是使用对象的多个调用 <xref:System.Text.Encoder> 或插入现有缓冲区。 但请记住，此方法版本有时不安全，因为指针是必需的。

- 如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。 在这种情况下， <xref:System.Text.Encoding.GetBytes%2A> 支持字节数组的版本是最佳选择。

- 请考虑使用 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 方法而不是 <xref:System.Text.Encoding.GetByteCount%2A> 。 转换方法可转换尽可能多的数据，如果输出缓冲区太小，则会引发异常。 对于流的连续编码，此方法通常是最佳选择。

## Examples
 下面的示例确定对字符数组中的三个字符进行编码、对字符进行编码并显示生成的字节所需的字节数。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> 为 <see langword="null" />。

- 或 -

 <paramref name="bytes" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" />、<paramref name="charCount" /> 或 <paramref name="byteIndex" /> 小于零。

- 或 -

 <paramref name="charIndex" /> 和 <paramref name="charCount" /> 不表示 <paramref name="chars" />中的有效范围。

- 或 -

 <paramref name="byteIndex" /> 不是 <paramref name="bytes" /> 中的有效索引。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="bytes" /> 中从 <paramref name="byteIndex" /> 到数组结尾没有足够的容量来容纳所产生的字节。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）

－和－

 将 <see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string * int * int * byte[] * int -&gt; int&#xA;override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">包含要编码的字符集的字符串。</param>
        <param name="charIndex">第一个要编码的字符的索引。</param>
        <param name="charCount">要编码的字符的数目。</param>
        <param name="bytes">要包含所产生的字节序列的字节数组。</param>
        <param name="byteIndex">要开始写入所产生的字节序列的索引位置。</param>
        <summary>在派生类中重写时，将指定字符串中的一组字符编码为指定的字节数组。</summary>
        <returns>写入 <paramref name="bytes" /> 的实际字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 若要计算存储生成的字节所需的确切数组大小 <xref:System.Text.Encoding.GetBytes%2A> ，应调用 <xref:System.Text.Encoding.GetByteCount%2A> 方法。 若要计算最大数组大小，请调用 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法。 <xref:System.Text.Encoding.GetByteCount%2A>方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法的执行速度通常更快。

 如果要转换的数据仅在顺序块（如从流中读取的数据）中可用，或者如果数据量很大以致需要分为更小块，则应使用 <xref:System.Text.Decoder> <xref:System.Text.Encoder> <xref:System.Text.Encoding.GetDecoder%2A> 派生类的方法或方法提供的或 <xref:System.Text.Encoding.GetEncoder%2A> 。

 <xref:System.Text.Encoding.GetByteCount%2A>方法确定导致对一组 Unicode 字符进行编码的字节数， <xref:System.Text.Encoding.GetBytes%2A> 方法执行实际编码。 <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>方法需要离散转换，这与方法不同， <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 后者处理单个输入流上的多个转换。

 支持和的多个版本 <xref:System.Text.Encoding.GetByteCount%2A> <xref:System.Text.Encoding.GetBytes%2A> 。 下面是有关使用这些方法的一些编程注意事项：

- 您的应用程序可能需要将许多输入字符编码为代码页，并使用多个调用处理这些字符。 在这种情况下，您可能需要维护两次调用之间的状态，同时考虑所使用的对象保留的状态 <xref:System.Text.Encoder> 。 （例如，包含代理项对的字符序列可能以高代理项结束。 <xref:System.Text.Encoder>将记住高代理项，以便可以在以下调用开始时将其与低代理项组合在一起。 <xref:System.Text.Encoding>无法维护状态，因此字符将发送到 <xref:System.Text.EncoderFallback> 。）

- 如果你的应用程序处理字符串输入，则应使用的字符串版本 <xref:System.Text.Encoding.GetBytes%2A> 。

- 的 Unicode 字符缓冲区版本 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 允许一些快速的技巧，尤其是使用对象的多个调用 <xref:System.Text.Encoder> 或插入现有缓冲区。 但请记住，此方法版本有时不安全，因为指针是必需的。

- 如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。 在这种情况下， <xref:System.Text.Encoding.GetBytes%2A> 支持字节数组的版本是最佳选择。

- 请考虑使用 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 方法而不是 <xref:System.Text.Encoding.GetByteCount%2A> 。 转换方法可转换尽可能多的数据，如果输出缓冲区太小，则会引发异常。 对于流的连续编码，此方法通常是最佳选择。

## Examples
 下面的示例确定了对字符串中的字符串或范围进行编码、对字符进行编码并显示生成的字节所需的字节数。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> 为 <see langword="null" />。

- 或 -

 <paramref name="bytes" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" />、<paramref name="charCount" /> 或 <paramref name="byteIndex" /> 小于零。

- 或 -

 <paramref name="charIndex" /> 和 <paramref name="charCount" /> 不表示 <paramref name="chars" />中的有效范围。

- 或 -

 <paramref name="byteIndex" /> 不是 <paramref name="bytes" /> 中的有效索引。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="bytes" /> 中从 <paramref name="byteIndex" /> 到数组结尾没有足够的容量来容纳所产生的字节。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）

－和－

 将 <see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在派生类中重写时，计算对字节序列进行解码所产生的字符数。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] -&gt; int&#xA;override this.GetCharCount : byte[] -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">包含要解码的字节序列的字节数组。</param>
        <summary>在派生类中重写时，计算对指定字节数组中的所有字节进行解码所产生的字符数。</summary>
        <returns>对指定字节序列进行解码所产生的字符数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 若要计算存储所生成的字符所需的确切数组大小 <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> ，应使用 <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> 方法。 若要计算最大数组大小，应使用 <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> 方法。 <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29>方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxCharCount%2A> 方法的执行速度通常更快。

 <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29>方法确定多少个字符会导致对一个字节序列进行解码，并且该 <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> 方法执行实际解码。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>方法需要分离转换，这与方法不同， <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 后者处理单个输入流上的多个传递。

 支持和的多个版本 <xref:System.Text.Encoding.GetCharCount%2A> <xref:System.Text.Encoding.GetChars%2A> 。 下面是有关使用这些方法的一些编程注意事项：

- 您的应用程序可能需要从代码页解码多个输入字节，并使用多个调用处理这些字节。 在这种情况下，可能需要在调用之间维护状态。

- 如果你的应用程序处理字符串输出，则应使用 <xref:System.Text.Encoding.GetString%2A> 方法。 由于此方法必须检查字符串长度并分配一个缓冲区，因此它稍慢一些，但生成的 <xref:System.String> 类型是首选的。

- 的字节版本 <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 允许一些快速的方法，尤其是对大缓冲区的多个调用。 但请记住，此方法版本有时不安全，因为指针是必需的。

- 如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。 在这种情况下， <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> 支持输出字符缓冲区的版本是最佳选择。

- 请考虑使用 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 方法而不是 <xref:System.Text.Encoding.GetCharCount%2A> 。 转换方法尽可能多地转换数据，如果输出缓冲区太小，则会引发异常。 对于流的连续解码，此方法通常是最佳选择。

## Examples
 下面的示例将字符串编码为一个字节数组，然后将这些字节解码为一个字符数组。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）

－和－

 将 <see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int&#xA;override this.GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="bytes">要解码的只读字节范围。</param>
        <summary>在派生类中重写时，计算对提供的只读字节范围进行解码所产生的字符数。</summary>
        <returns>对字节范围进行解码所产生的字符数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 若要计算 <xref:System.Text.Encoding.GetChars%2A> 存储所生成的字符所需的确切数组大小，应使用 <xref:System.Text.Encoding.GetCharCount%2A> 方法。 若要计算最大数组大小，请使用 <xref:System.Text.Encoding.GetMaxCharCount%2A> 方法。 <xref:System.Text.Encoding.GetCharCount%2A>方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxCharCount%2A> 方法的执行速度通常更快。

 <xref:System.Text.Encoding.GetCharCount%2A>方法确定多少个字符会导致对一个字节序列进行解码，并且该 <xref:System.Text.Encoding.GetChars%2A> 方法执行实际解码。 <xref:System.Text.Encoding.GetChars%2A>方法需要分离转换，这与方法不同， <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 后者处理单个输入流上的多个传递。

 支持和的多个版本 <xref:System.Text.Encoding.GetCharCount%2A> <xref:System.Text.Encoding.GetChars%2A> 。 下面是有关使用这些方法的一些编程注意事项：

- 您的应用程序可能需要从代码页解码多个输入字节，并使用多个调用处理这些字节。 在这种情况下，可能需要在调用之间维护状态。

- 如果你的应用程序处理字符串输出，则建议使用 <xref:System.Text.Encoding.GetString%2A> 方法。 由于此方法必须检查字符串长度并分配一个缓冲区，因此它稍慢一些，但生成的 <xref:System.String> 类型是首选的。

- 如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。 在这种情况下， <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> 支持输出字符缓冲区的版本是最佳选择。

- 请考虑使用 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 方法而不是 <xref:System.Text.Encoding.GetCharCount%2A> 。 转换方法尽可能多地转换数据，如果输出缓冲区太小，则会引发异常。 对于流的连续解码，此方法通常是最佳选择。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">指向第一个要解码的字节的指针。</param>
        <param name="count">要解码的字节数。</param>
        <summary>在派生类中重写时，计算对字节序列（从指定的字节指针开始）进行解码所产生的字符数。</summary>
        <returns>对指定字节序列进行解码所产生的字符数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 若要计算 <xref:System.Text.Encoding.GetChars%2A> 存储所生成的字符所需的确切数组大小，应使用 <xref:System.Text.Encoding.GetCharCount%2A> 方法。 若要计算最大数组大小，请使用 <xref:System.Text.Encoding.GetMaxCharCount%2A> 方法。 <xref:System.Text.Encoding.GetCharCount%2A>方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxCharCount%2A> 方法的执行速度通常更快。

 <xref:System.Text.Encoding.GetCharCount%2A>方法确定多少个字符会导致对一个字节序列进行解码，并且该 <xref:System.Text.Encoding.GetChars%2A> 方法执行实际解码。 <xref:System.Text.Encoding.GetChars%2A>方法需要分离转换，这与方法不同， <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 后者处理单个输入流上的多个传递。

 支持和的多个版本 <xref:System.Text.Encoding.GetCharCount%2A> <xref:System.Text.Encoding.GetChars%2A> 。 下面是有关使用这些方法的一些编程注意事项：

- 您的应用程序可能需要从代码页解码多个输入字节，并使用多个调用处理这些字节。 在这种情况下，可能需要在调用之间维护状态。

- 如果你的应用程序处理字符串输出，则建议使用 <xref:System.Text.Encoding.GetString%2A> 方法。 由于此方法必须检查字符串长度并分配一个缓冲区，因此它稍慢一些，但生成的 <xref:System.String> 类型是首选的。

- 的字节版本 <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 允许一些快速的方法，尤其是对大缓冲区的多个调用。 但请记住，此方法版本有时不安全，因为指针是必需的。

- 如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。 在这种情况下， <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> 支持输出字符缓冲区的版本是最佳选择。

- 请考虑使用 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 方法而不是 <xref:System.Text.Encoding.GetCharCount%2A> 。 转换方法尽可能多地转换数据，如果输出缓冲区太小，则会引发异常。 对于流的连续解码，此方法通常是最佳选择。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 小于零。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）

－和－

 将 <see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int -&gt; int" Usage="encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">包含要解码的字节序列的字节数组。</param>
        <param name="index">第一个要解码的字节的索引。</param>
        <param name="count">要解码的字节数。</param>
        <summary>在派生类中重写时，计算对字节序列（从指定字节数组开始）进行解码所产生的字符数。</summary>
        <returns>对指定字节序列进行解码所产生的字符数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 若要计算存储所生成的字符所需的确切数组大小 <xref:System.Text.Encoding.GetChars%2A> ，应使用 <xref:System.Text.Encoding.GetCharCount%2A> 方法。 若要计算最大数组大小，请使用 <xref:System.Text.Encoding.GetMaxCharCount%2A> 方法。 <xref:System.Text.Encoding.GetCharCount%2A>方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxCharCount%2A> 方法的执行速度通常更快。

 <xref:System.Text.Encoding.GetCharCount%2A>方法确定多少个字符会导致对一个字节序列进行解码，并且该 <xref:System.Text.Encoding.GetChars%2A> 方法执行实际解码。 <xref:System.Text.Encoding.GetChars%2A>方法需要分离转换，这与方法不同， <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 后者处理单个输入流上的多个传递。

 支持和的多个版本 <xref:System.Text.Encoding.GetCharCount%2A> <xref:System.Text.Encoding.GetChars%2A> 。 下面是有关使用这些方法的一些编程注意事项：

- 您的应用程序可能需要从代码页解码多个输入字节，并使用多个调用处理这些字节。 在这种情况下，可能需要在调用之间维护状态。

- 如果你的应用程序处理字符串输出，则建议使用 <xref:System.Text.Encoding.GetString%2A> 方法。 由于此方法必须检查字符串长度并分配一个缓冲区，因此它稍慢一些，但生成的 <xref:System.String> 类型是首选的。

- 的字节版本 <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 允许一些快速的方法，尤其是对大缓冲区的多个调用。 但请记住，此方法版本有时不安全，因为指针是必需的。

- 如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。 在这种情况下， <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> 支持输出字符缓冲区的版本是最佳选择。

- 请考虑使用 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 方法而不是 <xref:System.Text.Encoding.GetCharCount%2A> 。 转换方法尽可能多地转换数据，如果输出缓冲区太小，则会引发异常。 对于流的连续解码，此方法通常是最佳选择。

## Examples
 下面的示例将字符串从一种编码转换为另一种编码。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb" id="Snippet1":::

 下面的示例将字符串编码为一个字节数组，然后将一系列字节解码为字符数组。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 或 <paramref name="count" /> 小于零。

- 或 -

 <paramref name="index" /> 和 <paramref name="count" /> 不表示 <paramref name="bytes" /> 中的有效范围。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）

－和－

 将 <see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在派生类中重写时，将一个字节序列解码为一组字符。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte()) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] -&gt; char[]&#xA;override this.GetChars : byte[] -&gt; char[]" Usage="encoding.GetChars bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">包含要解码的字节序列的字节数组。</param>
        <summary>在派生类中重写时，将指定字节数组中的所有字节解码为一组字符。</summary>
        <returns>一个字节数组，包含对指定的字节序列进行解码的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>从输入字节序列中获取字符。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>不同于 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> ，因为 <xref:System.Text.Encoding> 需要离散转换，而 <xref:System.Text.Decoder> 为单个输入流上的多个传递设计。

 如果要转换的数据仅在顺序块（如从流中读取的数据）中可用，或者如果数据量很大以致需要分为更小块，则应使用 <xref:System.Text.Decoder> <xref:System.Text.Encoder> <xref:System.Text.Encoding.GetDecoder%2A> 派生类的方法或方法提供的或 <xref:System.Text.Encoding.GetEncoder%2A> 。

 > [!NOTE]
 > 此方法用于对 Unicode 字符进行操作，而不是针对任意二进制数据（如字节数组）。 如果需要将任意二进制数据编码为文本，应使用诸如 uuencode 这样的协议，该协议是由等方法实现的 <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType> 。

 <xref:System.Text.Encoding.GetCharCount%2A>方法确定多少个字符会导致对一个字节序列进行解码，并且该 <xref:System.Text.Encoding.GetChars%2A> 方法执行实际解码。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>方法需要分离转换，这与方法不同， <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 后者处理单个输入流上的多个传递。

 支持和的多个版本 <xref:System.Text.Encoding.GetCharCount%2A> <xref:System.Text.Encoding.GetChars%2A> 。 下面是有关使用这些方法的一些编程注意事项：

- 您的应用程序可能需要从代码页解码多个输入字节，并使用多个调用处理这些字节。 在这种情况下，您可能需要维护两次调用之间的状态，因为在分批处理时，字节序列可能会中断。 （例如，ISO-2022 移位序列的一部分可能结束一个 <xref:System.Text.Encoding.GetChars%2A> 调用并在下一次调用开始时继续 <xref:System.Text.Encoding.GetChars%2A> 。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>将为那些不完整的序列调用回退，但 <xref:System.Text.Decoder> 会记住这些序列的后续调用。）

- 如果你的应用程序处理字符串输出，则建议使用 <xref:System.Text.Encoding.GetString%2A> 方法。 由于此方法必须检查字符串长度并分配一个缓冲区，因此它稍慢一些，但生成的 <xref:System.String> 类型是首选的。

- 的字节版本 <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 允许一些快速的方法，尤其是对大缓冲区的多个调用。 但请记住，此方法版本有时不安全，因为指针是必需的。

- 如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。 在这种情况下， <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> 支持输出字符缓冲区的版本是最佳选择。

- 请考虑使用 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 方法而不是 <xref:System.Text.Encoding.GetCharCount%2A> 。 转换方法尽可能多地转换数据，如果输出缓冲区太小，则会引发异常。 对于流的连续解码，此方法通常是最佳选择。

## Examples
 下面的示例将字符串编码为一个字节数组，然后将这些字节解码为一个字符数组。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）

－和－

 将 <see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int&#xA;override this.GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int" Usage="encoding.GetChars (bytes, chars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="bytes">包含要解码的字节序列的只读范围。</param>
        <param name="chars">接收已解码字节的字符范围。</param>
        <summary>在派生类中重写时，将指定只读字节范围中的所有字节解码为字符范围。</summary>
        <returns>已解码的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>从输入字节跨度中获取字符。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>不同于 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> ，因为 <xref:System.Text.Encoding> 需要离散转换，而 <xref:System.Text.Decoder> 为单个输入流上的多个传递设计。

 如果要转换的数据仅在顺序块（如从流中读取的数据）中可用，或者如果数据量很大以致需要分为更小块，则应使用 <xref:System.Text.Decoder> <xref:System.Text.Encoder> <xref:System.Text.Encoding.GetDecoder%2A> 派生类的方法或方法提供的或 <xref:System.Text.Encoding.GetEncoder%2A> 。

 <xref:System.Text.Encoding.GetCharCount%2A>方法确定多少个字符会导致对一个字节序列进行解码，并且该 <xref:System.Text.Encoding.GetChars%2A> 方法执行实际解码。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>方法需要分离转换，这与方法不同， <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 后者处理单个输入流上的多个传递。

 支持和的多个版本 <xref:System.Text.Encoding.GetCharCount%2A> <xref:System.Text.Encoding.GetChars%2A> 。 下面是有关使用这些方法的一些编程注意事项：

- 您的应用程序可能需要从代码页解码多个输入字节，并使用多个调用处理这些字节。 在这种情况下，您可能需要维护两次调用之间的状态，因为在分批处理时，字节序列可能会中断。 （例如，ISO-2022 移位序列的一部分可能结束一个 <xref:System.Text.Encoding.GetChars%2A> 调用并在下一次调用开始时继续 <xref:System.Text.Encoding.GetChars%2A> 。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>将为那些不完整的序列调用回退，但 <xref:System.Text.Decoder> 会记住这些序列的后续调用。）

- 如果你的应用程序处理字符串输出，则建议使用 <xref:System.Text.Encoding.GetString%2A> 方法。 由于此方法必须检查字符串长度并分配一个缓冲区，因此它稍慢一些，但生成的 <xref:System.String> 类型是首选的。

- 的字节版本 <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 允许一些快速的方法，尤其是对大缓冲区的多个调用。 但请记住，此方法版本有时不安全，因为指针是必需的。

- 如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。 在这种情况下， <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> 支持输出字符缓冲区的版本是最佳选择。

- 请考虑使用 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 方法而不是 <xref:System.Text.Encoding.GetCharCount%2A> 。 转换方法尽可能多地转换数据，如果输出缓冲区太小，则会引发异常。 对于流的连续解码，此方法通常是最佳选择。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), index As Integer, count As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int -&gt; char[]&#xA;override this.GetChars : byte[] * int * int -&gt; char[]" Usage="encoding.GetChars (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">包含要解码的字节序列的字节数组。</param>
        <param name="index">第一个要解码的字节的索引。</param>
        <param name="count">要解码的字节数。</param>
        <summary>在派生类中重写时，将指定字节数组中的一个字节序列解码为一组字符。</summary>
        <returns>一个字节数组，包含对指定的字节序列进行解码的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>从输入字节序列中获取字符。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>不同于 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> ，因为 <xref:System.Text.Encoding> 需要离散转换，而 <xref:System.Text.Decoder> 为单个输入流上的多个传递设计。

 如果要转换的数据仅在顺序块（如从流中读取的数据）中可用，或者如果数据量很大以致需要分为更小块，则应使用 <xref:System.Text.Decoder> <xref:System.Text.Encoder> <xref:System.Text.Encoding.GetDecoder%2A> 派生类的方法或方法提供的或 <xref:System.Text.Encoding.GetEncoder%2A> 。

 > [!NOTE]
 > 此方法用于对 Unicode 字符进行操作，而不是针对任意二进制数据（如字节数组）。 如果需要将任意二进制数据编码为文本，应使用诸如 uuencode 这样的协议，该协议是由等方法实现的 <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType> 。

 <xref:System.Text.Encoding.GetCharCount%2A>方法确定多少个字符会导致对一个字节序列进行解码，并且该 <xref:System.Text.Encoding.GetChars%2A> 方法执行实际解码。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>方法需要分离转换，这与方法不同， <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 后者处理单个输入流上的多个传递。

 支持和的多个版本 <xref:System.Text.Encoding.GetCharCount%2A> <xref:System.Text.Encoding.GetChars%2A> 。 下面是有关使用这些方法的一些编程注意事项：

- 您的应用程序可能需要从代码页解码多个输入字节，并使用多个调用处理这些字节。 在这种情况下，您可能需要维护两次调用之间的状态，因为在分批处理时，字节序列可能会中断。 （例如，ISO-2022 移位序列的一部分可能结束一个 <xref:System.Text.Encoding.GetChars%2A> 调用并在下一次调用开始时继续 <xref:System.Text.Encoding.GetChars%2A> 。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>将为那些不完整的序列调用回退，但 <xref:System.Text.Decoder> 会记住这些序列的后续调用。）

- 如果你的应用程序处理字符串输出，则建议使用 <xref:System.Text.Encoding.GetString%2A> 方法。 由于此方法必须检查字符串长度并分配一个缓冲区，因此它稍慢一些，但生成的 <xref:System.String> 类型是首选的。

- 的字节版本 <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 允许一些快速的方法，尤其是对大缓冲区的多个调用。 但请记住，此方法版本有时不安全，因为指针是必需的。

- 如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。 在这种情况下， <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> 支持输出字符缓冲区的版本是最佳选择。

- 请考虑使用 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 方法而不是 <xref:System.Text.Encoding.GetCharCount%2A> 。 转换方法尽可能多地转换数据，如果输出缓冲区太小，则会引发异常。 对于流的连续解码，此方法通常是最佳选择。

## Examples
 下面的示例将字符串编码为一个字节数组，然后将一系列字节解码为字符数组。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 或 <paramref name="count" /> 小于零。

- 或 -

 <paramref name="index" /> 和 <paramref name="count" /> 不表示 <paramref name="bytes" /> 中的有效范围。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）

－和－

 将 <see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="chars" Type="System.Char*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">指向第一个要解码的字节的指针。</param>
        <param name="byteCount">要解码的字节数。</param>
        <param name="chars">一个指针，指向开始写入所产生的字符集的位置。</param>
        <param name="charCount">要写入的最大字符数。</param>
        <summary>在派生类中重写时，将一个字节序列（从指定的字节指针开始）解码为一组字符，并从指定的字符指针开始存储该组字符。</summary>
        <returns>在由 <paramref name="chars" /> 参数指示的位置处写入的实际字符数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 若要计算 <xref:System.Text.Encoding.GetChars%2A> 存储所生成的字符所需的确切数组大小，应使用 <xref:System.Text.Encoding.GetCharCount%2A> 方法。 若要计算最大数组大小，请使用 <xref:System.Text.Encoding.GetMaxCharCount%2A> 方法。 <xref:System.Text.Encoding.GetCharCount%2A>方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxCharCount%2A> 方法的执行速度通常更快。

 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>从输入字节序列中获取字符。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>不同于 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> ，因为 <xref:System.Text.Encoding> 需要离散转换，而 <xref:System.Text.Decoder> 为单个输入流上的多个传递设计。

 如果要转换的数据仅在 （如从流中读取的数据） 的顺序块中可用，或者如果数据量很大，它需要划分为较小的块，则应使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>提供对象<xref:System.Text.Encoding.GetDecoder%2A>或<xref:System.Text.Encoding.GetEncoder%2A>方法，分别的派生类。

 > [!NOTE]
 > 此方法用于对 Unicode 字符进行操作，而不是针对任意二进制数据（如字节数组）。 如果需要将任意二进制数据编码为文本，应使用诸如 uuencode 这样的协议，该协议是由等方法实现的 <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType> 。

 <xref:System.Text.Encoding.GetCharCount%2A>方法确定多少个字符会导致对一个字节序列进行解码，并且该 <xref:System.Text.Encoding.GetChars%2A> 方法执行实际解码。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>方法需要分离转换，这与方法不同， <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 后者处理单个输入流上的多个传递。

 支持和的多个版本 <xref:System.Text.Encoding.GetCharCount%2A> <xref:System.Text.Encoding.GetChars%2A> 。 下面是有关使用这些方法的一些编程注意事项：

- 您的应用程序可能需要从代码页解码多个输入字节，并使用多个调用处理这些字节。 在这种情况下，您可能需要维护两次调用之间的状态，因为在分批处理时，字节序列可能会中断。 （例如，ISO-2022 移位序列的一部分可能结束一个 <xref:System.Text.Encoding.GetChars%2A> 调用并在下一次调用开始时继续 <xref:System.Text.Encoding.GetChars%2A> 。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>将为那些不完整的序列调用回退，但 <xref:System.Text.Decoder> 会记住这些序列的后续调用。）

- 如果你的应用程序处理字符串输出，则 <xref:System.Text.Encoding.GetString%2A> 建议使用方法。 由于此方法必须检查字符串长度并分配一个缓冲区，因此它稍慢一些，但生成的 <xref:System.String> 类型是首选的。

- 的字节版本 <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 允许一些快速的方法，尤其是对大缓冲区的多个调用。 但请记住，此方法版本有时不安全，因为指针是必需的。

- 如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。 在这种情况下， <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> 支持输出字符缓冲区的版本是最佳选择。

- 请考虑使用 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 方法而不是 <xref:System.Text.Encoding.GetCharCount%2A> 。 转换方法尽可能多地转换数据，如果输出缓冲区太小，则会引发异常。 对于流的连续解码，此方法通常是最佳选择。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> 为 <see langword="null" />。

- 或 -

 <paramref name="chars" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> 或 <paramref name="charCount" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="charCount" /> 少于所产生的字符数。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）

－和－

 将 <see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">包含要解码的字节序列的字节数组。</param>
        <param name="byteIndex">第一个要解码的字节的索引。</param>
        <param name="byteCount">要解码的字节数。</param>
        <param name="chars">要用于包含所产生的字符集的字符数组。</param>
        <param name="charIndex">开始写入所产生的字符集的索引位置。</param>
        <summary>在派生类中重写时，将指定字节数组中的字节序列解码为指定的字符数组。</summary>
        <returns>写入 <paramref name="chars" /> 的实际字符数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 若要计算存储所生成的字符所需的确切数组大小 <xref:System.Text.Encoding.GetChars%2A> ，应使用 <xref:System.Text.Encoding.GetCharCount%2A> 方法。 若要计算最大数组大小，请使用 <xref:System.Text.Encoding.GetMaxCharCount%2A> 方法。 <xref:System.Text.Encoding.GetCharCount%2A>方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxCharCount%2A> 方法的执行速度通常更快。

 <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29>从输入字节序列中获取字符。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>不同于 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> ，因为 <xref:System.Text.Encoding> 需要离散转换，而 <xref:System.Text.Decoder> 为单个输入流上的多个传递设计。

 如果要转换的数据仅在顺序块（如从流中读取的数据）中可用，或者如果数据量很大以致需要分为更小块，则应使用 <xref:System.Text.Decoder> <xref:System.Text.Encoder> <xref:System.Text.Encoding.GetDecoder%2A> 派生类的方法或方法提供的或 <xref:System.Text.Encoding.GetEncoder%2A> 。

 > [!NOTE]
 > 此方法用于对 Unicode 字符进行操作，而不是针对任意二进制数据（如字节数组）。 如果需要将任意二进制数据编码为文本，应使用诸如 uuencode 这样的协议，该协议是由等方法实现的 <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType> 。

 <xref:System.Text.Encoding.GetCharCount%2A>方法确定多少个字符会导致对一个字节序列进行解码，并且该 <xref:System.Text.Encoding.GetChars%2A> 方法执行实际解码。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>方法需要分离转换，这与方法不同， <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 后者处理单个输入流上的多个传递。

 支持和的多个版本 <xref:System.Text.Encoding.GetCharCount%2A> <xref:System.Text.Encoding.GetChars%2A> 。 下面是有关使用这些方法的一些编程注意事项：

- 您的应用程序可能需要从代码页解码多个输入字节，并使用多个调用处理这些字节。 在这种情况下，您可能需要维护两次调用之间的状态，因为在分批处理时，字节序列可能会中断。 （例如，ISO-2022 移位序列的一部分可能结束一个 <xref:System.Text.Encoding.GetChars%2A> 调用并在下一次调用开始时继续 <xref:System.Text.Encoding.GetChars%2A> 。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>将为那些不完整的序列调用回退，但 <xref:System.Text.Decoder> 会记住这些序列的后续调用。）

- 如果你的应用程序处理字符串输出，则 <xref:System.Text.Encoding.GetString%2A> 建议使用方法。 由于此方法必须检查字符串长度并分配一个缓冲区，因此它稍慢一些，但生成的 <xref:System.String> 类型是首选的。

- 的字节版本 <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 允许一些快速的方法，尤其是对大缓冲区的多个调用。 但请记住，此方法版本有时不安全，因为指针是必需的。

- 如果你的应用程序必须转换大量数据，则应重新使用输出缓冲区。 在这种情况下， <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> 支持输出字符缓冲区的版本是最佳选择。

- 请考虑使用 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 方法而不是 <xref:System.Text.Encoding.GetCharCount%2A> 。 转换方法尽可能多地转换数据，如果输出缓冲区太小，则会引发异常。 对于流的连续解码，此方法通常是最佳选择。

## Examples
 下面的示例将字符串从一种编码转换为另一种编码。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb" id="Snippet1":::

 下面的示例将字符串编码为一个字节数组，然后将一系列字节解码为字符数组。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> 为 <see langword="null" />。

- 或 -

 <paramref name="chars" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteIndex" />、<paramref name="byteCount" /> 或 <paramref name="charIndex" /> 小于零。

- 或 -

 <paramref name="byteindex" /> 和 <paramref name="byteCount" /> 不表示 <paramref name="bytes" />中的有效范围。

- 或 -

 <paramref name="charIndex" /> 不是 <paramref name="chars" /> 中的有效索引。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="chars" /> 中从 <paramref name="charIndex" /> 到数组结尾没有足够容量来容纳所产生的字符。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）

－和－

 将 <see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="abstract member GetDecoder : unit -&gt; System.Text.Decoder&#xA;override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，获取一个解码器，该解码器将已编码的字节序列转换为字符序列。</summary>
        <returns>一个 <see cref="T:System.Text.Decoder" />，它将已编码的字节序列转换为字符序列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>方法使用类似于此类的方法的方式将连续字节块转换为连续的字符块 <xref:System.Text.Encoding.GetChars%2A> 。 但是， <xref:System.Text.Decoder> 会在调用之间维护状态信息，使其正确地对跨块的字节序列进行解码。 <xref:System.Text.Decoder>还保留数据块末尾的尾随字节，并在下一个解码操作中使用尾随字节。 因此， <xref:System.Text.Encoding.GetDecoder%2A> 和 <xref:System.Text.Encoding.GetEncoder%2A> 对于网络传输和文件操作非常有用，因为这些操作经常处理数据块而不是完整的数据流。

 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>默认实现返回 <see cref="T:System.Text.Decoder" /> ，它调用当前的 <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> 和 <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> 方法 <see cref="T:System.Text.Encoding" /> 。 必须重写此方法才能返回在 <see cref="T:System.Text.Decoder" /> 调用之间保持其状态的。</para></block>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <related type="Article" href="/dotnet/standard/base-types/character-encoding">了解编码</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="abstract member GetEncoder : unit -&gt; System.Text.Encoder&#xA;override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，获取一个解码器，该解码器将 Unicode 字符序列转换为已编码的字节序列。</summary>
        <returns>一个 <see cref="T:System.Text.Encoder" />，它将 Unicode 字符序列转换为已编码的字节序列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法使用类似于此类的方法的方式将顺序块字符转换为顺序字节块 <xref:System.Text.Encoding.GetBytes%2A> 。 但是， <xref:System.Text.Encoder> 会在调用之间维护状态信息，使其正确地对跨块的字符序列进行编码。 <xref:System.Text.Encoder>还保留数据块末尾的尾随字符，并在下一编码操作中使用尾随字符。 例如，数据块可能以不匹配的高代理项结束，并且匹配的低代理项可能位于下一个数据块中。 因此， <xref:System.Text.Encoding.GetDecoder%2A> 和 <xref:System.Text.Encoding.GetEncoder%2A> 对于网络传输和文件操作非常有用，因为这些操作经常处理数据块而不是完整的数据流。

 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>默认实现返回 <see cref="T:System.Text.Encoder" /> ，它调用当前的 <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> 和 <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> 方法 <see cref="T:System.Text.Encoding" /> 。 必须重写此方法才能返回在 <see cref="T:System.Text.Encoder" /> 调用之间保持其状态的。</para></block>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <related type="Article" href="/dotnet/standard/base-types/character-encoding">了解编码</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEncoding">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回指定代码页的编码。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (codepage As Integer) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding codepage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codepage">首选编码的代码页标识符。 有关可能值的列表，请参见 <see cref="T:System.Text.Encoding" />。

- 或 -

0（零），使用默认编码。</param>
        <summary>返回与指定代码页标识符关联的编码。</summary>
        <returns>与指定代码页关联的编码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 回退处理程序依赖于的编码类型 `codepage` 。 如果 `codepage` 是代码页或双字节字符集（DBCS）编码，则使用最佳回退处理程序。 否则，将使用替代回退处理程序。 这些回退处理程序可能不适合您的应用程序。 若要指定由指定的编码使用的回退处理程序 `codepage` ，可以调用 <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> 重载。

 在 .NET Framework 中， <xref:System.Text.Encoding.GetEncoding%2A> 方法依赖于基础平台来支持大多数代码页。 但是，.NET Framework 本机支持某些编码。 有关代码页的列表，请参阅[编码列表](/dotnet/api/system.text.encoding#list-of-encodings)。 在 .NET Core 中， <xref:System.Text.Encoding.GetEncoding%2A> 方法返回 .Net core 本机支持的编码。 在这两种 .NET 实现上，都可以调用 <xref:System.Text.Encoding.GetEncodings%2A> 方法来获取 <xref:System.Text.EncodingInfo> 对象的数组，这些对象包含有关所有可用的编码的信息。

 除了本机在 .NET Core 上可用或在 .NET Framework 的特定平台版本上受支持的编码以外，该 <xref:System.Text.Encoding.GetEncoding%2A> 方法还返回通过注册对象提供的任何其他编码 <xref:System.Text.EncodingProvider> 。 如果多个对象已注册了相同的编码 <xref:System.Text.EncodingProvider> ，则此方法将返回最后一个注册的。

还可以为参数提供0值 `codepage` 。 其确切行为取决于是否已通过注册对象提供了任何编码 <xref:System.Text.EncodingProvider> ：

- 如果注册了一个或多个编码提供程序，则它会返回上次注册的提供程序的编码，该提供程序已选择在向 <xref:System.Text.Encoding.GetEncoding%2A> 方法传递 `codepage` 参数0时返回编码。

- 在 .NET Framework 上，如果没有注册任何编码提供程序，如果 <xref:System.Text.CodePagesEncodingProvider> 是注册的编码提供程序，或者如果没有已注册的编码提供程序处理 `codepage` 值0，则返回操作系统的活动代码页。 若要确定 Windows 系统上的活动代码页，请从 Windows 桌面上 .NET Framework 调用 Windows [GetACP](/windows/win32/api/winnls/nf-winnls-getacp)函数。

- 在 .NET Core 中，如果未注册任何编码提供程序，或者没有任何注册的编码提供程序处理 `codepage` 值0，则返回 <xref:System.Text.UTF8Encoding> 。

> [!NOTE]
> - 某些不受支持的代码页会 <xref:System.ArgumentException> 引发，而另一些则 <xref:System.NotSupportedException> 导致。 因此，您的代码必须捕获 "异常" 部分中指示的所有异常。
> - 在 .NET 5.0 和更高版本中， `65000` 不支持表示 utf-8 的代码页标识符。

> [!NOTE]
> ANSI 代码页在不同计算机上可能不同，并且可以在一台计算机上更改，导致数据损坏。 出于此原因，如果活动代码页是 ANSI 代码页，则不建议使用返回的默认代码页对数据进行编码和解码 `Encoding.GetEncoding(0)` 。 为获得最一致的结果，应使用 Unicode 编码，例如 UTF-8 （代码页65001）或 UTF-16，而不是使用特定的代码页。

 <xref:System.Text.Encoding.GetEncoding%2A>使用默认设置返回缓存的实例。 应使用派生类的构造函数获取具有不同设置的实例。 例如， <xref:System.Text.UTF32Encoding> 类提供可让你启用错误检测的构造函数。

## Examples
 下面的示例获取相同编码的两个实例（一个按代码页，另一个按名称），并检查它们是否相等。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codepage" /> 小于零或大于 65535。</exception>
        <exception cref="T:System.ArgumentException">基础平台不支持 <paramref name="codepage" />。</exception>
        <exception cref="T:System.NotSupportedException">基础平台不支持 <paramref name="codepage" />。</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="/dotnet/standard/base-types/character-encoding">了解编码</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (name As String) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">首选编码的代码页名称。 <see cref="P:System.Text.Encoding.WebName" /> 属性返回的所有值均有效。 有关可能值的列表，请参见 <see cref="T:System.Text.Encoding" />。</param>
        <summary>返回与指定代码页名称关联的编码。</summary>
        <returns>与指定的代码页关联的编码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 回退处理程序依赖于的编码类型 `name` 。 如果 `name` 是代码页或双字节字符集（DBCS）编码，则使用最佳回退处理程序。 否则，将使用替代回退处理程序。 这些回退处理程序可能不适合您的应用程序。 若要指定由指定的编码使用的回退处理程序 `name` ，可以调用 <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> 重载。

在 .NET Framework 中， <xref:System.Text.Encoding.GetEncoding%2A> 方法依赖于基础平台来支持大多数代码页。 但是，.NET Framework 本机支持某些编码。 有关代码页的列表，请参阅[编码列表](/dotnet/api/system.text.encoding#list-of-encodings)。 在 .NET Core 中， <xref:System.Text.Encoding.GetEncoding%2A> 方法返回 .Net core 本机支持的编码。 在这两种 .NET 实现上，都可以调用 <xref:System.Text.Encoding.GetEncodings%2A> 方法来获取 <xref:System.Text.EncodingInfo> 对象的数组，这些对象包含有关所有可用的编码的信息。

 除了本机在 .NET Core 上可用或在 .NET Framework 的特定平台版本上受支持的编码以外，该 <xref:System.Text.Encoding.GetEncoding%2A> 方法还返回通过注册对象提供的任何其他编码 <xref:System.Text.EncodingProvider> 。 如果多个对象已注册了相同的编码 <xref:System.Text.EncodingProvider> ，则此方法将返回最后一个注册的。

在 .NET 5.0 和更高版本中，不支持代码页名称 `utf-7` 。

> [!NOTE]
> 在不同的计算机上，ANSI 代码页可能会不同，或者可以针对一台计算机进行更改，从而导致数据损坏。 为获得最一致的结果，请使用 Unicode，如 UTF-8 （代码页65001）或 UTF-16，而不是特定的代码页。

 <xref:System.Text.Encoding.GetEncoding%2A>使用默认设置返回缓存的实例。 应使用派生类的构造函数获取具有不同设置的实例。 例如， <xref:System.Text.UTF32Encoding> 类提供可让你启用错误检测的构造函数。

## Examples
 下面的示例获取相同编码的两个实例（一个按代码页，另一个按名称），并检查它们是否相等。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> 不是有效的代码页名称。

- 或 -

基础平台不支持 <paramref name="name" /> 所指示的代码页。</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="/dotnet/standard/base-types/character-encoding">了解编码</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (codepage As Integer, encoderFallback As EncoderFallback, decoderFallback As DecoderFallback) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (codepage, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codepage">首选编码的代码页标识符。 有关可能值的列表，请参见 <see cref="T:System.Text.Encoding" />。

- 或 -

0（零），使用默认编码。</param>
        <param name="encoderFallback">一个对象，在无法用当前编码对字符进行编码时，该对象可用来提供错误处理过程。</param>
        <param name="decoderFallback">一个对象，在无法用当前编码对字节序列进行解码时，该对象可用来提供错误处理过程。</param>
        <summary>返回与指定代码页标识符关联的编码。 参数指定一个错误处理程序，用于处理无法编码的字符和无法解码的字节序列。</summary>
        <returns>与指定代码页关联的编码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
> - 某些不受支持的代码页会 <xref:System.ArgumentException> 引发异常，而其他代码页则导致引发异常 <xref:System.NotSupportedException> 。 因此，您的代码必须捕获 "异常" 部分中指示的所有异常。
> - 在 .NET 5.0 和更高版本中， `65000` 不支持表示 utf-8 的代码页标识符。

在 .NET Framework 中， <xref:System.Text.Encoding.GetEncoding%2A> 方法依赖于基础平台来支持大多数代码页。 但是，.NET Framework 本机支持某些编码。 有关代码页的列表，请参阅[编码列表](/dotnet/api/system.text.encoding#list-of-encodings)。 在 .NET Core 中， <xref:System.Text.Encoding.GetEncoding%2A> 方法返回 .Net core 本机支持的编码。 在这两种 .NET 实现上，都可以调用 <xref:System.Text.Encoding.GetEncodings%2A> 方法来获取 <xref:System.Text.EncodingInfo> 对象的数组，这些对象包含有关所有可用的编码的信息。

 除了本机在 .NET Core 上可用或在 .NET Framework 的特定平台版本上受支持的编码以外，该 <xref:System.Text.Encoding.GetEncoding%2A> 方法还返回通过注册对象提供的任何其他编码 <xref:System.Text.EncodingProvider> 。 如果多个对象已注册了相同的编码 <xref:System.Text.EncodingProvider> ，则此方法将返回最后一个注册的。

还可以为参数提供0值 `codepage` 。 其确切行为取决于是否已通过注册对象提供了任何编码 <xref:System.Text.EncodingProvider> ：

- 如果注册了一个或多个编码提供程序，则它会返回上次注册的提供程序的编码，该提供程序已选择在向 <xref:System.Text.Encoding.GetEncoding%2A> 方法传递 `codepage` 参数0时返回编码。

- 在 .NET Framework 上，如果没有注册任何编码提供程序，如果 <xref:System.Text.CodePagesEncodingProvider> 是注册的编码提供程序，或者如果没有已注册的编码提供程序处理 `codepage` 值0，则返回活动代码页。

- 在 .NET Core 中，如果未注册任何编码提供程序，或者没有任何注册的编码提供程序处理 `codepage` 值0，则返回 <xref:System.Text.UTF8Encoding> 编码。

> [!NOTE]
> ANSI 代码页在不同计算机上可能不同，并且可以在一台计算机上更改，导致数据损坏。 出于此原因，如果活动代码页是 ANSI 代码页，则不建议使用返回的默认代码页对数据进行编码和解码 `Encoding.GetEncoding(0)` 。 为获得最一致的结果，应使用 Unicode，如 UTF-8 （代码页65001）或 UTF-16，而不是特定的代码页。

 若要获取与活动代码页关联的编码，可以为参数提供值 0; `codepage` 如果你的代码在 Windows 桌面上 .NET Framework 上运行，则检索属性的值 <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> 。 若要确定当前的活动代码页，请从 Windows 桌面上 .NET Framework 调用 Windows [GetACP](/windows/win32/api/winnls/nf-winnls-getacp)函数。

 <xref:System.Text.Encoding.GetEncoding%2A>使用默认设置返回缓存的实例。 应使用派生类的构造函数获取具有不同设置的实例。 例如， <xref:System.Text.UTF32Encoding> 类提供可让你启用错误检测的构造函数。

## Examples
 下面的示例演示 <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> 方法。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codepage" /> 小于零或大于 65535。</exception>
        <exception cref="T:System.ArgumentException">基础平台不支持 <paramref name="codepage" />。</exception>
        <exception cref="T:System.NotSupportedException">基础平台不支持 <paramref name="codepage" />。</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="/dotnet/standard/base-types/character-encoding">了解编码</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (name As String, encoderFallback As EncoderFallback, decoderFallback As DecoderFallback) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (name, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">首选编码的代码页名称。 <see cref="P:System.Text.Encoding.WebName" /> 属性返回的所有值均有效。 可能值均在 <see cref="T:System.Text.Encoding" /> 类主题中出现的表的“名称”一列中列出。</param>
        <param name="encoderFallback">一个对象，在无法用当前编码对字符进行编码时，该对象可用来提供错误处理过程。</param>
        <param name="decoderFallback">一个对象，在无法用当前编码对字节序列进行解码时，该对象可用来提供错误处理过程。</param>
        <summary>返回与指定代码页名称关联的编码。 参数指定一个错误处理程序，用于处理无法编码的字符和无法解码的字节序列。</summary>
        <returns>与指定代码页关联的编码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

在 .NET Framework 中， <xref:System.Text.Encoding.GetEncoding%2A> 方法依赖于基础平台来支持大多数代码页。 但是，.NET Framework 本机支持某些编码。 有关代码页的列表，请参阅[编码列表](/dotnet/api/system.text.encoding#list-of-encodings)。 在 .NET Core 中， <xref:System.Text.Encoding.GetEncoding%2A> 方法返回 .Net core 本机支持的编码。 在这两种 .NET 实现上，都可以调用 <xref:System.Text.Encoding.GetEncodings%2A> 方法来获取 <xref:System.Text.EncodingInfo> 对象的数组，这些对象包含有关所有可用的编码的信息。

 除了本机在 .NET Core 上可用或在 .NET Framework 的特定平台版本上受支持的编码以外，该 <xref:System.Text.Encoding.GetEncoding%2A> 方法还返回通过注册对象提供的任何其他编码 <xref:System.Text.EncodingProvider> 。 如果多个对象已注册了相同的编码 <xref:System.Text.EncodingProvider> ，则此方法将返回最后一个注册的。

在 .NET 5.0 和更高版本中，不支持代码页名称 `utf-7` 。

> [!NOTE]
> ANSI 代码页在不同计算机上可能不同，并且可以在一台计算机上更改，导致数据损坏。 为获得最一致的结果，应使用 Unicode 编码，例如 UTF-8 （代码页65001）或 UTF-16，而不是使用特定的代码页。

 <xref:System.Text.Encoding.GetEncoding%2A>使用默认设置返回缓存的实例。 应使用派生类的构造函数获取具有不同设置的实例。 例如， <xref:System.Text.UTF32Encoding> 类提供可让你启用错误检测的构造函数。

## Examples
 下面的示例演示 <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> 方法。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> 不是有效的代码页名称。

- 或 -

基础平台不支持 <paramref name="name" /> 所指示的代码页。</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="/dotnet/standard/base-types/character-encoding">了解编码</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncodings () As EncodingInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Text::EncodingInfo ^&gt; ^ GetEncodings();" />
      <MemberSignature Language="F#" Value="static member GetEncodings : unit -&gt; System.Text.EncodingInfo[]" Usage="System.Text.Encoding.GetEncodings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回包含所有编码的数组。</summary>
        <returns>包含所有编码的数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法返回受支持的编码的列表，该列表由代码页唯一区分。 有关列出受支持编码的表，请参阅 <xref:System.Text.Encoding> 。

> [!NOTE]
> 在 .NET 5.0 和更高版本中，返回的支持的编码的列表 <xref:System.Text.Encoding.GetEncodings%2A> 包括通过调用注册的任何实现提供的任何其他编码 <xref:System.Text.EncodingProvider> <xref:System.Text.Encoding.RegisterProvider%2A> 。
>
> 在 .NET Framework 和 .NET Core 中，返回的支持编码列表 *不* 包含这些附加编码。

 在 .NET Framework 上，编码50220和50222都与名称 "iso-2022-jp" 相关联，但它们不同。 编码50220将半角片假名字符转换为全角字符，而编码50222使用 "移入/移出" 序列对半角片假名字符进行编码。 编码50222的显示名称为 "日语（JIS-允许1字节假名-SO/SI）"，以将其与显示名称为 "日语（JIS）" 的编码50220区分开来。

 如果请求编码名称 "iso-2022-jp"，.NET Framework 将返回编码50220。 不过，适用于应用程序的编码取决于对半角片假名字符的首选处理方式。

 若要获取特定的编码，请使用 <xref:System.Text.Encoding.GetEncoding%2A> 方法。

 <xref:System.Text.Encoding.GetEncodings%2A>有时用于向用户显示 "**另存为**" 对话框中的编码列表。 但是，许多非 Unicode 编码都不完整，而是将多个字符转换为 "？"，或者在不同的平台上具有细微的不同行为。 请考虑使用 UTF-8 或 UTF-16 作为默认值。

## Examples
 下面的示例检查每个编码的布尔值属性的值。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="/dotnet/standard/base-types/character-encoding">了解编码</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回当前实例的哈希代码。</summary>
        <returns>当前实例的哈希代码。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxByteCount : int -&gt; int" Usage="encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">要编码的字符的数目。</param>
        <summary>在派生类中重写时，计算对指定数目的字符进行编码所产生的最大字节数。</summary>
        <returns>对指定数目的字符进行编码所产生的最大字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `charCount`参数实际上指定 <xref:System.Char> 表示要编码的 Unicode 字符的对象数，因为 .net 内部使用 utf-16 来表示 unicode 字符。 因此，大多数 Unicode 字符均可由一个 <xref:System.Char> 对象表示，但例如，代理项对表示的 unicode 字符需要两个 <xref:System.Char> 对象。

 若要计算存储生成的字节所需的确切数组大小 <xref:System.Text.Encoding.GetBytes%2A> ，应使用 <xref:System.Text.Encoding.GetByteCount%2A> 方法。 若要计算最大数组大小，请使用 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法。 <xref:System.Text.Encoding.GetByteCount%2A>方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxByteCount%2A> 方法的执行速度通常更快。

 <xref:System.Text.Encoding.GetMaxByteCount%2A>检索最差事例数，包括当前所选的最糟糕的情况 <xref:System.Text.EncoderFallback> 。 如果使用可能大的字符串选择回退，则会 <xref:System.Text.Encoding.GetMaxByteCount%2A> 检索较大的值，特别是在编码的最差情况涉及切换每个字符的模式的情况下。 例如，ISO-2022-JP 可能会发生这种情况。 有关详细信息，请参阅博客文章 "[GetMaxByteCount （）和 GetMaxCharCount （）？](https://blogs.msdn.microsoft.com/shawnste/2005/03/02/whats-with-encoding-getmaxbytecount-and-encoding-getmaxcharcount/)"。

 在大多数情况下，此方法检索小字符串的合理值。 对于大字符串，可能需要在很少的情况下选择使用非常大的缓冲区，并在很少的情况下捕获错误。 你可能还需要考虑使用或的其他方法 <xref:System.Text.Encoding.GetByteCount%2A> <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 。

 使用时 <xref:System.Text.Encoding.GetMaxByteCount%2A> ，应根据输入缓冲区的最大大小分配输出缓冲区。 如果输出缓冲区的大小受到限制，可以使用 <xref:System.Text.Encoding.Convert%2A> 方法。

 请注意，会 <xref:System.Text.Encoding.GetMaxByteCount%2A> 考虑以前的解码器操作的潜在遗留代理项。 由于解码器的原因，向方法传递值1时，将为单字节编码（如 ASCII）检索2。 <xref:System.Text.ASCIIEncoding.IsSingleByte%2A>如果此信息是必需的，则应使用属性。

> [!NOTE]
> `GetMaxByteCount(N)`不一定与相同 `N* GetMaxByteCount(1)` 。

## Examples
 下面的示例确定对字符数组进行编码、对字符进行编码并显示生成的字节所需的字节数。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> 小于零。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）

－和－

 将 <see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <block subset="none" type="overrides"><para><see cref="T:System.Text.Encoding" />如果根据此方法的计算结果调整了缓冲区的大小，则所有实现都必须保证没有发生缓冲区溢出异常。</para></block>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxCharCount : int -&gt; int" Usage="encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">要解码的字节数。</param>
        <summary>在派生类中重写时，计算对指定数目的字节进行解码时所产生的最大字符数。</summary>
        <returns>对指定数目的字节进行解码时所产生的最大字符数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 若要计算存储所生成的字符所需的确切数组大小 <xref:System.Text.Encoding.GetChars%2A> ，应使用 <xref:System.Text.Encoding.GetCharCount%2A> 方法。 若要计算最大数组大小，请使用 <xref:System.Text.Encoding.GetMaxCharCount%2A> 方法。 <xref:System.Text.Encoding.GetCharCount%2A>方法通常允许分配较少的内存，而 <xref:System.Text.Encoding.GetMaxCharCount%2A> 方法的执行速度通常更快。

 <xref:System.Text.Encoding.GetMaxCharCount%2A>检索最差事例数，包括当前所选的最糟糕的情况 <xref:System.Text.DecoderFallback> 。 如果使用可能大的字符串选择回退，则会 <xref:System.Text.Encoding.GetMaxCharCount%2A> 检索大型值。

 在大多数情况下，此方法检索小字符串的合理数字。 对于大字符串，你可能需要在很少的情况下选择使用非常大的缓冲区，并捕获更合理的缓冲区太小的错误。 你可能还需要考虑使用或的其他方法 <xref:System.Text.Encoding.GetCharCount%2A> <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 。

 <xref:System.Text.Encoding.GetMaxCharCount%2A>与之间没有关系 <xref:System.Text.Encoding.GetBytes%2A> 。 如果需要一个与一起使用的类似功能 <xref:System.Text.Encoding.GetBytes%2A> ，则应使用 <xref:System.Text.Encoding.GetMaxByteCount%2A> 。

 使用时 <xref:System.Text.Encoding.GetMaxCharCount%2A> ，应根据输入缓冲区的最大大小分配输出缓冲区。 如果输出缓冲区的大小受到限制，可以使用 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 方法。

 请注意， <xref:System.Text.Encoding.GetMaxCharCount%2A> 从上一个编码器操作中考虑剩余字节的最坏情况。 对于大多数代码页，将值0传递到此方法将检索大于或等于1的值。

> [!NOTE]
> `GetMaxCharCount(N)`不一定与相同 `N* GetMaxCharCount(1)` 。

## Examples
 下面的示例将字符串编码为一个字节数组，然后将这些字节解码为一个字符数组。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> 小于零。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）

－和－

 将 <see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <block subset="none" type="overrides"><para><see cref="T:System.Text.Encoding" />如果根据此方法的计算结果调整了缓冲区的大小，则所有实现都必须保证没有发生缓冲区溢出异常。</para></block>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="abstract member GetPreamble : unit -&gt; byte[]&#xA;override this.GetPreamble : unit -&gt; byte[]" Usage="encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，返回指定所用编码的字节序列。</summary>
        <returns>一个字节数组，包含指定所用编码的字节序列。

 - 或 -

 长度为零的字节数组（如果不需要前导码）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此对象还可以 <xref:System.Text.Encoding> 提供前导码，它是一个字节数组，可以作为编码过程中所产生的字节序列的前缀。 如果引言包含字节顺序标记（在 Unicode、码位 U + FEFF 中），则它有助于解码器确定字节顺序和转换格式或 UTF。

 Unicode 字节顺序标记（BOM）按以下方式序列化（十六进制）：

- UTF-8： EF BB BF

- UTF-16 大 endian 字节顺序： FE FF

- UTF-16 little endian 字节顺序： FF FE

- 32大 endian 字节顺序： 00 00 FE FF

- 32 little endian 字节顺序： FF FE 00 00

 应使用 BOM，因为它提供了对文件的编码的几乎某些标识，例如，对对象的引用丢失 <xref:System.Text.Encoding> 、未标记或标记不正确或标记为不正确的 web 数据或随机文本文件。 如果数据一致且标记正确（最好是 UTF-8 或 UTF-16），通常可以避免用户问题。

 对于提供编码类型的标准，BOM 有些多余。 但是，可以使用它来帮助服务器发送正确的编码标头。 或者，它可以用作回退，以防编码在其他情况下丢失。

 使用 BOM 存在一些缺点。 例如，了解如何限制使用 BOM 的数据库字段可能很困难。 文件的串联可能也是一个问题，例如，当文件以这样一种方式进行合并时，不需要的字符会在数据中间结束。 但尽管有几个缺点，但强烈建议使用 BOM。

 有关字节顺序和字节顺序标记的详细信息，请参阅[unicode 主页](https://home.unicode.org/)上的 unicode 标准。

> [!CAUTION]
> 若要确保编码的字节解码正确，应使用前导码作为编码字节的前缀。 但是，大多数编码不提供前导码。 若要确保已编码的字节解码正确，应使用 Unicode 编码，即、、 <xref:System.Text.UTF8Encoding> <xref:System.Text.UnicodeEncoding> 或 <xref:System.Text.UTF32Encoding> ，使用前导码。

## Examples
 下面的示例根据前导头确定编码的字节顺序。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在派生类中重写时，将一个字节序列解码为一个字符串。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] -&gt; string&#xA;override this.GetString : byte[] -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">包含要解码的字节序列的字节数组。</param>
        <summary>在派生类中重写时，将指定字节数组中的所有字节解码为一个字符串。</summary>
        <returns>包含指定字节序列解码结果的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果要转换的数据仅适用于连续块（如从流中读取的数据），或者如果数据量太大以致需要分为更小块，则应使用 <xref:System.Text.Decoder> 派生类的方法返回的对象 <xref:System.Text.Encoding.GetDecoder%2A> 。

 请参阅参考主题的 "备注" 部分， <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 了解解码方法和注意事项。

 请注意，特定实现的方法的精确行为 <xref:System.Text.Encoding.GetString%2A> <xref:System.Text.Encoding> 取决于为该对象定义的回退策略 <xref:System.Text.Encoding> 。 有关详细信息，请参阅[.net 中的字符编码](/dotnet/standard/base-types/character-encoding)主题的 "选择回退策略" 部分。

## Examples
 下面的示例从对象表示的二进制文件中读取 UTF-8 编码的字符串 <xref:System.IO.FileStream> 。 对于小于2048个字节的文件，它会将整个文件的内容读入一个字节数组中，并调用 <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> 方法来执行解码。 对于较大的文件，它一次将2048字节读取到字节数组中， <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 并调用方法来确定数组中包含的字符数，然后调用 <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> 方法来执行解码。

 [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]

 该示例使用以下文本，该文本应保存到名为 Utf8Example.txt 的 UTF-8 编码文件中。

```txt

This is a UTF-8-encoded file that contains primarily Latin text, although it
does list the first twelve letters of the Russian (Cyrillic) alphabet:

А б в г д е ё ж з и й к

The goal is to save this file, then open and decode it as a binary stream.

```

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">字节数组中包含无效的 Unicode 码位。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）

－和－

 将 <see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string? GetString (ReadOnlySpan&lt;byte&gt; bytes);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString (bytes As ReadOnlySpan(Of Byte)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="member this.GetString : ReadOnlySpan&lt;byte&gt; -&gt; string" Usage="encoding.GetString bytes" />
      <MemberSignature Language="C#" Value="public string GetString (ReadOnlySpan&lt;byte&gt; bytes);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="bytes">要解码为 Unicode 字符串的只读字节范围。</param>
        <summary>在派生类中重写时，将指定字节范围中的所有字节解码为一个字符串。</summary>
        <returns>一个字符串，其中包含提供的只读范围中的已解码字节。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoding.GetString%2A>方法旨在优化性能。 可以改为调用此方法而无需创建任何中间对象，而不是先创建托管字节数组再对其进行解码。

 如果要转换的数据仅适用于连续块（如从流中读取的数据），或者如果数据量太大以致需要分为更小块，则应使用 <xref:System.Text.Decoder> 派生类的方法返回的对象 <xref:System.Text.Encoding.GetDecoder%2A> 。

 请参阅参考主题的 "备注" 部分， <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 了解解码方法和注意事项。

 请注意，特定实现的方法的精确行为 <xref:System.Text.Encoding.GetString%2A> <xref:System.Text.Encoding> 取决于为该对象定义的回退策略 <xref:System.Text.Encoding> 。 有关详细信息，请参阅[.net 中的字符编码](/dotnet/standard/base-types/character-encoding)主题的 "选择回退策略" 部分。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="member this.GetString : nativeptr&lt;byte&gt; * int -&gt; string" Usage="encoding.GetString (bytes, byteCount)" />
      <MemberSignature Language="C#" Value="public string? GetString (byte* bytes, int byteCount);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">指向字节数组的指针。</param>
        <param name="byteCount">要解码的字节数。</param>
        <summary>在派生类中重写时，将在指定地址开始的指定字节数解码为字符串。</summary>
        <returns>包含指定字节序列解码结果的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此 <xref:System.Text.Encoding.GetString%2A> 方法旨在优化到字节数组的本机指针时的性能。 可以改为调用此方法而无需创建任何中间对象，而不是先创建托管字节数组再对其进行解码。

 如果要转换的数据仅适用于连续块（如从流中读取的数据），或者如果数据量太大以致需要分为更小块，则应使用 <xref:System.Text.Decoder> 派生类的方法返回的对象 <xref:System.Text.Encoding.GetDecoder%2A> 。

 请参阅参考主题的 "备注" 部分， <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 了解解码方法和注意事项。

 请注意，特定实现的方法的精确行为 <xref:System.Text.Encoding.GetString%2A> <xref:System.Text.Encoding> 取决于为该对象定义的回退策略 <xref:System.Text.Encoding> 。 有关详细信息，请参阅[.net 中的字符编码](/dotnet/standard/base-types/character-encoding)主题的 "选择回退策略" 部分。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> 为 null 指针。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> 小于零。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">发生了回退（如需完整说明，请参阅 <see href="/dotnet/standard/base-types/character-encoding">.NET 中的字符编码</see>）

－和－

 将 <see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] * int * int -&gt; string&#xA;override this.GetString : byte[] * int * int -&gt; string" Usage="encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">包含要解码的字节序列的字节数组。</param>
        <param name="index">第一个要解码的字节的索引。</param>
        <param name="count">要解码的字节数。</param>
        <summary>在派生类中重写时，将指定字节数组中的一个字节序列解码为一个字符串。</summary>
        <returns>包含指定字节序列解码结果的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果要转换的数据仅在顺序块（如从流中读取的数据）中可用，或者如果数据量很大以致需要分为更小块，则应使用 <xref:System.Text.Decoder> <xref:System.Text.Encoder> <xref:System.Text.Encoding.GetDecoder%2A> 派生类的方法或方法提供的或 <xref:System.Text.Encoding.GetEncoder%2A> 。

 请参阅参考主题的 "备注" 部分， <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 了解解码方法和注意事项。

## Examples
 下面的示例从由对象表示的二进制文件中读取 UTF-8 编码的字符串 <xref:System.IO.FileStream> 。 对于小于2048个字节的文件，它会将整个文件的内容读入一个字节数组中，并调用 <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 方法来执行解码。 对于较大的文件，它一次将2048字节读取到字节数组中， <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 并调用方法来确定数组中包含的字符数，然后调用 <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> 方法来执行解码。

 [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]

 该示例使用以下文本，该文本应保存到名为 Utf8Example.txt 的 UTF-8 编码文件中。

```txt

This is a UTF-8-encoded file that contains primarily Latin text, although it
does list the first twelve letters of the Russian (Cyrillic) alphabet:

А б в г д е ё ж з и й к

The goal is to save this file, then open and decode it as a binary stream.

```

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">字节数组中包含无效的 Unicode 码位。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 或 <paramref name="count" /> 小于零。

- 或 -

 <paramref name="index" /> 和 <paramref name="count" /> 不表示 <paramref name="bytes" /> 中的有效范围。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">发生回退（有关详细信息，请参阅<see href="/dotnet/standard/base-types/character-encoding">采用 .NET 的字符编码</see>）

－和－

 将 <see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HeaderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HeaderName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HeaderName : string" Usage="System.Text.Encoding.HeaderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取可与邮件代理头标记一起使用的当前编码的名称。</summary>
        <value>与邮件代理头标记一起使用的当前 <see cref="T:System.Text.Encoding" /> 的名称。

- 或 -

如果当前 <see cref="T:System.Text.Encoding" /> 无法使用，则为空字符串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果需要标头名称的编码，则应 <xref:System.Text.Encoding.GetEncoding%2A> 使用属性调用方法 <xref:System.Text.Encoding.HeaderName%2A> 。 通常，方法从调用中提供的测试编码检索不同的编码。 通常，只有电子邮件应用程序需要检索这种编码。

 在某些情况下，属性的值 <xref:System.Text.Encoding.BodyName%2A> 对应于定义该编码的国际标准。 这并不意味着实现完全符合该标准。

 请注意， <xref:System.Text.Encoding.WebName%2A> 返回用于描述编码的名称。 此 <xref:System.Text.Encoding.HeaderName%2A> 属性定义了一个可能更适用于电子邮件应用程序的不同编码，例如。 但是，不建议使用属性来定义编码。

## Examples
 下面的示例检索每个编码的不同名称，并显示一个或多个名称不同于的编码 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> 。 它将显示， <xref:System.Text.Encoding.EncodingName%2A> 但不会对其进行比较。

 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAlwaysNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取一个值，该值指示当前编码是否始终被规范化。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAlwaysNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAlwaysNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsAlwaysNormalized : unit -&gt; bool" Usage="encoding.IsAlwaysNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使用默认范式获取一个值，该值指示当前编码是否始终被规范化。</summary>
        <returns>如果当前 <see cref="T:System.Text.Encoding" /> 始终被规范化，则为 <see langword="true" />；否则，为 <see langword="false" />。 默认值为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 默认范式为 <xref:System.Text.NormalizationForm.FormC> ，使用完全规范分解，然后将序列替换为其主复合（如果可能）。

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAlwaysNormalized (form As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAlwaysNormalized(System::Text::NormalizationForm form);" />
      <MemberSignature Language="F#" Value="abstract member IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool&#xA;override this.IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool" Usage="encoding.IsAlwaysNormalized form" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="form"><see cref="T:System.Text.NormalizationForm" /> 值之一。</param>
        <summary>在派生类中重写时，使用指定范式获取一个值，该值指示当前编码是否始终被规范化。</summary>
        <returns>如果始终使用指定的 <see langword="true" /> 值规范化当前 <see cref="T:System.Text.Encoding" /> 对象，则为 <see cref="T:System.Text.NormalizationForm" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 默认范式为 <xref:System.Text.NormalizationForm.FormC> ，使用完全规范分解，然后将序列替换为其主复合（如果可能）。

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserDisplay : bool" Usage="System.Text.Encoding.IsBrowserDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取一个值，该值指示浏览器客户端是否可以使用当前的编码显示内容。</summary>
        <value>如果浏览器客户端可以使用当前的 <see cref="T:System.Text.Encoding" /> 显示内容，则为 <see langword="true" />；否则，为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的示例检查每个编码的布尔值属性的值。

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserSave" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserSave : bool" Usage="System.Text.Encoding.IsBrowserSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取一个值，该值指示浏览器客户端是否可以使用当前的编码保存内容。</summary>
        <value>如果浏览器客户端可以使用当前的 <see cref="T:System.Text.Encoding" /> 保存内容，则为 <see langword="true" />；否则，为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的示例检查每个编码的布尔值属性的值。

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsDisplay : bool" Usage="System.Text.Encoding.IsMailNewsDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取一个值，该值指示邮件和新闻客户端是否可以使用当前的编码显示内容。</summary>
        <value>如果邮件和新闻客户端可以使用当前的 <see cref="T:System.Text.Encoding" /> 显示内容，则为 <see langword="true" />；否则，为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的示例检查每个编码的布尔值属性的值。

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsSave : bool" Usage="System.Text.Encoding.IsMailNewsSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取一个值，该值指示邮件和新闻客户端是否可以使用当前的编码保存内容。</summary>
        <value>如果邮件和新闻客户端可以使用当前 <see langword="true" /> 保存内容，则为 <see cref="T:System.Text.Encoding" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的示例检查每个编码的布尔值属性的值。

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsSave" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Text.Encoding.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取一个值，该值指示当前的编码是否为只读。</summary>
        <value>如果当前 <see langword="true" /> 为只读，则为 <see cref="T:System.Text.Encoding" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSingleByte As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSingleByte { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSingleByte : bool" Usage="System.Text.Encoding.IsSingleByte" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取一个值，该值指示当前的编码是否使用单字节码位。</summary>
        <value>如果当前 <see langword="true" /> 使用单字节码位，则为 <see cref="T:System.Text.Encoding" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 例如，对于单字节编码， <xref:System.Text.ASCIIEncoding> 此属性检索 `true` 。

> [!CAUTION]
> 你应注意应用程序对的值的处理 <xref:System.Text.Encoding.IsSingleByte%2A> 。 如何进行编码的假设仍可能是错误的。 例如，Windows-1252 的值 `true` 为 <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType> ，但 GetMaxByteCount （1）返回2。 这是因为该方法会考虑以前的解码器操作的潜在遗留代理项。

## Examples
 下面的示例检查每个编码的布尔值属性的值。

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Latin1">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Latin1 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Latin1" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Latin1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Latin1 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Latin1 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Latin1 : System.Text.Encoding" Usage="System.Text.Encoding.Latin1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 Latin1 字符集 (ISO-8859-1) 的编码。</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public virtual ReadOnlySpan&lt;byte&gt;? Preamble { get; }" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.Encoding.Preamble" />
      <MemberSignature Language="C#" Value="public virtual ReadOnlySpan&lt;byte&gt; Preamble { get; }" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，返回包含指定所用编码的字节序列的范围。</summary>
        <value>包含指定所用编码的字节序列的字节范围，如果不需要报头，则为长度为零的范围。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此对象还可以 <xref:System.Text.Encoding> 提供前导码，它是一个字节序列，可以作为编码过程中所产生的字节的前缀。 如果引言包含字节顺序标记（在 Unicode、码位 U + FEFF 中），则它有助于解码器确定字节顺序和转换格式或 UTF。

 Unicode 字节顺序标记（BOM）按以下方式序列化（十六进制）：

- UTF-8： EF BB BF

- UTF-16 大 endian 字节顺序： FE FF

- UTF-16 little endian 字节顺序： FF FE

- 32大 endian 字节顺序： 00 00 FE FF

- 32 little endian 字节顺序： FF FE 00 00

 应使用 BOM，因为它提供了对文件的编码的几乎某些标识，例如，对对象的引用丢失 <xref:System.Text.Encoding> 、未标记或标记不正确或标记为不正确的 web 数据或随机文本文件。 如果数据一致且标记正确（最好是 UTF-8 或 UTF-16），通常可以避免用户问题。

 对于提供编码类型的标准，BOM 有些多余。 但是，可以使用它来帮助服务器发送正确的编码标头。 或者，它可以用作回退，以防编码在其他情况下丢失。

 使用 BOM 存在一些缺点。 例如，了解如何限制使用 BOM 的数据库字段可能很困难。 文件的串联可能也是一个问题，例如，当文件以这样一种方式进行合并时，不需要的字符会在数据中间结束。 尽管有几个缺点，但强烈建议使用 BOM。

 有关字节顺序和字节顺序标记的详细信息，请参阅[unicode 主页](https://home.unicode.org/)上的 unicode 标准。

> [!CAUTION]
> 若要确保编码的字节解码正确，应使用前导码作为编码字节的前缀。 但是，大多数编码不提供前导码。 若要确保已编码的字节解码正确，应使用 Unicode 编码，即、、 <xref:System.Text.UTF8Encoding> <xref:System.Text.UnicodeEncoding> 或 <xref:System.Text.UTF32Encoding> ，使用前导码。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterProvider (provider As EncodingProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterProvider(System::Text::EncodingProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member RegisterProvider : System.Text.EncodingProvider -&gt; unit" Usage="System.Text.Encoding.RegisterProvider provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">提供对其他字符编码的访问权限的 <see cref="T:System.Text.EncodingProvider" /> 的子类。</param>
        <summary>注册编码提供程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoding.RegisterProvider%2A>方法允许注册派生自 <xref:System.Text.EncodingProvider> 的类，使字符编码在不支持它们的平台上可用。 注册编码提供程序后，可通过调用任何重载来检索它支持的编码 <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> 。 如果有多个编码提供程序，则该 <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> 方法会尝试从每个提供程序中检索指定的编码（从最近注册的提供程序开始）。

使用方法注册编码提供程序 <xref:System.Text.Encoding.RegisterProvider%2A> 还会在传递的参数时，修改[Encoding.getencoding （int32）](<xref:System.Text.Encoding.GetEncoding(System.Int32)>)和[EncodingProvider （Int32，EncoderFallback，DecoderFallback）](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback))方法的行为 `0` ：

- 如果注册的提供程序为 <xref:System.Text.CodePagesEncodingProvider> ，则在 Windows 操作系统上运行时，方法将返回与系统活动代码页匹配的编码。

- 自定义编码提供程序可以选择在 <xref:System.Text.Encoding.GetEncoding%2A> 为这些方法重载之一传递参数时要返回的编码 `0` 。 提供程序还可以选择不通过使方法返回来返回编码 <xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType> `null` 。

从 .NET Framework 4.6 开始，.NET Framework 包含一个编码提供程序，该提供程序使编码可用，该提供程序 <xref:System.Text.CodePagesEncodingProvider> 在完整 .NET Framework 中存在，但在通用 Windows 平台中不可用。 默认情况下，通用 Windows 平台仅支持 Unicode 编码、ASCII 和代码页28591。

 如果对方法的多个调用中使用了相同的编码提供程序 <xref:System.Text.Encoding.RegisterProvider%2A> ，则只有第一个方法调用将注册该提供程序。 后续调用将被忽略。

 如果 <xref:System.Text.Encoding.RegisterProvider%2A> 调用方法来注册处理相同编码的多个提供程序，则最后一个注册的提供程序将用于所有编码和解码操作。 将忽略任何以前注册的提供程序。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="provider" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Text.CodePagesEncodingProvider" />
        <altmember cref="T:System.Text.EncodingProvider" />
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Unicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Unicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unicode : System.Text.Encoding" Usage="System.Text.Encoding.Unicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取使用 Little-Endian 字节顺序的 UTF-16 格式的编码。</summary>
        <value>使用 Little-Endian 字节顺序的 UTF-16 格式的编码。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 有关 .NET 支持的编码以及要使用的 Unicode 编码的讨论的信息，请参阅[.net 中的字符编码](/dotnet/standard/base-types/character-encoding)。

 <xref:System.Text.UnicodeEncoding>此属性返回的对象可能没有适用于你的应用程序的行为。 它使用替换回退来替换每个不能进行编码的字符串，以及无法使用问号（"？"）字符解码的每个字节。 相反，你可以调用 <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 构造函数来实例化 <xref:System.Text.UnicodeEncoding> 其回退为或的 little endian 对象 <xref:System.Text.EncoderFallbackException> <xref:System.Text.DecoderFallbackException> ，如下面的示例所示。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb" id="Snippet2":::

## Examples
 下面的示例确定对字符数组进行编码、对字符进行编码并显示生成的字节所需的字节数。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="/dotnet/standard/base-types/character-encoding">了解编码</related>
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF32 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF32 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF32 : System.Text.Encoding" Usage="System.Text.Encoding.UTF32" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取使用 Little-Endian 字节顺序的 UTF-32 格式的编码。</summary>
        <value>使用 Little-Endian 字节顺序的 UTF-32 格式的编码对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.UTF32Encoding>此属性返回的对象可能没有适用于你的应用程序的行为。 它使用替换回退来替换每个不能进行编码的字符串，以及无法使用 Unicode 替换字符（U + FFFE）解码的每个字节。 相反，你可以调用 <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 构造函数来实例化 <xref:System.Text.UTF32Encoding> 其回退为 <xref:System.Text.EncoderFallbackException> 或的对象 <xref:System.Text.DecoderFallbackException> ，如下例所示。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb" id="Snippet1":::

 有关 little endian 字节顺序的讨论，请参阅 <xref:System.Text.Encoding> 。

 有关 .NET 支持的编码以及要使用的 Unicode 编码的讨论的信息，请参阅[.net 中的字符编码](/dotnet/standard/base-types/character-encoding)。

## Examples
 下面的示例确定对字符数组进行编码、对字符进行编码并显示生成的字节所需的字节数。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF32Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="/dotnet/standard/base-types/character-encoding">了解编码</related>
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF7 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF7 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF7 : System.Text.Encoding" Usage="System.Text.Encoding.UTF7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0">
          <AttributeName Language="C#">[System.Obsolete("The UTF-7 encoding is insecure and should not be used. Consider using UTF-8 instead.", DiagnosticId="SYSLIB0001", UrlFormat="https://aka.ms/dotnet-warnings/{0}")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("The UTF-7 encoding is insecure and should not be used. Consider using UTF-8 instead.", DiagnosticId="SYSLIB0001", UrlFormat="https://aka.ms/dotnet-warnings/{0}")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 UTF-7 格式的编码。</summary>
        <value>UTF-7 格式的编码。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 UTF-7 编码主要用于在过去限制为7位（如 NNTP 和某些电子邮件应用程序）的环境中。 由于可靠性和安全性问题，不应在可以使用 UTF-8 编码的8位环境中使用 UTF-7 编码。

## Examples
 下面的示例确定对字符数组进行编码、对字符进行编码并显示生成的字节所需的字节数。

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF7Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <related type="Article" href="/dotnet/standard/base-types/character-encoding">了解编码</related>
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF8 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF8 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF8 : System.Text.Encoding" Usage="System.Text.Encoding.UTF8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 UTF-8 格式的编码。</summary>
        <value>UTF-8 格式的编码。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此属性返回一个 <xref:System.Text.UTF8Encoding> 对象，该对象将 Unicode （utf-16 编码的）字符编码为每个字符一至四个字节的序列，并将 utf-8 编码的字节数组解码为 Unicode （utf-16 编码的）字符。 有关 .NET 支持的字符编码以及要使用的 Unicode 编码的讨论，请参阅[.net 中的字符编码](/dotnet/standard/base-types/character-encoding)。

 <xref:System.Text.UTF8Encoding>此属性返回的对象可能没有适用于你的应用程序的行为。

- 它将返回一个 <xref:System.Text.UTF8Encoding> 对象，该对象提供一个 Unicode 字节顺序标记（BOM）。 若要实例化不提供 BOM 的 UTF8 编码，请调用构造函数的任何重载 <xref:System.Text.UTF8Encoding.%23ctor%2A> 。

- 它将返回一个 <xref:System.Text.UTF8Encoding> 对象，该对象使用替换回退来替换每个无法编码的字符串，以及无法使用问号（"？"）字符解码的每个字节。 相反，你可以调用 <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 构造函数来实例化 <xref:System.Text.UTF8Encoding> 其回退为 <xref:System.Text.EncoderFallbackException> 或的对象 <xref:System.Text.DecoderFallbackException> ，如下例所示。

     :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs" interactive="try-dotnet" id="Snippet1":::
     :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb" id="Snippet1":::

## Examples
 下面的示例定义一个包含以下字符的数组：

- 拉丁文小写字母 Z （U + 007A）

- 拉丁文小写字母 A （U + 0061）

- 组合短音符（U + 0306）

- 拉丁文小写字母 AE WITH 锐音符（U + 01FD）

- 希腊文小写字母 BETA （U + 03B2）

- 构成希腊语 ACROPHONIC 阁楼 1000 STATERS （U + 10154）的代理项对（U + D800 U + DD54）。

 它显示每个字符的 UTF-16 代码单元，并确定 UTF-8 编码器对字符数组进行编码所需的字节数。 然后，它对字符进行编码，并显示生成的 UTF-8 编码字节。

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb" id="Snippet2":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF8Encoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="/dotnet/standard/base-types/character-encoding">了解编码</related>
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WebName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ WebName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebName : string" Usage="System.Text.Encoding.WebName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取在 Internet 编号分配管理机构 (IANA) 注册的当前编码的名称。</summary>
        <value>当前 <see cref="T:System.Text.Encoding" /> 的 IANA 名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoding.WebName%2A>属性与 <xref:System.Text.EncodingInfo.Name%2A> 属性相同。

 请注意， <xref:System.Text.Encoding.WebName%2A> 返回编码的 IANA 注册名称。 如果其值为标准的名称，则编码的实现可能不会完全符合该标准。 <xref:System.Text.Encoding.HeaderName%2A>属性定义可能更适用于电子邮件标头的其他编码。 但是，大多数应用程序应改用 <xref:System.Text.Encoding.WebName%2A> 。

 有关 IANA 的详细信息，请参阅[www.iana.org](https://www.iana.org/)。

 与 <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> 返回的相同 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> 。 某些 web 名称是重复的;有关详细信息，请参阅 "备注" <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> 。

## Examples
 下面的示例 <xref:System.Text.Encoding.WebName%2A> 在 HTML 标头中包含。

 [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]

 下面的示例检索每个编码的不同名称，并显示一个或多个名称不同于的编码 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> 。 它将显示， <xref:System.Text.Encoding.EncodingName%2A> 但不会对其进行比较。

 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WindowsCodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WindowsCodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WindowsCodePage : int" Usage="System.Text.Encoding.WindowsCodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取与当前编码最紧密对应的 Windows 操作系统代码页。</summary>
        <value>与当前 <see cref="T:System.Text.Encoding" /> 最紧密对应的 Windows 操作系统代码页。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 提供此属性是为了与 Windows 多语言（MLang） Api 兼容，例如确定字体系列。 对于全球化，建议改为使用其中一个 Unicode 编码。 还建议使用 <xref:System.Text.Encoding.WebName%2A> 而不是 <xref:System.Text.Encoding.WindowsCodePage%2A> 来标识代码页。

## Examples
 下面的示例确定与每个编码最紧密对应的 Windows 代码页。

 [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
      </Docs>
    </Member>
  </Members>
</Type>
