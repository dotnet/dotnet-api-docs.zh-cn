<Type Name="Rune" FullName="System.Text.Rune">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d225ea5ac7f03ccca20b87a17830cf73ffdd9aa8" /><Meta Name="ms.sourcegitcommit" Value="930a2e90be5bc29a285f5df9da5cd44a74574596" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/23/2020" /><Meta Name="ms.locfileid" Value="91130240" /></Metadata><TypeSignature Language="C#" Value="public struct Rune : IComparable, IComparable&lt;System.Text.Rune&gt;, IEquatable&lt;System.Text.Rune&gt;" FrameworkAlternate="net-5.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Rune extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Text.Rune&gt;, class System.IEquatable`1&lt;valuetype System.Text.Rune&gt;" FrameworkAlternate="net-5.0" />
  <TypeSignature Language="DocId" Value="T:System.Text.Rune" />
  <TypeSignature Language="VB.NET" Value="Public Structure Rune&#xA;Implements IComparable, IComparable(Of Rune), IEquatable(Of Rune)" FrameworkAlternate="net-5.0" />
  <TypeSignature Language="C++ CLI" Value="public value class Rune : IComparable, IComparable&lt;System::Text::Rune&gt;, IEquatable&lt;System::Text::Rune&gt;" FrameworkAlternate="net-5.0" />
  <TypeSignature Language="F#" Value="type Rune = struct" />
  <TypeSignature Language="C#" Value="public struct Rune : IComparable&lt;System.Text.Rune&gt;, IEquatable&lt;System.Text.Rune&gt;" FrameworkAlternate="netcore-3.0;netcore-3.1" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Rune extends System.ValueType implements class System.IComparable`1&lt;valuetype System.Text.Rune&gt;, class System.IEquatable`1&lt;valuetype System.Text.Rune&gt;" FrameworkAlternate="netcore-3.0;netcore-3.1" />
  <TypeSignature Language="VB.NET" Value="Public Structure Rune&#xA;Implements IComparable(Of Rune), IEquatable(Of Rune)" FrameworkAlternate="netcore-3.0;netcore-3.1" />
  <TypeSignature Language="C++ CLI" Value="public value class Rune : IComparable&lt;System::Text::Rune&gt;, IEquatable&lt;System::Text::Rune&gt;" FrameworkAlternate="netcore-3.0;netcore-3.1" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface FrameworkAlternate="net-5.0">
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Text.Rune&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Text.Rune&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="01189-101">è¡¨ç¤º Unicode æ ‡é‡å€¼ï¼ˆ[ U+0000..U+D7FF ]ï¼Œå«é¦–å°¾å€¼ï¼›æˆ– [ U+E000..U+10FFFF ]ï¼Œå«é¦–å°¾å€¼ï¼‰ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-101">Represents a Unicode scalar value ([ U+0000..U+D7FF ], inclusive; or [ U+E000..U+10FFFF ], inclusive).</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="01189-102"><xref:System.Text.Rune>å®ä¾‹è¡¨ç¤ºä¸€ä¸ª Unicode æ ‡é‡å€¼ï¼Œè¿™æ„å‘³ç€ï¼Œä»»ä½•ä¸åŒ…æ‹¬ä»£ç†é¡¹èŒƒå›´çš„ä»£ç ç‚¹éƒ½ (U + D800.ã€‚U + DFFF) ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-102">A <xref:System.Text.Rune> instance represents a Unicode scalar value, which means any code point excluding the surrogate range (U+D800..U+DFFF).</span></span> <span data-ttu-id="01189-103">ç±»å‹çš„æ„é€ å‡½æ•°å’Œè½¬æ¢è¿ç®—ç¬¦ä¼šéªŒè¯è¾“å…¥ï¼Œå› æ­¤ä½¿ç”¨è€…å¯ä»¥è°ƒç”¨ Apiï¼Œå‡å®šåŸºç¡€ <xref:System.Text.Rune> å®ä¾‹çš„æ ¼å¼æ­£ç¡®ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-103">The type's constructors and conversion operators validate the input, so consumers can call the APIs assuming that the underlying <xref:System.Text.Rune> instance is well formed.</span></span>

<span data-ttu-id="01189-104">å¦‚æœä½ ä¸ç†Ÿæ‚‰ Unicode æ ‡é‡å€¼ã€ä»£ç ç‚¹ã€ä»£ç†é¡¹èŒƒå›´å’Œæ ¼å¼æ­£ç¡®çš„æœ¯è¯­ï¼Œè¯·å‚é˜… [.net ä¸­çš„å­—ç¬¦ç¼–ç ç®€ä»‹](/dotnet/standard/base-types/character-encoding-introduction)ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-104">If you aren't familiar with the terms Unicode scalar value, code point, surrogate range, and well-formed, see [Introduction to character encoding in .NET](/dotnet/standard/base-types/character-encoding-introduction).</span></span>

<span data-ttu-id="01189-105">ä»¥ä¸‹å„èŠ‚å°†å¯¹æ­¤è¿›è¡Œè¯´æ˜ï¼š</span><span class="sxs-lookup"><span data-stu-id="01189-105">The following sections explain:</span></span>

* [<span data-ttu-id="01189-106">ä½•æ—¶ä½¿ç”¨ Rune ç±»å‹</span><span class="sxs-lookup"><span data-stu-id="01189-106">When to use the Rune type</span></span>](#when-to-use-the-rune-type)
* [<span data-ttu-id="01189-107">ä½•æ—¶ä¸ä½¿ç”¨ Rune ç±»å‹</span><span class="sxs-lookup"><span data-stu-id="01189-107">When not to use the Rune type</span></span>](#when-not-to-use-rune)
* [<span data-ttu-id="01189-108">å¦‚ä½•å®ä¾‹åŒ– Rune</span><span class="sxs-lookup"><span data-stu-id="01189-108">How to instantiate a Rune</span></span>](#how-to-instantiate-a-rune)
* [<span data-ttu-id="01189-109">å¦‚ä½•æŸ¥è¯¢ Rune å®ä¾‹çš„å±æ€§</span><span class="sxs-lookup"><span data-stu-id="01189-109">How to query properties of a Rune instance</span></span>](#query-properties-of-a-rune)
* [<span data-ttu-id="01189-110">å°†è½¬æ¢ä¸º `Rune` utf-8 æˆ– utf-16</span><span class="sxs-lookup"><span data-stu-id="01189-110">Convert a `Rune` to UTF-8 or UTF-16</span></span>](#convert-a-rune-to-utf-8-or-utf-16)
* [<span data-ttu-id="01189-111">.NET ä¸­çš„ Rune ä¸å…¶ä»–è¯­è¨€</span><span class="sxs-lookup"><span data-stu-id="01189-111">Rune in .NET vs. other languages</span></span>](#rune-in-net-vs-other-languages)

### <a name="when-to-use-the-rune-type"></a><span data-ttu-id="01189-112">ä½•æ—¶ä½¿ç”¨ Rune ç±»å‹</span><span class="sxs-lookup"><span data-stu-id="01189-112">When to use the Rune type</span></span>

<span data-ttu-id="01189-113">`Rune`å¦‚æœä½ çš„ä»£ç ï¼Œè¯·è€ƒè™‘ä½¿ç”¨ç±»å‹ï¼š</span><span class="sxs-lookup"><span data-stu-id="01189-113">Consider using the `Rune` type if your code:</span></span>

* <span data-ttu-id="01189-114">è°ƒç”¨éœ€è¦ Unicode æ ‡é‡å€¼çš„ Api</span><span class="sxs-lookup"><span data-stu-id="01189-114">Calls APIs that require Unicode scalar values</span></span>
* <span data-ttu-id="01189-115">æ˜¾å¼å¤„ç†ä»£ç†é¡¹å¯¹</span><span class="sxs-lookup"><span data-stu-id="01189-115">Explicitly handles surrogate pairs</span></span>

#### <a name="apis-that-require-unicode-scalar-values"></a><span data-ttu-id="01189-116">éœ€è¦ Unicode æ ‡é‡å€¼çš„ Api</span><span class="sxs-lookup"><span data-stu-id="01189-116">APIs that require Unicode scalar values</span></span>

<span data-ttu-id="01189-117">å¦‚æœä»£ç  `char` åœ¨æˆ–ä¸­å¾ªç¯è®¿é—®å®ä¾‹ `string` `ReadOnlySpan<char>` ï¼Œåˆ™æŸäº› `char` æ–¹æ³•å°†æ— æ³•åœ¨ `char` ä»£ç†é¡¹èŒƒå›´å†…çš„å®ä¾‹ä¸Šæ­£å¸¸å·¥ä½œã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-117">If your code iterates through the `char` instances in a `string` or a `ReadOnlySpan<char>`, some of the `char` methods won't work correctly on `char` instances that are in the surrogate range.</span></span> <span data-ttu-id="01189-118">ä¾‹å¦‚ï¼Œä»¥ä¸‹ Api éœ€è¦æ ‡é‡å€¼ `char` æ‰èƒ½æ­£å¸¸å·¥ä½œï¼š</span><span class="sxs-lookup"><span data-stu-id="01189-118">For example, the following APIs require a scalar value `char` to work correctly:</span></span>

* <xref:System.Char.GetNumericValue%2A?displayProperty=nameWithType>
* <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType>
* <xref:System.Char.IsDigit%2A?displayProperty=nameWithType>
* <xref:System.Char.IsLetter%2A?displayProperty=nameWithType>
* <xref:System.Char.IsLetterOrDigit%2A?displayProperty=nameWithType>
* <xref:System.Char.IsLower%2A?displayProperty=nameWithType>
* <xref:System.Char.IsNumber%2A?displayProperty=nameWithType>
* <xref:System.Char.IsPunctuation%2A?displayProperty=nameWithType>
* <xref:System.Char.IsSymbol%2A?displayProperty=nameWithType>
* <xref:System.Char.IsUpper%2A?displayProperty=nameWithType>

<span data-ttu-id="01189-119">ä¸‹é¢çš„ç¤ºä¾‹æ¼”ç¤ºå¦‚æœæœ‰ä»»ä½• `char` å®ä¾‹æ˜¯ä»£ç†é¡¹ç ä½ï¼Œä»£ç å°†æ— æ³•æ­£å¸¸è¿è¡Œï¼š</span><span class="sxs-lookup"><span data-stu-id="01189-119">The following example shows code that won't work correctly if any of the `char` instances are surrogate code points:</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/CountLettersInString.cs" id="SnippetBadExample":::

<span data-ttu-id="01189-120">ä¸‹é¢æ˜¯é€‚ç”¨äºçš„ç­‰æ•ˆä»£ç  `ReadOnlySpan<char>` ï¼š</span><span class="sxs-lookup"><span data-stu-id="01189-120">Here's equivalent code that works with a `ReadOnlySpan<char>`:</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/CountLettersInSpan.cs" id="SnippetBadExample":::

<span data-ttu-id="01189-121">å‰é¢çš„ä»£ç ä½¿ç”¨æŸäº›è¯­è¨€ï¼ˆå¦‚è‹±è¯­ï¼‰æ­£å¸¸å·¥ä½œï¼š</span><span class="sxs-lookup"><span data-stu-id="01189-121">The preceding code works correctly with some languages such as English:</span></span>

```csharp
CountLettersInString("Hello")
// Returns 5
```

<span data-ttu-id="01189-122">ä½†å¯¹äºåŸºæœ¬å¤šè¯­è¨€å¹³é¢ä»¥å¤–çš„è¯­è¨€ï¼ˆå¦‚ Osageï¼‰ï¼Œå®ƒå°†æ— æ³•æ­£å¸¸å·¥ä½œï¼š</span><span class="sxs-lookup"><span data-stu-id="01189-122">But it won't work correctly for languages outside the Basic Multilingual Plane, such as Osage:</span></span>

```csharp
CountLettersInString("ğ“ğ“˜ğ“»ğ“˜ğ“»ğ“Ÿ ğ’»ğ“Ÿ")
// Returns 0
```

<span data-ttu-id="01189-123">æ­¤æ–¹æ³•è¿”å›ä¸æ­£ç¡®çš„ Osage æ–‡æœ¬ç»“æœçš„åŸå› æ˜¯ `char` Osage å­—æ¯çš„å®ä¾‹æ˜¯ä»£ç†é¡¹ç ä½ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-123">The reason this method returns incorrect results for Osage text is that the `char` instances for Osage letters are surrogate code points.</span></span> <span data-ttu-id="01189-124">æ²¡æœ‰å•ä¸ªä»£ç†é¡¹ç ä½å…·æœ‰è¶³å¤Ÿçš„ä¿¡æ¯æ¥ç¡®å®šå®ƒæ˜¯å¦æ˜¯å­—æ¯ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-124">No single surrogate code point has enough information to determine if it's a letter.</span></span>

<span data-ttu-id="01189-125">å¦‚æœå°†æ­¤ä»£ç æ›´æ”¹ä¸ºä½¿ç”¨ `Rune` è€Œä¸æ˜¯ `char` ï¼Œåˆ™è¯¥æ–¹æ³•å°†ä¸åŸºæœ¬å¤šè¯­è¨€å¹³é¢ä¹‹å¤–çš„ä»£ç ç‚¹ä¸€èµ·æ­£å¸¸å·¥ä½œï¼š</span><span class="sxs-lookup"><span data-stu-id="01189-125">If you change this code to use `Rune` instead of `char`, the method works correctly with code points outside the Basic Multilingual Plane:</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/CountLettersInString.cs" id="SnippetGoodExample":::

<span data-ttu-id="01189-126">ä¸‹é¢æ˜¯é€‚ç”¨äºçš„ç­‰æ•ˆä»£ç  `ReadOnlySpan<char>` ï¼š</span><span class="sxs-lookup"><span data-stu-id="01189-126">Here's equivalent code that works with a `ReadOnlySpan<char>`:</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/CountLettersInSpan.cs" id="SnippetGoodExample":::

<span data-ttu-id="01189-127">å‰é¢çš„ä»£ç ä¼šæ­£ç¡®ç»Ÿè®¡ Osage å­—æ¯ï¼š</span><span class="sxs-lookup"><span data-stu-id="01189-127">The preceding code counts Osage letters correctly:</span></span>

```csharp
CountLettersInString("ğ“ğ“˜ğ“»ğ“˜ğ“»ğ“Ÿ ğ’»ğ“Ÿ")
// Returns 8
```

#### <a name="code-that-explicitly-handles-surrogate-pairs"></a><span data-ttu-id="01189-128">æ˜¾å¼å¤„ç†ä»£ç†é¡¹å¯¹çš„ä»£ç </span><span class="sxs-lookup"><span data-stu-id="01189-128">Code that explicitly handles surrogate pairs</span></span>

<span data-ttu-id="01189-129">`Rune`å¦‚æœä½ çš„ä»£ç è°ƒç”¨æ˜¾å¼æ“ä½œä»£ç†é¡¹ç ä½çš„ api ï¼ˆä¾‹å¦‚ä»¥ä¸‹æ–¹æ³•ï¼‰ï¼Œè¯·è€ƒè™‘ä½¿ç”¨ç±»å‹ï¼š</span><span class="sxs-lookup"><span data-stu-id="01189-129">Consider using the `Rune` type if your code calls APIs that explicitly operate on surrogate code points, such as the following methods:</span></span>

* <xref:System.Char.IsSurrogate%2A?displayProperty=nameWithType>
* <xref:System.Char.IsSurrogatePair%2A?displayProperty=nameWithType>
* <xref:System.Char.IsHighSurrogate%2A?displayProperty=nameWithType>
* <xref:System.Char.IsLowSurrogate%2A?displayProperty=nameWithType>
* <xref:System.Char.ConvertFromUtf32%2A?displayProperty=nameWithType>
* <xref:System.Char.ConvertToUtf32%2A?displayProperty=nameWithType>

<span data-ttu-id="01189-130">ä¾‹å¦‚ï¼Œä¸‹é¢çš„æ–¹æ³•å…·æœ‰ç”¨äºå¤„ç†ä»£ç†é¡¹å¯¹çš„ç‰¹æ®Šé€»è¾‘ `char` ï¼š</span><span class="sxs-lookup"><span data-stu-id="01189-130">For example, the following method has special logic to deal with surrogate `char` pairs:</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/WorkWithSurrogates.cs" id="SnippetUseChar":::

<span data-ttu-id="01189-131">æ­¤ç±»ä»£ç åœ¨ä½¿ç”¨æ—¶æ›´ç®€å• `Rune` ï¼Œå¦‚ä»¥ä¸‹ç¤ºä¾‹ä¸­æ‰€ç¤ºï¼š</span><span class="sxs-lookup"><span data-stu-id="01189-131">Such code is simpler if it uses `Rune`, as in the following example:</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/WorkWithSurrogates.cs" id="SnippetUseRune":::

### <a name="when-not-to-use-rune"></a><span data-ttu-id="01189-132">ä½•æ—¶ä¸ä½¿ç”¨ `Rune`</span><span class="sxs-lookup"><span data-stu-id="01189-132">When not to use `Rune`</span></span>

<span data-ttu-id="01189-133">å¦‚æœä½ çš„ä»£ç ä¸ºï¼Œåˆ™æ— éœ€ä½¿ç”¨ `Rune` ç±»å‹ï¼š</span><span class="sxs-lookup"><span data-stu-id="01189-133">You don't need to use the `Rune` type if your code:</span></span>

* <span data-ttu-id="01189-134">æŸ¥æ‰¾å®Œå…¨ `char` åŒ¹é…é¡¹</span><span class="sxs-lookup"><span data-stu-id="01189-134">Looks for exact `char` matches</span></span>
* <span data-ttu-id="01189-135">æ‹†åˆ†å·²çŸ¥ char å€¼ä¸Šçš„å­—ç¬¦ä¸²</span><span class="sxs-lookup"><span data-stu-id="01189-135">Splits a string on a known char value</span></span>

<span data-ttu-id="01189-136">`Rune`å¦‚æœä½ çš„ä»£ç ï¼š</span><span class="sxs-lookup"><span data-stu-id="01189-136">Using the `Rune` type may return incorrect results if your code:</span></span>

* <span data-ttu-id="01189-137">è®¡ç®—ä¸­çš„æ˜¾ç¤ºå­—ç¬¦æ•° `string`</span><span class="sxs-lookup"><span data-stu-id="01189-137">Counts the number of display characters in a `string`</span></span>

#### <a name="look-for-exact-char-matches"></a><span data-ttu-id="01189-138">æŸ¥æ‰¾å®Œå…¨ `char` åŒ¹é…é¡¹</span><span class="sxs-lookup"><span data-stu-id="01189-138">Look for exact `char` matches</span></span>

<span data-ttu-id="01189-139">ä¸‹é¢çš„ä»£ç å¾ªç¯è®¿é—® `string` æŸ¥æ‰¾ç‰¹å®šå­—ç¬¦ï¼Œå¹¶è¿”å›ç¬¬ä¸€ä¸ªåŒ¹é…é¡¹çš„ç´¢å¼•ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-139">The following code iterates through a `string` looking for specific characters, returning the index of the first match.</span></span> <span data-ttu-id="01189-140">æ— éœ€æ›´æ”¹æ­¤ä»£ç å³å¯ä½¿ç”¨ `Rune` ï¼Œå› ä¸ºä»£ç æŸ¥æ‰¾ç”±å•ä¸ªè¡¨ç¤ºçš„å­—ç¬¦ `char` ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-140">There's no need to change this code to use `Rune`, as the code is looking for characters that are represented by a single `char`.</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/FindFirstLetter.cs" id="SnippetExample":::

#### <a name="split-a-string-on-a-known-char"></a><span data-ttu-id="01189-141">æ‹†åˆ†å·²çŸ¥çš„å­—ç¬¦ä¸² `char`</span><span class="sxs-lookup"><span data-stu-id="01189-141">Split a string on a known `char`</span></span>

<span data-ttu-id="01189-142">é€šå¸¸è°ƒç”¨ `string.Split` å’Œä½¿ç”¨åˆ†éš”ç¬¦ï¼ˆå¦‚ `' '` (space) æˆ– `','` (é€—å·) ï¼‰ï¼Œå¦‚ä»¥ä¸‹ç¤ºä¾‹ä¸­æ‰€ç¤ºï¼š</span><span class="sxs-lookup"><span data-stu-id="01189-142">It's common to call `string.Split` and use delimiters such as `' '` (space) or `','` (comma), as in the following example:</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/SplitStringOnChar.cs" id="SnippetExample":::

<span data-ttu-id="01189-143">æ— éœ€ `Rune` åœ¨æ­¤å¤„ä½¿ç”¨ï¼Œå› ä¸ºä»£ç æ­£åœ¨æŸ¥æ‰¾ç”±å•ä¸ªè¡¨ç¤ºçš„å­—ç¬¦ `char` ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-143">There is no need to use `Rune` here, because the code is looking for characters that are represented by a single `char`.</span></span>

#### <a name="count-the-number-of-display-characters-in-a-string"></a><span data-ttu-id="01189-144">è®¡ç®—ä¸­çš„æ˜¾ç¤ºå­—ç¬¦æ•° `string`</span><span class="sxs-lookup"><span data-stu-id="01189-144">Count the number of display characters in a `string`</span></span>

<span data-ttu-id="01189-145">`Rune`å­—ç¬¦ä¸²ä¸­çš„å®ä¾‹æ•°å¯èƒ½ä¸æ˜¾ç¤ºå­—ç¬¦ä¸²æ—¶æ‰€æ˜¾ç¤ºçš„ç”¨æˆ·å¯è¯†åˆ«å­—ç¬¦çš„æ•°ç›®ä¸åŒ¹é…ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-145">The number of `Rune` instances in a string might not match the number of user-perceivable characters shown when displaying the string.</span></span>

<span data-ttu-id="01189-146">ç”±äº `Rune` å®ä¾‹è¡¨ç¤º unicode æ ‡é‡å€¼ï¼Œå› æ­¤éµå¾ª [unicode æ–‡æœ¬åˆ†æ®µæŒ‡å¯¼åŸåˆ™](https://www.unicode.org/reports/tr29/) çš„ç»„ä»¶å¯ `Rune` ç”¨ä½œç»Ÿè®¡æ˜¾ç¤ºå­—ç¬¦çš„æ„å»ºåŸºå—ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-146">Since `Rune` instances represent Unicode scalar values, components that follow the [Unicode text segmentation guidelines](https://www.unicode.org/reports/tr29/) can use `Rune` as a building block for counting display characters.</span></span>

<span data-ttu-id="01189-147"><xref:System.Globalization.StringInfo>ç±»å‹å¯ç”¨äºç»Ÿè®¡æ˜¾ç¤ºå­—ç¬¦ï¼Œä½†åœ¨ .net ä»¥å¤–çš„ .net å®ç°ä¸­ï¼Œå®ƒä¸ä¼šåœ¨æ‰€æœ‰æ–¹æ¡ˆä¸­æ­£ç¡®è®¡æ•°ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-147">The <xref:System.Globalization.StringInfo> type can be used to count display characters, but in implementations of .NET other than .NET 5 it doesn't count correctly in all scenarios.</span></span>

<span data-ttu-id="01189-148">æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜… [å­—å½¢ç¾¤é›†](/dotnet/standard/base-types/character-encoding-introduction#grapheme-clusters)ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-148">For more information, see [Grapheme clusters](/dotnet/standard/base-types/character-encoding-introduction#grapheme-clusters).</span></span>

### <a name="how-to-instantiate-a-rune"></a><span data-ttu-id="01189-149">å¦‚ä½•å®ä¾‹åŒ– `Rune`</span><span class="sxs-lookup"><span data-stu-id="01189-149">How to instantiate a `Rune`</span></span>

<span data-ttu-id="01189-150">å¯ä»¥é€šè¿‡å¤šç§æ–¹æ³•è·å– `Rune` å®ä¾‹ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-150">There are several ways to get a `Rune` instance.</span></span> <span data-ttu-id="01189-151">å¯ä»¥ä½¿ç”¨æ„é€ å‡½æ•° `Rune` ç›´æ¥ä»ä¸­åˆ›å»ºï¼š</span><span class="sxs-lookup"><span data-stu-id="01189-151">You can use a constructor to create a `Rune` directly from:</span></span>

* <span data-ttu-id="01189-152">ç ä½ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-152">A code point.</span></span>

  :::code language="csharp" source="~/snippets/System.Text/Rune/csharp/InstantiateRunes.cs" id="SnippetCodePoint":::

* <span data-ttu-id="01189-153">å•ä¸ª `char`ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-153">A single `char`.</span></span>

  :::code language="csharp" source="~/snippets/System.Text/Rune/csharp/InstantiateRunes.cs" id="SnippetChar":::

* <span data-ttu-id="01189-154">ä»£ç†é¡¹ `char` å¯¹ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-154">A surrogate `char` pair.</span></span>

  :::code language="csharp" source="~/snippets/System.Text/Rune/csharp/InstantiateRunes.cs" id="SnippetSurrogate":::

<span data-ttu-id="01189-155">`ArgumentException`å¦‚æœè¾“å…¥ä¸è¡¨ç¤ºæœ‰æ•ˆçš„ Unicode æ ‡é‡å€¼ï¼Œåˆ™æ‰€æœ‰æ„é€ å‡½æ•°éƒ½å°†å¼•å‘ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-155">All of the constructors throw an `ArgumentException` if the input doesn't represent a valid Unicode scalar value.</span></span>

<span data-ttu-id="01189-156">æœ‰ä¸€äº› <xref:System.Text.Rune.TryCreate%2A?displayProperty=nameWithType> æ–¹æ³•å¯ç”¨äºä¸å¸Œæœ›åœ¨å¤±è´¥æ—¶å¼•å‘å¼‚å¸¸çš„è°ƒç”¨æ–¹ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-156">There are <xref:System.Text.Rune.TryCreate%2A?displayProperty=nameWithType> methods available for callers who don't want exceptions to be thrown on failure.</span></span>

<span data-ttu-id="01189-157">`Rune` ä¹Ÿå¯ä»¥ä»ç°æœ‰è¾“å…¥åºåˆ—ä¸­è¯»å–å®ä¾‹ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-157">`Rune` instances can also be read from existing input sequences.</span></span> <span data-ttu-id="01189-158">ä¾‹å¦‚ï¼Œå¦‚æœç»™å®š `ReadOnlySpan<char>` è¡¨ç¤º utf-16 æ•°æ®çš„ï¼Œåˆ™è¯¥æ–¹æ³•å°† <xref:System.Text.Rune.DecodeFromUtf16%2A?displayProperty=nameWithType> è¿”å› `Rune` è¾“å…¥èŒƒå›´å¼€å§‹å¤„çš„ç¬¬ä¸€ä¸ªå®ä¾‹ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-158">For instance, given a `ReadOnlySpan<char>` that represents UTF-16 data, the <xref:System.Text.Rune.DecodeFromUtf16%2A?displayProperty=nameWithType> method returns the first `Rune` instance at the beginning of the input span.</span></span> <span data-ttu-id="01189-159">æ­¤ <xref:System.Text.Rune.DecodeFromUtf8%2A?displayProperty=nameWithType> æ–¹æ³•çš„æ“ä½œæ–¹å¼ç±»ä¼¼äºæ¥å— `ReadOnlySpan<byte>` è¡¨ç¤º utf-8 æ•°æ®çš„å‚æ•°ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-159">The <xref:System.Text.Rune.DecodeFromUtf8%2A?displayProperty=nameWithType> method operates similarly, accepting a `ReadOnlySpan<byte>` parameter that represents UTF-8 data.</span></span> <span data-ttu-id="01189-160">å¯ä»¥ä»è·¨åº¦çš„æœ«å°¾è€Œä¸æ˜¯åœ¨èŒƒå›´çš„å¼€å¤´è¯»å–ç­‰æ•ˆçš„æ–¹æ³•ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-160">There are equivalent methods to read from the end of the span instead of the beginning of the span.</span></span>

### <a name="query-properties-of-a-rune"></a><span data-ttu-id="01189-161">çš„æŸ¥è¯¢å±æ€§ `Rune`</span><span class="sxs-lookup"><span data-stu-id="01189-161">Query properties of a `Rune`</span></span>

<span data-ttu-id="01189-162">è‹¥è¦è·å–å®ä¾‹çš„æ•´æ•°ç ä½å€¼ `Rune` ï¼Œè¯·ä½¿ç”¨ <xref:System.Text.Rune.Value?displayProperty=nameWithType> å±æ€§ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-162">To get the integer code point value of a `Rune` instance, use the <xref:System.Text.Rune.Value?displayProperty=nameWithType> property.</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/InstantiateRunes.cs" id="SnippetValue":::

<span data-ttu-id="01189-163">ç±»å‹ä¸Šä¹Ÿæä¾›äº†è®¸å¤šå¯ç”¨çš„é™æ€ Api `char` `Rune` ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-163">Many of the static APIs available on the `char` type are also available on the `Rune` type.</span></span> <span data-ttu-id="01189-164">ä¾‹å¦‚ï¼Œ <xref:System.Text.Rune.IsWhiteSpace%2A?displayProperty=nameWithType> å’Œ <xref:System.Text.Rune.GetUnicodeCategory%2A?displayProperty=nameWithType> æ˜¯ä¸ <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> å’Œæ–¹æ³•ç­‰æ•ˆçš„ <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-164">For instance, <xref:System.Text.Rune.IsWhiteSpace%2A?displayProperty=nameWithType> and <xref:System.Text.Rune.GetUnicodeCategory%2A?displayProperty=nameWithType> are equivalents to <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> and <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="01189-165">è¿™äº› `Rune` æ–¹æ³•æ­£ç¡®åœ°å¤„ç†ä»£ç†é¡¹å¯¹ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-165">The `Rune` methods correctly handle surrogate pairs.</span></span>

<span data-ttu-id="01189-166">ä¸‹é¢çš„ä»£ç ç¤ºä¾‹é‡‡ç”¨ `ReadOnlySpan<char>` ä½œä¸ºè¾“å…¥ï¼Œå¹¶åœ¨è·¨åº¦çš„èµ·å§‹å’Œç»“æŸä¹‹é—´è¿›è¡Œè£å‰ªï¼Œæ¯ä¸ª `Rune` ä¸æ˜¯å­—æ¯æˆ–æ•°å­—ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-166">The following example code takes a `ReadOnlySpan<char>` as input and trims from both the start and the end of the span every `Rune` that isn't a letter or a digit.</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/TrimNonLettersAndNonDigits.cs" id="SnippetExample":::

<span data-ttu-id="01189-167">ä¸ä¹‹é—´å­˜åœ¨ä¸€äº› API å·®å¼‚ `char` `Rune` ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-167">There are some API differences between `char` and `Rune`.</span></span> <span data-ttu-id="01189-168">ä¾‹å¦‚ï¼š</span><span class="sxs-lookup"><span data-stu-id="01189-168">For example:</span></span>

* <span data-ttu-id="01189-169">æ²¡æœ‰ç­‰æ•ˆé¡¹ `Rune` <xref:System.Char.IsSurrogate(System.Char)?displayProperty=nameWithType> ï¼Œå› ä¸º `Rune` æ ¹æ®å®šä¹‰ï¼Œå®ä¾‹æ°¸è¿œä¸èƒ½æ˜¯ä»£ç†é¡¹ç ä½ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-169">There is no `Rune` equivalent  to <xref:System.Char.IsSurrogate(System.Char)?displayProperty=nameWithType>, since `Rune` instances by definition can never be surrogate code points.</span></span>
* <span data-ttu-id="01189-170"><xref:System.Text.Rune.GetUnicodeCategory%2A?displayProperty=nameWithType>å¹¶ä¸æ€»æ˜¯è¿”å›ä¸ç›¸åŒçš„ç»“æœ <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-170">The <xref:System.Text.Rune.GetUnicodeCategory%2A?displayProperty=nameWithType> doesn't always return the same result as <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="01189-171">å®ƒä¼šè¿”å›ä¸ç›¸åŒçš„å€¼ <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-171">It does return the same value as <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="01189-172">æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…ä¸­çš„ **å¤‡æ³¨** <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-172">For more information, see the **Remarks** on <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType>.</span></span>

### <a name="convert-a-rune-to-utf-8-or-utf-16"></a><span data-ttu-id="01189-173">å°†è½¬æ¢ä¸º `Rune` utf-8 æˆ– utf-16</span><span class="sxs-lookup"><span data-stu-id="01189-173">Convert a `Rune` to UTF-8 or UTF-16</span></span>

<span data-ttu-id="01189-174">ç”±äº `Rune` æ˜¯ä¸€ä¸ª Unicode æ ‡é‡å€¼ï¼Œå› æ­¤å¯å°†å…¶è½¬æ¢ä¸º utf-8ã€utf-16 æˆ– utf-32 ç¼–ç ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-174">Since a `Rune` is a Unicode scalar value, it can be converted to UTF-8, UTF-16, or UTF-32 encoding.</span></span> <span data-ttu-id="01189-175">`Rune`ç±»å‹å†…ç½®äº†å¯¹ utf-8 å’Œ utf-16 çš„è½¬æ¢æ”¯æŒã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-175">The `Rune` type has built-in support for conversion to UTF-8 and UTF-16.</span></span>

<span data-ttu-id="01189-176">å°† <xref:System.Text.Rune.EncodeToUtf16%2A?displayProperty=nameWithType> å®ä¾‹è½¬æ¢ `Rune` ä¸º `char` å®ä¾‹ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-176">The <xref:System.Text.Rune.EncodeToUtf16%2A?displayProperty=nameWithType> converts a `Rune` instance to `char` instances.</span></span> <span data-ttu-id="01189-177">è‹¥è¦æŸ¥è¯¢ `char` å°†å®ä¾‹è½¬æ¢ä¸º utf-16 è€Œäº§ç”Ÿçš„å®ä¾‹æ•° `Rune` ï¼Œè¯·ä½¿ç”¨ <xref:System.Text.Rune.Utf16SequenceLength?displayProperty=nameWithType> å±æ€§ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-177">To query the number of `char` instances that would result from converting a `Rune` instance to UTF-16, use the <xref:System.Text.Rune.Utf16SequenceLength?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="01189-178">å¯¹äº UTF-8 è½¬æ¢ï¼Œå­˜åœ¨ç±»ä¼¼çš„æ–¹æ³•ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-178">Similar methods exist for UTF-8 conversion.</span></span>

<span data-ttu-id="01189-179">ä¸‹é¢çš„ç¤ºä¾‹å°† `Rune` å®ä¾‹è½¬æ¢ä¸º `char` æ•°ç»„ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-179">The following example converts a `Rune` instance to a `char` array.</span></span> <span data-ttu-id="01189-180">è¯¥ä»£ç å‡å®š `Rune` å˜é‡ä¸­æœ‰ä¸€ä¸ªå®ä¾‹ `rune` ï¼š</span><span class="sxs-lookup"><span data-stu-id="01189-180">The code assumes you have a `Rune` instance in the `rune` variable:</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/EncodeRune.cs" id="SnippetUtf16CharArray":::

<span data-ttu-id="01189-181">ç”±äº `string` æ˜¯ utf-16 å­—ç¬¦çš„åºåˆ—ï¼Œä¸‹é¢çš„ç¤ºä¾‹è¿˜å°† `Rune` å®ä¾‹è½¬æ¢ä¸º utf-16ï¼š</span><span class="sxs-lookup"><span data-stu-id="01189-181">Since a `string` is a sequence of UTF-16 chars, the following example also converts a `Rune` instance to UTF-16:</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/EncodeRune.cs" id="SnippetUtf16String":::

<span data-ttu-id="01189-182">ä¸‹é¢çš„ç¤ºä¾‹å°† `Rune` å®ä¾‹è½¬æ¢ä¸º `UTF-8` å­—èŠ‚æ•°ç»„ï¼š</span><span class="sxs-lookup"><span data-stu-id="01189-182">The following example converts a `Rune` instance to a `UTF-8` byte array:</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/EncodeRune.cs" id="SnippetUtf8ByteArray":::

<span data-ttu-id="01189-183"><xref:System.Text.Rune.EncodeToUtf16%2A?displayProperty=nameWithType>å’Œ <xref:System.Text.Rune.EncodeToUtf8%2A?displayProperty=nameWithType> æ–¹æ³•è¿”å›å·²å†™å…¥çš„å®é™…å…ƒç´ æ•°ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-183">The <xref:System.Text.Rune.EncodeToUtf16%2A?displayProperty=nameWithType> and <xref:System.Text.Rune.EncodeToUtf8%2A?displayProperty=nameWithType> methods return the actual number of elements written.</span></span> <span data-ttu-id="01189-184">å¦‚æœç›®æ ‡ç¼“å†²åŒºå¤ªçŸ­è€Œæ— æ³•åŒ…å«ç»“æœï¼Œå®ƒä»¬å°†å¼•å‘å¼‚å¸¸ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-184">They throw an exception if the destination buffer is too short to contain the result.</span></span> <span data-ttu-id="01189-185"><xref:System.Text.Rune.TryEncodeToUtf8%2A> <xref:System.Text.Rune.EncodeToUtf16%2A> å¯¹äºæƒ³è¦é¿å…å¼‚å¸¸çš„è°ƒç”¨æ–¹ï¼Œè¿˜å­˜åœ¨éå¼•å‘å’Œæ–¹æ³•ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-185">There are non-throwing <xref:System.Text.Rune.TryEncodeToUtf8%2A> and <xref:System.Text.Rune.EncodeToUtf16%2A> methods as well for callers who want to avoid exceptions.</span></span>

### <a name="rune-in-net-vs-other-languages"></a><span data-ttu-id="01189-186">.NET ä¸­çš„ Rune ä¸å…¶ä»–è¯­è¨€</span><span class="sxs-lookup"><span data-stu-id="01189-186">Rune in .NET vs. other languages</span></span>

<span data-ttu-id="01189-187">Unicode æ ‡å‡†ä¸­æœªå®šä¹‰ "rune" ä¸€è¯ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-187">The term "rune" is not defined in the Unicode Standard.</span></span> <span data-ttu-id="01189-188">æœ¯è¯­ "æ—¥æœŸ" æ”¹å› [åˆ›å»º utf-8](https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt)ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-188">The term dates back to [the creation of UTF-8](https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt).</span></span> <span data-ttu-id="01189-189">è®¨è®ºæ¶Œç°å’Œ Ken Thompson æ­£åœ¨å¯»æ‰¾ä¸€é¡¹æœ¯è¯­æ¥æè¿°æœ€ç»ˆæˆä¸ºä¸€ä¸ªç ä½çš„å†…å®¹ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-189">Rob Pike and Ken Thompson were looking for a term to describe what would eventually become known as a code point.</span></span> <span data-ttu-id="01189-190">[å®ƒä»¬æ˜¯åœ¨ "rune" ä¸€è¯ä¸Šç»“ç®—](https://twitter.com/rob_pike/status/732353233474064384)çš„ï¼Œè€Œä¸”åœ¨æ¶Œç°çš„æ›´é«˜ç‰ˆæœ¬ä¸­ï¼Œå¯¹ä¸­è½¬ç¼–ç¨‹è¯­è¨€çš„å½±å“å°†ä¼šå¸®åŠ© popularizeã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-190">[They settled on the term "rune"](https://twitter.com/rob_pike/status/732353233474064384), and Rob Pike's later influence over the Go programming language helped popularize the term.</span></span>

<span data-ttu-id="01189-191">ä½†æ˜¯ï¼Œ.NET `Rune` ç±»å‹ä¸æ˜¯ "å¼€å§‹" ç±»å‹çš„ç­‰æ•ˆé¡¹ `rune` ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-191">However, the .NET `Rune` type is not the equivalent of the Go `rune` type.</span></span> <span data-ttu-id="01189-192">åœ¨ "å¼€å§‹" ä¸­ï¼Œ `rune` ç±»å‹æ˜¯[çš„ `int32` åˆ«å](https://blog.golang.org/strings)ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-192">In Go, the `rune` type is an [alias for `int32`](https://blog.golang.org/strings).</span></span> <span data-ttu-id="01189-193">ä¸­è½¬ rune ç”¨äºè¡¨ç¤º Unicode ç ä½ï¼Œä½†å®ƒå¯ä»¥æ˜¯ä»»ä½•32ä½å€¼ï¼Œå…¶ä¸­åŒ…æ‹¬ä»£ç†é¡¹ç ä½å’Œä¸æ˜¯åˆæ³• Unicode ç ä½çš„å€¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-193">A Go rune is intended to represent a Unicode code point, but it can be any 32-bit value, including surrogate code points and values that are not legal Unicode code points.</span></span>

<span data-ttu-id="01189-194">å¯¹äºå…¶ä»–ç¼–ç¨‹è¯­è¨€ä¸­ç±»ä¼¼çš„ç±»å‹ï¼Œè¯·å‚é˜… [Rust çš„åŸºå…ƒ `char` ç±»å‹](https://doc.rust-lang.org/std/primitive.char.html) æˆ– [Swift çš„ `Unicode.Scalar` ç±»å‹](https://developer.apple.com/documentation/swift/unicode/scalar)ï¼Œä¸¤è€…éƒ½è¡¨ç¤º Unicode æ ‡é‡å€¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-194">For similar types in other programming languages, see [Rust's primitive `char` type](https://doc.rust-lang.org/std/primitive.char.html) or [Swift's `Unicode.Scalar` type](https://developer.apple.com/documentation/swift/unicode/scalar), both of which represent Unicode scalar values.</span></span> <span data-ttu-id="01189-195">å®ƒä»¬æä¾›ç±»ä¼¼äºçš„åŠŸèƒ½ã€‚NET çš„ `Rune` ç±»å‹ï¼Œå¹¶ä¸”ä¸å…è®¸å¯¹ä¸æ˜¯åˆæ³• Unicode æ ‡é‡å€¼çš„å€¼è¿›è¡Œå®ä¾‹åŒ–ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-195">They provide functionality similar to .NET's `Rune` type, and they disallow instantiation of values that are not legal Unicode scalar values.</span></span>

          ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rune (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.#ctor(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ch As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rune(char ch);" />
      <MemberSignature Language="F#" Value="new System.Text.Rune : char -&gt; System.Text.Rune" Usage="new System.Text.Rune ch" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch"><span data-ttu-id="01189-196">UTF-16 ä»£ç å•å…ƒã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-196">A UTF-16 code unit.</span></span></param>
        <summary><span data-ttu-id="01189-197">ä»æä¾›çš„ UTF-16 ä»£ç å•å…ƒä¸­åˆ›å»º <see cref="T:System.Text.Rune" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-197">Creates a <see cref="T:System.Text.Rune" /> from the provided UTF-16 code unit.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="01189-198"><paramref name="ch" /> è¡¨ç¤º UTF-16 ä»£ç†é¡¹ç ä½ï¼ˆU+D800..U+DFFFï¼Œå«é¦–å°¾å€¼ï¼‰ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-198"><paramref name="ch" /> represents a UTF-16 surrogate code point (U+D800..U+DFFF, inclusive).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rune (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rune(int value);" />
      <MemberSignature Language="F#" Value="new System.Text.Rune : int -&gt; System.Text.Rune" Usage="new System.Text.Rune value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="01189-199">ä¸€ä¸ª Unicode æ ‡é‡å€¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-199">A Unicode scalar value.</span></span></param>
        <summary><span data-ttu-id="01189-200">ä»è¡¨ç¤º Unicode æ ‡é‡å€¼çš„æŒ‡å®š 32 ä½æ•´æ•°ä¸­åˆ›å»º <see cref="T:System.Text.Rune" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-200">Creates a <see cref="T:System.Text.Rune" /> from the specified 32-bit integer that represents a Unicode scalar value.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="01189-201"><paramref name="value" /> ä¸è¡¨ç¤º Unicode æ ‡é‡å€¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-201"><paramref name="value" /> does not represent a Unicode scalar value.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rune (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.#ctor(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rune(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="new System.Text.Rune : uint32 -&gt; System.Text.Rune" Usage="new System.Text.Rune value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="01189-202">ä¸€ä¸ª Unicode æ ‡é‡å€¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-202">A Unicode scalar value.</span></span></param>
        <summary><span data-ttu-id="01189-203">ä»è¡¨ç¤º Unicode æ ‡é‡å€¼çš„æŒ‡å®š 32 ä½æ— ç¬¦å·æ•´æ•°ä¸­åˆ›å»º <see cref="T:System.Text.Rune" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-203">Creates a <see cref="T:System.Text.Rune" /> from the specified 32-bit unsigned integer that represents a Unicode scalar value.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="01189-204"><paramref name="value" /> ä¸è¡¨ç¤º Unicode æ ‡é‡å€¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-204"><paramref name="value" /> does not represent a Unicode scalar value.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rune (char highSurrogate, char lowSurrogate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char highSurrogate, char lowSurrogate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.#ctor(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (highSurrogate As Char, lowSurrogate As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rune(char highSurrogate, char lowSurrogate);" />
      <MemberSignature Language="F#" Value="new System.Text.Rune : char * char -&gt; System.Text.Rune" Usage="new System.Text.Rune (highSurrogate, lowSurrogate)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="highSurrogate" Type="System.Char" />
        <Parameter Name="lowSurrogate" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="highSurrogate"><span data-ttu-id="01189-205">ä»£ç†é¡¹å¯¹çš„é«˜ä»£ç†é¡¹ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-205">The high surrogate of the surrogate pair.</span></span></param>
        <param name="lowSurrogate"><span data-ttu-id="01189-206">ä»£ç†é¡¹å¯¹çš„ä½ä»£ç†é¡¹ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-206">The low surrogate of the surrogate pair.</span></span></param>
        <summary><span data-ttu-id="01189-207">ä»æä¾›çš„ UTF-16 ä»£ç†é¡¹å¯¹ä¸­åˆ›å»º <see cref="T:System.Text.Rune" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-207">Creates a <see cref="T:System.Text.Rune" /> from the provided UTF-16 surrogate pair.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="01189-208"><paramref name="highSurrogate" /> ä¸è¡¨ç¤º UTF-16 é«˜ä»£ç†é¡¹ç ä½ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-208"><paramref name="highSurrogate" /> does not represent a UTF-16 high surrogate code point.</span></span>
          
<span data-ttu-id="01189-209">- æˆ– -</span><span class="sxs-lookup"><span data-stu-id="01189-209">-or-</span></span>

<span data-ttu-id="01189-210"><paramref name="lowSurrogate" /> ä¸è¡¨ç¤º UTF-16 ä½ä»£ç†é¡¹ç ä½ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-210"><paramref name="lowSurrogate" /> does not represent a UTF-16 low surrogate code point.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Text.Rune other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Text.Rune other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.CompareTo(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As Rune) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Text::Rune other);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : System.Text.Rune -&gt; int&#xA;override this.CompareTo : System.Text.Rune -&gt; int" Usage="rune.CompareTo other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="01189-211">è¦ä¸å½“å‰å®ä¾‹è¿›è¡Œæ¯”è¾ƒçš„å®ä¾‹ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-211">The instance to compare with the current instance.</span></span></param>
        <summary><span data-ttu-id="01189-212">å°†å½“å‰å®ä¾‹ä¸æŒ‡å®šçš„ <see cref="T:System.Text.Rune" /> å®ä¾‹è¿›è¡Œæ¯”è¾ƒã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-212">Compares the current instance to the specified <see cref="T:System.Text.Rune" /> instance.</span></span></summary>
        <returns><span data-ttu-id="01189-213">ä¸€ä¸ªå¸¦ç¬¦å·æ•´æ•°ï¼ŒæŒ‡ç¤ºæ­¤å®ä¾‹åœ¨æ’åºé¡ºåºä¸­ç›¸å¯¹äº <paramref name="other" /> çš„ä½ç½®ï¼š</span><span class="sxs-lookup"><span data-stu-id="01189-213">A signed integer indicating the position of this instance in the sort order in relation to <paramref name="other" />:</span></span> <br /><span data-ttu-id="01189-214">- å°äºé›¶ï¼šæ­¤å®ä¾‹ä½äº <paramref name="other" /> ä¹‹å‰ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-214">- Less than zero: This instance precedes <paramref name="other" />.</span></span> 
<br /><span data-ttu-id="01189-215">- é›¶ï¼šå®ä¾‹åœ¨æ’åºé¡ºåºä¸­çš„ä½ç½®ä¸ <paramref name="other" /> ç›¸åŒã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-215">- Zero: The instance has the same position in the sort order as <paramref name="other" />.</span></span>
<br /><span data-ttu-id="01189-216">- å¤§äºé›¶ï¼šæ­¤å®ä¾‹ä½äº <paramref name="other" /> ä¹‹åã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-216">- Greater than zero: This instance follows <paramref name="other" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DecodeFromUtf16">
      <MemberSignature Language="C#" Value="public static System.Buffers.OperationStatus DecodeFromUtf16 (ReadOnlySpan&lt;char&gt; source, out System.Text.Rune result, out int charsConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Buffers.OperationStatus DecodeFromUtf16(valuetype System.ReadOnlySpan`1&lt;char&gt; source, [out] valuetype System.Text.Rune&amp; result, [out] int32&amp; charsConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.DecodeFromUtf16(System.ReadOnlySpan{System.Char},System.Text.Rune@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DecodeFromUtf16 (source As ReadOnlySpan(Of Char), ByRef result As Rune, ByRef charsConsumed As Integer) As OperationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Buffers::OperationStatus DecodeFromUtf16(ReadOnlySpan&lt;char&gt; source, [Runtime::InteropServices::Out] System::Text::Rune % result, [Runtime::InteropServices::Out] int % charsConsumed);" />
      <MemberSignature Language="F#" Value="static member DecodeFromUtf16 : ReadOnlySpan&lt;char&gt; * Rune * int -&gt; System.Buffers.OperationStatus" Usage="System.Text.Rune.DecodeFromUtf16 (source, result, charsConsumed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.OperationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Text.Rune" RefType="out" />
        <Parameter Name="charsConsumed" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="01189-217">åªè¯» UTF-16 å­—ç¬¦èŒƒå›´ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-217">A read-only UTF-16 character span.</span></span></param>
        <param name="result"><span data-ttu-id="01189-218">æ­¤æ–¹æ³•è¿”å›æ—¶ï¼Œå·²è§£ç çš„ runeã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-218">When this method returns, the decoded rune.</span></span></param>
        <param name="charsConsumed"><span data-ttu-id="01189-219">æ­¤æ–¹æ³•è¿”å›æ—¶ï¼Œä¸ºåˆ›å»º rune è€Œè¯»å–çš„å­—ç¬¦æ•°ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-219">When this method returns, the number of characters read to create the rune.</span></span></param>
        <summary><span data-ttu-id="01189-220">åœ¨æä¾›çš„ UTF-16 æºç¼“å†²åŒºå¼€å§‹å¤„è§£ç  <see cref="T:System.Text.Rune" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-220">Decodes the <see cref="T:System.Text.Rune" /> at the beginning of the provided UTF-16 source buffer.</span></span></summary>
        <returns><span data-ttu-id="01189-221">å¦‚æœæºç¼“å†²åŒºä»¥æœ‰æ•ˆçš„ UTF-16 ç¼–ç æ ‡é‡å€¼å¼€å¤´ï¼Œåˆ™ <see cref="F:System.Buffers.OperationStatus.Done" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-221"><see cref="F:System.Buffers.OperationStatus.Done" /> if the source buffer begins with a valid UTF-16 encoded scalar value.</span></span> <span data-ttu-id="01189-222">ç„¶å <paramref name="result" /> åŒ…å«è§£ç çš„ <see cref="T:System.Text.Rune" />ï¼Œ<paramref name="charsConsumed" /> åŒ…å«ç”¨äºåœ¨è¾“å…¥ç¼“å†²åŒºä¸­è§£ç  <see cref="T:System.Text.Rune" /> çš„ <see cref="T:System.Char" /> å€¼çš„æ•°ç›®ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-222"><paramref name="result" /> then contains the decoded <see cref="T:System.Text.Rune" />, and <paramref name="charsConsumed" /> contains the number of <see cref="T:System.Char" /> values used in the input buffer to encode the <see cref="T:System.Text.Rune" />.</span></span>
            
<span data-ttu-id="01189-223">å¦‚æœæºç¼“å†²åŒºä¸ºç©ºï¼Œæˆ–ä»…åŒ…å«ç‹¬ç«‹çš„ UTF-16 é«˜ä»£ç†é¡¹å­—ç¬¦ï¼Œåˆ™ <see cref="F:System.Buffers.OperationStatus.NeedMoreData" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-223"><see cref="F:System.Buffers.OperationStatus.NeedMoreData" /> if the source buffer is empty or contains only a standalone UTF-16 high surrogate character.</span></span> <span data-ttu-id="01189-224">ç„¶å <paramref name="result" /> åŒ…å« <see cref="P:System.Text.Rune.ReplacementChar" />ï¼Œ<paramref name="charsConsumed" /> åŒ…å«è¾“å…¥ç¼“å†²åŒºçš„é•¿åº¦ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-224"><paramref name="result" /> then contains <see cref="P:System.Text.Rune.ReplacementChar" />, and <paramref name="charsConsumed" /> contains the length of the input buffer.</span></span>
            
<span data-ttu-id="01189-225">å¦‚æœæºç¼“å†²åŒºä»¥æ ¼å¼é”™è¯¯çš„ UTF-16 ç¼–ç æ ‡é‡å€¼å¼€å¤´ï¼Œåˆ™ <see cref="F:System.Buffers.OperationStatus.InvalidData" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-225"><see cref="F:System.Buffers.OperationStatus.InvalidData" /> if the source buffer begins with an ill-formed UTF-16 encoded scalar value.</span></span> <span data-ttu-id="01189-226">ç„¶å <paramref name="result" /> åŒ…å« <see cref="P:System.Text.Rune.ReplacementChar" />ï¼Œ<paramref name="charsConsumed" /> åŒ…å«ç”¨äºè§£ç æ ¼å¼é”™è¯¯çš„åºåˆ—çš„ <see cref="T:System.Char" /> å€¼çš„æ•°ç›®ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-226"><paramref name="result" /> then contains <see cref="P:System.Text.Rune.ReplacementChar" />, and <paramref name="charsConsumed" /> contains the number of <see cref="T:System.Char" /> values used to encode the ill-formed sequence.</span></span>
<span data-ttu-id="01189-227">ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-227">.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="01189-228">ä¸€èˆ¬çº¦å®šæ˜¯åœ¨å¾ªç¯ä¸­è°ƒç”¨æ­¤æ–¹æ³•ï¼Œ `source` é€šè¿‡ `charsConsumed` å¾ªç¯çš„æ¯æ¬¡è¿­ä»£ä¸Šçš„å…ƒç´ å¯¹ç¼“å†²åŒºè¿›è¡Œåˆ‡ç‰‡ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-228">The general convention is to call this method in a loop, slicing the `source` buffer by `charsConsumed` elements on each iteration of the loop.</span></span> <span data-ttu-id="01189-229">åœ¨å¾ªç¯çš„æ¯æ¬¡è¿­ä»£ä¸­ï¼Œ `result` å¦‚æœæ•°æ®å·²æˆåŠŸè§£ç ï¼Œåˆ™åŒ…å«å®æ ‡é‡å€¼; <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType> å¦‚æœæ•°æ®æœªæˆåŠŸè§£ç ï¼Œåˆ™åŒ…å«å®ƒã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-229">On each iteration of the loop, `result` contains the real scalar value if the data was successfully decoded, or it contains <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType> if the data was not successfully decoded.</span></span> <span data-ttu-id="01189-230">åœ¨å¾ªç¯è®¿é—®å¾ªç¯æ—¶ï¼Œæ­¤æ¨¡å¼æä¾›äº†æ–¹ä¾¿çš„è‡ªåŠ¨ U + FFFD æ›¿æ¢æ— æ•ˆåºåˆ—ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-230">This pattern provides convenient automatic U+FFFD substitution of invalid sequences while iterating through the loop.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DecodeFromUtf8">
      <MemberSignature Language="C#" Value="public static System.Buffers.OperationStatus DecodeFromUtf8 (ReadOnlySpan&lt;byte&gt; source, out System.Text.Rune result, out int bytesConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Buffers.OperationStatus DecodeFromUtf8(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] valuetype System.Text.Rune&amp; result, [out] int32&amp; bytesConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.DecodeFromUtf8(System.ReadOnlySpan{System.Byte},System.Text.Rune@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DecodeFromUtf8 (source As ReadOnlySpan(Of Byte), ByRef result As Rune, ByRef bytesConsumed As Integer) As OperationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Buffers::OperationStatus DecodeFromUtf8(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::Text::Rune % result, [Runtime::InteropServices::Out] int % bytesConsumed);" />
      <MemberSignature Language="F#" Value="static member DecodeFromUtf8 : ReadOnlySpan&lt;byte&gt; * Rune * int -&gt; System.Buffers.OperationStatus" Usage="System.Text.Rune.DecodeFromUtf8 (source, result, bytesConsumed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.OperationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="result" Type="System.Text.Rune" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="01189-231">åªè¯» UTF-8 ç¼–ç å­—èŠ‚èŒƒå›´ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-231">A read-only UTF-8 encoded byte span.</span></span></param>
        <param name="result"><span data-ttu-id="01189-232">æ­¤æ–¹æ³•è¿”å›æ—¶ï¼Œå·²è§£ç çš„ runeã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-232">When this method returns, the decoded rune.</span></span></param>
        <param name="bytesConsumed"><span data-ttu-id="01189-233">æ­¤æ–¹æ³•è¿”å›æ—¶ï¼Œä¸ºåˆ›å»º rune è€Œè¯»å–çš„å­—èŠ‚æ•°ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-233">When this method returns, the number of bytes read to create the rune.</span></span></param>
        <summary><span data-ttu-id="01189-234">åœ¨æä¾›çš„ UTF-8 æºç¼“å†²åŒºå¼€å§‹å¤„è§£ç  <see cref="T:System.Text.Rune" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-234">Decodes the <see cref="T:System.Text.Rune" /> at the beginning of the provided UTF-8 source buffer.</span></span></summary>
        <returns><span data-ttu-id="01189-235">å¦‚æœæºç¼“å†²åŒºä»¥æœ‰æ•ˆçš„ UTF-8 ç¼–ç æ ‡é‡å€¼å¼€å¤´ï¼Œåˆ™ <see cref="F:System.Buffers.OperationStatus.Done" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-235"><see cref="F:System.Buffers.OperationStatus.Done" /> if the source buffer begins with a valid UTF-8 encoded scalar value.</span></span> <span data-ttu-id="01189-236">ç„¶å <paramref name="result" /> åŒ…å«è§£ç çš„ <see cref="T:System.Text.Rune" />ï¼Œ<paramref name="bytesConsumed" /> åŒ…å«ç”¨äºåœ¨è¾“å…¥ç¼“å†²åŒºä¸­è§£ç  <see cref="T:System.Text.Rune" /> çš„ <see cref="T:System.Byte" /> å€¼çš„æ•°ç›®ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-236"><paramref name="result" /> then contains the decoded <see cref="T:System.Text.Rune" />, and <paramref name="bytesConsumed" /> contains the number of <see cref="T:System.Byte" /> values used in the input buffer to encode the <see cref="T:System.Text.Rune" />.</span></span>
            
<span data-ttu-id="01189-237">å¦‚æœæºç¼“å†²åŒºä¸ºç©ºï¼Œæˆ–ä»…åŒ…å«ç‹¬ç«‹çš„ UTF-8 é«˜ä»£ç†é¡¹å­—ç¬¦ï¼Œåˆ™ <see cref="F:System.Buffers.OperationStatus.NeedMoreData" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-237"><see cref="F:System.Buffers.OperationStatus.NeedMoreData" /> if the source buffer is empty or contains only a standalone UTF-8 high surrogate character.</span></span> <span data-ttu-id="01189-238">ç„¶å <paramref name="result" /> åŒ…å« <see cref="P:System.Text.Rune.ReplacementChar" />ï¼Œ<paramref name="bytesConsumed" /> åŒ…å«è¾“å…¥ç¼“å†²åŒºçš„é•¿åº¦ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-238"><paramref name="result" /> then contains <see cref="P:System.Text.Rune.ReplacementChar" />, and <paramref name="bytesConsumed" /> contains the length of the input buffer.</span></span>
            
<span data-ttu-id="01189-239">å¦‚æœæºç¼“å†²åŒºä»¥æ ¼å¼é”™è¯¯çš„ UTF-8 ç¼–ç æ ‡é‡å€¼å¼€å¤´ï¼Œåˆ™ <see cref="F:System.Buffers.OperationStatus.InvalidData" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-239"><see cref="F:System.Buffers.OperationStatus.InvalidData" /> if the source buffer begins with an ill-formed UTF-8 encoded scalar value.</span></span> <span data-ttu-id="01189-240">ç„¶å <paramref name="result" /> åŒ…å« <see cref="P:System.Text.Rune.ReplacementChar" />ï¼Œ<paramref name="bytesConsumed" /> åŒ…å«ç”¨äºåœ¨è¾“å…¥ç¼“å†²åŒºè§£ç æ ¼å¼é”™è¯¯çš„åºåˆ—çš„ <see cref="T:System.Byte" /> å€¼çš„æ•°ç›®ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-240"><paramref name="result" /> then contains <see cref="P:System.Text.Rune.ReplacementChar" />, and <paramref name="bytesConsumed" /> contains the number of <see cref="T:System.Byte" /> values used in the input buffer to encode the ill-formed sequence.</span></span>
<span data-ttu-id="01189-241">ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-241">.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="01189-242">ä¸€èˆ¬çº¦å®šæ˜¯åœ¨å¾ªç¯ä¸­è°ƒç”¨æ­¤æ–¹æ³•ï¼Œ `source` é€šè¿‡ `bytesConsumed` å¾ªç¯çš„æ¯æ¬¡è¿­ä»£ä¸Šçš„å…ƒç´ å¯¹ç¼“å†²åŒºè¿›è¡Œåˆ‡ç‰‡ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-242">The general convention is to call this method in a loop, slicing the `source` buffer by `bytesConsumed` elements on each iteration of the loop.</span></span> <span data-ttu-id="01189-243">åœ¨å¾ªç¯çš„æ¯æ¬¡è¿­ä»£ä¸­ï¼Œ `result` å¦‚æœæˆåŠŸè¿›è¡Œè§£ç ï¼Œåˆ™åŒ…å«å®é™…æ ‡é‡å€¼; <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType> å¦‚æœæ•°æ®æ— æ³•æˆåŠŸè§£ç ï¼Œåˆ™åŒ…å«å®ƒã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-243">On each iteration of the loop, `result` contains the real scalar value if successfully decoded, or it contains <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType> if the data could not be successfully decoded.</span></span> <span data-ttu-id="01189-244">åœ¨å¾ªç¯è®¿é—®å¾ªç¯æ—¶ï¼Œæ­¤æ¨¡å¼æä¾›äº†æ–¹ä¾¿çš„è‡ªåŠ¨ U + FFFD æ›¿æ¢æ— æ•ˆåºåˆ—ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-244">This pattern provides convenient automatic U+FFFD substitution of invalid sequences while iterating through the loop.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DecodeLastFromUtf16">
      <MemberSignature Language="C#" Value="public static System.Buffers.OperationStatus DecodeLastFromUtf16 (ReadOnlySpan&lt;char&gt; source, out System.Text.Rune result, out int charsConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Buffers.OperationStatus DecodeLastFromUtf16(valuetype System.ReadOnlySpan`1&lt;char&gt; source, [out] valuetype System.Text.Rune&amp; result, [out] int32&amp; charsConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.DecodeLastFromUtf16(System.ReadOnlySpan{System.Char},System.Text.Rune@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DecodeLastFromUtf16 (source As ReadOnlySpan(Of Char), ByRef result As Rune, ByRef charsConsumed As Integer) As OperationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Buffers::OperationStatus DecodeLastFromUtf16(ReadOnlySpan&lt;char&gt; source, [Runtime::InteropServices::Out] System::Text::Rune % result, [Runtime::InteropServices::Out] int % charsConsumed);" />
      <MemberSignature Language="F#" Value="static member DecodeLastFromUtf16 : ReadOnlySpan&lt;char&gt; * Rune * int -&gt; System.Buffers.OperationStatus" Usage="System.Text.Rune.DecodeLastFromUtf16 (source, result, charsConsumed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.OperationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Text.Rune" RefType="out" />
        <Parameter Name="charsConsumed" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="01189-245">åªè¯» UTF-16 ç¼–ç å­—ç¬¦èŒƒå›´ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-245">A read-only UTF-16 encoded character span.</span></span></param>
        <param name="result"><span data-ttu-id="01189-246">æ­¤æ–¹æ³•è¿”å›æ—¶ï¼Œå·²è§£ç çš„ runeã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-246">When this method returns, the decoded rune.</span></span></param>
        <param name="charsConsumed"><span data-ttu-id="01189-247">æ­¤æ–¹æ³•è¿”å›æ—¶ï¼Œä¸ºåˆ›å»º rune è€Œè¯»å–çš„å­—èŠ‚æ•°ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-247">When this method returns, the number of bytes read to create the rune.</span></span></param>
        <summary><span data-ttu-id="01189-248">åœ¨æä¾›çš„ UTF-16 æºç¼“å†²åŒºç»“å°¾å¤„è§£ç  <see cref="T:System.Text.Rune" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-248">Decodes the <see cref="T:System.Text.Rune" /> at the end of the provided UTF-16 source buffer.</span></span></summary>
        <returns><span data-ttu-id="01189-249">å¦‚æœæºç¼“å†²åŒºä»¥æœ‰æ•ˆçš„ UTF-16 ç¼–ç æ ‡é‡å€¼å¼€å¤´ï¼Œåˆ™ <see cref="F:System.Buffers.OperationStatus.Done" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-249"><see cref="F:System.Buffers.OperationStatus.Done" /> if the source buffer begins with a valid UTF-16 encoded scalar value.</span></span> <span data-ttu-id="01189-250">ç„¶å <paramref name="result" /> åŒ…å«è§£ç çš„ <see cref="T:System.Text.Rune" />ï¼Œ<paramref name="charsConsumed" /> åŒ…å«ç”¨äºåœ¨è¾“å…¥ç¼“å†²åŒºä¸­è§£ç  <see cref="T:System.Text.Rune" /> çš„ <see cref="T:System.Char" /> å€¼çš„æ•°ç›®ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-250"><paramref name="result" /> then contains the decoded <see cref="T:System.Text.Rune" />, and <paramref name="charsConsumed" /> contains the number of <see cref="T:System.Char" /> values used in the input buffer to encode the <see cref="T:System.Text.Rune" />.</span></span>
            
<span data-ttu-id="01189-251">å¦‚æœæºç¼“å†²åŒºä¸ºç©ºï¼Œæˆ–ä»…åŒ…å«ç‹¬ç«‹çš„ UTF-16 é«˜ä»£ç†é¡¹å­—ç¬¦ï¼Œåˆ™ <see cref="F:System.Buffers.OperationStatus.NeedMoreData" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-251"><see cref="F:System.Buffers.OperationStatus.NeedMoreData" /> if the source buffer is empty or contains only a standalone UTF-16 high surrogate character.</span></span> <span data-ttu-id="01189-252">ç„¶å <paramref name="result" /> åŒ…å« <see cref="P:System.Text.Rune.ReplacementChar" />ï¼Œ<paramref name="charsConsumed" /> åŒ…å«è¾“å…¥ç¼“å†²åŒºçš„é•¿åº¦ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-252"><paramref name="result" /> then contains <see cref="P:System.Text.Rune.ReplacementChar" />, and <paramref name="charsConsumed" /> contains the length of the input buffer.</span></span>
            
<span data-ttu-id="01189-253">å¦‚æœæºç¼“å†²åŒºä»¥æ ¼å¼é”™è¯¯çš„ UTF-16 ç¼–ç æ ‡é‡å€¼å¼€å¤´ï¼Œåˆ™ <see cref="F:System.Buffers.OperationStatus.InvalidData" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-253"><see cref="F:System.Buffers.OperationStatus.InvalidData" /> if the source buffer begins with an ill-formed UTF-16 encoded scalar value.</span></span> <span data-ttu-id="01189-254">ç„¶å <paramref name="result" /> åŒ…å« <see cref="P:System.Text.Rune.ReplacementChar" />ï¼Œ<paramref name="charsConsumed" /> åŒ…å«ç”¨äºè§£ç æ ¼å¼é”™è¯¯çš„åºåˆ—çš„ <see cref="T:System.Char" /> å€¼çš„æ•°ç›®ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-254"><paramref name="result" /> then contains <see cref="P:System.Text.Rune.ReplacementChar" />, and <paramref name="charsConsumed" /> contains the number of <see cref="T:System.Char" /> values used to encode the ill-formed sequence.</span></span>
<span data-ttu-id="01189-255">ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-255">.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="01189-256">æ­¤æ–¹æ³•éå¸¸ç±»ä¼¼äº <xref:System.Text.Rune.DecodeFromUtf16(System.ReadOnlySpan{System.Char},System.Text.Rune@,System.Int32@)> ï¼Œä½†å®ƒå…è®¸è°ƒç”¨æ–¹åå‘å¾ªç¯ï¼Œè€Œä¸æ˜¯è½¬å‘ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-256">This method is very similar to <xref:System.Text.Rune.DecodeFromUtf16(System.ReadOnlySpan{System.Char},System.Text.Rune@,System.Int32@)>, except it allows the caller to loop backward instead of forward.</span></span> <span data-ttu-id="01189-257">å…¸å‹çš„è°ƒç”¨çº¦å®šæ˜¯ï¼Œåœ¨å¾ªç¯çš„æ¯æ¬¡è¿­ä»£æ—¶ï¼Œè°ƒç”¨æ–¹åº”åˆ‡åˆ†ç¼“å†²åŒºçš„æœ€åä¸€ä¸ª `charsConsumed` å…ƒç´  `source` ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-257">The typical calling convention is that on each iteration of the loop, the caller should slice off the final `charsConsumed` elements of the `source` buffer.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DecodeLastFromUtf8">
      <MemberSignature Language="C#" Value="public static System.Buffers.OperationStatus DecodeLastFromUtf8 (ReadOnlySpan&lt;byte&gt; source, out System.Text.Rune value, out int bytesConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Buffers.OperationStatus DecodeLastFromUtf8(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] valuetype System.Text.Rune&amp; value, [out] int32&amp; bytesConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.DecodeLastFromUtf8(System.ReadOnlySpan{System.Byte},System.Text.Rune@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DecodeLastFromUtf8 (source As ReadOnlySpan(Of Byte), ByRef value As Rune, ByRef bytesConsumed As Integer) As OperationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Buffers::OperationStatus DecodeLastFromUtf8(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::Text::Rune % value, [Runtime::InteropServices::Out] int % bytesConsumed);" />
      <MemberSignature Language="F#" Value="static member DecodeLastFromUtf8 : ReadOnlySpan&lt;byte&gt; * Rune * int -&gt; System.Buffers.OperationStatus" Usage="System.Text.Rune.DecodeLastFromUtf8 (source, value, bytesConsumed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.OperationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Text.Rune" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="01189-258">åªè¯» UTF-8 ç¼–ç å­—èŠ‚èŒƒå›´ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-258">A read-only UTF-8 encoded byte span.</span></span></param>
        <param name="value"><span data-ttu-id="01189-259">æ­¤æ–¹æ³•è¿”å›æ—¶ï¼Œå·²è§£ç çš„ runeã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-259">When this method returns, the decoded rune.</span></span></param>
        <param name="bytesConsumed"><span data-ttu-id="01189-260">æ­¤æ–¹æ³•è¿”å›æ—¶ï¼Œä¸ºåˆ›å»º rune è€Œè¯»å–çš„å­—èŠ‚æ•°ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-260">When this method returns, the number of bytes read to create the rune.</span></span></param>
        <summary><span data-ttu-id="01189-261">åœ¨æä¾›çš„ UTF-8 æºç¼“å†²åŒºç»“å°¾å¤„è§£ç  <see cref="T:System.Text.Rune" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-261">Decodes the <see cref="T:System.Text.Rune" /> at the end of the provided UTF-8 source buffer.</span></span></summary>
        <returns><span data-ttu-id="01189-262">å¦‚æœæºç¼“å†²åŒºä»¥æœ‰æ•ˆçš„ UTF-8 ç¼–ç æ ‡é‡å€¼ç»“å°¾ï¼Œåˆ™ <see cref="F:System.Buffers.OperationStatus.Done" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-262"><see cref="F:System.Buffers.OperationStatus.Done" /> if the source buffer ends with a valid UTF-8 encoded scalar value.</span></span> <span data-ttu-id="01189-263">ç„¶å <paramref name="result" /> åŒ…å«è§£ç çš„ <see cref="T:System.Text.Rune" />ï¼Œ<paramref name="bytesConsumed" /> åŒ…å«ç”¨äºåœ¨è¾“å…¥ç¼“å†²åŒºä¸­è§£ç  <see cref="T:System.Text.Rune" /> çš„ <see cref="T:System.Byte" /> å€¼çš„æ•°ç›®ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-263"><paramref name="result" /> then contains the decoded <see cref="T:System.Text.Rune" />, and <paramref name="bytesConsumed" /> contains the number of <see cref="T:System.Byte" /> values used in the input buffer to encode the <see cref="T:System.Text.Rune" />.</span></span>
            
<span data-ttu-id="01189-264">å¦‚æœæºç¼“å†²åŒºä¸ºç©ºï¼Œæˆ–ä»…åŒ…å«ç‹¬ç«‹çš„ UTF-8 é«˜ä»£ç†é¡¹å­—ç¬¦ï¼Œåˆ™ <see cref="F:System.Buffers.OperationStatus.NeedMoreData" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-264"><see cref="F:System.Buffers.OperationStatus.NeedMoreData" /> if the source buffer is empty or contains only a standalone UTF-8 high surrogate character.</span></span> <span data-ttu-id="01189-265">ç„¶å <paramref name="result" /> åŒ…å« <see cref="P:System.Text.Rune.ReplacementChar" />ï¼Œ<paramref name="bytesConsumed" /> åŒ…å«è¾“å…¥ç¼“å†²åŒºçš„é•¿åº¦ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-265"><paramref name="result" /> then contains <see cref="P:System.Text.Rune.ReplacementChar" />, and <paramref name="bytesConsumed" /> contains the length of the input buffer.</span></span>
            
<span data-ttu-id="01189-266">å¦‚æœæºç¼“å†²åŒºä»¥æ ¼å¼é”™è¯¯çš„ UTF-8 ç¼–ç æ ‡é‡å€¼ç»“å°¾ï¼Œåˆ™ <see cref="F:System.Buffers.OperationStatus.InvalidData" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-266"><see cref="F:System.Buffers.OperationStatus.InvalidData" /> if the source buffer ends with an ill-formed UTF-8 encoded scalar value.</span></span> <span data-ttu-id="01189-267">ç„¶å <paramref name="result" /> åŒ…å« <see cref="P:System.Text.Rune.ReplacementChar" />ï¼Œ<paramref name="bytesConsumed" /> åŒ…å«ç”¨äºåœ¨è¾“å…¥ç¼“å†²åŒºè§£ç æ ¼å¼é”™è¯¯çš„åºåˆ—çš„ <see cref="T:System.Byte" /> å€¼çš„æ•°ç›®ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-267"><paramref name="result" /> then contains <see cref="P:System.Text.Rune.ReplacementChar" />, and <paramref name="bytesConsumed" /> contains the number of <see cref="T:System.Byte" /> values used in the input buffer to encode the ill-formed sequence.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="01189-268">æ­¤æ–¹æ³•éå¸¸ç±»ä¼¼äº <xref:System.Text.Rune.DecodeFromUtf8(System.ReadOnlySpan{System.Byte},System.Text.Rune@,System.Int32@)> ï¼Œä½†å®ƒå…è®¸è°ƒç”¨æ–¹åå‘å¾ªç¯ï¼Œè€Œä¸æ˜¯è½¬å‘ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-268">This method is very similar to <xref:System.Text.Rune.DecodeFromUtf8(System.ReadOnlySpan{System.Byte},System.Text.Rune@,System.Int32@)>, except it allows the caller to loop backward instead of forward.</span></span> <span data-ttu-id="01189-269">å…¸å‹çš„è°ƒç”¨çº¦å®šæ˜¯ï¼Œåœ¨å¾ªç¯çš„æ¯æ¬¡è¿­ä»£æ—¶ï¼Œè°ƒç”¨æ–¹åº”åˆ‡åˆ†ç¼“å†²åŒºçš„æœ€åä¸€ä¸ª `bytesConsumed` å…ƒç´  `source` ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-269">The typical calling convention is that on each iteration of the loop, the caller should slice off the final `bytesConsumed` elements of the `source` buffer.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncodeToUtf16">
      <MemberSignature Language="C#" Value="public int EncodeToUtf16 (Span&lt;char&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EncodeToUtf16(valuetype System.Span`1&lt;char&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.EncodeToUtf16(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function EncodeToUtf16 (destination As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EncodeToUtf16(Span&lt;char&gt; destination);" />
      <MemberSignature Language="F#" Value="member this.EncodeToUtf16 : Span&lt;char&gt; -&gt; int" Usage="rune.EncodeToUtf16 destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="01189-270">å°†æ­¤å€¼ä½œä¸º UTF-16 å†™å…¥åˆ°çš„ç¼“å†²åŒºã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-270">The buffer to which to write this value as UTF-16.</span></span></param>
        <summary><span data-ttu-id="01189-271">å°†æ­¤ <see cref="T:System.Text.Rune" /> è§£ç ä¸º UTF-16 ç›®æ ‡ç¼“å†²åŒºã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-271">Encodes this <see cref="T:System.Text.Rune" /> to a UTF-16 destination buffer.</span></span></summary>
        <returns><span data-ttu-id="01189-272">å†™å…¥åˆ° <paramref name="destination" /> çš„ <see cref="T:System.Char" /> å€¼çš„æ•°ç›®ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-272">The number of <see cref="T:System.Char" /> values written to <paramref name="destination" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="01189-273"><paramref name="destination" /> çš„å¤§å°ä¸è¶³ä»¥ä¿å­˜è¾“å‡ºã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-273"><paramref name="destination" /> is not large enough to hold the output.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EncodeToUtf8">
      <MemberSignature Language="C#" Value="public int EncodeToUtf8 (Span&lt;byte&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EncodeToUtf8(valuetype System.Span`1&lt;unsigned int8&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.EncodeToUtf8(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function EncodeToUtf8 (destination As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EncodeToUtf8(Span&lt;System::Byte&gt; destination);" />
      <MemberSignature Language="F#" Value="member this.EncodeToUtf8 : Span&lt;byte&gt; -&gt; int" Usage="rune.EncodeToUtf8 destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="01189-274">å°†æ­¤å€¼ä½œä¸º UTF-8 å†™å…¥åˆ°çš„ç¼“å†²åŒºã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-274">The buffer to which to write this value as UTF-8.</span></span></param>
        <summary><span data-ttu-id="01189-275">å°†æ­¤ <see cref="T:System.Text.Rune" /> è§£ç ä¸º UTF-8 ç›®æ ‡ç¼“å†²åŒºã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-275">Encodes this <see cref="T:System.Text.Rune" /> to a UTF-8 destination buffer.</span></span></summary>
        <returns><span data-ttu-id="01189-276">å†™å…¥åˆ° <paramref name="destination" /> çš„ <see cref="T:System.Byte" /> å€¼çš„æ•°ç›®ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-276">The number of <see cref="T:System.Byte" /> values written to <paramref name="destination" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="01189-277"><paramref name="destination" /> çš„å¤§å°ä¸è¶³ä»¥ä¿å­˜è¾“å‡ºã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-277"><paramref name="destination" /> is not large enough to hold the output.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="rune.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="01189-278">è¦ä¸å½“å‰å®ä¾‹è¿›è¡Œæ¯”è¾ƒçš„å¯¹è±¡ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-278">The object to compare with the current instance.</span></span></param>
        <summary><span data-ttu-id="01189-279">è¿”å›ä¸€ä¸ªæŒ‡ç¤ºå½“å‰å®ä¾‹æ˜¯å¦ä¸æŒ‡å®šå¯¹è±¡ç›¸ç­‰çš„å€¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-279">Returns a value that indicates whether the current instance and a specified object are equal.</span></span></summary>
        <returns><span data-ttu-id="01189-280">å¦‚æœ <paramref name="obj" /> ä¸º <see cref="T:System.Text.Rune" /> ç±»å‹ï¼Œå¹¶ä¸”ç­‰äºå½“å‰çš„å®ä¾‹ï¼Œåˆ™ä¸º <see langword="true" />ï¼›å¦åˆ™ä¸º <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-280"><see langword="true" /> if <paramref name="obj" /> is of type <see cref="T:System.Text.Rune" /> and is equal to the current instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.Rune other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Text.Rune other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.Equals(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Text::Rune other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Text.Rune -&gt; bool" Usage="rune.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="01189-281">è¦ä¸å½“å‰å®ä¾‹è¿›è¡Œæ¯”è¾ƒçš„å¯¹è±¡ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-281">The object to compare with the current instance.</span></span></param>
        <summary><span data-ttu-id="01189-282">è¿”å›ä¸€ä¸ªå€¼ï¼Œè¯¥å€¼æŒ‡ç¤ºå½“å‰å®ä¾‹æ˜¯å¦ä¸æŒ‡å®šçš„ rune ç›¸ç­‰ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-282">Returns a value that indicates whether the current instance and a specified rune are equal.</span></span></summary>
        <returns><span data-ttu-id="01189-283">å¦‚æœå½“å‰å®ä¾‹ä¸ <paramref name="other" /> ç›¸ç­‰ï¼Œåˆ™ä¸º <see langword="true" />ï¼›å¦åˆ™ä¸º <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-283"><see langword="true" /> if the current instance and <paramref name="other" /> are equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="rune.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="01189-284">è¿”å›æ­¤å®ä¾‹çš„å“ˆå¸Œä»£ç ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-284">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="01189-285">æ­¤å®ä¾‹çš„å“ˆå¸Œä»£ç ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-285">The hash code for this instance.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNumericValue">
      <MemberSignature Language="C#" Value="public static double GetNumericValue (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetNumericValue(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.GetNumericValue(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNumericValue (value As Rune) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetNumericValue(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member GetNumericValue : System.Text.Rune -&gt; double" Usage="System.Text.Rune.GetNumericValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="01189-286">è¦è·å–å…¶æ•°å€¼çš„ runeã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-286">The rune for which to get the numeric value.</span></span></param>
        <summary><span data-ttu-id="01189-287">è·å–ä¸æŒ‡å®š rune å…³è”çš„æ•°å€¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-287">Gets the numeric value associated with the specified rune.</span></span></summary>
        <returns><span data-ttu-id="01189-288">ä¸ <paramref name="value" /> å…³è”çš„æ•°å€¼ï¼›å¦‚æœ <paramref name="value" /> ä¸è¡¨ç¤ºæ•°å­—å­—ç¬¦ï¼Œåˆ™ä¸º -1ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-288">The numeric value associated with <paramref name="value" />, or -1 if <paramref name="value" /> doesn't represent a numeric character.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="01189-289">æ­¤æ–¹æ³•çš„è¡Œä¸ºä¸ç­‰æ•ˆ <xref:System.Globalization.CharUnicodeInfo.GetNumericValue%2A?displayProperty=nameWithType> ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-289">This method has behavior equivalent to <xref:System.Globalization.CharUnicodeInfo.GetNumericValue%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="01189-290">æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…è¯¥æ–‡æ¡£ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-290">Refer to that documentation for more information.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRuneAt">
      <MemberSignature Language="C#" Value="public static System.Text.Rune GetRuneAt (string input, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.Rune GetRuneAt(string input, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.GetRuneAt(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRuneAt (input As String, index As Integer) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Rune GetRuneAt(System::String ^ input, int index);" />
      <MemberSignature Language="F#" Value="static member GetRuneAt : string * int -&gt; System.Text.Rune" Usage="System.Text.Rune.GetRuneAt (input, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input"><span data-ttu-id="01189-291">ä»ä¸­åˆ›å»º rune çš„å­—ç¬¦ä¸²ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-291">The string from which to create the rune.</span></span></param>
        <param name="index"><span data-ttu-id="01189-292">åœ¨ <paramref name="input" /> ä¸­åˆ›å»º rune çš„èµ·å§‹ä½ç½®ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-292">The starting position in <paramref name="input" /> at which to create the rune.</span></span></param>
        <summary><span data-ttu-id="01189-293">è·å–åœ¨å­—ç¬¦ä¸²ä¸­æŒ‡å®šä½ç½®å¼€å§‹çš„ <see cref="T:System.Text.Rune" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-293">Gets the <see cref="T:System.Text.Rune" /> that begins at a specified position in a string.</span></span></summary>
        <returns><span data-ttu-id="01189-294">ä» <paramref name="input" /> ä¸­çš„æŒ‡å®š <paramref name="index" /> å¤„è·å–çš„ runeã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-294">The rune obtained from <paramref name="input" /> at the specified <paramref name="index" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="01189-295">å¦‚æœ `input` ä¸º `null` ã€ `index` è¶…å‡ºèŒƒå›´æˆ– `index` æœªå¼•ç”¨ä¸­æœ‰æ•ˆæ ‡é‡å€¼çš„å¼€å¤´ï¼Œåˆ™ä¼šå¼•å‘å¼‚å¸¸ `input` ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-295">Throws an exception if `input` is `null`, `index` is out of range, or `index` does not reference the start of a valid scalar value within `input`.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="01189-296"><paramref name="input" /> ä¸º <see langword="null" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-296"><paramref name="input" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="01189-297"><paramref name="index" /> ä¸å¼•ç”¨ <paramref name="input" /> ä¸­æœ‰æ•ˆæ ‡é‡å€¼çš„å¼€å¤´ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-297"><paramref name="index" /> does not reference the start of a valid scalar value in <paramref name="input" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="01189-298"><paramref name="index" /> è¶…å‡ºäº† <paramref name="input" /> çš„èŒƒå›´ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-298"><paramref name="index" /> is outside the range of <paramref name="input" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetUnicodeCategory">
      <MemberSignature Language="C#" Value="public static System.Globalization.UnicodeCategory GetUnicodeCategory (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Globalization.UnicodeCategory GetUnicodeCategory(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUnicodeCategory (value As Rune) As UnicodeCategory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Globalization::UnicodeCategory GetUnicodeCategory(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member GetUnicodeCategory : System.Text.Rune -&gt; System.Globalization.UnicodeCategory" Usage="System.Text.Rune.GetUnicodeCategory value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.UnicodeCategory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="01189-299">è¦è·å–å…¶ Unicode ç±»åˆ«çš„ runeã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-299">The rune for which to get the Unicode category.</span></span></param>
        <summary><span data-ttu-id="01189-300">è·å–ä¸æŒ‡å®š rune å…³è”çš„ Unicode ç±»åˆ«ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-300">Gets the Unicode category associated with the specified rune.</span></span></summary>
        <returns><span data-ttu-id="01189-301">ä¸ <paramref name="value" /> å…³è”çš„ Unicode ç±»åˆ«ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-301">The Unicode category associated with <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="01189-302">æ­¤æ–¹æ³•çš„è¡Œä¸ºä¸ç­‰æ•ˆ <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-302">This method has behavior equivalent to <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="01189-303">æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…è¯¥æ–‡æ¡£ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-303">Refer to that documentation for more information.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAscii">
      <MemberSignature Language="C#" Value="public bool IsAscii { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAscii" />
      <MemberSignature Language="DocId" Value="P:System.Text.Rune.IsAscii" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAscii As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAscii { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAscii : bool" Usage="System.Text.Rune.IsAscii" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="01189-304">è·å–ä¸€ä¸ªå€¼ï¼Œè¯¥å€¼æŒ‡ç¤ºä¸æ­¤ <see cref="T:System.Text.Rune" /> å…³è”çš„æ ‡é‡å€¼æ˜¯å¦åœ¨ ASCII ç¼–ç èŒƒå›´å†…ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-304">Gets a value that indicates whether the scalar value associated with this <see cref="T:System.Text.Rune" /> is within the ASCII encoding range.</span></span></summary>
        <value><span data-ttu-id="01189-305"><see langword="true" /> å¦‚æœå…³è”çš„æ ‡é‡å€¼åœ¨ ASCII ç¼–ç èŒƒå›´å†… ( [U + 0000.. U + 007F] ) å¹¶å› æ­¤ç”±å•ä¸ª UTF-8 ä»£ç å•å…ƒè¡¨ç¤ºï¼Œåˆ™ä¸º;å¦åˆ™ä¸º <see langword="false" /> ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-305"><see langword="true" /> if the scalar value associated is within the ASCII encoding range ([ U+0000..U+007F ]) and therefore representable by a single UTF-8 code unit; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBmp">
      <MemberSignature Language="C#" Value="public bool IsBmp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBmp" />
      <MemberSignature Language="DocId" Value="P:System.Text.Rune.IsBmp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBmp As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBmp { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBmp : bool" Usage="System.Text.Rune.IsBmp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="01189-306">è·å–ä¸€ä¸ªå€¼ï¼Œè¯¥å€¼æŒ‡ç¤ºä¸æ­¤ <see cref="T:System.Text.Rune" /> å…³è”çš„æ ‡é‡å€¼æ˜¯å¦åœ¨ BMP ç¼–ç èŒƒå›´å†…ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-306">Gets a value that indicates whether the scalar value associated with this <see cref="T:System.Text.Rune" /> is within the BMP encoding range.</span></span></summary>
        <value><span data-ttu-id="01189-307"><see langword="true" /> å¦‚æœå…³è”çš„æ ‡é‡å€¼åœ¨ BMP ç¼–ç èŒƒå›´å†… ( [U + 0000. U + FFFF] ) å¹¶å› æ­¤ç”±å•ä¸ª UTF-16 ä»£ç å•å…ƒè¡¨ç¤ºï¼Œåˆ™ä¸º;å¦åˆ™ä¸º <see langword="false" /> ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-307"><see langword="true" /> if the scalar value associated is within the BMP encoding range ([ U+0000..U+FFFF ]) and therefore representable by a single UTF-16 code unit; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsControl">
      <MemberSignature Language="C#" Value="public static bool IsControl (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsControl(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsControl(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsControl (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsControl(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsControl : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsControl value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="01189-308">è¦è®¡ç®—çš„ runeã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-308">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="01189-309">è¿”å›ä¸€ä¸ªå€¼ï¼Œè¯¥å€¼æŒ‡ç¤ºæŒ‡å®šçš„ rune æ˜¯å¦å±äºæ§åˆ¶å­—ç¬¦ç±»åˆ«ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-309">Returns a value that indicates whether the specified rune is categorized as a control character.</span></span></summary>
        <returns><span data-ttu-id="01189-310">å¦‚æœ <see langword="true" /> æ˜¯æ§åˆ¶å­—ç¬¦ï¼Œåˆ™ä¸º <paramref name="value" />ï¼›å¦åˆ™ä¸º <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-310"><see langword="true" /> if <paramref name="value" /> is a control character; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="01189-311">æ­¤æ–¹æ³•ç­‰æ•ˆäºå¯¹ç»“æœè¿›è¡ŒæŸ¥è¯¢ <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> å’Œæ¯”è¾ƒ <xref:System.Globalization.UnicodeCategory.Control> ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-311">This method is equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against <xref:System.Globalization.UnicodeCategory.Control>.</span></span>

<span data-ttu-id="01189-312">æ ¹æ® [Unicode ç¨³å®šæ€§ç­–ç•¥](https://www.unicode.org/policies/stability_policy.html)ï¼Œæ§åˆ¶å­—ç¬¦é›†æ°¸ä¹…å›ºå®šä¸ºå’Œçš„è”åˆ `[ U+0000..U+001F ]` `[ U+007F..U+009F ]` ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-312">Per [Unicode stability policies](https://www.unicode.org/policies/stability_policy.html), the set of control characters is permanently fixed to be the union of `[ U+0000..U+001F ]` and `[ U+007F..U+009F ]`.</span></span>

<span data-ttu-id="01189-313">æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜… <xref:System.Char.IsControl%2A?displayProperty=nameWithType>ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-313">For more information, see <xref:System.Char.IsControl%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDigit">
      <MemberSignature Language="C#" Value="public static bool IsDigit (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDigit(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsDigit(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDigit (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDigit(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsDigit : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsDigit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="01189-314">è¦è®¡ç®—çš„ runeã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-314">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="01189-315">è¿”å›ä¸€ä¸ªå€¼ï¼Œè¯¥å€¼æŒ‡ç¤ºæŒ‡å®šçš„ rune æ˜¯å¦å±äºåè¿›åˆ¶æ•°å­—ç±»åˆ«ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-315">Returns a value that indicates whether the specified rune is categorized as a decimal digit.</span></span></summary>
        <returns><span data-ttu-id="01189-316">å¦‚æœ <see langword="true" /> æ˜¯åè¿›åˆ¶æ•°ï¼Œåˆ™ä¸º <paramref name="value" />ï¼›å¦åˆ™ä¸º <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-316"><see langword="true" /> if <paramref name="value" /> is a decimal digit; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="01189-317">æ­¤æ–¹æ³•ç­‰æ•ˆäºå¯¹ç»“æœè¿›è¡ŒæŸ¥è¯¢ <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> å’Œæ¯”è¾ƒ <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber> ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-317">This method is equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber>.</span></span>

<span data-ttu-id="01189-318">æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜… <xref:System.Char.IsDigit%2A?displayProperty=nameWithType>ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-318">For more information, see <xref:System.Char.IsDigit%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLetter">
      <MemberSignature Language="C#" Value="public static bool IsLetter (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetter(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsLetter(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetter (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetter(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsLetter : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsLetter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="01189-319">è¦è®¡ç®—çš„ runeã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-319">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="01189-320">è¿”å›ä¸€ä¸ªå€¼ï¼Œè¯¥å€¼æŒ‡ç¤ºæŒ‡å®šçš„ rune æ˜¯å¦å±äºå­—æ¯ç±»åˆ«ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-320">Returns a value that indicates whether the specified rune is categorized as a letter.</span></span></summary>
        <returns><span data-ttu-id="01189-321">å¦‚æœ <see langword="true" /> æ˜¯ä¸€ä¸ªå­—æ¯ï¼Œåˆ™ä¸º <paramref name="value" />ï¼›å¦åˆ™ä¸º <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-321"><see langword="true" /> if <paramref name="value" /> is a letter; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="01189-322">æ­¤æ–¹æ³•ç­‰æ•ˆäºå¯¹ <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> ä»»ä½•å€¼ <xref:System.Globalization.UnicodeCategory.UppercaseLetter> ï¼ˆ <xref:System.Globalization.UnicodeCategory.LowercaseLetter> ã€ <xref:System.Globalization.UnicodeCategory.TitlecaseLetter> ã€ <xref:System.Globalization.UnicodeCategory.ModifierLetter> å’Œï¼‰è¿›è¡ŒæŸ¥è¯¢å’Œæ¯”è¾ƒ <xref:System.Globalization.UnicodeCategory.OtherLetter> ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-322">This method is equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against any of the values <xref:System.Globalization.UnicodeCategory.UppercaseLetter>, <xref:System.Globalization.UnicodeCategory.LowercaseLetter>, <xref:System.Globalization.UnicodeCategory.TitlecaseLetter>, <xref:System.Globalization.UnicodeCategory.ModifierLetter>, and <xref:System.Globalization.UnicodeCategory.OtherLetter>.</span></span>

<span data-ttu-id="01189-323">æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜… <xref:System.Char.IsLetter%2A?displayProperty=nameWithType>ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-323">For more information, see <xref:System.Char.IsLetter%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLetterOrDigit">
      <MemberSignature Language="C#" Value="public static bool IsLetterOrDigit (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetterOrDigit(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsLetterOrDigit(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetterOrDigit (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetterOrDigit(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsLetterOrDigit : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsLetterOrDigit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="01189-324">è¦è®¡ç®—çš„ runeã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-324">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="01189-325">è¿”å›ä¸€ä¸ªå€¼ï¼Œè¯¥å€¼æŒ‡ç¤ºæŒ‡å®šçš„ rune å±äºå­—æ¯ç±»åˆ«è¿˜æ˜¯åè¿›åˆ¶æ•°å­—ç±»åˆ«ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-325">Returns a value that indicates whether the specified rune is categorized as a letter or a decimal digit.</span></span></summary>
        <returns><span data-ttu-id="01189-326">å¦‚æœ <see langword="true" /> æ˜¯å­—æ¯æˆ–åè¿›åˆ¶æ•°ï¼Œåˆ™ä¸º <paramref name="value" />ï¼›å¦åˆ™ä¸º <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-326"><see langword="true" /> if <paramref name="value" /> is a letter or a decimal digit; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="01189-327">æ­¤æ–¹æ³•ç­‰æ•ˆäºå¯¹ <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> ä»»ä½•å€¼ <xref:System.Globalization.UnicodeCategory.UppercaseLetter> ï¼ˆ <xref:System.Globalization.UnicodeCategory.LowercaseLetter> ã€ <xref:System.Globalization.UnicodeCategory.TitlecaseLetter> ã€ã€ <xref:System.Globalization.UnicodeCategory.ModifierLetter> <xref:System.Globalization.UnicodeCategory.OtherLetter> å’Œ <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber> ï¼‰è¿›è¡ŒæŸ¥è¯¢å’Œæ¯”è¾ƒã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-327">This method is equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against any of the values <xref:System.Globalization.UnicodeCategory.UppercaseLetter>, <xref:System.Globalization.UnicodeCategory.LowercaseLetter>, <xref:System.Globalization.UnicodeCategory.TitlecaseLetter>, <xref:System.Globalization.UnicodeCategory.ModifierLetter>, <xref:System.Globalization.UnicodeCategory.OtherLetter>, and <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber>.</span></span>

<span data-ttu-id="01189-328">æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜… <xref:System.Char.IsLetterOrDigit%2A?displayProperty=nameWithType>ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-328">For more information, see <xref:System.Char.IsLetterOrDigit%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLower">
      <MemberSignature Language="C#" Value="public static bool IsLower (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLower(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsLower(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLower (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLower(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsLower : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsLower value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="01189-329">è¦è®¡ç®—çš„ runeã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-329">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="01189-330">è¿”å›ä¸€ä¸ªå€¼ï¼Œè¯¥å€¼æŒ‡ç¤ºæŒ‡å®šçš„ rune æ˜¯å¦å±äºå°å†™å­—æ¯ç±»åˆ«ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-330">Returns a value that indicates whether the specified rune is categorized as a lowercase letter.</span></span></summary>
        <returns><span data-ttu-id="01189-331">å¦‚æœ <see langword="true" /> æ˜¯ä¸€ä¸ªå°å†™å­—æ¯ï¼Œåˆ™ä¸º <paramref name="value" />ï¼›å¦åˆ™ä¸º <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-331"><see langword="true" /> if <paramref name="value" /> is a lowercase letter; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="01189-332">æ­¤æ–¹æ³•ç­‰æ•ˆäºå¯¹ç»“æœè¿›è¡ŒæŸ¥è¯¢ <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> å’Œæ¯”è¾ƒ <xref:System.Globalization.UnicodeCategory.LowercaseLetter> ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-332">This method is equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against <xref:System.Globalization.UnicodeCategory.LowercaseLetter>.</span></span>

<span data-ttu-id="01189-333">æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜… <xref:System.Char.IsLower%2A?displayProperty=nameWithType>ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-333">For more information, see <xref:System.Char.IsLower%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNumber">
      <MemberSignature Language="C#" Value="public static bool IsNumber (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNumber(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsNumber(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNumber (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNumber(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsNumber : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsNumber value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="01189-334">è¦è®¡ç®—çš„ runeã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-334">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="01189-335">è¿”å›ä¸€ä¸ªå€¼ï¼Œè¯¥å€¼æŒ‡ç¤ºæŒ‡å®šçš„ rune æ˜¯å¦å±äºæ•°å­—ç±»åˆ«ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-335">Returns a value that indicates whether the specified rune is categorized as a number.</span></span></summary>
        <returns><span data-ttu-id="01189-336">å¦‚æœ <see langword="true" /> æ˜¯ä¸€ä¸ªæ•°å­—ï¼Œåˆ™ä¸º <paramref name="value" />ï¼›å¦åˆ™ä¸º <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-336"><see langword="true" /> if <paramref name="value" /> is a number; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="01189-337">æ­¤æ–¹æ³•ç­‰æ•ˆäºæŸ¥è¯¢ <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> ç»“æœå¹¶å°†å…¶ä¸ä»»ä½•å€¼ <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber> ã€å’Œè¿›è¡Œæ¯”è¾ƒ <xref:System.Globalization.UnicodeCategory.LetterNumber> <xref:System.Globalization.UnicodeCategory.OtherNumber> ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-337">This method is equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against any of the values <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber>, <xref:System.Globalization.UnicodeCategory.LetterNumber>, and <xref:System.Globalization.UnicodeCategory.OtherNumber>.</span></span>

<span data-ttu-id="01189-338">æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜… <xref:System.Char.IsNumber%2A?displayProperty=nameWithType>ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-338">For more information, see <xref:System.Char.IsNumber%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPunctuation">
      <MemberSignature Language="C#" Value="public static bool IsPunctuation (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPunctuation(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsPunctuation(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPunctuation (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPunctuation(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsPunctuation : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsPunctuation value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="01189-339">è¦è®¡ç®—çš„ runeã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-339">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="01189-340">è¿”å›ä¸€ä¸ªå€¼ï¼Œè¯¥å€¼æŒ‡ç¤ºæŒ‡å®šçš„ rune æ˜¯å¦å±äºæ ‡ç‚¹ç¬¦å·ç±»åˆ«ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-340">Returns a value that indicates whether the specified rune is categorized as a punctuation mark.</span></span></summary>
        <returns><span data-ttu-id="01189-341">å¦‚æœ <see langword="true" /> æ˜¯ä¸€ä¸ªæ ‡ç‚¹ç¬¦å·ï¼Œåˆ™ä¸º <paramref name="value" />ï¼›å¦åˆ™ä¸º <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-341"><see langword="true" /> if <paramref name="value" /> is a punctuation mark; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="01189-342">æ­¤æ–¹æ³•ç­‰æ•ˆäºå¯¹ <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> ä»»ä½•å€¼ <xref:System.Globalization.UnicodeCategory.ConnectorPunctuation> ï¼ˆ <xref:System.Globalization.UnicodeCategory.DashPunctuation> ã€ã€ã€ã€ <xref:System.Globalization.UnicodeCategory.OpenPunctuation> <xref:System.Globalization.UnicodeCategory.ClosePunctuation> <xref:System.Globalization.UnicodeCategory.InitialQuotePunctuation> <xref:System.Globalization.UnicodeCategory.FinalQuotePunctuation> å’Œ <xref:System.Globalization.UnicodeCategory.OtherPunctuation> ï¼‰è¿›è¡ŒæŸ¥è¯¢å’Œæ¯”è¾ƒã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-342">This method is equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against any of the values <xref:System.Globalization.UnicodeCategory.ConnectorPunctuation>, <xref:System.Globalization.UnicodeCategory.DashPunctuation>, <xref:System.Globalization.UnicodeCategory.OpenPunctuation>, <xref:System.Globalization.UnicodeCategory.ClosePunctuation>, <xref:System.Globalization.UnicodeCategory.InitialQuotePunctuation>, <xref:System.Globalization.UnicodeCategory.FinalQuotePunctuation>, and <xref:System.Globalization.UnicodeCategory.OtherPunctuation>.</span></span>

<span data-ttu-id="01189-343">æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜… <xref:System.Char.IsPunctuation%2A?displayProperty=nameWithType>ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-343">For more information, see <xref:System.Char.IsPunctuation%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSeparator">
      <MemberSignature Language="C#" Value="public static bool IsSeparator (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSeparator(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsSeparator(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSeparator (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSeparator(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsSeparator : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsSeparator value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="01189-344">è¦è®¡ç®—çš„ runeã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-344">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="01189-345">è¿”å›ä¸€ä¸ªå€¼ï¼Œè¯¥å€¼æŒ‡ç¤ºæŒ‡å®šçš„ rune æ˜¯å¦å±äºåˆ†éš”ç¬¦ç±»åˆ«ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-345">Returns a value that indicates whether the specified rune is categorized as a separator character.</span></span></summary>
        <returns><span data-ttu-id="01189-346">å¦‚æœ <see langword="true" /> æ˜¯åˆ†éš”ç¬¦ï¼Œåˆ™ä¸º <paramref name="value" />ï¼›å¦åˆ™ä¸º <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-346"><see langword="true" /> if <paramref name="value" /> is a separator character; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="01189-347">æ­¤æ–¹æ³•ç­‰æ•ˆäºæŸ¥è¯¢ <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> ç»“æœå¹¶å°†å…¶ä¸ä»»ä½•å€¼ <xref:System.Globalization.UnicodeCategory.SpaceSeparator> ã€å’Œè¿›è¡Œæ¯”è¾ƒ <xref:System.Globalization.UnicodeCategory.LineSeparator> <xref:System.Globalization.UnicodeCategory.ParagraphSeparator> ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-347">This method is equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against any of the values <xref:System.Globalization.UnicodeCategory.SpaceSeparator>, <xref:System.Globalization.UnicodeCategory.LineSeparator>, and <xref:System.Globalization.UnicodeCategory.ParagraphSeparator>.</span></span>

<span data-ttu-id="01189-348">æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜… <xref:System.Char.IsSeparator%2A?displayProperty=nameWithType>ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-348">For more information, see <xref:System.Char.IsSeparator%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSymbol">
      <MemberSignature Language="C#" Value="public static bool IsSymbol (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSymbol(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsSymbol(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSymbol (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSymbol(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsSymbol : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsSymbol value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="01189-349">è¦è®¡ç®—çš„ runeã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-349">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="01189-350">è¿”å›ä¸€ä¸ªå€¼ï¼Œè¯¥å€¼æŒ‡ç¤ºæŒ‡å®šçš„ rune æ˜¯å¦å±äºç¬¦å·å­—ç¬¦ç±»åˆ«ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-350">Returns a value that indicates whether the specified rune is categorized as a symbol character.</span></span></summary>
        <returns><span data-ttu-id="01189-351">å¦‚æœ <see langword="true" /> æ˜¯ç¬¦å·å­—ç¬¦ï¼Œåˆ™ä¸º <paramref name="value" />ï¼›å¦åˆ™ä¸º <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-351"><see langword="true" /> if <paramref name="value" /> is a symbol character; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="01189-352">æ­¤æ–¹æ³•ç­‰æ•ˆäºå¯¹ <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> ä»»ä½•å€¼ <xref:System.Globalization.UnicodeCategory.MathSymbol> ï¼ˆã€å’Œï¼‰è¿›è¡ŒæŸ¥è¯¢å’Œæ¯”è¾ƒ <xref:System.Globalization.UnicodeCategory.CurrencySymbol> <xref:System.Globalization.UnicodeCategory.ModifierSymbol> <xref:System.Globalization.UnicodeCategory.OtherSymbol> ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-352">This method is equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against any of the values <xref:System.Globalization.UnicodeCategory.MathSymbol>, <xref:System.Globalization.UnicodeCategory.CurrencySymbol>, <xref:System.Globalization.UnicodeCategory.ModifierSymbol>, and <xref:System.Globalization.UnicodeCategory.OtherSymbol>.</span></span>

<span data-ttu-id="01189-353">æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜… <xref:System.Char.IsSymbol%2A?displayProperty=nameWithType>ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-353">For more information, see <xref:System.Char.IsSymbol%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpper">
      <MemberSignature Language="C#" Value="public static bool IsUpper (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsUpper(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsUpper(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsUpper (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsUpper(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsUpper : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsUpper value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="01189-354">è¦è®¡ç®—çš„ runeã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-354">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="01189-355">è¿”å›ä¸€ä¸ªå€¼ï¼Œè¯¥å€¼æŒ‡ç¤ºæŒ‡å®šçš„ rune æ˜¯å¦å±äºå¤§å†™å­—æ¯ç±»åˆ«ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-355">Returns a value that indicates whether the specified rune is categorized as an uppercase letter.</span></span></summary>
        <returns><span data-ttu-id="01189-356">å¦‚æœ <paramref name="value" /> æ˜¯ä¸€ä¸ªå¤§å†™å­—æ¯ï¼Œåˆ™ä¸º <see langword="true" />ï¼›å¦åˆ™ä¸º <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-356"><see langword="true" /> if <paramref name="value" /> is an uppercase letter; otherwise,<see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="01189-357">æ­¤æ–¹æ³•ç­‰æ•ˆäºå¯¹ç»“æœè¿›è¡ŒæŸ¥è¯¢ <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> å’Œæ¯”è¾ƒ <xref:System.Globalization.UnicodeCategory.UppercaseLetter> ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-357">This method is equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against <xref:System.Globalization.UnicodeCategory.UppercaseLetter>.</span></span>

<span data-ttu-id="01189-358">æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜… <xref:System.Char.IsUpper%2A?displayProperty=nameWithType>ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-358">For more information, see <xref:System.Char.IsUpper%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValid">
      <MemberSignature Language="C#" Value="public static bool IsValid (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsValid(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsValid(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsValid (value As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsValid(int value);" />
      <MemberSignature Language="F#" Value="static member IsValid : int -&gt; bool" Usage="System.Text.Rune.IsValid value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="01189-359">Unicode æ ‡é‡å€¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-359">The Unicode scalar value.</span></span></param>
        <summary><span data-ttu-id="01189-360">è¿”å›ä¸€ä¸ªå€¼ï¼Œè¯¥å€¼æŒ‡ç¤º 32 ä½å¸¦ç¬¦å·æ•´æ•°æ˜¯å¦è¡¨ç¤ºæœ‰æ•ˆçš„ Unicode æ ‡é‡å€¼ï¼›å³å®ƒåœ¨ [ U+0000..U+D7FF ]ï¼ˆå«é¦–å°¾å€¼ï¼‰æˆ– [ U+E000..U+10FFFF ]ï¼ˆå«é¦–å°¾å€¼ï¼‰èŒƒå›´å†…ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-360">Returns a value that indicates whether a 32-bit signed integer represents a valid Unicode scalar value; that is, it is in the range [ U+0000..U+D7FF ], inclusive; or [ U+E000..U+10FFFF ], inclusive.</span></span></summary>
        <returns><span data-ttu-id="01189-361">å¦‚æœ <paramref name="value" /> æ˜¯æœ‰æ•ˆçš„ Unicode æ ‡é‡å€¼ï¼Œåˆ™ä¸º <see langword="true" />ï¼›å¦åˆ™ä¸º <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-361"><see langword="true" /> if <paramref name="value" /> is a valid Unicode scalar value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValid">
      <MemberSignature Language="C#" Value="public static bool IsValid (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsValid(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsValid(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsValid (value As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsValid(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member IsValid : uint32 -&gt; bool" Usage="System.Text.Rune.IsValid value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="01189-362">Unicode æ ‡é‡å€¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-362">The Unicode scalar value.</span></span></param>
        <summary><span data-ttu-id="01189-363">è¿”å›ä¸€ä¸ªå€¼ï¼Œè¯¥å€¼æŒ‡ç¤º 32 ä½æ— ç¬¦å·æ•´æ•°æ˜¯å¦è¡¨ç¤ºæœ‰æ•ˆçš„ Unicode æ ‡é‡å€¼ï¼›å³å®ƒåœ¨ [ U+0000..U+D7FF ]ï¼ˆå«é¦–å°¾å€¼ï¼‰æˆ– [ U+E000..U+10FFFF ]ï¼ˆå«é¦–å°¾å€¼ï¼‰èŒƒå›´å†…ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-363">Returns a value that indicates whether a 32-bit unsigned integer represents a valid Unicode scalar value; that is, it is in the range [ U+0000..U+D7FF ], inclusive, or [ U+E000..U+10FFFF ], inclusive.</span></span></summary>
        <returns><span data-ttu-id="01189-364">å¦‚æœ <paramref name="value" /> æ˜¯æœ‰æ•ˆçš„ Unicode æ ‡é‡å€¼ï¼Œåˆ™ä¸º <see langword="true" />ï¼›å¦åˆ™ä¸º <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-364"><see langword="true" /> if <paramref name="value" /> is a valid Unicode scalar value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsWhiteSpace (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWhiteSpace(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsWhiteSpace(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsWhiteSpace (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsWhiteSpace(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsWhiteSpace : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsWhiteSpace value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="01189-365">è¦è®¡ç®—çš„ runeã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-365">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="01189-366">è¿”å›ä¸€ä¸ªå€¼ï¼Œè¯¥å€¼æŒ‡ç¤ºæŒ‡å®šçš„ rune æ˜¯å¦å±äºç©ºæ ¼å­—ç¬¦ç±»åˆ«ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-366">Returns a value that indicates whether the specified rune is categorized as a white space character.</span></span></summary>
        <returns><span data-ttu-id="01189-367">å¦‚æœ <paramref name="value" /> æ˜¯ä¸€ä¸ªç©ºæ ¼å­—ç¬¦ï¼Œåˆ™ä¸º <see langword="true" />ï¼›å¦åˆ™ä¸º <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-367"><see langword="true" /> if <paramref name="value" /> is a white space character; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="01189-368">æ­¤æ–¹æ³•é€šå¸¸ç­‰æ•ˆäºæŸ¥è¯¢ <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> ç»“æœå¹¶å°†å…¶ä¸ä»»ä½•å€¼ <xref:System.Globalization.UnicodeCategory.SpaceSeparator> ã€å’Œè¿›è¡Œæ¯”è¾ƒ <xref:System.Globalization.UnicodeCategory.LineSeparator> <xref:System.Globalization.UnicodeCategory.ParagraphSeparator> ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-368">This method is generally equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against any of the values <xref:System.Globalization.UnicodeCategory.SpaceSeparator>, <xref:System.Globalization.UnicodeCategory.LineSeparator>, and <xref:System.Globalization.UnicodeCategory.ParagraphSeparator>.</span></span> <span data-ttu-id="01189-369">ä½†æ˜¯ï¼Œ <xref:System.Text.Rune> åœ¨ç±»åˆ«ä¸­æœ‰ä¸€äº› <xref:System.Globalization.UnicodeCategory.Control> ä¹Ÿå½’ç±»ä¸ºç©ºç™½å­—ç¬¦ï¼Œæ­¤æ–¹æ³•ä¼šå¯¹è¿™äº›å€¼è¿›è¡Œè¯´æ˜ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-369">However, there are some <xref:System.Text.Rune>s in the <xref:System.Globalization.UnicodeCategory.Control> category which are also classified as white space characters, and this method accounts for those values.</span></span>

<span data-ttu-id="01189-370">æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜… <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-370">For more information, see <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Text.Rune left, System.Text.Rune right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Text.Rune left, valuetype System.Text.Rune right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_Equality(System.Text.Rune,System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Rune, right As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Text::Rune left, System::Text::Rune right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Text.Rune * System.Text.Rune -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Text.Rune" />
        <Parameter Name="right" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="01189-371">è¦æ¯”è¾ƒçš„ç¬¬ä¸€ä¸ªå€¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-371">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="01189-372">è¦æ¯”è¾ƒçš„ç¬¬äºŒä¸ªå€¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-372">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="01189-373">è¿”å›ä¸€ä¸ªå€¼ï¼Œè¯¥å€¼æŒ‡ç¤ºä¸¤ä¸ª <see cref="T:System.Text.Rune" /> å®ä¾‹æ˜¯å¦ç›¸ç­‰ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-373">Returns a value that indicates whether two <see cref="T:System.Text.Rune" /> instances are equal.</span></span></summary>
        <returns><span data-ttu-id="01189-374">å¦‚æœ <paramref name="left" /> å’Œ <paramref name="right" /> ç›¸ç­‰ï¼Œåˆ™ä¸º <see langword="true" />ï¼›å¦åˆ™ä¸º <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-374"><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Text.Rune (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Text.Rune op_Explicit(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_Explicit(System.Char)~System.Text.Rune" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (ch As Char) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Text::Rune(char ch);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : char -&gt; System.Text.Rune" Usage="System.Text.Rune.op_Explicit ch" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch"><span data-ttu-id="01189-375">è¦è½¬æ¢çš„ 16 ä½ Unicode å­—ç¬¦ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-375">The 16-bit Unicode character to convert.</span></span></param>
        <summary><span data-ttu-id="01189-376">å®šä¹‰ä» 16 ä½ Unicode å­—ç¬¦åˆ° <see cref="T:System.Text.Rune" /> çš„æ˜¾å¼è½¬æ¢ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-376">Defines an explicit conversion of a 16-bit Unicode character to a <see cref="T:System.Text.Rune" />.</span></span></summary>
        <returns><span data-ttu-id="01189-377">32 ä½ Unicode å­—ç¬¦å½¢å¼çš„ <paramref name="ch" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-377"><paramref name="ch" /> as a 32-bit Unicode character.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="01189-378"><paramref name="ch" /> æ˜¯è¡¨ç¤ºä»£ç†ç ä½çš„ Unicode æ ‡é‡ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-378"><paramref name="ch" /> is a Unicode scalar that represents a surrogate code point.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Text.Rune (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Text.Rune op_Explicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_Explicit(System.Int32)~System.Text.Rune" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Integer) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Text::Rune(int value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : int -&gt; System.Text.Rune" Usage="System.Text.Rune.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="01189-379">è¦è½¬æ¢çš„ 32 ä½å¸¦ç¬¦å·æ•´æ•°ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-379">The 32-bit signed integer to convert.</span></span></param>
        <summary><span data-ttu-id="01189-380">å®šä¹‰ä» 32 ä½å¸¦ç¬¦å·æ•´æ•°åˆ° <see cref="T:System.Text.Rune" /> çš„æ˜¾å¼è½¬æ¢ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-380">Defines an explicit conversion of a 32-bit signed integer to a <see cref="T:System.Text.Rune" />.</span></span></summary>
        <returns><span data-ttu-id="01189-381">32 ä½ Unicode å­—ç¬¦å½¢å¼çš„ <paramref name="value" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-381"><paramref name="value" /> as a 32-bit Unicode character.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="01189-382"><paramref name="value" /> æ˜¯æ— æ•ˆçš„ Unicode æ ‡é‡ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-382"><paramref name="value" /> is an invalid Unicode scalar.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Text.Rune (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Text.Rune op_Explicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_Explicit(System.UInt32)~System.Text.Rune" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As UInteger) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Text::Rune(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : uint32 -&gt; System.Text.Rune" Usage="System.Text.Rune.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="01189-383">è¦è½¬æ¢çš„ 32 ä½å¸¦ç¬¦å·æ•´æ•°ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-383">The 32-bit signed integer to convert.</span></span></param>
        <summary><span data-ttu-id="01189-384">å®šä¹‰ä» 32 ä½æ— ç¬¦å·æ•´æ•°åˆ° <see cref="T:System.Text.Rune" /> çš„æ˜¾å¼è½¬æ¢ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-384">Defines an explicit conversion of a 32-bit unsigned integer to a <see cref="T:System.Text.Rune" />.</span></span></summary>
        <returns><span data-ttu-id="01189-385">32 ä½ Unicode å­—ç¬¦å½¢å¼çš„ <paramref name="value" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-385"><paramref name="value" /> as a 32-bit Unicode character.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="01189-386"><paramref name="value" /> æ˜¯æ— æ•ˆçš„ Unicode æ ‡é‡ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-386"><paramref name="value" /> is an invalid Unicode scalar.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Text.Rune left, System.Text.Rune right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Text.Rune left, valuetype System.Text.Rune right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_GreaterThan(System.Text.Rune,System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Rune, right As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Text::Rune left, System::Text::Rune right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Text.Rune * System.Text.Rune -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Text.Rune" />
        <Parameter Name="right" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="01189-387">è¦æ¯”è¾ƒçš„ç¬¬ä¸€ä¸ªå€¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-387">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="01189-388">è¦æ¯”è¾ƒçš„ç¬¬äºŒä¸ªå€¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-388">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="01189-389">è¿”å›ä¸€ä¸ªå€¼ï¼Œè¯¥å€¼æŒ‡ç¤ºæŒ‡å®šçš„ <see cref="T:System.Text.Rune" /> æ˜¯å¦å¤§äºå¦ä¸€ä¸ªæŒ‡å®šçš„ <see cref="T:System.Text.Rune" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-389">Returns a value indicating whether a specified <see cref="T:System.Text.Rune" /> is greater than another specified <see cref="T:System.Text.Rune" />.</span></span></summary>
        <returns><span data-ttu-id="01189-390">å¦‚æœ <see langword="true" /> å¤§äº <paramref name="left" />ï¼Œåˆ™ä¸º <paramref name="right" />ï¼›å¦åˆ™ä¸º <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-390"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Text.Rune left, System.Text.Rune right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Text.Rune left, valuetype System.Text.Rune right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_GreaterThanOrEqual(System.Text.Rune,System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Rune, right As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Text::Rune left, System::Text::Rune right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Text.Rune * System.Text.Rune -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Text.Rune" />
        <Parameter Name="right" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="01189-391">è¦æ¯”è¾ƒçš„ç¬¬ä¸€ä¸ªå€¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-391">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="01189-392">è¦æ¯”è¾ƒçš„ç¬¬äºŒä¸ªå€¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-392">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="01189-393">è¿”å›ä¸€ä¸ªå€¼ï¼Œè¯¥å€¼æŒ‡ç¤ºæŒ‡å®šçš„ <see cref="T:System.Text.Rune" /> æ˜¯å¦å¤§äºç­‰äºå¦ä¸€ä¸ªæŒ‡å®šçš„ <see cref="T:System.Text.Rune" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-393">Returns a value indicating whether a specified <see cref="T:System.Text.Rune" /> is greater than or equal to another specified <see cref="T:System.Text.Rune" />.</span></span></summary>
        <returns><span data-ttu-id="01189-394">å¦‚æœ <paramref name="left" /> å¤§äºç­‰äº <paramref name="right" />ï¼Œåˆ™ä¸º <see langword="true" />ï¼›å¦åˆ™ä¸º <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-394"><see langword="true" /> if <paramref name="left" /> is greater than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Text.Rune left, System.Text.Rune right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Text.Rune left, valuetype System.Text.Rune right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_Inequality(System.Text.Rune,System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Rune, right As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Text::Rune left, System::Text::Rune right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Text.Rune * System.Text.Rune -&gt; bool" Usage="System.Text.Rune.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Text.Rune" />
        <Parameter Name="right" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="01189-395">è¦æ¯”è¾ƒçš„ç¬¬ä¸€ä¸ªå€¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-395">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="01189-396">è¦æ¯”è¾ƒçš„ç¬¬äºŒä¸ªå€¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-396">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="01189-397">è¿”å›ä¸€ä¸ªå€¼ï¼Œè¯¥å€¼æŒ‡ç¤ºä¸¤ä¸ª <see cref="T:System.Text.Rune" /> å®ä¾‹æ˜¯å¦å…·æœ‰ä¸åŒçš„å€¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-397">Returns a value that indicates whether two <see cref="T:System.Text.Rune" /> instances have different values.</span></span></summary>
        <returns><span data-ttu-id="01189-398">å¦‚æœ <paramref name="left" /> å’Œ <paramref name="right" /> ä¸ç›¸ç­‰ï¼Œåˆ™ä¸º <see langword="true" />ï¼›å¦åˆ™ä¸º <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-398"><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Text.Rune left, System.Text.Rune right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Text.Rune left, valuetype System.Text.Rune right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_LessThan(System.Text.Rune,System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Rune, right As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Text::Rune left, System::Text::Rune right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Text.Rune * System.Text.Rune -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Text.Rune" />
        <Parameter Name="right" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="01189-399">è¦æ¯”è¾ƒçš„ç¬¬ä¸€ä¸ªå€¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-399">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="01189-400">è¦æ¯”è¾ƒçš„ç¬¬äºŒä¸ªå€¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-400">the second value to compare.</span></span></param>
        <summary><span data-ttu-id="01189-401">è¿”å›ä¸€ä¸ªå€¼ï¼Œè¯¥å€¼æŒ‡ç¤ºæŒ‡å®šçš„ <see cref="T:System.Text.Rune" /> æ˜¯å¦å°äºå¦ä¸€ä¸ªæŒ‡å®šçš„ <see cref="T:System.Text.Rune" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-401">Returns a value indicating whether a specified <see cref="T:System.Text.Rune" /> is less than another specified <see cref="T:System.Text.Rune" />.</span></span></summary>
        <returns><span data-ttu-id="01189-402">å¦‚æœ <paramref name="left" /> å°äº <paramref name="right" />ï¼Œåˆ™ä¸º <see langword="true" />ï¼›å¦åˆ™ä¸º <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-402"><see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Text.Rune left, System.Text.Rune right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Text.Rune left, valuetype System.Text.Rune right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_LessThanOrEqual(System.Text.Rune,System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Rune, right As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Text::Rune left, System::Text::Rune right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Text.Rune * System.Text.Rune -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Text.Rune" />
        <Parameter Name="right" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="01189-403">è¦æ¯”è¾ƒçš„ç¬¬ä¸€ä¸ªå€¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-403">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="01189-404">è¦æ¯”è¾ƒçš„ç¬¬äºŒä¸ªå€¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-404">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="01189-405">è¿”å›ä¸€ä¸ªå€¼ï¼Œè¯¥å€¼æŒ‡ç¤ºæŒ‡å®šçš„ <see cref="T:System.Text.Rune" /> æ˜¯å°äºè¿˜æ˜¯ç­‰äºå¦ä¸€ä¸ªæŒ‡å®šçš„ <see cref="T:System.Text.Rune" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-405">Returns a value indicating whether a specified <see cref="T:System.Text.Rune" /> is less than or equal to another specified <see cref="T:System.Text.Rune" />.</span></span></summary>
        <returns><span data-ttu-id="01189-406">å¦‚æœ <paramref name="left" /> å°äºç­‰äº <paramref name="right" />ï¼Œåˆ™ä¸º <see langword="true" />ï¼›å¦åˆ™ä¸º <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-406"><see langword="true" /> if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Plane">
      <MemberSignature Language="C#" Value="public int Plane { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Plane" />
      <MemberSignature Language="DocId" Value="P:System.Text.Rune.Plane" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Plane As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Plane { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Plane : int" Usage="System.Text.Rune.Plane" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="01189-407">è·å–åŒ…å«æ­¤æ ‡é‡çš„ Unicode å¹³é¢ï¼ˆ0 è‡³ 16ï¼Œå« 0 å’Œ 16ï¼‰ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-407">Gets the Unicode plane (0 to 16, inclusive) that contains this scalar.</span></span></summary>
        <value><span data-ttu-id="01189-408">Unicode å¹³é¢ (0 åˆ°16ï¼Œå…¶ä¸­åŒ…å«æ­¤æ ‡é‡) ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-408">The Unicode plane (0 to 16, inclusive) that contains this scalar.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReplacementChar">
      <MemberSignature Language="C#" Value="public static System.Text.Rune ReplacementChar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Text.Rune ReplacementChar" />
      <MemberSignature Language="DocId" Value="P:System.Text.Rune.ReplacementChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ReplacementChar As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Rune ReplacementChar { System::Text::Rune get(); };" />
      <MemberSignature Language="F#" Value="member this.ReplacementChar : System.Text.Rune" Usage="System.Text.Rune.ReplacementChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="01189-409">è·å–è¡¨ç¤º Unicode æ›¿æ¢å­—ç¬¦ U+FFFD çš„ <see cref="T:System.Text.Rune" /> å®ä¾‹ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-409">Gets a <see cref="T:System.Text.Rune" /> instance that represents the Unicode replacement character U+FFFD.</span></span></summary>
        <value><span data-ttu-id="01189-410">ä¸€ä¸ª <see cref="T:System.Text.Rune" /> å®ä¾‹ï¼Œè¡¨ç¤º Unicode æ›¿æ¢å­—ç¬¦ U+FFFDã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-410">A <see cref="T:System.Text.Rune" /> instance that represents the Unicode replacement character U+FFFD.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (obj As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ obj) = IComparable::CompareTo;" />
      <MemberSignature Language="F#" Value="abstract member System.IComparable.CompareTo : obj -&gt; int&#xA;override this.System.IComparable.CompareTo : obj -&gt; int" Usage="rune.System.IComparable.CompareTo obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="01189-411">è¦ä¸å½“å‰å®ä¾‹è¿›è¡Œæ¯”è¾ƒçš„å¯¹è±¡ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-411">The object to compare with the current instance.</span></span></param>
        <summary><span data-ttu-id="01189-412">å°†å½“å‰å®ä¾‹ä¸æŒ‡å®šçš„å¯¹è±¡è¿›è¡Œæ¯”è¾ƒã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-412">Compares the current instance to the specified object.</span></span></summary>
        <returns><span data-ttu-id="01189-413">ä¸€ä¸ªå¸¦ç¬¦å·æ•´æ•°ï¼ŒæŒ‡ç¤ºæ­¤å®ä¾‹åœ¨æ’åºé¡ºåºä¸­ç›¸å¯¹äº <paramref name="other" /> çš„ä½ç½®ï¼š</span><span class="sxs-lookup"><span data-stu-id="01189-413">A signed integer indicating the position of this instance in the sort order in relation to <paramref name="other" />:</span></span> <br /><span data-ttu-id="01189-414">- å°äºé›¶ï¼šæ­¤å®ä¾‹ä½äº <paramref name="other" /> ä¹‹å‰ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-414">- Less than zero: This instance precedes <paramref name="other" />.</span></span> 
<br /><span data-ttu-id="01189-415">- é›¶ï¼šå®ä¾‹åœ¨æ’åºé¡ºåºä¸­çš„ä½ç½®ä¸ <paramref name="other" /> ç›¸åŒã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-415">- Zero: The instance has the same position in the sort order as <paramref name="other" />.</span></span>
<br /><span data-ttu-id="01189-416">- å¤§äºé›¶ï¼šæ­¤å®ä¾‹ä½äº <paramref name="other" /> ä¹‹åã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-416">- Greater than zero: This instance follows <paramref name="other" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="01189-417">æ­¤æˆå‘˜æ˜¯æ˜¾å¼æ¥å£æˆå‘˜çš„å®ç°ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-417">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="01189-418">å®ƒåªèƒ½åœ¨ <xref:System.Text.Rune> å®ä¾‹è¢«å¼ºåˆ¶è½¬æ¢ä¸º <xref:System.IComparable> æ¥å£æ—¶ä½¿ç”¨ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-418">It can be used only when the <xref:System.Text.Rune> instance is cast to an <xref:System.IComparable> interface.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public static System.Text.Rune ToLower (System.Text.Rune value, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.Rune ToLower(valuetype System.Text.Rune value, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.ToLower(System.Text.Rune,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToLower (value As Rune, culture As CultureInfo) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Rune ToLower(System::Text::Rune value, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member ToLower : System.Text.Rune * System.Globalization.CultureInfo -&gt; System.Text.Rune" Usage="System.Text.Rune.ToLower (value, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="01189-419">è¦è½¬æ¢çš„ 32 ä½ Unicode å­—ç¬¦ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-419">The 32-bit Unicode character to convert.</span></span></param>
        <param name="culture"><span data-ttu-id="01189-420">ä¸€ä¸ªå¯¹è±¡ï¼Œç”¨äºæä¾›åŒºåŸŸæ€§ç‰¹å®šçš„å¤§å°å†™è§„åˆ™ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-420">An object that supplies culture-specific casing rules.</span></span></param>
        <summary><span data-ttu-id="01189-421">æ ¹æ®æŒ‡å®šåŒºåŸŸæ€§çš„å¤§å°å†™è§„åˆ™è¿”å›æŒ‡å®š <see cref="T:System.Text.Rune" /> è½¬æ¢ä¸ºå°å†™å½¢å¼çš„å‰¯æœ¬ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-421">Returns a copy of the specified <see cref="T:System.Text.Rune" /> converted to lowercase, using the casing rules of the specified culture.</span></span></summary>
        <returns><span data-ttu-id="01189-422"><paramref name="value" /> çš„å°å†™ç­‰æ•ˆå½¢å¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-422">The lowercase equivalent of <paramref name="value" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public static System.Text.Rune ToLowerInvariant (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.Rune ToLowerInvariant(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.ToLowerInvariant(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToLowerInvariant (value As Rune) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Rune ToLowerInvariant(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member ToLowerInvariant : System.Text.Rune -&gt; System.Text.Rune" Usage="System.Text.Rune.ToLowerInvariant value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="01189-423">è¦è½¬æ¢çš„ 32 ä½ Unicode å­—ç¬¦ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-423">The 32-bit Unicode character to convert.</span></span></param>
        <summary><span data-ttu-id="01189-424">æ ¹æ®å›ºå®šåŒºåŸŸæ€§çš„å¤§å°å†™è§„åˆ™è¿”å›æŒ‡å®š <see cref="T:System.Text.Rune" /> è½¬æ¢ä¸ºå°å†™å½¢å¼çš„å‰¯æœ¬ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-424">Returns a copy of the specified <see cref="T:System.Text.Rune" /> converted to lowercase using the casing rules of the invariant culture.</span></span></summary>
        <returns><span data-ttu-id="01189-425"><paramref name="value" /> çš„å°å†™ç­‰æ•ˆå½¢å¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-425">The lowercase equivalent of <paramref name="value" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="rune.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="01189-426">è¿”å›æ­¤ <see cref="T:System.Text.Rune" /> å®ä¾‹çš„å­—ç¬¦ä¸²è¡¨ç¤ºå½¢å¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-426">Returns the string representation of this <see cref="T:System.Text.Rune" /> instance.</span></span></summary>
        <returns><span data-ttu-id="01189-427">æ­¤ rune çš„å­—ç¬¦ä¸²è¡¨ç¤ºå½¢å¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-427">The string representation of this rune.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public static System.Text.Rune ToUpper (System.Text.Rune value, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.Rune ToUpper(valuetype System.Text.Rune value, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.ToUpper(System.Text.Rune,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUpper (value As Rune, culture As CultureInfo) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Rune ToUpper(System::Text::Rune value, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member ToUpper : System.Text.Rune * System.Globalization.CultureInfo -&gt; System.Text.Rune" Usage="System.Text.Rune.ToUpper (value, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="01189-428">è¦è½¬æ¢çš„ 32 ä½ Unicode å­—ç¬¦ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-428">The 32-bit Unicode character to convert.</span></span></param>
        <param name="culture"><span data-ttu-id="01189-429">ä¸€ä¸ªå¯¹è±¡ï¼Œç”¨äºæä¾›åŒºåŸŸæ€§ç‰¹å®šçš„å¤§å°å†™è§„åˆ™ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-429">An object that supplies culture-specific casing rules.</span></span></param>
        <summary><span data-ttu-id="01189-430">æ ¹æ®æŒ‡å®šåŒºåŸŸæ€§çš„å¤§å°å†™è§„åˆ™è¿”å›æŒ‡å®š <see cref="T:System.Text.Rune" /> è½¬æ¢ä¸ºå¤§å†™å½¢å¼çš„å‰¯æœ¬ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-430">Returns a copy of the specified <see cref="T:System.Text.Rune" /> converted to uppercase, using the casing rules of the specified culture.</span></span></summary>
        <returns><span data-ttu-id="01189-431"><paramref name="value" /> çš„å¤§å†™ç­‰æ•ˆå½¢å¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-431">The uppercase equivalent of <paramref name="value" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public static System.Text.Rune ToUpperInvariant (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.Rune ToUpperInvariant(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.ToUpperInvariant(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUpperInvariant (value As Rune) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Rune ToUpperInvariant(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member ToUpperInvariant : System.Text.Rune -&gt; System.Text.Rune" Usage="System.Text.Rune.ToUpperInvariant value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="01189-432">è¦è½¬æ¢çš„ 32 ä½ Unicode å­—ç¬¦ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-432">The 32-bit Unicode character to convert.</span></span></param>
        <summary><span data-ttu-id="01189-433">æ ¹æ®å›ºå®šåŒºåŸŸæ€§çš„å¤§å°å†™è§„åˆ™è¿”å›æŒ‡å®š <see cref="T:System.Text.Rune" /> è½¬æ¢ä¸ºå¤§å†™å½¢å¼çš„å‰¯æœ¬ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-433">Returns a copy of the specified <see cref="T:System.Text.Rune" /> converted to uppercase using the casing rules of the invariant culture.</span></span></summary>
        <returns><span data-ttu-id="01189-434"><paramref name="value" /> çš„å¤§å†™ç­‰æ•ˆå½¢å¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-434">The uppercase equivalent of <paramref name="value" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (char ch, out System.Text.Rune result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(char ch, [out] valuetype System.Text.Rune&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.TryCreate(System.Char,System.Text.Rune@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (ch As Char, ByRef result As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(char ch, [Runtime::InteropServices::Out] System::Text::Rune % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : char * Rune -&gt; bool" Usage="System.Text.Rune.TryCreate (ch, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
        <Parameter Name="result" Type="System.Text.Rune" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ch"><span data-ttu-id="01189-435">ä»ä¸­åˆ›å»º rune çš„å­—ç¬¦ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-435">The character from which to create the rune.</span></span></param>
        <param name="result"><span data-ttu-id="01189-436">æ­¤æ–¹æ³•è¿”å›æ—¶ï¼Œå¯¹åº”äº <paramref name="ch" /> çš„ runeã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-436">When this method returns, the rune that corresponds to <paramref name="ch" />.</span></span></param>
        <summary><span data-ttu-id="01189-437">å°è¯•ä»æŒ‡å®šçš„å­—ç¬¦ä¸­åˆ›å»º <see cref="T:System.Text.Rune" />ï¼Œå¹¶è¿”å›æŒ‡ç¤ºæ“ä½œæ˜¯å¦æˆåŠŸçš„å€¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-437">Attempts to create a <see cref="T:System.Text.Rune" /> from a specified character and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="01189-438">å¦‚æœæ­¤æ–¹æ³•æˆåŠŸï¼Œåˆ™ä¸º <see langword="true" />ï¼›å¦åˆ™ä¸º <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-438"><see langword="true" /> if the method succeeded; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (int value, out System.Text.Rune result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(int32 value, [out] valuetype System.Text.Rune&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.TryCreate(System.Int32,System.Text.Rune@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (value As Integer, ByRef result As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(int value, [Runtime::InteropServices::Out] System::Text::Rune % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : int * Rune -&gt; bool" Usage="System.Text.Rune.TryCreate (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
        <Parameter Name="result" Type="System.Text.Rune" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="01189-439">Unicode æ ‡é‡å€¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-439">The Unicode scalar value.</span></span></param>
        <param name="result"><span data-ttu-id="01189-440">æ­¤æ–¹æ³•è¿”å›æ—¶ï¼Œå¯¹åº”äº <paramref name="value" /> çš„ runeã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-440">When this method returns, the rune that corresponds to <paramref name="value" />.</span></span></param>
        <summary><span data-ttu-id="01189-441">å°è¯•ä»è¡¨ç¤º Unicode æ ‡é‡å€¼çš„æŒ‡å®šå¸¦ç¬¦å·æ•´æ•°ä¸­åˆ›å»º <see cref="T:System.Text.Rune" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-441">Attempts to create a <see cref="T:System.Text.Rune" /> from a specified signed integer that represents a Unicode scalar value.</span></span></summary>
        <returns><span data-ttu-id="01189-442">å¦‚æœæ­¤æ–¹æ³•æˆåŠŸï¼Œåˆ™ä¸º <see langword="true" />ï¼›å¦åˆ™ä¸º <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-442"><see langword="true" /> if the method succeeded; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (uint value, out System.Text.Rune result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(unsigned int32 value, [out] valuetype System.Text.Rune&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.TryCreate(System.UInt32,System.Text.Rune@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (value As UInteger, ByRef result As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(System::UInt32 value, [Runtime::InteropServices::Out] System::Text::Rune % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : uint32 * Rune -&gt; bool" Usage="System.Text.Rune.TryCreate (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
        <Parameter Name="result" Type="System.Text.Rune" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="01189-443">Unicode æ ‡é‡å€¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-443">The Unicode scalar value.</span></span></param>
        <param name="result"><span data-ttu-id="01189-444">æ­¤æ–¹æ³•è¿”å›æ—¶ï¼Œå¯¹åº”äº <paramref name="value" /> çš„ runeã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-444">When this method returns, the rune that corresponds to <paramref name="value" />.</span></span></param>
        <summary><span data-ttu-id="01189-445">å°è¯•ä»è¡¨ç¤º Unicode æ ‡é‡å€¼çš„æŒ‡å®š 32 ä½æ— ç¬¦å·æ•´æ•°ä¸­åˆ›å»º <see cref="T:System.Text.Rune" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-445">Attempts to create a <see cref="T:System.Text.Rune" /> from the specified 32-bit unsigned integer that represents a Unicode scalar value.</span></span></summary>
        <returns><span data-ttu-id="01189-446">å¦‚æœæ­¤æ–¹æ³•æˆåŠŸï¼Œåˆ™ä¸º <see langword="true" />ï¼›å¦åˆ™ä¸º <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-446"><see langword="true" /> if the method succeeded; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (char highSurrogate, char lowSurrogate, out System.Text.Rune result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(char highSurrogate, char lowSurrogate, [out] valuetype System.Text.Rune&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.TryCreate(System.Char,System.Char,System.Text.Rune@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (highSurrogate As Char, lowSurrogate As Char, ByRef result As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(char highSurrogate, char lowSurrogate, [Runtime::InteropServices::Out] System::Text::Rune % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : char * char * Rune -&gt; bool" Usage="System.Text.Rune.TryCreate (highSurrogate, lowSurrogate, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="highSurrogate" Type="System.Char" />
        <Parameter Name="lowSurrogate" Type="System.Char" />
        <Parameter Name="result" Type="System.Text.Rune" RefType="out" />
      </Parameters>
      <Docs>
        <param name="highSurrogate"><span data-ttu-id="01189-447">ä»£ç†é¡¹å¯¹çš„é«˜ä»£ç†é¡¹ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-447">The high surrogate of the surrogate pair.</span></span></param>
        <param name="lowSurrogate"><span data-ttu-id="01189-448">ä»£ç†é¡¹å¯¹çš„ä½ä»£ç†é¡¹ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-448">The low surrogate of the surrogate pair.</span></span></param>
        <param name="result"><span data-ttu-id="01189-449">å¯¹åº”äºæŒ‡å®šçš„ä»£ç†é¡¹å¯¹çš„ runeã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-449">The rune that corresponds to the specified surrogate pair.</span></span></param>
        <summary><span data-ttu-id="01189-450">å°è¯•ä»æŒ‡å®šçš„ UTF-16 ä»£ç†é¡¹å¯¹ä¸­åˆ›å»º <see cref="T:System.Text.Rune" />ï¼Œå¹¶è¿”å›æŒ‡ç¤ºæ“ä½œæ˜¯å¦æˆåŠŸçš„å€¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-450">Attempts to create a <see cref="T:System.Text.Rune" /> from the specified UTF-16 surrogate pair and returns a value that indicates whether the operation was successful.</span></span></summary>
        <returns><span data-ttu-id="01189-451">å¦‚æœæ“ä½œæˆåŠŸï¼Œåˆ™ä¸º <see langword="true" />ï¼›å¦‚æœè¾“å…¥å€¼ä¸è¡¨ç¤ºæ ¼å¼æ ‡å‡†çš„ UTF-16 ä»£ç†é¡¹å¯¹ï¼Œåˆ™ä¸º <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-451"><see langword="true" /> if the operation succeeded; <see langword="false" /> if the input values don't represent a well-formed UTF-16 surrogate pair.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryEncodeToUtf16">
      <MemberSignature Language="C#" Value="public bool TryEncodeToUtf16 (Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEncodeToUtf16(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.TryEncodeToUtf16(System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEncodeToUtf16 (destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEncodeToUtf16(Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="member this.TryEncodeToUtf16 : Span&lt;char&gt; * int -&gt; bool" Usage="rune.TryEncodeToUtf16 (destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="01189-452">å°†æ­¤å€¼ä½œä¸º UTF-16 ç¼–ç å€¼å†™å…¥åˆ°çš„ç¼“å†²åŒºã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-452">The buffer to which to write this value as UTF-16 encoded value.</span></span></param>
        <param name="charsWritten"><span data-ttu-id="01189-453">å†™å…¥ <paramref name="destination" /> çš„ <see cref="T:System.Char" /> å€¼çš„æ•°ç›®ï¼Œæˆ–è€…å¦‚æœç›®æ ‡ç¼“å†²åŒºå¤§å°ä¸è¶³ä»¥åŒ…å«è¾“å‡ºï¼Œåˆ™ä¸º 0ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-453">The number of <see cref="T:System.Char" /> values written to <paramref name="destination" />, or 0 if the destination buffer is not large enough to contain the output.</span></span></param>
        <summary><span data-ttu-id="01189-454">å°†æ­¤ <see cref="T:System.Text.Rune" /> è§£ç ä¸º UTF-16 ç¼–ç ç›®æ ‡ç¼“å†²åŒºã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-454">Encodes this <see cref="T:System.Text.Rune" /> to a UTF-16 encoded destination buffer.</span></span></summary>
        <returns><span data-ttu-id="01189-455">å¦‚æœè¯¥å€¼å·²å†™å…¥ç¼“å†²åŒºï¼Œåˆ™ä¸º <see langword="true" />ï¼›å¦åˆ™ä¸º <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-455"><see langword="true" /> if the value was written to the buffer; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
          
## Remarks

<span data-ttu-id="01189-456"><xref:System.Text.Rune.Utf16SequenceLength>å¯ä»¥æå‰æŸ¥è¯¢å±æ€§ï¼Œä»¥ç¡®å®šæ‰€éœ€çš„ `destination` ç¼“å†²åŒºå¤§å°ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-456">The <xref:System.Text.Rune.Utf16SequenceLength> property can be queried ahead of time to determine the required size of the `destination` buffer.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryEncodeToUtf8">
      <MemberSignature Language="C#" Value="public bool TryEncodeToUtf8 (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEncodeToUtf8(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.TryEncodeToUtf8(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEncodeToUtf8 (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEncodeToUtf8(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="member this.TryEncodeToUtf8 : Span&lt;byte&gt; * int -&gt; bool" Usage="rune.TryEncodeToUtf8 (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="01189-457">UTF-8 ç¼–ç å€¼å†™å…¥åˆ°çš„ç¼“å†²åŒºã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-457">The buffer to which to write the UTF-8 encoded value.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="01189-458">å†™å…¥ <paramref name="destination" /> çš„ <see cref="T:System.Byte" /> å€¼çš„æ•°ç›®ï¼Œæˆ–è€…å¦‚æœç›®æ ‡ç¼“å†²åŒºå¤§å°ä¸è¶³ä»¥åŒ…å«è¾“å‡ºï¼Œåˆ™ä¸º 0ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-458">The number of <see cref="T:System.Byte" /> values written to <paramref name="destination" />, or 0 if the destination buffer is not large enough to contain the output.</span></span></param>
        <summary><span data-ttu-id="01189-459">å°†æ­¤ <see cref="T:System.Text.Rune" /> è§£ç ä¸º UTF-8 ç¼–ç ç›®æ ‡ç¼“å†²åŒºã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-459">Encodes this <see cref="T:System.Text.Rune" /> to a UTF-8 encoded destination buffer.</span></span></summary>
        <returns><span data-ttu-id="01189-460">å¦‚æœè¯¥å€¼å·²å†™å…¥ç¼“å†²åŒºï¼Œåˆ™ä¸º <see langword="true" />ï¼›å¦åˆ™ä¸º <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-460"><see langword="true" /> if the value was written to the buffer; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
          
## Remarks

<span data-ttu-id="01189-461"><xref:System.Text.Rune.Utf8SequenceLength>å¯ä»¥æå‰æŸ¥è¯¢å±æ€§ï¼Œä»¥ç¡®å®šæ‰€éœ€çš„ `destination` ç¼“å†²åŒºå¤§å°ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-461">The <xref:System.Text.Rune.Utf8SequenceLength> property can be queried ahead of time to determine the required size of the `destination` buffer.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetRuneAt">
      <MemberSignature Language="C#" Value="public static bool TryGetRuneAt (string input, int index, out System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetRuneAt(string input, int32 index, [out] valuetype System.Text.Rune&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.TryGetRuneAt(System.String,System.Int32,System.Text.Rune@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetRuneAt (input As String, index As Integer, ByRef value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetRuneAt(System::String ^ input, int index, [Runtime::InteropServices::Out] System::Text::Rune % value);" />
      <MemberSignature Language="F#" Value="static member TryGetRuneAt : string * int * Rune -&gt; bool" Usage="System.Text.Rune.TryGetRuneAt (input, index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Text.Rune" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input"><span data-ttu-id="01189-462">ä»ä¸­æå– rune çš„å­—ç¬¦ä¸²ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-462">The string from which to extract the rune.</span></span></param>
        <param name="index"><span data-ttu-id="01189-463">ä»ä¸­æå– rune çš„ä»é›¶å¼€å§‹çš„ç´¢å¼•ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-463">The zero-based index from which to extract the rune.</span></span></param>
        <param name="value"><span data-ttu-id="01189-464">æ­¤æ–¹æ³•è¿”å›æ—¶ï¼Œå·²è§£ç çš„ runeã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-464">When this method returns, the decoded rune.</span></span></param>
        <summary><span data-ttu-id="01189-465">å°è¯•è·å–åœ¨å­—ç¬¦ä¸²çš„æŒ‡å®šä½ç½®å¤„å¼€å§‹çš„ <see cref="T:System.Text.Rune" />ï¼Œå¹¶è¿”å›æŒ‡ç¤ºæ“ä½œæ˜¯å¦æˆåŠŸçš„å€¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-465">Attempts to get the <see cref="T:System.Text.Rune" /> that begins at a specified position in a string, and return a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="01189-466">å¦‚æœæˆåŠŸä»æŒ‡å®šç´¢å¼•ä¸­æå–æ ‡é‡å€¼ï¼Œåˆ™ä¸º <see langword="true" />ï¼›å¦‚æœæŸå€¼ç”±äºæ— æ•ˆæ•°æ®è€Œæ— æ³•è¿›è¡Œæå–ï¼Œåˆ™ä¸º <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-466"><see langword="true" /> if a scalar value was successfully extracted from the specified index; <see langword="false" /> if a value could not be extracted because of invalid data.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="01189-467">å¦‚æœ `input` ä¸º `null` æˆ– `index` è¶…å‡ºèŒƒå›´ï¼Œåˆ™å¼•å‘å¼‚å¸¸ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-467">Throws an exception if `input` is `null` or `index` is out of range.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="01189-468"><paramref name="input" /> ä¸º <see langword="null" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-468"><paramref name="input" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="01189-469"><paramref name="index" /> è¶…å‡ºäº† <paramref name="input" /> çš„èŒƒå›´ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-469"><paramref name="index" /> is out of the range of <paramref name="input" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Utf16SequenceLength">
      <MemberSignature Language="C#" Value="public int Utf16SequenceLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Utf16SequenceLength" />
      <MemberSignature Language="DocId" Value="P:System.Text.Rune.Utf16SequenceLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Utf16SequenceLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Utf16SequenceLength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Utf16SequenceLength : int" Usage="System.Text.Rune.Utf16SequenceLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="01189-470">è·å–è¡¨ç¤ºæ­¤æ ‡é‡å€¼æ‰€éœ€çš„ UTF-16 åºåˆ—çš„ä»£ç å•å…ƒ (<see cref="T:System.Char" />) ä¸­çš„é•¿åº¦ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-470">Gets the length in code units (<see cref="T:System.Char" />) of the UTF-16 sequence required to represent this scalar value.</span></span></summary>
        <value><span data-ttu-id="01189-471">ç”¨ä»£ç å•ä½è¡¨ç¤ºçš„é•¿åº¦ (<see cref="T:System.Char" /> ç”¨äºè¡¨ç¤ºæ­¤æ ‡é‡å€¼æ‰€éœ€çš„ utf-16 åºåˆ—) ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-471">The length in code units (<see cref="T:System.Char" />) of the UTF-16 sequence required to represent this scalar value.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="01189-472">è¿”å›å€¼å°†ä¸º1æˆ–2ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-472">The return value will be 1 or 2.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Utf8SequenceLength">
      <MemberSignature Language="C#" Value="public int Utf8SequenceLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Utf8SequenceLength" />
      <MemberSignature Language="DocId" Value="P:System.Text.Rune.Utf8SequenceLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Utf8SequenceLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Utf8SequenceLength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Utf8SequenceLength : int" Usage="System.Text.Rune.Utf8SequenceLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="01189-473">è·å–è¡¨ç¤ºæ­¤æ ‡é‡å€¼æ‰€éœ€çš„ UTF-8 åºåˆ—çš„ä»£ç å•å…ƒä¸­çš„é•¿åº¦ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-473">Gets the length in code units of the UTF-8 sequence required to represent this scalar value.</span></span></summary>
        <value><span data-ttu-id="01189-474">è¡¨ç¤ºæ­¤æ ‡é‡å€¼æ‰€éœ€çš„ UTF-8 åºåˆ—çš„é•¿åº¦ï¼ˆä»¥ä»£ç å•ä½è¡¨ç¤ºï¼‰ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-474">The length in code units of the UTF-8 sequence required to represent this scalar value.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="01189-475">è¿”å›å€¼ä¸º1åˆ°4ï¼ˆå«ï¼‰ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-475">The return value will be 1 through 4, inclusive.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public int Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Value" />
      <MemberSignature Language="DocId" Value="P:System.Text.Rune.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Value { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : int" Usage="System.Text.Rune.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="01189-476">è·å–æ•´æ•°å½¢å¼çš„ Unicode æ ‡é‡å€¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-476">Gets the Unicode scalar value as an integer.</span></span></summary>
        <value><span data-ttu-id="01189-477">æ•´æ•°å½¢å¼çš„ Unicode æ ‡é‡å€¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="01189-477">The Unicode scalar value as an integer.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
