<Type Name="MessageEnumerator" FullName="System.Messaging.MessageEnumerator">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8efdebcdda0d244a01f27597d636c3a6bc61870e" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83953893" /></Metadata><TypeSignature Language="C#" Value="public class MessageEnumerator : MarshalByRefObject, IDisposable, System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageEnumerator extends System.MarshalByRefObject implements class System.Collections.IEnumerator, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageEnumerator&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable, IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageEnumerator : MarshalByRefObject, IDisposable, System::Collections::IEnumerator" />
  <TypeSignature Language="F#" Value="type MessageEnumerator = class&#xA;    inherit MarshalByRefObject&#xA;    interface IEnumerator&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="2c9b6-101">提供一个只进游标，用于枚举消息队列中的消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-101">Provides a forward-only cursor to enumerate through messages in a message queue.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c9b6-102">使用 <xref:System.Messaging.MessageEnumerator> 来与队列中的消息进行动态交互。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-102">Use <xref:System.Messaging.MessageEnumerator> for dynamic interaction with messages in a queue.</span></span> <span data-ttu-id="2c9b6-103">通过 <xref:System.Messaging.MessageQueue> 类提供的方法可以返回指向队列中的消息动态列表的 <xref:System.Messaging.MessageEnumerator>，或返回在调用指定方法时队列的给定即时快照上包含副本的数组。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-103">Methods available through the <xref:System.Messaging.MessageQueue> class can return either a <xref:System.Messaging.MessageEnumerator> pointing to a dynamic list of messages in the queue, or an array that contains a copy at a given instant - a snapshot - of the queue at the time the specified method was called.</span></span>  
  
 <span data-ttu-id="2c9b6-104">与静态快照不同，枚举器允许您修改集合。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-104">Unlike a static snapshot, an enumerator allows you to modify the collection.</span></span> <span data-ttu-id="2c9b6-105">使用 <xref:System.Messaging.MessageEnumerator>，可以从队列中删除消息，而更改会立即反映在队列中。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-105">Using a <xref:System.Messaging.MessageEnumerator>, you can remove messages from the queue, and the change is immediately reflected in the queue.</span></span>  
  
 <span data-ttu-id="2c9b6-106">枚举器在查询队列时不会从队列中删除消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-106">An enumerator does not remove the messages from the queue when it queries the queue.</span></span> <span data-ttu-id="2c9b6-107">它返回有关当前光标位置处的消息的信息，但它将消息保留在队列中。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-107">It returns information about the message at the current cursor position, but it leaves the message in the queue.</span></span>  
  
 <span data-ttu-id="2c9b6-108"><xref:System.Messaging.MessageEnumerator> 是游标，初始化为动态列表的开头。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-108">A <xref:System.Messaging.MessageEnumerator> is a cursor, initialized to the head of a dynamic list.</span></span> <span data-ttu-id="2c9b6-109">列表的顺序与消息在队列中的顺序相同，具体取决于消息的优先级。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-109">The list order is the same as the order of the messages in the queue, according to message priority.</span></span> <span data-ttu-id="2c9b6-110">可以通过调用 <xref:System.Messaging.MessageEnumerator.MoveNext%2A>将光标移到队列中的第一条消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-110">You can move the cursor to the first message in the queue by calling <xref:System.Messaging.MessageEnumerator.MoveNext%2A>.</span></span> <span data-ttu-id="2c9b6-111">初始化枚举器后，可以使用 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 前进到其余的消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-111">After the enumerator has been initialized, you can use <xref:System.Messaging.MessageEnumerator.MoveNext%2A> to step forward through the remaining messages.</span></span> <span data-ttu-id="2c9b6-112">可以通过将超时传递到 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 方法来指定是否等待消息变为可用。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-112">You can specify whether to wait for a message to become available by passing a timeout into the <xref:System.Messaging.MessageEnumerator.MoveNext%2A> method.</span></span>  
  
 <span data-ttu-id="2c9b6-113">由于枚举器是动态的，因此枚举器可以访问附加在游标当前位置之外的消息（例如，由于低优先级）。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-113">Because the enumerator is dynamic, a message that is appended beyond the cursor's current position (for example, due to low priority), can be accessed by the enumerator.</span></span> <span data-ttu-id="2c9b6-114">无法访问在游标的当前位置之前插入的消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-114">A message that is inserted before the cursor's current position cannot be accessed.</span></span> <span data-ttu-id="2c9b6-115">不能使用 <xref:System.Messaging.MessageEnumerator>向后移动。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-115">It is not possible to step backward with a <xref:System.Messaging.MessageEnumerator>.</span></span> <span data-ttu-id="2c9b6-116">游标允许只进移动。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-116">A cursor allows forward-only movement.</span></span> <span data-ttu-id="2c9b6-117">利用 <xref:System.Messaging.MessageEnumerator.Reset%2A> 方法，您可以将游标放回队列的开头。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-117">The <xref:System.Messaging.MessageEnumerator.Reset%2A> method enables you to place the cursor back at the beginning of the queue.</span></span>  
  
 <span data-ttu-id="2c9b6-118">给定队列的 <xref:System.Messaging.MessageEnumerator> 实例是独立工作的。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-118">Instances of <xref:System.Messaging.MessageEnumerator> for a given queue work independently.</span></span> <span data-ttu-id="2c9b6-119">你可以创建两个适用于同一队列的 <xref:System.Messaging.MessageEnumerator> 实例。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-119">You can create two <xref:System.Messaging.MessageEnumerator> instances that apply to the same queue.</span></span> <span data-ttu-id="2c9b6-120">如果第二个枚举器定位在第一个枚举器之前，则 <xref:System.Messaging.MessageEnumerator> 对队列中的消息所做的更改将立即反映在第二个枚举器中。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-120">The changes that one <xref:System.Messaging.MessageEnumerator> makes to the messages in the queue will be reflected immediately in a second enumerator if the second enumerator is positioned before the first.</span></span> <span data-ttu-id="2c9b6-121">但是，如果两个枚举器具有相同的位置，并且其中一个枚举器删除了该位置的消息，则如果其他枚举器尝试获取现已删除消息的 <xref:System.Messaging.MessageEnumerator.Current%2A> 属性的值，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-121">However, if two enumerators have the same position and one of them removes the message at that position, an exception is thrown if the other enumerator attempts to get the value of the <xref:System.Messaging.MessageEnumerator.Current%2A> property on the now-deleted message.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2c9b6-122">如果创建 <xref:System.Messaging.MessageQueue> 的实例，并将 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=nameWithType> 设置为 `true`，则在连接到队列时，其他应用程序不能修改枚举器中的消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-122">If you create an instance of <xref:System.Messaging.MessageQueue> with <xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=nameWithType> set to `true`, no other application can modify the messages in your enumerator while you have the connection to the queue.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2c9b6-123">下面的示例获取队列中消息的动态列表，并对 <xref:System.Messaging.Message.Priority%2A> 属性设置为 <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>的所有消息进行计数。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-123">The following example gets a dynamic list of messages in a queue and counts all messages with the <xref:System.Messaging.Message.Priority%2A> property set to <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.</span></span>  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageEnumerator.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2c9b6-124">释放与枚举数关联的资源。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-124">Frees the resources associated with the enumerator.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c9b6-125">在游标的生存期内，操作系统会将打开的句柄保留到队列中。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-125">The operating system retains an open handle to the queue during the lifetime of the cursor.</span></span> <span data-ttu-id="2c9b6-126">使用完枚举器后，调用 <xref:System.Messaging.MessageEnumerator.Close%2A> 以释放与句柄关联的资源。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-126">When you have finished working with the enumerator, call <xref:System.Messaging.MessageEnumerator.Close%2A> to release the resources associated with the handle.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.Message Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Message ^ Current { System::Messaging::Message ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Messaging.Message" Usage="System.Messaging.MessageEnumerator.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2c9b6-127">获取该枚举数指向的当前 <see cref="T:System.Messaging.Message" />。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-127">Gets the current <see cref="T:System.Messaging.Message" /> that this enumerator points to.</span></span></summary>
        <value><span data-ttu-id="2c9b6-128">当前消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-128">The current message.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c9b6-129">创建枚举器后，该枚举数指向第一条消息之前的位置。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-129">When the enumerator is created, it points to the head of the queue, at a location before the first message.</span></span> <span data-ttu-id="2c9b6-130">在这种情况下，<xref:System.Messaging.MessageEnumerator.Current%2A> 无效，如果访问，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-130">In this case, <xref:System.Messaging.MessageEnumerator.Current%2A> is not valid and will throw an exception if it is accessed.</span></span> <span data-ttu-id="2c9b6-131">必须调用 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 将游标定位到队列中的第一条消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-131">You must call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> to position the cursor at the first message in the queue.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="2c9b6-132">您在第一次调用 <see cref="P:System.Messaging.MessageEnumerator.Current" /> 之前调用了 <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-132">You called <see cref="P:System.Messaging.MessageEnumerator.Current" /> before the first call to <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />.</span></span> <span data-ttu-id="2c9b6-133">游标位于消息枚举的第一个元素之前。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-133">The cursor is located before the first element of the message enumeration.</span></span>  
  
<span data-ttu-id="2c9b6-134">- 或 -</span><span class="sxs-lookup"><span data-stu-id="2c9b6-134">-or-</span></span> 
<span data-ttu-id="2c9b6-135">您在对 <see cref="P:System.Messaging.MessageEnumerator.Current" /> 的调用返回 <see langword="false" />（指示游标位于消息枚举中的最后一个元素之后）之后调用了 <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-135">You called <see cref="P:System.Messaging.MessageEnumerator.Current" /> after a call to <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> had returned <see langword="false" /> (indicating the cursor is located after the last element of the message enumeration.)</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="2c9b6-136">枚举数当前所指向的消息不再存在。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-136">The message the enumerator is currently pointing to no longer exists.</span></span> <span data-ttu-id="2c9b6-137">可能已将其删除。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-137">It might have been deleted.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="CursorHandle">
      <MemberSignature Language="C#" Value="public IntPtr CursorHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int CursorHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CursorHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr CursorHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.CursorHandle : nativeint" Usage="System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2c9b6-138">获取用于浏览队列消息的本机消息队列游标句柄。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-138">Gets the native Message Queuing cursor handle used to browse messages in the queue.</span></span></summary>
        <value><span data-ttu-id="2c9b6-139">本机游标句柄。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-139">The native cursor handle.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c9b6-140">此属性包含枚举的本机句柄。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-140">This property contains the native handle to the enumeration.</span></span> <span data-ttu-id="2c9b6-141">使用完枚举器后，调用 <xref:System.Messaging.MessageEnumerator.Close%2A> 释放此资源。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-141">When you have finished working with the enumerator, call <xref:System.Messaging.MessageEnumerator.Close%2A> to release this resource.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="2c9b6-142">此句柄不存在。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-142">The handle does not exist.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2c9b6-143">释放 <see cref="T:System.Messaging.MessageEnumerator" /> 使用的资源。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-143">Releases the resources used by the <see cref="T:System.Messaging.MessageEnumerator" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="messageEnumerator.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2c9b6-144">释放 <see cref="T:System.Messaging.MessageEnumerator" /> 使用的所有资源。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-144">Releases all resources used by the <see cref="T:System.Messaging.MessageEnumerator" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c9b6-145">调用 <xref:System.Messaging.MessageEnumerator.Dispose%2A> 允许出于其他目的重新分配 <xref:System.Messaging.MessageEnumerator> 所使用的资源。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-145">Calling <xref:System.Messaging.MessageEnumerator.Dispose%2A> allows the resources used by the <xref:System.Messaging.MessageEnumerator> to be reallocated for other purposes.</span></span> <span data-ttu-id="2c9b6-146">有关 <xref:System.Messaging.MessageEnumerator.Dispose%2A>的详细信息，请参阅[清理非托管资源](/dotnet/standard/garbage-collection/unmanaged)。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-146">For more information about <xref:System.Messaging.MessageEnumerator.Dispose%2A>, see [Cleaning Up Unmanaged Resources](/dotnet/standard/garbage-collection/unmanaged).</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/garbage-collection/unmanaged"><span data-ttu-id="2c9b6-147">清理非托管资源</span><span class="sxs-lookup"><span data-stu-id="2c9b6-147">Cleaning Up Unmanaged Resources</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="messageEnumerator.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="2c9b6-148">如果为 <see langword="true" />，则托管及非托管资源都释放；如果为 <see langword="false" />，则仅释放非托管资源。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-148"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="2c9b6-149">释放 <see cref="T:System.Messaging.MessageEnumerator" /> 使用的非托管资源，并选择性地释放托管资源。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-149">Releases the unmanaged resources used by the <see cref="T:System.Messaging.MessageEnumerator" /> and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c9b6-150">此方法由 public <xref:System.Messaging.MessageEnumerator.Dispose%2A> 方法和 <xref:System.Object.Finalize%2A> 方法调用。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-150">This method is called by the public <xref:System.Messaging.MessageEnumerator.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="2c9b6-151">`Dispose()` 调用受保护的 `Dispose(Boolean)` 方法，并将 `disposing` 参数设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-151">`Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="2c9b6-152"><xref:System.Object.Finalize%2A> 调用 `disposing` 设置为 `false`的 `Dispose`。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-152"><xref:System.Object.Finalize%2A> invokes `Dispose` with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="2c9b6-153">当 `disposing` 参数为 `true` 时，此方法释放该 <xref:System.Messaging.MessageEnumerator> 引用的、由任何托管对象持有的全部资源。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-153">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Messaging.MessageEnumerator> references.</span></span> <span data-ttu-id="2c9b6-154">此方法将调用每个被引用对象的 `Dispose()` 方法。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-154">This method invokes the `Dispose()` method of each referenced object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="2c9b6-155">
            <see langword="Dispose" /> 可以由其他对象多次调用。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-155">
            <see langword="Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="2c9b6-156">重写 <see langword="Dispose(Boolean)" /> 时，请注意不要引用在以前调用 <see langword="Dispose" /> 时已释放的对象。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-156">When overriding <see langword="Dispose(Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see langword="Dispose" />.</span></span> <span data-ttu-id="2c9b6-157">有关如何实现 <see langword="Dispose" />的详细信息，请参阅[实现 Dispose 方法](/dotnet/standard/garbage-collection/implementing-dispose)。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-157">For more information about how to implement <see langword="Dispose" />, see [Implementing a Dispose Method](/dotnet/standard/garbage-collection/implementing-dispose).</span></span>  
  
<span data-ttu-id="2c9b6-158">有关 <see langword="Dispose" /> 和 <see langword="Finalize" />的详细信息，请参阅[清理非托管资源](/dotnet/standard/garbage-collection/unmanaged)和[重写 Finalize 方法](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-158">For more information about <see langword="Dispose" /> and <see langword="Finalize" />, see [Cleaning Up Unmanaged Resources](/dotnet/standard/garbage-collection/unmanaged) and [Overriding the Finalize Method](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</span></span></para></block>
        <related type="Article" href="/dotnet/standard/garbage-collection/implementing-dispose"><span data-ttu-id="2c9b6-159">实现 Dispose 方法</span><span class="sxs-lookup"><span data-stu-id="2c9b6-159">Implementing a Dispose method</span></span></related>
        <related type="Article" href="/dotnet/standard/garbage-collection/unmanaged"><span data-ttu-id="2c9b6-160">清理非托管资源</span><span class="sxs-lookup"><span data-stu-id="2c9b6-160">Cleaning Up Unmanaged Resources</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~MessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!MessageEnumerator ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="messageEnumerator.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2c9b6-161">释放枚举数控制的资源。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-161">Releases the resources held by the enumerator.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="2c9b6-162">此方法重写 <xref:System.Object.Finalize>。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-162">This method overrides <xref:System.Object.Finalize>.</span></span> <span data-ttu-id="2c9b6-163">应用程序代码不应调用此方法;在垃圾回收过程中会自动调用对象的 Finalize 方法，除非已通过调用 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> 方法禁用了垃圾回收器终止。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-163">Application code should not call this method; an object's Finalize method is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled by a call to the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="2c9b6-164">有关详细信息，请参阅[Finalize 方法和析构函数](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0s71x931(v=vs.100))、[清理非托管资源](/dotnet/standard/garbage-collection/unmanaged)和[重写 Finalize 方法](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-164">For more information, see [Finalize Methods and Destructors](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0s71x931(v=vs.100)), [Cleaning Up Unmanaged Resources](/dotnet/standard/garbage-collection/unmanaged), and [Overriding the Finalize Method](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</span></span>

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveNext">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2c9b6-165">使枚举数前进到队列中的下一条消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-165">Advances the enumerator to the next message in the queue.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberSignature Language="F#" Value="abstract member MoveNext : unit -&gt; bool&#xA;override this.MoveNext : unit -&gt; bool" Usage="messageEnumerator.MoveNext " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2c9b6-166">如果当前队列中有下一条可用的消息，则使枚举数前进到该消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-166">Advances the enumerator to the next message in the queue, if one is currently available.</span></span></summary>
        <returns><span data-ttu-id="2c9b6-167">如果枚举器已成功推进到下一条消息，则为 <see langword="true" />；如果枚举器已传递到队列的末尾，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-167"><see langword="true" /> if the enumerator was successfully advanced to the next message; <see langword="false" /> if the enumerator has reached the end of the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c9b6-168">如果队列中没有消息，则此重载立即返回。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-168">This overload returns immediately if there is no message in the queue.</span></span> <span data-ttu-id="2c9b6-169">还有另一个重载，用于等待消息到达的指定 <xref:System.TimeSpan>。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-169">There is another overload that waits a specified <xref:System.TimeSpan> for a message to arrive.</span></span>  
  
 <span data-ttu-id="2c9b6-170">如果消息当前不可用，因为队列为空或者已移出集合中的最后一个元素，则 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 将 `false` 返回到调用方法。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-170">If a message is not currently available because the queue is empty or because you have moved beyond the last element in the collection, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> returns `false` to the calling method.</span></span>  
  
 <span data-ttu-id="2c9b6-171">创建时，枚举器在概念上放置在队列的第一条消息之前，第一次调用 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 会将队列的第一条消息引入视图中。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-171">Upon creation, an enumerator is conceptually positioned before the first message of the queue, and the first call to <xref:System.Messaging.MessageEnumerator.MoveNext%2A> brings the first message of the queue into view.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="2c9b6-172">引发了消息队列特定的异常。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-172">An exception specific to Message Queuing was thrown.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool MoveNext(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool MoveNext(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.MoveNext : TimeSpan -&gt; bool" Usage="messageEnumerator.MoveNext timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="2c9b6-173">枚举数位于队列的末尾时，等待消息变得可用的 <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-173">The <see cref="T:System.TimeSpan" /> to wait for a message to be available if the enumerator is positioned at the end of the queue.</span></span></param>
        <summary><span data-ttu-id="2c9b6-174">使枚举数前进到队列中的下一条消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-174">Advances the enumerator to the next message in the queue.</span></span> <span data-ttu-id="2c9b6-175">如果枚举数位于队列的末尾，则 <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> 将一直等到消息可用或给定 timeout 到期为止。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-175">If the enumerator is positioned at the end of the queue, <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> waits until a message is available or the given timeout expires.</span></span></summary>
        <returns><span data-ttu-id="2c9b6-176">如果枚举数成功地前进到下一条消息，为 <see langword="true" />；如果枚举数已经到达队列的末尾，并且在 <paramref name="timeout" /> 参数所指定的时间内没有消息变得可用，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-176"><see langword="true" /> if the enumerator successfully advanced to the next message; <see langword="false" /> if the enumerator has reached the end of the queue and a message does not become available within the time specified by the <paramref name="timeout" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c9b6-177">如果队列中没有消息，或者游标已到达队列的末尾，则此重载将等待。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-177">This overload waits if there is no message in the queue or if the cursor has reached the end of the queue.</span></span> <span data-ttu-id="2c9b6-178">如果消息当前不可用，因为队列为空，或由于移动超出了集合中的最后一个元素，<xref:System.Messaging.MessageEnumerator.MoveNext%2A> 将等待指定的超时。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-178">If a message is not currently available because the queue is empty or because you have moved beyond the last element in the collection, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> waits the specified timeout.</span></span>  
  
 <span data-ttu-id="2c9b6-179">如果游标已在队列的末尾，<xref:System.Messaging.MessageEnumerator.MoveNext%2A> 仅在新消息到达指定的时间间隔内时返回 `true`，其优先级低于当前队列中的所有消息，并置于队列的末尾。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-179">If the cursor is already at the end of the queue, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> only returns `true` if the new message arrives within the specified time interval, has lower priority than all messages currently in the queue and is placed at the end of the queue.</span></span> <span data-ttu-id="2c9b6-180">如果队列中没有更多的消息，则不会立即返回没有参数的重载。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-180">An overload with no parameter returns immediately if no further messages are in the queue.</span></span>  
  
 <span data-ttu-id="2c9b6-181">创建时，枚举器在概念上定位在枚举的第一条消息之前，第一次调用 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 会将枚举的第一条消息引入视图中。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-181">Upon creation, an enumerator is conceptually positioned before the first message of the enumeration, and the first call to <xref:System.Messaging.MessageEnumerator.MoveNext%2A> brings the first message of the enumeration into view.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2c9b6-182">为 timeout 参数指定的值无效。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-182">The value specified for the timeout parameter is invalid.</span></span> <span data-ttu-id="2c9b6-183">它可能表示负数。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-183">It might represent a negative number.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="2c9b6-184">引发了消息队列特定的异常。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-184">An exception specific to Message Queuing was thrown.</span></span>  
  
 <span data-ttu-id="2c9b6-185">- 或 -</span><span class="sxs-lookup"><span data-stu-id="2c9b6-185">-or-</span></span>  
  
 <span data-ttu-id="2c9b6-186">超时已过期。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-186">The timeout has expired.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveCurrent">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2c9b6-187">从队列中移除当前消息并将该消息返回给调用应用程序。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-187">Removes the current message from the queue and returns the message to the calling application.</span></span> <span data-ttu-id="2c9b6-188">移除消息即从队列中删除该消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-188">Removing the message deletes it from the queue.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c9b6-189">仅当使用 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>检索 <xref:System.Messaging.MessageEnumerator> 实例时，才适用为这些重载描述的行为。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-189">The behavior described for these overloads is applicable only if the <xref:System.Messaging.MessageEnumerator> instance is retrieved by using the <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>.</span></span> <span data-ttu-id="2c9b6-190">不要使用 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> 检索 <xref:System.Messaging.MessageEnumerator> 的实例，因为此方法已弃用。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-190">Do not use <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> to retrieve an instance of <xref:System.Messaging.MessageEnumerator> as this method has been deprecated.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent();" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : unit -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2c9b6-191">从事务性或非事务性队列中移除当前消息，并将该消息返回给调用应用程序。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-191">Removes the current message from a transactional or non-transactional queue and returns the message to the calling application.</span></span> <span data-ttu-id="2c9b6-192">对于消息到达队列的用时没有超时指定。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-192">There is no timeout specified for a message to arrive in the queue.</span></span></summary>
        <returns><span data-ttu-id="2c9b6-193"><see cref="T:System.Messaging.Message" />，它引用队列中可用的第一条消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-193">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c9b6-194"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 删除并返回光标当前位置的消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-194"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location.</span></span>  
  
 <span data-ttu-id="2c9b6-195">如果使用队列日志记录，删除消息将导致副本保留在日记队列中，就像 <xref:System.Messaging.MessageQueue> 类的 <xref:System.Messaging.MessageQueue.Receive%2A> 方法一样。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-195">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="2c9b6-196">删除当前消息时，光标将移到下一条消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-196">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="2c9b6-197">调用 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>后，无需调用 <xref:System.Messaging.MessageEnumerator.MoveNext%2A>。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-197">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 <span data-ttu-id="2c9b6-198">如果在事务队列中调用此重载，则消息队列将创建单个内部事务。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-198">If you call this overload on a transactional queue, Message Queuing creates a single internal transaction.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction"><span data-ttu-id="2c9b6-199">指定从中移除消息的事务的 <see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-199">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object that specifies the transaction in which the message will be removed.</span></span></param>
        <summary><span data-ttu-id="2c9b6-200">从事务性队列中移除当前消息，并将该消息返回给调用应用程序。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-200">Removes the current message from a transactional queue and returns the message to the calling application.</span></span> <span data-ttu-id="2c9b6-201">对于消息到达队列的用时没有超时指定。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-201">There is no timeout specified for a message to arrive in the queue.</span></span></summary>
        <returns><span data-ttu-id="2c9b6-202"><see cref="T:System.Messaging.Message" />，它引用队列中可用的第一条消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-202">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c9b6-203"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 使用 `transaction` 参数定义的内部事务上下文删除并返回光标当前位置的消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-203"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location, using the internal transaction context defined by the `transaction` parameter.</span></span>  
  
 <span data-ttu-id="2c9b6-204">如果使用队列日志记录，删除消息将导致副本保留在日记队列中，就像 <xref:System.Messaging.MessageQueue> 类的 <xref:System.Messaging.MessageQueue.Receive%2A> 方法一样。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-204">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="2c9b6-205">使用事务性队列时，事务的回滚会导致通过调用 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 删除的任何消息都将返回到队列中。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-205">When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> to be returned to the queue.</span></span> <span data-ttu-id="2c9b6-206">在提交事务之前，删除操作不可逆。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-206">The removal is not irreversible until the transaction is committed.</span></span>  
  
 <span data-ttu-id="2c9b6-207">删除当前消息时，光标将移到下一条消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-207">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="2c9b6-208">调用 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>后，无需调用 <xref:System.Messaging.MessageEnumerator.MoveNext%2A>。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-208">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2c9b6-209">
          <paramref name="transaction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-209">The <paramref name="transaction" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType"><span data-ttu-id="2c9b6-210"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文的类型。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-210">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</span></span></param>
        <summary><span data-ttu-id="2c9b6-211">从队列中移除当前消息并将该消息返回给调用应用程序。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-211">Removes the current message from a queue and returns the message to the calling application.</span></span> <span data-ttu-id="2c9b6-212">对于消息到达队列的用时没有超时指定。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-212">There is no timeout specified for a message to arrive in the queue.</span></span></summary>
        <returns><span data-ttu-id="2c9b6-213"><see cref="T:System.Messaging.Message" />，它引用队列中可用的第一条消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-213">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c9b6-214"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 使用 `transactionType` 参数定义的事务上下文删除并返回光标当前位置的消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-214"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location, using a transaction context defined by the `transactionType` parameter.</span></span>  
  
 <span data-ttu-id="2c9b6-215">如果已存在附加到要用于接收消息的线程的外部事务上下文，请指定 `transactionType` 参数 `Automatic`。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-215">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</span></span> <span data-ttu-id="2c9b6-216">如果要将消息作为单个内部事务接收，请指定 `Single`。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-216">Specify `Single` if you want to receive the message as a single internal transaction.</span></span> <span data-ttu-id="2c9b6-217">如果要在事务上下文之外接收来自事务性队列的消息，可以指定 `None`。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-217">You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.</span></span>  
  
 <span data-ttu-id="2c9b6-218">如果使用队列日志记录，删除消息将导致副本保留在日记队列中，就像 <xref:System.Messaging.MessageQueue> 类的 <xref:System.Messaging.MessageQueue.Receive%2A> 方法一样。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-218">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="2c9b6-219">使用事务性队列时，事务的回滚会导致通过调用 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 删除的任何消息都将返回到队列中。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-219">When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> to be returned to the queue.</span></span> <span data-ttu-id="2c9b6-220">在提交事务之前，删除操作不可逆。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-220">The removal is not irreversible until the transaction is committed.</span></span>  
  
 <span data-ttu-id="2c9b6-221">删除当前消息时，光标将移到下一条消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-221">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="2c9b6-222">调用 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>后，无需调用 <xref:System.Messaging.MessageEnumerator.MoveNext%2A>。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-222">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="2c9b6-223"><paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-223">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="2c9b6-224">等待消息到达队列的时间间隔。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-224">The interval of time to wait for a message to arrive in the queue.</span></span></param>
        <summary><span data-ttu-id="2c9b6-225">从队列中移除当前消息并将该消息返回给调用应用程序。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-225">Removes the current message from the queue and returns the message to the calling application.</span></span> <span data-ttu-id="2c9b6-226">如果有要移除的消息，该方法将立即返回该消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-226">If there is a message to remove, the method returns it immediately.</span></span> <span data-ttu-id="2c9b6-227">否则，该方法在指定的超时内等待新消息到达。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-227">Otherwise, the method waits the specified timeout for a new message to arrive.</span></span></summary>
        <returns><span data-ttu-id="2c9b6-228"><see cref="T:System.Messaging.Message" />，它引用队列中可用的第一条消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-228">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c9b6-229"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 删除并返回光标当前位置的消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-229"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location.</span></span> <span data-ttu-id="2c9b6-230">如果游标位于队列的末尾，则该方法的重载将一直等待，直到有可用的消息或 `timeout` 参数指定的间隔过期。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-230">If the cursor is at the end of the queue, this overload of the method waits until a message is available or the interval specified by the `timeout` parameter has expired.</span></span>  
  
 <span data-ttu-id="2c9b6-231">如果使用队列日志记录，删除消息将导致副本保留在日记队列中，就像 <xref:System.Messaging.MessageQueue> 类的 <xref:System.Messaging.MessageQueue.Receive%2A> 方法一样。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-231">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="2c9b6-232">删除当前消息时，光标将移到下一条消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-232">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="2c9b6-233">调用 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>后，无需调用 <xref:System.Messaging.MessageEnumerator.MoveNext%2A>。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-233">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 <span data-ttu-id="2c9b6-234">如果在事务队列中调用此重载，则消息队列将创建单个内部事务。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-234">If you call this overload on a transactional queue, Message Queuing creates a single internal transaction.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2c9b6-235">为 <paramref name="timeout" /> 参数指定的值无效。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-235">The value specified for the <paramref name="timeout" /> parameter is invalid.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="2c9b6-236">超时已过期。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-236">The timeout has expired.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="2c9b6-237">等待消息被移除的时间间隔。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-237">The interval of time to wait for the message to be removed.</span></span></param>
        <param name="transaction"><span data-ttu-id="2c9b6-238">为消息指定事务上下文的 <see cref="T:System.Messaging.MessageQueueTransaction" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-238">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object that specifies the transaction context for the message.</span></span></param>
        <summary><span data-ttu-id="2c9b6-239">从事务性队列中移除当前消息，并将该消息返回给调用应用程序。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-239">Removes the current message from a transactional queue and returns the message to the calling application.</span></span> <span data-ttu-id="2c9b6-240">如果有要移除的消息，该方法将立即返回该消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-240">If there is a message to remove, the method returns it immediately.</span></span> <span data-ttu-id="2c9b6-241">否则，该方法在指定的超时内等待新消息到达。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-241">Otherwise, the method waits the specified timeout for a new message to arrive.</span></span></summary>
        <returns><span data-ttu-id="2c9b6-242"><see cref="T:System.Messaging.Message" />，它引用队列中可用的第一条消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-242">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c9b6-243"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 删除并返回光标当前位置的消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-243"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location.</span></span> <span data-ttu-id="2c9b6-244">如果游标位于队列的末尾，则该方法的重载将一直等待，直到有可用的消息或 `timeout` 参数指定的间隔过期。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-244">If the cursor is at the end of the queue, this overload of the method waits until a message is available or the interval specified by the `timeout` parameter has expired.</span></span>  
  
 <span data-ttu-id="2c9b6-245">使用事务性队列时，事务的回滚会导致通过调用 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 删除的任何消息都将返回到队列中。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-245">When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> to be returned to the queue.</span></span> <span data-ttu-id="2c9b6-246">在提交事务之前，删除操作不可逆。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-246">The removal is not irreversible until the transaction is committed.</span></span>  
  
 <span data-ttu-id="2c9b6-247">如果使用队列日志记录，删除消息将导致副本保留在日记队列中，就像 <xref:System.Messaging.MessageQueue> 类的 <xref:System.Messaging.MessageQueue.Receive%2A> 方法一样。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-247">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="2c9b6-248">删除当前消息时，光标将移到下一条消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-248">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="2c9b6-249">调用 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>后，无需调用 <xref:System.Messaging.MessageEnumerator.MoveNext%2A>。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-249">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2c9b6-250">为 <paramref name="timeout" /> 参数指定的值无效。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-250">The value specified for the <paramref name="timeout" /> parameter is invalid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2c9b6-251">
          <paramref name="transaction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-251">The <paramref name="transaction" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="2c9b6-252">超时已过期。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-252">The timeout has expired.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="2c9b6-253">等待消息被移除的时间间隔。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-253">The interval of time to wait for the message to be removed.</span></span></param>
        <param name="transactionType"><span data-ttu-id="2c9b6-254"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 值之一，它描述与消息关联的事务上下文的类型。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-254">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</span></span></param>
        <summary><span data-ttu-id="2c9b6-255">从队列中移除当前消息并将该消息返回给调用应用程序。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-255">Removes the current message from a queue and returns the message to the calling application.</span></span> <span data-ttu-id="2c9b6-256">如果有要移除的消息，该方法将立即返回该消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-256">If there is a message to remove, the method returns it immediately.</span></span> <span data-ttu-id="2c9b6-257">否则，该方法在指定的超时内等待新消息到达。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-257">Otherwise, the method waits the specified timeout for a new message to arrive.</span></span></summary>
        <returns><span data-ttu-id="2c9b6-258"><see cref="T:System.Messaging.Message" />，它引用队列中可用的第一条消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-258">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c9b6-259"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 使用 `transactionType` 参数定义的事务上下文删除并返回光标当前位置的消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-259"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location, using a transaction context defined by the `transactionType` parameter.</span></span> <span data-ttu-id="2c9b6-260">如果游标位于队列的末尾，则该方法的重载将一直等待，直到有可用的消息或 `timeout` 参数指定的间隔过期。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-260">If the cursor is at the end of the queue, this overload of the method waits until a message is available or the interval specified by the `timeout` parameter has expired.</span></span>  
  
 <span data-ttu-id="2c9b6-261">如果已存在附加到要用于接收消息的线程的外部事务上下文，请指定 `transactionType` 参数 `Automatic`。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-261">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</span></span> <span data-ttu-id="2c9b6-262">如果要将消息作为单个内部事务接收，请指定 `Single`。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-262">Specify `Single` if you want to receive the message as a single internal transaction.</span></span> <span data-ttu-id="2c9b6-263">如果要在事务上下文之外接收来自事务性队列的消息，可以指定 `None`。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-263">You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.</span></span>  
  
 <span data-ttu-id="2c9b6-264">如果使用队列日志记录，删除消息将导致副本保留在日记队列中，就像 <xref:System.Messaging.MessageQueue> 类的 <xref:System.Messaging.MessageQueue.Receive%2A> 方法一样。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-264">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="2c9b6-265">使用事务性队列时，事务的回滚会导致通过调用 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 删除的任何消息都将返回到队列中。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-265">When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> to be returned to the queue.</span></span> <span data-ttu-id="2c9b6-266">在提交事务之前，删除操作不可逆。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-266">The removal is not irreversible until the transaction is committed.</span></span>  
  
 <span data-ttu-id="2c9b6-267">删除当前消息时，光标将移到下一条消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-267">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="2c9b6-268">调用 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>后，无需调用 <xref:System.Messaging.MessageEnumerator.MoveNext%2A>。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-268">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2c9b6-269">为 <paramref name="timeout" /> 参数指定的值无效。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-269">The value specified for the <paramref name="timeout" /> parameter is invalid.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="2c9b6-270">超时已过期。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-270">The timeout has expired.</span></span></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="2c9b6-271"><paramref name="transactionType" /> 参数不是 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成员之一。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-271">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="messageEnumerator.Reset " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2c9b6-272">重置当前枚举数，使其指向队列开头。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-272">Resets the current enumerator so it points to the head of the queue.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2c9b6-273">枚举器只能向前移动。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-273">An enumerator can only move in a forward direction.</span></span> <span data-ttu-id="2c9b6-274">使用此方法可以在队列的开头重新开始。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-274">Use this method to start over at the beginning of the queue.</span></span>  
  
 <span data-ttu-id="2c9b6-275">调用 <xref:System.Messaging.MessageEnumerator.Reset%2A>后，游标将指向第一条消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-275">After calling <xref:System.Messaging.MessageEnumerator.Reset%2A>, the cursor points to the first message.</span></span> <span data-ttu-id="2c9b6-276">调用 <xref:System.Messaging.MessageEnumerator.Reset%2A> 后，无需调用 <xref:System.Messaging.MessageEnumerator.MoveNext%2A>，以便将游标向前移动到队列中的第一条消息。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-276">You do not need to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.Reset%2A> to move the cursor forward to the first message in the queue.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IEnumerator::Current { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.IEnumerator.Current : obj" Usage="System.Collections.IEnumerator.Current" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2c9b6-277">返回引用当前游标位置的消息的 <see cref="T:System.Messaging.Message" />。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-277">Returns a <see cref="T:System.Messaging.Message" /> that references the message at the current cursor position.</span></span></summary>
        <value><span data-ttu-id="2c9b6-278">引用当前游标位置的消息的 <see cref="T:System.Messaging.Message" />。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-278">A <see cref="T:System.Messaging.Message" /> that references the message at the current cursor position.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="2c9b6-279">您在第一次调用 <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> 之前访问了此属性。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-279">You accessed this property before the first call to <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />.</span></span> <span data-ttu-id="2c9b6-280">游标位于消息枚举的第一个元素之前。- 或 - 你在对 <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> 的调用返回 false（指示游标位于消息枚举中的最后一个元素之后）之后访问了此属性。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-280">The cursor is located before the first element of the message enumeration.-or- You accessed this property after a call to <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> had returned false (indicating the cursor is located after the last element of the message enumeration.)</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="2c9b6-281">枚举数当前所指向的消息不再存在。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-281">The message the enumerator is currently pointing to no longer exists.</span></span> <span data-ttu-id="2c9b6-282">可能已将其删除。</span><span class="sxs-lookup"><span data-stu-id="2c9b6-282">It might have been deleted.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
